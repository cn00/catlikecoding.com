<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/tutorial-image.jpg">
		<meta property="og:title" content="Orbit Camera">
		<meta property="og:description" content="A Unity Movement tutorial about controlling a sphere via an orbit camera.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Orbit Camera</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/movement/orbit-camera/#article",
				"headline": "Orbit Camera",
				"alternativeHeadline": "Relative Control",
				"datePublished": "2020-01-26",
				"dateModified": "2020-07-16",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Movement tutorial about controlling a sphere via an orbit camera.",
				"image": "https://catlikecoding.com/unity/tutorials/movement/orbit-camera/tutorial-image.jpg",
				"dependencies": "Unity 2019.2.18f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/movement/", "name": "Movement" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				MovingSphere: 1,
				OrbitCamera: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Movement</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Orbit Camera</h1>
					<p>Relative Control</p>
					<ul>
						<li>Create an orbiting camera.</li>
						<li>Support manual and automatic camera rotation.</li>
						<li>Make movement relative to the camera.</li>
						<li>Prevent the camera from intersecting geometry.</li>
					</ul>
				</header>
				
				<p>This is the fourth installment of a tutorial series about controlling the <a href="../index.html">movement</a> of a character. This time we focus on the camera, creating an orbiting point of view from which we control the sphere.</p>
				
				<p>This tutorial is made with Unity 2019.2.18f1. It also uses the ProBuilder package.</p>
				
				<figure>
					<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/tutorial-image.jpg" width="512" height="256">
					<figcaption>A camera sticking close to a sphere.</figcaption>
				</figure>
				
				<section>
					<h2>Following the Sphere</h2>
					
					<p>A fixed point of view only works when the sphere is constrained to an area that is completely visible. But usually characters in games can roam about large areas. The typical ways to make this possible is by either using a first-person view or having the camera follow the player's avatar in third-person view mode. Other approaches exists as well, like switching between multiple cameras depending on the avatar's position.</p>
					
					<aside>
						<h3>Is there a second-person view?</h3>
						<div>
							<p>The third person exists outside the game world, representing the player. A second person exists inside the game. It could be anyone or anything that is not the player's avatar. It's rare, but some games use this viewpoint as a gimmick, for example it's one of the psychic powers in Psychonauts.</p>
						</div>
					</aside>
					
					<section>
						<h3>Orbit Camera</h3>
						
						<p>We'll create a simple orbiting camera to follow our sphere in third-person mode.  Define an <code>OrbitCamera</code> component type for it, giving it the <code>RequireComponent</code> attribute to enforcing that it is gets attached to a game object that also has a regular <code>Camera</code> component.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>[RequireComponent(typeof(Camera))]</ins>
<ins>public class OrbitCamera : MonoBehaviour {}</ins></pre>
						
						<p>Adjust the main camera of a scene with a single sphere so it has this component. I made a new scene for this with a large flat plane, positioning the camera so it looks down at a 45&deg; angle with the sphere at the center of its view, at a distance of roughly five units.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/following-the-sphere/orbit-camera-inspector.png" width="320" height="200" alt="inspector"><br>
							<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/following-the-sphere/orbit-camera-view.png" width="320" height="170" alt="view">
							<figcaption>Orbit camera.</figcaption>
						</figure>
						
						<aside>
							<h3>Why not use <em translate="no">Cinemachine</em>?</h3>
							<div>
								<p><em translate="no">Cinemachine</em> provides a ready-made free-look camera that can orbit our sphere, so we could just use that. However, by creating a simple orbit camera ourselves we'll better understand what goes into creating one and what its limitations are. Also, the <em translate="no">Cinemachine</em> option requires a lot of tuning to get right and might still not behave as you prefer. Our simple approach is much easier to understand and tweak.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Maintaining Relative Position</h3>
						
						<p>To keep the camera focused on the sphere we need to tell it what to focus on. This could really be anything, so add a configurable <code>Transform</code> field for the focus. Also add an option for the orbit distance, set to five units by default.</p>
						
						<pre translate="no">	<ins>[SerializeField]</ins>
	<ins>Transform focus = default;</ins>

	<ins>[SerializeField, Range(1f, 20f)]</ins>
	<ins>float distance = 5f;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/following-the-sphere/focus-distance.png" width="320" height="72">
							<figcaption>Focus and distance.</figcaption>
						</figure>
						
						<p>Every update we have to adjust the camera's position so it stays at the desired distance. We'll do this in <code>LateUpdate</code> in case anything moves the focus in <code>Update</code>. The camera's position is found by moving it away from the focus position in the opposite direction that it's looking by an amount equal to the configured distance. We'll use the <code>position</code> property of the focus instead of <code>localPosition</code> so we can correctly focus on child objects inside a hierarchy.</p>
						
						<pre translate="no">	<ins>void LateUpdate () {</ins>
		<ins>Vector3 focusPoint = focus.position;</ins>
		<ins>Vector3 lookDirection = transform.forward;</ins>
		<ins>transform.localPosition = focusPoint - lookDirection * distance;</ins>
	<ins>}</ins></pre>
						
						<p>The camera will not always stay at the same distance and orientation, but because PhysX adjusts the sphere's position at a fixed time step so will our camera. When that doesn't match the frame rate it will result in jittery camera motion.</p>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/honorablebouncyfunnelweaverspider?controls=0'></iframe></div>
							<figcaption>Jittery motion; timestep 0.2.</figcaption>
						</figure>
						
						<p>The simplest and most robust way to fix this is by setting the sphere's <code>Rigidbody</code> to interpolate its position. That gets rid of the jittery motion of both the sphere and the camera. This is typically only needed for objects that are focused on by the camera.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/following-the-sphere/interpolated-rigidbody.png" width="320" height="74">
							<figcaption>Interpolated rigidbody.</figcaption>
						</figure>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/sarcasticjampackediceblueredtopzebra?controls=0'></iframe></div>
							<figcaption>Interpolated motion; timestep 0.2.</figcaption>
						</figure>
						
						<aside>
							<h3>Why is the camera still a little jittery?</h3>
							<div>
								<p>An irregular frame rate will always cause some jitter, especially when there are significant frame rate dips. The editor is prone to this. A build will most likely be much smoother.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Focus Radius</h3>
						
						<p>Always keeping the sphere in exact focus might feel too rigid. Even the smallest motion of the sphere will be copied by the camera, which affects the entire view. We can relax this constraint by making the camera only move when its focus point differs too much from the ideal focus. We'll make this configurable by adding a focus radius, set to to one unit by default.</p>
						
						<pre translate="no">	<ins>[SerializeField, Min(0f)]</ins>
	<ins>float focusRadius = 1f;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/following-the-sphere/focus-radius.png" width="320" height="38">
							<figcaption>Focus radius.</figcaption>
						</figure>
												
						<p>A relaxed focus requires us to keep track of the current focus point, as it might no longer exactly match the position of the focus. Initialize it to the focus object's position in <code>Awake</code> and move updating it to a separate <code>UpdateFocusPoint</code> method.</p>
						
						<pre translate="no">	<ins>Vector3 focusPoint;</ins>

	<ins>void Awake () {</ins>
		<ins>focusPoint = focus.position;</ins>
	<ins>}</ins>

	void LateUpdate () {
		<del>//Vector3 focusPoint = focus.position;</del>
		<ins>UpdateFocusPoint();</ins>
		Vector3 lookDirection = transform.forward;
		transform.localPosition = focusPoint - lookDirection * distance;
	}

	<ins>void UpdateFocusPoint () {</ins>
		<ins>Vector3 targetPoint = focus.position;</ins>
		<ins>focusPoint = targetPoint;</ins>
	<ins>}</ins></pre>
						
						<p>If the focus radius is positive, check whether the distance between the target and current focus points is greater than the radius. If so, pull the focus toward the target until the distance matches the radius. This can be done by interpolating from target point to current point, using the radius divided by current distance as the interpolator. Otherwise directly set the focus point to the target point as before.</p>
						
						<pre translate="no">		Vector3 targetPoint = focus.position;
		<ins>if (focusRadius > 0f) {</ins>
			<ins>float distance = Vector3.Distance(targetPoint, focusPoint);</ins>
			<ins>if (distance > focusRadius) {</ins>
				<ins>focusPoint = Vector3.Lerp(</ins>
					<ins>targetPoint, focusPoint, focusRadius / distance</ins>
				<ins>);</ins>
			<ins>}</ins>
		<ins>}</ins>
		<ins>else {</ins>
			focusPoint = targetPoint;
		<ins>}</ins></pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/fewdaringkawala?controls=0'></iframe></div>
							<figcaption>Relaxed camera movement.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Centering the Focus</h3>
						
						<p>Using a focus radius makes the camera respond only to larger motion of the focus, but when the focus stops so does the camera. It's also possible to keep the camera moving until the focus is back in the center of its view. To make this motion appear more subtle and organic we can pull back slower as the focus approaches the center.</p>
						
						<p>For example, the focus starts at some distance from the center. We pull it back so that after a second that distance has been halved. We keep doing this, halving the distance every second. The distance will never be reduced to zero this way, but we can stop when it has gotten small enough that it is unnoticeable.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/following-the-sphere/halving.png" width="100" height="100">
							<figcaption>Halving every second.</figcaption>
						</figure>
						
						<p>Halving a starting distance each second can be done by multiplying it with &frac12; raised to the elapsed time: `d_(n+1) = d_n(1/2)^(t_n)`. We don't need to exactly halve the distance each second, we can use an arbitrary centering factor between zero and one: `d_(n+1)=d_nc^(t_n)`.</p>
						
						<aside>
							<h3>Does this work for incremental and variable time steps?</h3>
							<div>
								<p>Yes, because of the product rule for exponents: `x^ax^b=x^(a+b)`. For example, suppose we start with distance `d` and had one frame with a delta time of one second. Then the new distance is `dc^1=dc`. Now suppose we had two frames with a delta time of 0.6 and 0.4 seconds instead, ending up at the same time but in two steps. Then the new distance is again `dc^0.6c^0.4=dc^(0.6+0.4)=dc^1=dc`.</p> 
							</div>
						</aside>
						
						<p>Add a configuration option for the focus centering factor, which has to be a value in the 0&ndash;1 range, with 0.5 as a good default.</p>
						
						<pre translate="no">	<ins>[SerializeField, Range(0f, 1f)]</ins>
	<ins>float focusCentering = 0.5f;</ins></pre>
						
						<figure>
							<img src="following-the-sphere/focus-centering.png" width="320" height="38">
							<figcaption>Focus centering.</figcaption>
						</figure>
						
						<p>To apply the expected centering behavior we have to interpolate between the target and current focus points, using `(1-c)^t` as the interpolator, with help of the <code>Mathf.Pow</code> method. We only need to do this if the distance is large enough&mdash;say above 0.01&mdash;and the centering factor is positive. To both center and enforce the focus radius we use the minimum of both interpolators for the final interpolation.</p>
						
						<pre translate="no">			float distance = Vector3.Distance(targetPoint, focusPoint);
			<ins>float t = 1f;</ins>
			<ins>if (distance > 0.01f &amp;&amp; focusCentering > 0f) {</ins>
				<ins>t = Mathf.Pow(1f - focusCentering, Time.deltaTime);</ins>
			<ins>}</ins>
			if (distance > focusRadius) {
				<del>//focusPoint = Vector3.Lerp(</del>
				<del>//	targetPoint, focusPoint, focusRadius / distance</del>
				<del>//);</del>
				<ins>t = Mathf.Min€(t, focusRadius / distance);</ins>
			}
			<ins>focusPoint = Vector3.Lerp(targetPoint, focusPoint, t);</ins></pre>
						
						<p>But relying on the normal time delta makes the camera subject to the game's time scale, so it would also slow down during slow motion effects and even freeze in place if the game would be paused. To prevent this make it depend on <code>Time.unscaledDeltaTime</code> instead.</p>
						
						<pre translate="no">				t = Mathf.Pow(1f - focusCentering, Time.<ins>unscaledDeltaTime</ins>);</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/sadhelpfulcrustacean?controls=0'></iframe></div>
							<figcaption>Centering the focus.</figcaption>
						</figure>
					</section>
					
				</section>
				
				<section>
					<h2>Orbiting the Sphere</h2>
					
					<p>The next step is to make it possible to adjust the camera's orientation so it can describe an orbit around the focus point. We'll make it possible to both manually control the orbit and have the camera automatically rotate to follow its focus.</p>
					
					<section>
						<h3>Orbit Angles</h3>
						
						<p>The orientation of the camera can be described with two orbit angles. The X angle defines its vertical orientation, with 0&deg; looking straight to the horizon and 90&deg; looking straight down. The Y angle defines the horizontal orientation, with 0&deg; looking along the world Z axis. Keep track of those angles in a <code>Vector2</code> field, set to 45&deg; and 0&deg; by default.</p>
						
						<pre translate="no">	<ins>Vector2 orbitAngles = new Vector2(45f, 0f);</ins></pre>
						
						<p>In <code>LateUpdate</code> we'll now have to construct a quaternion defining the camera's look rotation via the <code>Quaternion.Euler</code> method, passing it the orbit angles. It required a <code>Vector3</code>, to which our vector implicitly gets converted, with the Z rotation set to zero.</p>
						
						<p>The look direction can then be found by replacing <code>transform.forward</code> with the quaternion multiplied with the forward vector. And instead of only setting the camera's position we'll now invoke <code>transform.SetPositionAndRotation</code> with the look position and rotation in one go.</p>
						
						<pre translate="no">	void LateUpdate () {
		UpdateFocusPoint();
		<ins>Quaternion lookRotation = Quaternion.Euler(orbitAngles);</ins>
		Vector3 lookDirection = <ins>lookRotation * Vector3.forward</ins>;
		<ins>Vector3 lookPosition</ins> = focusPoint - lookDirection * distance;
		<ins>transform.SetPositionAndRotation(lookPosition, lookRotation);</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Controlling the Orbit</h3>
						
						<p>To manually control the orbit, add a rotation speed configuration option, expressed in degrees per second. 90&deg; per second is a reasonable default.</p>
						
						<pre translate="no">	<ins>[SerializeField, Range(1f, 360f)]</ins>
	<ins>float rotationSpeed = 90f;</ins></pre>
						
						<figure>
							<img src="orbiting-the-sphere/rotation-speed.png" width="320" height="40">
							<figcaption>Rotation speed (Responsiveness should be Focus Centering).</figcaption>
						</figure>
						
						<p>Add a <code>ManualRotation</code> method that retrieves an input vector. I defined <em translate="no">Vertical Camera</em> and <em translate="no">Horizontal Camera</em> input axes for this, bound to the third and fourth axis, the ijkl and qe keys, and the mouse with sensitivity increased to 0.5. It is a good idea to make sensitivity configurable in your game and to allow flipping of axis directions, but we won't bother with that in this tutorial.</p>
							
							<p>If there's an input exceeding some small epsilon value like 0.001 then add the input to the orbit angles, scaled by the rotation speed and time delta. Again, we make this independent of the in-game time.</p>
						
						<pre translate="no">	<ins>void ManualRotation () {</ins>
		<ins>Vector2 input = new Vector2(</ins>
			<ins>Input.GetAxis("Vertical Camera"),</ins>
			<ins>Input.GetAxis("Horizontal Camera")</ins>
		<ins>);</ins>
		<ins>const float e = 0.001f;</ins>
		<ins>if (input.x &lt; -e || input.x > e || input.y &lt; -e || input.y > e) {</ins>
			<ins>orbitAngles += rotationSpeed * Time.unscaledDeltaTime * input;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Invoke this method after <code>UpdateFocusPoint</code> in <code>LateUpdate</code>.</p>
						
						<pre translate="no">	void LateUpdate () {
		UpdateFocusPoint();
		<ins>ManualRotation();</ins>
		&hellip;
	}</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/snivelingcraftyaustraliancattledog?controls=0'></iframe></div>
							<figcaption>Manual rotation; focus radius zero.</figcaption>
						</figure>
						
						<p>Note that the sphere is still controlled in world space, regardless of the camera's orientation. So if you horizontally rotate the camera 180&deg; then the sphere's controls will appear flipped. This makes it possible to easily keep the same heading no matter the camera view, but can be disorienting. If you have trouble with this you can have both the game and scene window open at the same time and rely on the fixed perspective of the latter. We'll make the sphere controls relative to the camera view later.</p>
					</section>
					
					<section>
						<h3>Constraining the Angles</h3>
						
						<p>While it's fine for the camera to describe full horizontal orbits, vertical rotation will turn the world upside down once it goes beyond 90&deg; in either direction. Even before that point it becomes hard to see where you're going when looking mostly up or down. So let's add configuration options to constrain the min and max vertical angle, with the extremes limited to at most 89&deg; in either direction. Let's use &minus;30&deg; and 60&deg; as the defaults.</p>
						
						<pre translate="no">	<ins>[SerializeField, Range(-89f, 89f)]</ins>
	<ins>float minVerticalAngle = -30f, maxVerticalAngle = 60f;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/orbiting-the-sphere/min-max-vertical-angle.png" width="320" height="56">
							<figcaption>Min and max vertical angle.</figcaption>
						</figure>
						
						<p>The max should never drop below the min, so enforce that in an <code>OnValidate</code> method. As this only sanitizes configuration via the inspector, we don't need to invoke it in builds.</p>
						
						<pre translate="no">	<ins>void OnValidate () {</ins>
		<ins>if (maxVerticalAngle &lt; minVerticalAngle) {</ins>
			<ins>maxVerticalAngle = minVerticalAngle;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Add a <code>ConstrainAngles</code> method that clamps the vertical orbit angle to the configured range. The horizontal orbit has no limits, but ensure that the angle stays inside the 0&ndash;360 range.</p>
						
						<pre translate="no">	<ins>void ConstrainAngles () {</ins>
		<ins>orbitAngles.x =</ins>
			<ins>Mathf.Clamp(orbitAngles.x, minVerticalAngle, maxVerticalAngle);</ins>

		<ins>if (orbitAngles.y &lt; 0f) {</ins>
			<ins>orbitAngles.y += 360f;</ins>
		<ins>}</ins>
		<ins>else if (orbitAngles.y >= 360f) {</ins>
			<ins>orbitAngles.y -= 360f;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<aside>
							<h3>Shouldn't we loop until we're in the 0&ndash;360 range?</h3>
							<div>
								<p>If the orbit angle were arbitrary then indeed it would be correct to keep adding or subtracting 360&deg; until it falls inside the range. However, we only incrementally adjust the angles by small amounts so this shouldn't be necessary.</p>
							</div>
						</aside>
						
						<p>We only need to constrain angles when they changed. So make <code>ManualRotation</code> return whether it made a change and invoke <code>ConstrainAngles</code> based on that in <code>LateUpdate</code>. We also only need to recalculate the rotation if there was a change, otherwise we can retrieve the existing one.</p>
						
						<pre translate="no">	<ins>bool</ins> ManualRotation () {
		&hellip;
		if (input.x &lt; e || input.x > e || input.y &lt; e || input.y > e) {
			orbitAngles += rotationSpeed * Time.unscaledDeltaTime * input;
			<ins>return true;</ins>
		}
		<ins>return false;</ins>
	}
	
	&hellip;
	
	void LateUpdate () {
		UpdateFocusPoint();
		<ins>Quaternion lookRotation;</ins>
		<ins>if (</ins>ManualRotation()<ins>) {</ins>
			<ins>ConstrainAngles();</ins>
			<ins>lookRotation = Quaternion.Euler(orbitAngles);</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>lookRotation = transform.localRotation;</ins>
		<ins>}</ins>
		<del>//Quaternion lookRotation = Quaternion.Euler(orbitAngles);</del>
		&hellip;
	}</pre>
						
						<p>We must also make sure that the initial rotation matches the orbit angles in <code>Awake</code>.</p>
						
						<pre translate="no">	void Awake () {
		focusPoint = focus.position;
		<ins>transform.localRotation = Quaternion.Euler(orbitAngles);</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Automatic Alignment</h3>
						
						<p>A common feature of orbit cameras is that they align themselves to stay behind the player's avatar. We'll do this by automatically adjusting the horizontal orbit angle. But it is important that the player can override this automatic behavior at all times and that the automatic rotation doesn't immediately kick back in. So we'll add a configurable align delay, set to five seconds by default. This delay doesn't have an upper bound. If you don't want automatic alignment at all then you can simply set a very high delay.</p>
						
						<pre translate="no">	<ins>[SerializeField, Min(0f)]</ins>
	<ins>float alignDelay = 5f;</ins></pre>
						
						<figure>
							<img src="orbiting-the-sphere/align-delay.png" width="320" height="38">
							<figcaption>Align delay.</figcaption>
						</figure>
						
						<p>Keep track of the last time that a manual rotation happened. Once again we rely on the unscaled time here, not the in-game time.</p>
						
						<pre translate="no">	<ins>float lastManualRotationTime;</ins>

	&hellip;

	bool ManualRotation () {
		&hellip;
		if (input.x &lt; -e || input.x > e || input.y &lt; -e || input.y > e) {
			orbitAngles += rotationSpeed * Time.unscaledDeltaTime * input;
			<ins>lastManualRotationTime = Time.unscaledTime;</ins>
			return true;
		}
		return false;
	}</pre>
						
						<p>Then add an <code>AutomaticRotation</code> method that also returns whether it changed the orbit. It aborts if the current time minus the last manual rotation time is less than the align delay.</p>
						
						<pre translate="no">	<ins>bool AutomaticRotation () {</ins>
		<ins>if (Time.unscaledTime - lastManualRotationTime &lt; alignDelay) {</ins>
			<ins>return false;</ins>
		<ins>}</ins>
		
		<ins>return true;</ins>
	<ins>}</ins></pre>
						
						<p>In <code>LateUpdate</code> we now constrain the angles and calculate the rotation when either manual or automation rotation happened, tried in that order.</p>
						
						<pre translate="no">		if (ManualRotation() <ins>|| AutomaticRotation()</ins>) {
			ConstrainAngles();
			lookRotation = Quaternion.Euler(orbitAngles);
		}</pre>
					</section>
					
					<section>
						<h3>Focus Heading</h3>
						
						<p>The criteria that are used to align cameras varies. In our case, we'll base it solely on the focus point's movement since the previous frame. The idea is that it makes most sense to look in the direction that the focus was last heading. To make this possible we'll need to know both the current and previous focus point, so have <code>UpdateFocusPoint</code> set fields for both.</p>
						
						<pre translate="no">	Vector3 focusPoint<ins>, previousFocusPoint</ins>;

	&hellip;

	void UpdateFocusPoint () {
		<ins>previousFocusPoint = focusPoint;</ins>
		&hellip;
	}</pre>
						
						<p>Then have <code>AutomaticRotation</code> calculate the movement vector for the current frame. As we're only rotating horizontally we only need the 2D movement in the XZ plane. If the square magnitude of this movement vector is less than a small threshold like 0.0001 then there wasn't much movement and we won't bother rotating.</p>
						
						<pre translate="no">	bool AutomaticRotation () {
		if (Time.unscaledTime - lastManualRotationTime &lt; alignDelay) {
			return false;
		}

		<ins>Vector2 movement = new Vector2(</ins>
			<ins>focusPoint.x - previousFocusPoint.x,</ins>
			<ins>focusPoint.z - previousFocusPoint.z</ins>
		<ins>);</ins>
		<ins>float movementDeltaSqr = movement.sqrMagnitude;</ins>
		<ins>if (movementDeltaSqr &lt; 0.0001f) {</ins>
			<ins>return false;</ins>
		<ins>}</ins>

		return true;
	}</pre>
						
						<p>Otherwise we have to figure out the horizontal angle matching the current direction. Create a static <code>GetAngle</code> method to convert a 2D direction to an angle for that. The Y component of the direction is the cosine of the angle we need, so put it through <code>Mathf.Acos</code> and then convert from radians to degrees.</p>
						
						<pre translate="no">	<ins>static float GetAngle (Vector2 direction) {</ins>
		<ins>float angle = Mathf.Acos(direction.y) * Mathf.Rad2Deg;</ins>
		<ins>return angle;</ins>
	<ins>}</ins></pre>
						
						<p>But that angle could represent either a clockwise or a counterclockwise rotation. We can look at the X component of the direction to know which it is. If X is negative then it's counterclockwise and we have to subtract the angle from from 360&deg;.</p>
						
						<pre translate="no">		return <ins>direction.x &lt; 0f ? 360f - angle :</ins> angle;</pre>
						
						<p>Back in <code>AutomaticRotation</code> we can use <code>GetAngle</code> to get the heading angle, passing it the normalized movement vector. As we already have its squared magnitude it's more efficient to do the normalization ourselves. The result becomes the new horizontal orbit angle.</p>
						
						<pre translate="no">		if (movementDeltaSqr &lt; 0.0001f) {
			return false;
		}

		<ins>float headingAngle = GetAngle(movement / Mathf.Sqrt(movementDeltaSqr));</ins>
		<ins>orbitAngles.y = headingAngle;</ins>
		return true;</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/remorsefulalarmedasianporcupine?controls=0'></iframe></div>
							<figcaption>Immediate alignment.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Smooth Alignment</h3>
						
						<p>The automatic alignment works, but immediately snapping to match the heading is too abrupt. Let's slow it down by using the configured rotation speed for automation rotation as well, so it mimics manual rotation. We can use <code>Mathf.MoveTowardsAngle</code> for this, which works like <code>Mathf.MoveTowards</code> except that it can deal with the 0&ndash;360 range of angles.</p>
						
						<pre translate="no">		float headingAngle = GetAngle(movement / Mathf.Sqrt(movementDeltaSqr));
		<ins>float rotationChange = rotationSpeed * Time.unscaledDeltaTime;</ins>
		orbitAngles.y =
			<ins>Mathf.MoveTowardsAngle(orbitAngles.y,</ins> headingAngle<ins>, rotationChange)</ins>;</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/frankseriousagouti?controls=0'></iframe></div>
							<figcaption>Limited by rotation speed.</figcaption>
						</figure>
						
						<p>This is better, but the maximum rotation speed is always used, even for small realignments. A more natural behavior would be to make the rotation speed scale with the difference between current and desired angle. We'll make it scale linearly up to some angle at which we'll rotate at full speed. Make this angle configurable by adding an align smooth range configuration option, with a 0&ndash;90 range and a default of 45&deg;.
						
						<pre translate="no">	<ins>[SerializeField, Range(0f, 90f)]</ins>
	<ins>float alignSmoothRange = 45f;</ins></pre>
						
						<figure>
							<img src="orbiting-the-sphere/align-smooth-range.png" width="320" height="38">
							<figcaption>Align smooth range.</figcaption>
						</figure>
						
						<p>To make this work we need to know the angle delta in <code>AutomaticRotation</code>, which we can find by passing the current and desired angle to <code>Mathf.DeltaAngle</code> and taking the absolute of that. If this delta falls inside the smooth range scale the rotation adjustment accordingly.</p>
						
						<pre translate="no">		<ins>float deltaAbs = Mathf.Abs(Mathf.DeltaAngle(orbitAngles.y, headingAngle));</ins>
		float rotationChange = rotationSpeed * Time.unscaledDeltaTime;
		<ins>if (deltaAbs &lt; alignSmoothRange) {</ins>
			<ins>rotationChange *= deltaAbs / alignSmoothRange;</ins>
		<ins>}</ins>
		orbitAngles.y =
			Mathf.MoveTowardsAngle(orbitAngles.y, headingAngle, rotationChange);</pre>
						
						<p>This covers the case when the focus moves away from the camera, but we can also do it when the focus moves toward the camera. That prevents the camera from rotating away at full speed, changing direction each time the heading crosses the 180&deg; boundary. It works the same except we use 180&deg; minus the absolute delta instead.</p>
						
						<pre translate="no">		if (deltaAbs &lt; alignSmoothRange) {
			rotationChange *= deltaAbs / alignSmoothRange;
		}
		<ins>else if (180f - deltaAbs &lt; alignSmoothRange) {</ins>
			<ins>rotationChange *= (180f - deltaAbs) / alignSmoothRange;</ins>
		<ins>}</ins></pre>
						
						<p>Finally, we can dampen rotation of tiny angles a bit more by scaling the rotation speed by the minimum of the time delta and the square movement delta.</p>
						
						<pre translate="no">		float rotationChange =
			rotationSpeed * <ins>Mathf.Min(</ins>Time.unscaledDeltaTime<ins>, movementDeltaSqr)</ins>;</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/glossydigitalbaldeagle?controls=0'></iframe></div>
							<figcaption>Smooth alignment.</figcaption>
						</figure>
						
						<p>Note that with this approach it's possible to move the sphere straight toward the camera without it rotating away. Tiny deviations in direction will be damped as well. Automatic rotation will come into effect smoothly once the heading has been changed significantly.</p>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/famouselectricdavidstiger?controls=0'></iframe></div>
							<figcaption>180&deg; alignment.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Camera-Relative Movement</h2>
					
					<p>At this point we have a decent simple orbit camera. Now we're going to make the player's movement input relative to the camera's point of view.</p>
					
					<section>
						<h3>Input Space</h3>
						
						<p>The input could be defined in any space, not just world space or the orbit camera's. It can be any space defined by a <code>Transform</code> component. Add a player input space configuration field to <code>MovingSphere</code> for this purpose.</p>
						
						<pre translate="no">	<ins>[SerializeField]</ins>
	<ins>Transform playerInputSpace = default;</ins></pre>
						
						<p>Assign the orbit camera to this field. This is a scene-specific configuration, so not part of the sphere prefab, although it could be set to itself, which would make movement relative to its own orientation.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/camera-relative-movement/player-input-space.png" width="320" height="88">
							<figcaption>Player input space set to camera.</figcaption>
						</figure>
						
						<p>If the input space is not set then we keep the player input in world space. Otherwise, we have to convert from the provided space to world space. We can do that by invoking <code>Transform.TransformDirection</code> in <code>Update</code> if a player input space is set.</p>
						
						<pre translate="no">		<ins>if (playerInputSpace) {</ins>
			<ins>desiredVelocity = playerInputSpace.TransformDirection(</ins>
				<ins>playerInput.x, 0f, playerInput.y</ins>
			<ins>) * maxSpeed;</ins>
		<ins>}</ins>
		<ins>else {</ins>
			desiredVelocity =
				new Vector3(playerInput.x, 0f, playerInput.y) * maxSpeed;
		<ins>}</ins></pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/minorjaggedbream?controls=0'></iframe></div>
							<figcaption>Relative movement, only going forward.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Normalized Direction</h3>
						
						<p>Although converting to world space makes the sphere move in the correct direction, its forward speed is affected by the vertical orbit angle. The further it deviates from horizontal the slower the sphere moves. That happens because we expect the desired velocity to lie in the XZ plane. We can make it so by retrieving the forward and right vectors from the player input space, discarding their Y components and normalizing them. Then the desired velocity becomes the sum of those vectors scaled by the player input.</p>
						
						<pre translate="no">		if (playerInputSpace) {
			<ins>Vector3 forward = playerInputSpace.forward;</ins>
			<ins>forward.y = 0f;</ins>
			<ins>forward.Normalize();</ins>
			<ins>Vector3 right = playerInputSpace.right;</ins>
			<ins>right.y = 0f;</ins>
			<ins>right.Normalize();</ins>
			desiredVelocity =
				<ins>(forward * playerInput.y + right * playerInput.x)</ins> * maxSpeed;
		}</pre>
						
						
					</section>
				</section>
				
				<section>
					<h2>Camera Collisions</h2>
					
					<p>Currently our camera only cares about its position and orientation relative to its focus. It doesn't know anything about the rest of the scene. Thus, it goes straight through other geometry, which causes a few problems. First, it is ugly. Second, it can cause geometry to obstruct our view of the sphere, which makes it hard to navigate. Third, clipping through geometry can reveal areas that shouldn't be visible. We'll begin by only considering the case where the camera's focus distance is set to zero.</p>
					
					<figure>
						<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/excellentcaninekentrosaurus?controls=0'></iframe></div>
						<figcaption>Camera going through geometry.</figcaption>
					</figure>
					
					<section>
						<h3>Reducing Look Distance</h3>
						
						<p>There are various strategies that can be used to keep the camera's view valid. We'll apply the simplest, which is to pull the camera forward along its look direction if something ends up in between the camera and its focus point.</p>
						
						<p>The most obvious way to detect a problem is by casting a ray from the focus point toward where we want to place the camera. Do this in <code>OrbitCamera.LateUpdate</code> once we have the look direction. If we hit something then we use the hit distance instead of the configured distance.</p>
						
						<pre translate="no">		Vector3 lookDirection = lookRotation * Vector3.forward;
		Vector3 lookPosition = focusPoint - lookDirection * distance;

		<ins>if (Physics.Raycast(</ins>
			<ins>focusPoint, -lookDirection, out RaycastHit hit, distance</ins>
		<ins>)) {</ins>
			<ins>lookPosition = focusPoint - lookDirection * hit.distance;</ins>
		<ins>}</ins>
		
		transform.SetPositionAndRotation(lookPosition, lookRotation);</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/cornyremarkableimperialeagle?controls=0'></iframe></div>
							<figcaption>Staying in front of geometry.</figcaption>
						</figure>
						
						<p>Pulling the camera closer to the focus point can get it so close that it enters the sphere. When the sphere intersects the camera's near plane it can get partially of even totally clipped. You could enforce a minimum distance to avoid this, but that would mean the camera remains inside other geometry. There is no perfect solution to this, but it can be mitigated by restricting vertical orbit angles, not making level geometry too tight, and reducing the camera's near clip plane distance.</p>
					</section>
					
					<section>
						<h3>Keeping the Near Plane Clear</h3>
						
						<p>Casting a single ray isn't enough to solve the problem entirely. That's because the camera's near plane rectangle can still partially cut through geometry even when there is a clear line between the camera's position and the focus point. The solution is to perform a box cast instead, matching the near plane rectangle of the camera in world space, which represents the closest thing that the camera can see. It's analogous to a camera's sensor.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/camera-collisions/box-cast.png" width="300" height="200">
							<figcaption>Camera box cast; near plane rectangle is the long side of the triangle.</figcaption>
						</figure>
						
						<p>First, <code>OrbitCamera</code> needs a reference to its <code>Camera</code> component.</p>
						
						<pre translate="no">	<ins>Camera regularCamera;</ins>

	&hellip;
	
	void Awake () {
		<ins>regularCamera = GetComponent&lt;Camera>();</ins>
		focusPoint = focus.position;
		transform.localRotation = Quaternion.Euler(orbitAngles);
	}</pre>
						
						<p>Second, a box cast requires a 3D vector that contains the half extends of a box, which means half its width, height, and depth.</p>
						
						<p>Half the height can be found by taking the tangent of half the camera's field-of-view angle in radians, scaled by its near clip plane distance. Half the width is that scaled by the camera's aspect ratio. The depth of the box is zero. Let's calculate this in a convenient property.</p>
						
						<pre translate="no">	<ins>Vector3 CameraHalfExtends {</ins>
		<ins>get {</ins>
			<ins>Vector3 halfExtends;</ins>
			<ins>halfExtends.y =</ins>
				<ins>regularCamera.nearClipPlane *</ins>
				<ins>Mathf.Tan(0.5f * Mathf.Deg2Rad * regularCamera.fieldOfView);</ins>
			<ins>halfExtends.x = halfExtends.y * regularCamera.aspect;</ins>
			<ins>halfExtends.z = 0f;</ins>
			<ins>return halfExtends;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<aside>
							<h3>Can't we cache the half extends?</h3>
							<div>
								<p>Yes, assuming that the relevant camera properties don't change. Calculating it each frame ensures that it always works, but you could also explicitly recalculate it only when necessary.</p>
							</div>
						</aside>
						
						<p>Now replace <code>Physics.Raycast</code> with <code>Physics.BoxCast</code> in <code>LateUpdate</code>. The half extends has to be added as a second argument, along with the box's rotation as a new fifth argument.</p>
						
						<pre translate="no">		if (Physics.<ins>BoxCast</ins>(
			focusPoint, <ins>CameraHalfExtends,</ins> -lookDirection, out RaycastHit hit,
			<ins>lookRotation,</ins> distance
		)) {
			lookPosition = focusPoint - lookDirection * hit.distance;
		}</pre>
						
						<p>The near plane sits in front of the camera's position, so we should only cast up to that distance, which is the configured distance minus the camera's near plane distance. If we end up hitting something then the final distance is the hit distance plus the near plane distance.</p>
						
						<pre translate="no">		if (Physics.BoxCast(
			focusPoint, CameraHalfExtends, -lookDirection, out RaycastHit hit,
			lookRotation, distance <ins>- regularCamera.nearClipPlane</ins>
		)) {
			lookPosition = focusPoint -
				lookDirection * <ins>(</ins>hit.distance <ins>+ regularCamera.nearClipPlane)</ins>;
		}</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/reflectingremotedartfrog?controls=0'></iframe></div>
							<figcaption>Never clipping geometry.</figcaption>
						</figure>
						
						<p>Note that this means that the camera's position can still end up inside geometry, but its near plane rectangle will always remain outside. Of course this could fail if the box cast already starts inside geometry. If the focus object is already intersecting geometry it's likely the camera will do so as well.</p>
					</section>
					
					<section>
						<h3>Focus Radius</h3>
						
						<p>Our current approach works, but only if the focus radius is zero. When the focus is relaxed we can end up with a focus point inside geometry, even though the ideal focus point is valid. Thus we cannot expect that the focus point is a valid start of the box cast, so we'll have to use the ideal focus point instead. We'll cast from there to the near plane box position, which we find by moving from the camera position to the focus position until we reach the near plane.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/camera-collisions/box-cast-from-ideal-focus.png" width="300" height="200">
							<figcaption>Box cast from ideal focus point.</figcaption>
						</figure>
						
						<pre translate="no">		Vector3 lookDirection = lookRotation * Vector3.forward;
		Vector3 lookPosition = focusPoint - lookDirection * distance;

		<ins>Vector3 rectOffset = lookDirection * regularCamera.nearClipPlane;</ins>
		<ins>Vector3 rectPosition = lookPosition + rectOffset;</ins>
		<ins>Vector3 castFrom = focus.position;</ins>
		<ins>Vector3 castLine = rectPosition - castFrom;</ins>
		<ins>float castDistance = castLine.magnitude;</ins>
		<ins>Vector3 castDirection = castLine / castDistance;</ins>

		if (Physics.BoxCast(
			<ins>castFrom</ins>, CameraHalfExtends, <ins>castDirection</ins>, out RaycastHit hit,
			lookRotation, <ins>castDistance</ins>
		)) { &hellip; }</pre>
						
						<p>If something is hit then we position the box as far away as possible, then we offset to find the corresponding camera position.</p>
						
						<pre translate="no">		if (Physics.BoxCast(
			castFrom, CameraHalfExtends, castDirection, out RaycastHit hit,
			lookRotation, castDistance
		)) {
			<ins>rectPosition = castFrom + castDirection * hit.distance;</ins>
			lookPosition = <ins>rectPosition - rectOffset</ins>;
		}</pre>
						
						<figure>
						<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/majordistantgiraffe?controls=0'></iframe></div>
							<figcaption>Focus radius 2.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Obstruction Masking</h3>
						
						<p>We wrap up by making it possible for the camera to intersect some geometry, by ignoring it when performing the box cast. This makes it possible to ignore small detailed geometry, either for performance reasons or camera stability. Optionally those objects could still be detected but fade out instead of affecting the camera's position, but we won't cover that approach in this tutorial. Transparent geometry could be ignored as well. Most importantly, we should ignore the sphere itself. When casting from inside the sphere it will always be ignored, but a less responsive camera can end up casting from outside the sphere. If it then hits the sphere the camera would jump to the opposite side of the sphere.</p>
						
						<p>We control this behavior via a layer mask configuration field, just like those the sphere uses.</p>
						
						<pre translate="no">	<ins>[SerializeField]</ins>
	<ins>LayerMask obstructionMask = -1;</ins>
	
	&hellip;
	
	void LateUpdate () {
		&hellip;
		if (Physics.BoxCast(
			focusPoint, CameraHalfExtends, castDirection, out RaycastHit hit,
			lookRotation, castDistance<ins>, obstructionMask</ins>
		)) {
			rectPosition = castFrom + castDirection * hit.distance;
			lookPosition = rectPosition - rectOffset;
		}
		&hellip;
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/camera-collisions/obstruction-mask.png" width="320" height="38">
							<figcaption>Obstruction mask.</figcaption>
						</figure>
						
						<p>The next tutorial is <a href="../custom-gravity/index.html">Custom Gravity</a>.</p>
						
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/movement-04-orbit-camera/" class="repository">repository</a>
					<a href="https://catlikecoding.com/unity/tutorials/movement/orbit-camera/Orbit-Camera.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>