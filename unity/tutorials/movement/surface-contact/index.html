<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/movement/surface-contact/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/movement/surface-contact/tutorial-image.jpg">
		<meta property="og:title" content="Surface Contact">
		<meta property="og:description" content="A Unity Movement tutorial about refining how a sphere interacts with surfaces.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Surface Contact</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/movement/surface-contact/#article",
				"headline": "Surface Contact",
				"alternativeHeadline": "Staying in Touch",
				"datePublished": "2019-12-09",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Movement tutorial about refining how a sphere interacts with surfaces.",
				"image": "https://catlikecoding.com/unity/tutorials/movement/surface-contact/tutorial-image.jpg",
				"dependencies": "Unity 2019.2.14f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/movement/", "name": "Movement" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				MovingSphere: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Movement</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Surface Contact</h1>
					<p>Staying in Touch</p>
					<ul>
						<li>Stick to the ground instead of launching off a ramp.</li>
						<li>Perform a raycast.</li>
						<li>Configure multiple layers and their interaction.</li>
						<li>Navigate stairs.</li>
						<li>Make use of steep contacts.</li>
					</ul>
				</header>
				
				<p>This is the third installment of a tutorial series about controlling the <a href="../index.html">movement</a> of a character. It's about refining how a sphere interacts with surfaces.</p>
				
				<p>This tutorial is made with Unity 2019.2.14f1. It also uses the ProBuilder package.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>A sphere doing some parkour.</figcaption>
				</figure>
				
				<section>
					<h2>Sticking to the Ground</h2>
					
					<p>When our sphere reaches the top of a ramp it goes flying, due to its upward momentum. This is realistic, but might not be desirable.</p>
					
					<figure>
						<img src="sticking-to-the-ground/slopes-flying.png" width="400" height="200">
						<figcaption>Spheres go flying at top of ramp.</figcaption>
					</figure>
					
					<p>A similar thing happens when spheres bump into sudden small elevation differences. I made a test scene that demonstrates this for steps up to one unit high, with 0.1 increments.</p>
					
					<figure>
						<img src="sticking-to-the-ground/steps-scene.png" width="400" height="130">
						<figcaption>Steps test scene.</figcaption>
					</figure>
					
					<p>When approaching with enough velocity a sphere will bounce if the step isn't too high. In the test scene this even happens a little for the flat lane, because I made it by reducing the step height to zero without merging the vertices. That produces what's known as a ghost collision. Scene geometry should be designed to avoid that, but I kept it in to point it out.</p>
					
					<figure>
						<div class="vid" style="width: 190px; height:170px;"><iframe src='https://gfycat.com/ifr/weightybrokenamethystgemclam?controls=0'></iframe></div>
						<figcaption>Bouncing off steps.</figcaption>
					</figure>
					
					<p>In real life there are various techniques to keep something stuck to the ground. For example Formula One race cars are designed to convert airflow to downforce. So there is a realistic basis to do something similar for our spheres.</p>
					
					
					
					<section>
						<h3>Collision Timing</h3>
						
						<p>Let's consider the moment a sphere would get launched off a ramp. To keep it stuck to the surface we'll have to make adjustments to its velocity, realigning it with the surface. Let's examine exactly when we'll receive the information that we need. I'll make the sphere white when it's not on the ground, by adjusting its color in <code>Update</code> based on <code>OnGround</code>, similar to the coloration demonstrated at the end of the previous tutorial.</p>
						
						<pre translate="no">	void Update () {
		&hellip;

		<ins>GetComponent&lt;Renderer>().material.SetColor(</ins>
			<ins>"_Color", OnGround ? Color.black : Color.white</ins>
		<ins>);</ins>
	}</pre>
						
						<p>To observe the exact timing, temporarily reduce the physics timestep and time scale.</p>
						
						<figure>
							<img src="sticking-to-the-ground/launch-1.png" width="290" height="110" alt="frame 1"><br>
							<img src="sticking-to-the-ground/launch-2.png" width="290" height="110" alt="frame 2"><br>
							<img src="sticking-to-the-ground/launch-3.png" width="290" height="110" alt="frame 3">
							<figcaption>Three physics steps; timestep 0.2; time scale 0.5.</figcaption>
						</figure>
						
						<p>The physics step during which the sphere gets launched still has a collision. We act on that data during the next step, so we think that we're still grounded while we no longer are. It's the step after that when we no longer get collision data. So we're always going to be a bit too late, but this isn't a problem as long as we're aware of it.
					</section>
					
					<section>
						<h3>Steps Since Last Grounded</h3>
						
						<p>Let's keep track of how many physics steps there have been since we considered ourselves grounded. Add an integer field for it and increment it at the start of <code>UpdateState</code>. Then if it turns out that we're on the ground set it back to zero. We'll use this to determine when we should snap to the ground. It can also be useful for debugging.</p>
						
						<pre translate="no">	<ins>int stepsSinceLastGrounded;</ins>

	&hellip;

	void UpdateState () {
		<ins>stepsSinceLastGrounded += 1;</ins>
		velocity = body.velocity;
		if (OnGround) {
			<ins>stepsSinceLastGrounded = 0;</ins>
			jumpPhase = 0;
			if (groundContactCount > 1) {
				contactNormal.Normalize();
			}
		}
		else {
			contactNormal = Vector3.up;
		}
	}</pre>
						
						<aside>
							<h3>Don't we have to guard against integer overflow?</h3>
							<div>
								<p>We don't need to worry about that. It would take months in real time of not being grounded for the integer to overflow.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Snapping</h3>
						
						<p>Add a <code>SnapToGround</code> method that keeps us stuck to the ground if needed. If it succeeds then we'll be grounded. Have it indicate whether this happened by returning a boolean, initially just returning <code>false</code>.</p>
						
						<pre translate="no">	<ins>bool SnapToGround () {</ins>
		<ins>return false;</ins>
	<ins>}</ins></pre>
						
						<p>That way we can conveniently combine it with the <code>OnGround</code> check in <code>UpdateState</code> using a boolean OR. That works because <code>SnapToGround</code> will only get invoked when <code>OnGround</code> is <code>false</code>.</p>
						
						<pre translate="no">	void UpdateState () {
		stepsSinceLastGrounded += 1;
		velocity = body.velocity;
		if (OnGround <ins>|| SnapToGround()</ins>) {
			&hellip;
		}
		&hellip;
	}</pre>
						
						<p><code>SnapToGround</code> only gets invoked when we're not grounded, so the amount of steps since last grounded is greater than zero. But we should only try to snap once directly after we lost contact. Thus when the amount of steps is greater than one we should abort.</p>
						
						<pre translate="no">	bool SnapToGround () {
		<ins>if (stepsSinceLastGrounded > 1) {</ins>
			<ins>return false;</ins>
		<ins>}</ins>
		return false;
	}</pre>
					</section>
					
					<section>
						<h3>Raycasting</h3>
						
						<p>We only want to snap when there's ground below the sphere to stick to. We can check this by casting a ray from the sphere body's position straight down, by invoking <code>Physics.Raycast</code> with <code>body.position</code> and the down vector as arguments. The physics engine will perform this raycast and return whether it hit something. If not then there is no ground and we abort.</p>
						
						<pre translate="no">		if (stepsSinceLastGrounded > 1) {
			return false;
		}
		<ins>if (!Physics.Raycast(body.position, Vector3.down)) {</ins>
			<ins>return false;</ins>
		<ins>}</ins>
		return false;</pre>
						
						<p>If the ray did hit something then we must check whether it counts as ground. Information about what was hit can be retrieved via a third <code>RaycastHit</code> struct output parameter.</p>
						
						<pre translate="no">		if (!Physics.Raycast(body.position, Vector3.down, <ins>out RaycastHit hit</ins>)) {
			return false;
		}</pre>
						
						<aside>
							<h3>How does that code work?</h3>
							<div>
								<p><code>RaycastHit</code> is a struct, thus a value type. We can define a variable via <code>RaycastHit hit</code>, then pass it as a third argument to <code>Physics.Raycast</code>. But it's an output argument, which means that it's passed by reference as if it were an object reference. This must be explicitly indicated by adding the <code>out</code> modifier to it. The method is responsible for assigning a value to it.</p>
								
								<p>Besides that, it's also possible to declare the variable used for the output argument inside the argument list, instead of on a separate line. That's what we do here.</p>
							</div>
						</aside>
						
						<p>The hit data includes a normal vector, which we can use to check whether the surface we hit counts as ground. If not, abort. Note that in this case we're dealing with the true surface normal, not a collision normal.</p>
						
						<pre translate="no">		if (!Physics.Raycast(body.position, Vector3.down, out RaycastHit hit)) {
			return false;
		}
		<ins>if (hit.normal.y &lt; minGroundDotProduct) {</ins>
			<ins>return false;</ins>
		<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Realigning with the Ground</h3>
						
						<p>If we haven't aborted at this point then we've just lost contact with the ground but are still above ground, so we snap to it. Set the ground contact count to one, use the found normal as the contact normal, and return <code>true</code>.</p>
						
						<pre translate="no">		if (hit.normal.y &lt; minGroundDotProduct) {
			return false;
		}

		<ins>groundContactCount = 1;</ins>
		<ins>contactNormal = hit.normal;</ins>
		return <ins>true</ins>;</pre>
						
						<p>Now we consider ourselves to be grounded, although we're still in the air. The next step is to adjust our velocity to align with the ground. This works just like aligning the desired velocity, except that we have to keep the current speed and we'll calculate it explicitly instead of relying on <code>ProjectOnContactPlane</code>.</p>
						
						<pre translate="no">		groundContactCount = 1;
		contactNormal = hit.normal;
		<ins>float speed = velocity.magnitude;</ins>
		<ins>float dot = Vector3.Dot(velocity, hit.normal);</ins>
		<ins>velocity = (velocity - hit.normal * dot).normalized * speed;</ins>
		return true;</pre>
						
						<p>At this point we are still floating above the ground, but gravity will take care of pulling us down to the surface. In fact, the velocity might already point somewhat down, in which case realigning it would slow convergence to the ground. So we should only adjust the velocity when the dot product of it and the surface normal is positive.</p>
						
						<pre translate="no">		<ins>if (dot > 0f) {</ins>
			velocity = (velocity - hit.normal * dot).normalized * speed;
		<ins>}</ins></pre>
						
						<p>This is enough to keep our spheres sticking to the ramp when going over the top. They will float for a little bit but this is hardly noticeable in practice. Even though the spheres will turn white for one frame, in <code>FixedUpdate</code> we'll treat the spheres as grounded the whole time. It's just that <code>Update</code> gets invoked while we're in an intermediate state.</p>
						
						<figure>
							<div class="vid" style="width: 300px; height:145px;"><iframe src='https://gfycat.com/ifr/unacceptablejubilantcockroach?controls=0'></iframe></div>
							<figcaption>Sticking to slope.</figcaption>
						</figure>
						
						<p>It also prevents spheres from getting launched when bouncing off a step.</p>
						
						<figure>
							<div class="vid" style="width: 200px; height:160px;"><iframe src='https://gfycat.com/ifr/weakelementaryliger?controls=0'></iframe></div>
							<figcaption>Sticking to a step.</figcaption>
						</figure>
						
						<p>Note that we're only considering a single point below us to decide whether we're above ground. This works fine as long as the level geometry isn't too noisy nor too detailed. For example a tiny deep crack could cause this to fail if the ray happened to be cast into it.</p>
					</section>
					
					<section>
						<h3>Max Snap Speed</h3>
						
						<p>It makes sense that at high speeds our sphere gets launched anyway, so let's add a configurable max snap speed. Set it to the maximum speed by default so snapping always happens when possible.</p>
						
						<pre translate="no">	<ins>[SerializeField, Range(0f, 100f)]</ins>
	<ins>float maxSnapSpeed = 100f;</ins></pre>
						
						<figure>
							<img src="sticking-to-the-ground/max-snap-speed.png" width="320" height="38">
							<figcaption>Max snap speed.</figcaption>
						</figure>
						
						<p>Then also abort <code>SnapToGround</code> when the current speed exceeds the max snap speed. We can do this before the raycast by calculating the speed earlier.</p>
						
						<pre translate="no">	bool SnapToGround () {
		if (stepsSinceLastGrounded > 1) {
			return false;
		}
		<ins>float speed = velocity.magnitude;</ins>
		<ins>if (speed > maxSnapSpeed) {</ins>
			<ins>return false;</ins>
		<ins>}</ins>
		if (!Physics.Raycast(body.position, Vector3.down, out RaycastHit hit)) {
			return false;
		}
		if (hit.normal.y &lt; minGroundDotProduct) {
			return false;
		}

		groundContactCount = 1;
		contactNormal = hit.normal;
		<del>//float speed = velocity.magnitude;</del>
		float dot = Vector3.Dot(velocity, hit.normal);
		if (dot > 0f) {
			velocity = (velocity - hit.normal * dot).normalized * speed;
		}
		return true;
	}</pre>
						
						<p>Note that setting both max speeds to the same value can produce inconsistent results due to precision limitations. It's better to make the max snap speed a bit higher or lower than the max speed.</p>
						
						<figure>
							<img src="sticking-to-the-ground/same-max-speeds.png" width="200" height="170">
							<figcaption>Same max speeds produce inconsistent results.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>Probe Distance</h3>
						
						<p>We're snapping when there's ground below the sphere, no matter how far away it is. It's better to only check for nearby ground. We do this by limiting the range of the probe. There is no best maximum distance, but if too low snapping can fail at steep angles or high velocities, while too high can lead to nonsensical snapping to ground far below. Make it configurable with a minimum of zero and a default of one. As our sphere has a radius of 0.5 that means we check up to half a unit below the sphere's bottom.</p>
						
						<pre translate="no">	<ins>[SerializeField, Min(0f)]</ins>
	<ins>float probeDistance = 1f;</ins></pre>
						
						<figure>
							<img src="sticking-to-the-ground/probe-distance.png" width="320" height="38">
							<figcaption>Probe distance.</figcaption>
						</figure>
						
						<p>Add the distance as a fourth parameter to <code>Physics.Raycast</code>.</p>
						
						<pre translate="no">		if (!Physics.Raycast(
			body.position, Vector3.down, out RaycastHit hit<ins>, probeDistance</ins>
		)) {
			return false;
		}</pre>
					</section>
					
					<section>
						<h3>Ignoring Agents</h3>
						
						<p>When checking for ground to snap to it makes sense that we only consider geometry that could represent ground. By default the raycast checks anything except for objects put on the <em translate="no">Ignore Raycast</em> layer. What shouldn't count can vary, but the spheres that we're moving most likely don't. We won't accidentally hit the sphere we're casting for, because we're casting from its position outward, but we might hit another moving sphere. To avoid that we can set their <em translate="no">Layer</em> to <em translate="no">Ignore Raycast</em>, but let's create a new layer for everything that's active and should be ignored for this purpose.</p>
						
						<p>Go to the layer settings, either via the <em translate="no">Add Layer...</em> option of a game object's <em translate="no">Layer</em> dropdown or the <em translate="no">Tags and Layers</em> section of the project settings. Then define a new custom user layer. Let's name it <em translate="no">Agent</em>, for generic active entities that aren't part of the level geometry.</p>
						
						<figure>
							<img src="sticking-to-the-ground/tags-layers.png" width="320" height="280">
							<figcaption>Tags and layers, with custom <em translate="no">Agent</em> layer 8.</figcaption>
						</figure>
						
						<p>Move all spheres to that layer. Changing the prefab's layer will do.</p>
						
						<figure>
							<img src="sticking-to-the-ground/layer-agent.png" width="320" height="44">
							<figcaption>Layer set to <em translate="no">Agent</em>.</figcaption>
						</figure>
						
						<p>Next, add a configurable <code>LayerMask</code> probe mask to <code>MovingSphere</code>, initially set to &minus;1, which matches all layers.</p>
						
						<pre translate="no">	<ins>[SerializeField]</ins>
	<ins>LayerMask probeMask = -1;</ins></pre>
						
						<p>Then we can configure the sphere so it probes all layers except <em translate="no">Ignore Raycast</em> and <em translate="no">Agent</em>.</p>
						
						<figure>
							<img src="sticking-to-the-ground/probe-mask.png" width="320" height="176">
							<figcaption>Probe mask.</figcaption>
						</figure>
						
						<p>To apply the mask add it as a fifth parameter to <code>Physics.Raycast</code>.</p>
						
						<pre translate="no">		if (!Physics.Raycast(
			body.position, Vector3.down, out RaycastHit hit,
			probeDistance<ins>, probeMask</ins>
		)) {
			return false;
		}</pre>
						
					</section>
					
					<section>
						<h3>Jumping and Snapping</h3>
						
						<p>Snapping now works and is configurable, but it also activates when we jump, negating upward momentum. To make jumps functional again we have to avoid snapping directly after we jumped. We can track this by counting the physics steps since we last jumped, just like we count the steps since last grounded. Increment it at the beginning of <code>UpdateState</code> and set it back to zero when a jump activates.</p>
						
						<pre translate="no">	int stepsSinceLastGrounded<ins>, stepsSinceLastJump</ins>;

	&hellip;

	void UpdateState () {
		stepsSinceLastGrounded += 1;
		<ins>stepsSinceLastJump += 1;</ins>
		&hellip;
	}

	&hellip;

	void Jump () {
		if (OnGround || jumpPhase &lt; maxAirJumps) {
			<ins>stepsSinceLastJump = 0;</ins>
			jumpPhase += 1;
			&hellip;
		}
	}</pre>
						
						<p>Now we can abort <code>SnapToGround</code> also when it's too soon after a jump. Because of the collision data delay we're still considered grounded the step after the jump was initiated. So we must abort if we're two or fewer steps after a jump.</p>
						
						<pre translate="no">		if (stepsSinceLastGrounded > 1 <ins>|| stepsSinceLastJump &lt;= 2</ins>) {
			return false;
		}</pre>
						
					</section>
				</section>
				
				<section>
					<h2>Stairs</h2>
					
					<p>Let's next consider a more difficult kind of surface: stairs. Realistically spheres cannot roll up stairs very well if at all, but we might want them to do so anyway, maybe because they represent something that should be able to navigate stairs. I made a test scene containing five 45&deg; stairs, with step sizes 0.1, 0.2, 0.3, 0.4, and 0.5.</p>
					
					<figure>
						<img src="stairs/stairs-test-scene.png" width="400" height="190">
						<figcaption>Stairs test scene.</figcaption>
					</figure>
					
					<p>With default settings the spheres can't handle the stairs at all. At maximum acceleration most manage to ascend, but the results are unreliable and bouncy, no smooth movement at all. Trying to move at an angle instead of straight up the stairs is almost impossible.</p>
					
					<figure>
						<div class="vid" style="width: 300px; height:170px;"><iframe src='https://gfycat.com/ifr/paleinconsequentialbrownbear?controls=0'></iframe></div>
						<figcaption>Bouncing up stairs; acceleration 100.</figcaption>
					</figure>
					
					<section>
						<h3>Simplified Collider</h3>
						
						<p>Large stair steps make movement impossible. And while it is possible to bounce up stairs with small steps, collisions become arbitrary and motion becomes jittery instead of smooth.</p>
						
						<p>Rather than try to fight agains the physics engine we'll be pragmatic and make its work easier. We want smooth, consistent, controllable motion on stairs. We can get that when we use flat ramps instead. So let's replace the colliders of the stairs with ramps.</p>
						
						<p>A ramp is a poor approximation of stairs. The best compromise is to design the collider ramp so it cuts through the middle of the steps. The collisions will then happen both a bit above and below the visible geometry.</p>
						
						<figure>
							<img src="stairs/simplification.png" width="300" height="260">
							<figcaption>Stairs simplification.</figcaption>
						</figure>
						
						<p>I've created such shapes to match the five stairs, first as regular <em translate="no">ProBuilder</em> objects. Then I converted them to colliders via the <em translate="no">Set Collider</em> option in the <em translate="no">ProBuilder</em> window.</p>
						
						<figure>
							<img src="stairs/simplified.png" width="250" height="220" alt="normal">
							<img src="stairs/simplified-colliders.png" width="250" height="220" alt="colliders">
							<figcaption>Simplified stairs, as normal objects and as colliders.</figcaption>
						</figure>
						
						<p>Disable the mesh collider components of the stairs, but don't remove them at this point. Then temporarily increase the max ground angle to 46&deg; so the spheres can move up the 45&deg; stairs.</p>
						
						<figure>
							<div class="vid" style="width: 300px; height:170px;"><iframe src='https://gfycat.com/ifr/thoughtfuldismalgyrfalcon?controls=0'></iframe></div>
							<figcaption>Treating stairs as ramps, max ground angle 46&deg;.</figcaption>
						</figure>
						
						<p>While it requires some additional level design work, using simplified colliders for stairs is the best way to make them navigable using physics. In general it is a good idea to make collision shapes as simple as possible, avoiding needless details both for performance and movement stability reasons. So we'll stick with this approach. But it is an approximation, so on close inspection you'll see that the spheres both cut through and hover above the stair steps. However this usually isn't that obvious from a distance and while in motion.</p>
						
						<figure>
							<img src="stairs/approximation.png" width="180" height="170">
							<figcaption>Approximation.</figcaption>
						</figure>
						
						<aside>
							<h3>Can we avoid slowly rolling down stairs?</h3>
							<div>
								<p>We'll deal with that in the future, when we focus on gravity.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Detailed and Stairs Layers</h3>
						
						<p>That we use a simplified collider for sphere-stairs interaction doesn't mean we cannot use the original stairs collider for other collisions. For example we might want small debris to land on the individual stair steps correctly, instead of sliding down the ramp. Let's make this possible by adding two more layers: one for detailed and one for stairs objects.</p>
						
						<figure>
							<img src="stairs/detailed-stairs-layers.png" width="320" height="56">
							<figcaption>Layers for detailed and stairs objects.</figcaption>
						</figure>
						
						<p>The probe mask should include the <em translate="no">Stairs</em> layer but not the <em translate="no">Detailed</em> layer.</p>
						
						<figure>
							<img src="stairs/probe-mask.png" width="320" height="190">
							<figcaption>Adjusted probe mask.</figcaption>
						</figure>
						
						<p>Next, go to the <em translate="no">Physics</em> section of the projects settings and adjust the layer collision matrix. <em translate="no">Stairs</em> should only interact with <em translate="no">Agent</em>, which should not interact with <em translate="no">Detailed</em>.</p>
						
						<figure>
							<img src="stairs/layer-collision-matrix.png" width="270" height="248">
							<figcaption>Layer collision matrix.</figcaption>
						</figure>
						
						<p>Now enable the stairs mesh collider components again. Then add a few small rigidbody objects to fall on top of them to see both kind of interactions at the same time. If you give those objects a low enough mass&mdash;like 0.05&mdash;the spheres will be able to push them aside.</p>
						
						<figure>
							<div class="vid" style="width: 300px; height:216px;"><iframe src='https://gfycat.com/ifr/terriblewelcomeirrawaddydolphin?controls=0'></iframe></div>
							<figcaption>Two ways of colliding with stairs.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Max Stairs Angle</h3>
						
						<p>If we're able to climb stairs, it makes sense that we use a different max angle for stairs than for normal ground. So add a separate max angle for them, set to 50&deg; by default.</p>
						
						<pre translate="no">	[SerializeField, Range(0, 90)]
	float maxGroundAngle = 25f<ins>, maxStairsAngle = 50f</ins>;
	
	&hellip;
	
	float minGroundDotProduct<ins>, minStairsDotProduct</ins>;

	&hellip;

	void OnValidate () {
		minGroundDotProduct = Mathf.Cos(maxGroundAngle * Mathf.Deg2Rad);
		<ins>minStairsDotProduct = Mathf.Cos(maxStairsAngle * Mathf.Deg2Rad);</ins>
	}</pre>
						
						<figure>
							<img src="stairs/max-stairs-angle.png" width="320" height="38">
							<figcaption>Max ground and stairs angle.</figcaption>
						</figure>
						
						<p>Which min dot product we have to compare with now depends on what kind of surface we're on. We'll add a configurable stairs mask option for that, similar to the probe mask.</p>
						
						<pre translate="no">	[SerializeField]
	LayerMask probeMask = -1<ins>, stairsMask = -1</ins>;</pre>
						
						<figure>
							<img src="stairs/stairs-mask.png" width="320" height="38">
							<figcaption>Stairs mask.</figcaption>
						</figure>
						
						<aside>
							<h3>Why not use <code>LayerMask.NameToLayer("Stairs")</code>?</h3>
							<div>
								<p>That's possible, but by using a mask we don't rely on a hard-coded layer name and are more flexible, which also makes experimentation easier.</p>
							</div>
						</aside>
						
						<p>Create a new <code>GetMinDot</code> method that returns the appropriate minimum for a given layer, which is an integer. Assuming we can directly compare the stairs mask and layer, then if they're not equal return the min ground dot product, otherwise the min stairs dot product.</p>
						
						<pre translate="no">	<ins>float GetMinDot (int layer) {</ins>
		<ins>return stairsMask != layer ?</ins>
			<ins>minGroundDotProduct : minStairsDotProduct;</ins>
	<ins>}</ins></pre>
						
						<p>However, the mask is a bit mask, with one bit per layer. Specifically, if the stairs is the eleventh layer then it matches the eleventh bit. We can create a value with that single bit set by using <code>1 &lt;&lt; layer</code>, which applies the left-shift operator to the number 1 an amount of times equal to the layer index, which is ten. The result would be the binary number 10000000000.</p>
						
						<pre translate="no">		return stairsMask != <ins>(1 &lt;&lt; layer)</ins> ?</pre>
						
						<p>That would work if the mask has only a single layer selected, but let's support a mask for any combination of layers. We do that by taking the boolean AND of the mask and layer bit. If the result is zero then the layer is not part of the mask.</p>
						
						<pre translate="no">	return <ins>(stairsMask &amp; (1 &lt;&lt; layer)) == 0</ins> ?</pre>
						
						<p>Retrieve the correct min dot value at the start of <code>EvaluateCollision</code> and use it to check whether a contact counts as ground.</p>
						
						<pre translate="no">	void EvaluateCollision (Collision collision) {
		<ins>float minDot = GetMinDot(collision.gameObject.layer);</ins>
		for (int i = 0; i &lt; collision.contactCount; i++) {
			Vector3 normal = collision.GetContact(i).normal;
			if (normal.y >= <ins>minDot</ins>) {
				groundContactCount += 1;
				contactNormal += normal;
			}
		}
	}</pre>
						
						<p>Also use <code>GetMinDot</code> in <code>SnapToGround</code> when checking whether we're above ground.</p>
						
						<pre translate="no">		if (hit.normal.y &lt; <ins>GetMinDot(hit.collider.gameObject.layer)</ins>) {
			return false;
		}</pre>
						
					</section>
				</section>
				
				<section>
					<h2>Steep Contacts</h2>
					
					<p>Besides ground contacts there are also other contacts. A ground contact is needed for movement, but sometimes we're only in contact with a wall. Or we could be stuck in a crevasse. If we had air acceleration we would still have some control in such cases, but with some extra work we can do a lot more.</p>
					
					<section>
						<h3>Detecting Steep Contacts</h3>
						
						<p>A steep contact is one that is too steep to count as ground, but isn't a ceiling or overhang. So everything up to a perfectly vertical wall. Let's keep track of the normal and count of such contacts in fields and with a property, just like we do for the regular ground contacts.</p>
						
						<pre translate="no">	Vector3 contactNormal<ins>, steepNormal</ins>;

	int groundContactCount<ins>, steepContactCount</ins>;

	bool OnGround => groundContactCount > 0;

	<ins>bool OnSteep => steepContactCount > 0;</ins></pre>
						
						<p>Reset the new data in <code>ClearState</code> as well.</p>
						
						<pre translate="no">	void ClearState () {
		groundContactCount = <ins>steepContactCount =</ins> 0;
		contactNormal = <ins>steepNormal =</ins> Vector3.zero;
	}</pre>
						
						<p>In <code>EvaluateCollision</code>, if we don't have a ground contact check whether it's a steep contact. The dot product of a perfectly vertical wall should be zero, but let's be a bit lenient and accept everything above &minus;0.01.
						
						<pre translate="no">			if (normal.y >= minDot) {
				groundContactCount += 1;
				contactNormal += normal;
			}
			<ins>else if (normal.y > -0.01f) {</ins>
				<ins>steepContactCount += 1;</ins>
				<ins>steepNormal += normal;</ins>
			<ins>}</ins></pre>
						
					</section>
					
					<section>
						<h3>Crevasses</h3>
						
						<p>A crevasse is problematic, because once stuck in it without air jumps available it's impossible to get out, unless air acceleration is large. I created a test scene with a small crevasse to demonstrate this.</p>
						
						<figure>
							<img src="steep-contacts/crevasse.png" width="290" height="80">
							<figcaption>Crevasse test scene.</figcaption>
						</figure>
						
						<p>The idea is that if we end up grounded the steep contacts aren't needed. But when even snapping cannot detect the ground our next best bet is to check for a crevasse or similar case. If we find ourselves wedged inside a narrow space, with multiple steep contacts, then we might be able to move by pushing against those contact points.</p>
						
						<p>Create a <code>CheckSteepContacts</code> that returns whether it succeeded in converting the steep contacts into virtual ground. If there are multiple steep contacts then normalize them and check whether the result counts as ground. If so, return success, otherwise failure. In this case we don't have to check for stairs.</p>
						
						<pre translate="no">	<ins>bool CheckSteepContacts () {</ins>
		<ins>if (steepContactCount > 1) {</ins>
			<ins>steepNormal.Normalize();</ins>
			<ins>if (steepNormal.y >= minGroundDotProduct) {</ins>
				<ins>groundContactCount = 1;</ins>
				<ins>contactNormal = steepNormal;</ins>
				<ins>return true;</ins>
			<ins>}</ins>
		<ins>}</ins>
		<ins>return false;</ins>
	<ins>}</ins></pre>
						
						<p>Add <code>CheckSteepContacts</code> as a third check for the grounded state in <code>UpdateState</code>.</p>
						
						<pre translate="no">		if (OnGround || SnapToGround() <ins>|| CheckSteepContacts()</ins>) {
			stepsSinceLastGrounded = 0;
			jumpPhase = 0;
			if (groundContactCount > 1) {
				contactNormal.Normalize();
			}
		}</pre>
						
						<p>Now we're able to move a bit and jump while in the crevasse, and in similar places where we previously got stuck.</p>
						
						<figure>
							<img src="steep-contacts/escaping-crevasse.png" width="250" height="80">
							<figcaption>Escaping crevasse.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Wall Jumping</h3>
						
						<p>Let's also revisit wall jumping. We previously restricted jumping to only when on the ground, or air jumps. But we can support jumping off walls as well, if we base the jump direction on the steep normal instead of the contact normal.</p>
						
						<p>Begin by making the jump direction variable and removing the current validity check in <code>Jump</code>.</p>
						
						<pre translate="no">	void Jump () {
		<ins>Vector3 jumpDirection;</ins>
		
		<del>//if (OnGround || jumpPhase &lt; maxAirJumps) {</del>
		stepsSinceLastJump = 0;
		jumpPhase += 1;
		float jumpSpeed = Mathf.Sqrt(-2f * Physics.gravity.y * jumpHeight);
		float alignedSpeed = Vector3.Dot(velocity, <ins>jumpDirection</ins>);
		if (alignedSpeed > 0f) {
			jumpSpeed = Mathf.Max(jumpSpeed - alignedSpeed, 0f);
		}
		velocity += <ins>jumpDirection</ins> * jumpSpeed;
		<ins>//}</ins>
	}</pre>
						
						<p>Instead, check whether we're on the ground. If so, use the contact normal for the jump direction. If not, the next check is whether we're on something steep. If so, use the steep normal instead. After that comes the check for air jumps, for which we use the contact normal again, which has been set to the up vector. And if none of these apply then a jump is not possible and we abort.</p>
						
						<pre translate="no">		Vector3 jumpDirection;
		<ins>if (OnGround) {</ins>
			<ins>jumpDirection = contactNormal;</ins>
		<ins>}</ins>
		<ins>else if (OnSteep) {</ins>
			<ins>jumpDirection = steepNormal;</ins>
		<ins>}</ins>
		<ins>else if (jumpPhase &lt; maxAirJumps) {</ins>
			<ins>jumpDirection = contactNormal;</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>return;</ins>
		<ins>}</ins></pre>
						
						<figure>
							<img src="steep-contacts/wall-jump.png" width="220" height="160">
							<figcaption>Wall jumping.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Air Jumping</h3>
						
						<p>At this point we should revisit air jumping. Checking whether the jump phase is less than the max air jumps only works because the phase gets set back to zero directly after the jump, because in the next step we still count as grounded. Thus we should only reset the jump phase in <code>UpdateState</code> when we're more than one step after a jump was initiated, to avoid the false landing.</p>
						
						<pre translate="no">			stepsSinceLastGrounded = 0;
			<ins>if (stepsSinceLastJump > 1) {</ins>
				jumpPhase = 0;
			<ins>}</ins></pre>
						
						<p>To keep air jumps working we now have to check whether the jump phase is less than or equal to the max in <code>Jump</code>.</p>
						
						<pre translate="no">		else if (jumpPhase <ins>&lt;=</ins> maxAirJumps) {
			jumpDirection = contactNormal;
		}</pre>
						
						<p>However, this makes it possible to air jump one extra time after falling off a surface without jumping. To prevent that we skip the first jump phase when air jumping.</p>
						
						<pre translate="no">		else if (jumpPhase &lt;= maxAirJumps) {
			<ins>if (jumpPhase == 0) {</ins>
				<ins>jumpPhase = 1;</ins>
			<ins>}</ins>
			jumpDirection = contactNormal;
		}</pre>
						
						<p>But this is only valid if air jumping is allowed at all, so begin by checking that.</p>
						
						<pre translate="no">		else if (<ins>maxAirJumps > 0 &amp;&amp;</ins> jumpPhase &lt;= maxAirJumps) {
			if (jumpPhase == 0) {
				jumpPhase = 1;
			}
			jumpDirection = contactNormal;
		}</pre>
						
						<p>Finally, let's make wall jumping reset the jump phase so it's possible to wall jump into a new sequence of air jumps.</p>
						
						<pre translate="no">		else if (OnSteep) {
			jumpDirection = steepNormal;
			<ins>jumpPhase = 0;</ins>
		}</pre>
						
						<figure>
							<img src="steep-contacts/air-wall-air-jump.png" width="220" height="200">
							<figcaption>Air-wall-air jumping.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Upward Jump Bias</h3>
						
						<p>Jumping off a vertical wall doesn't increase vertical speed. So while it's possible to bounce between nearby opposite walls, gravity will always pull the sphere down. I made a test scene with two blocks to demonstrate this.</p>
						
						<figure>
							<img src="steep-contacts/stuck-at-the-bottom.png" width="220" height="180">
							<figcaption>Stuck at the bottom; jump height 3.</figcaption>
						</figure>
						
						<p>However, some games feature wall jumping as a means to reach great height. We can support this by adding an upward bias to the jump direction. The simplest way to do this is by adding the up vector to the jump direction and normalizing the result. The final direction is the average of both, so a jump from flat ground isn't affected while a jump off a perfectly vertical wall is affected the most, becoming into a 45&deg; jump.</p>
						
						<pre translate="no">		<ins>jumpDirection = (jumpDirection + Vector3.up).normalized;</ins>
		float alignedSpeed = Vector3.Dot(velocity, jumpDirection);</pre>
						
						<figure>
							<img src="steep-contacts/wall-jumping-upward.png" width="220" height="180">
							<figcaption>Wall jumping upward; jump height 3.</figcaption>
						</figure>
						
						<p>This affects all jump trajectories that aren't on perfectly flat ground or in the air, which is the most obvious when jumping while moving up a slope.</p>
						
						<figure>
							<img src="steep-contacts/jumping-without-bias.png" width="230" height="150" alt="without">
							<img src="steep-contacts/jumping-with-bias.png" width="230" height="150" alt="with">
							<figcaption>Jumping without and with bias.</figcaption>
						</figure>
						
						<p>Let's wrap up by removing the debug sphere coloration from <code>Update</code>.</p>
						
						<pre translate="no">		<del>//GetComponent&lt;Renderer>().material.SetColor(</del>
		<del>//	"_Color", OnGround ? Color.black : Color.white</del>
		<del>//);</del></pre>
						
						<p>The next tutorial is <a href="../orbit-camera/index.html">Orbit Camera</a>.</p>
						
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/movement-03-surface-contact/" class="repository">repository</a>
					<a href="https://catlikecoding.com/unity/tutorials/movement/surface-contact/Surface-Contact.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>