<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/tower-defense/scenarios/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/tower-defense/scenarios/tutorial-image.jpg">
		<meta property="og:title" content="Scenarios">
		<meta property="og:description" content="A Unity Tower Defense tutorial about creating gameplay scenarios to spawn waves of varied enemies.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Scenarios</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/tower-defense/scenarios/#article",
				"headline": "Scenarios",
				"alternativeHeadline": "Waves of Enemies",
				"datePublished": "2019-08-22",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Tower Defense tutorial about creating gameplay scenarios to spawn waves of varied enemies.",
				"image": "https://catlikecoding.com/unity/tutorials/tower-defense/scenarios/tutorial-image.jpg",
				"dependencies": "Unity 2018.4.6f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/tower-defense/", "name": "Tower Defense" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				Direction: 1,
				DirectionChange: 1,
				DirectionExtensions: 1,
				Enemy: 1,
				EnemyConfig: 1,
				EnemyFactory: 1,
				EnemySpawnSequence: 1,
				EnemyType: 1,
				EnemyWave: 1,
				Explosion: 1,
				FloatRange: 1,
				FloatRangeSlider: 1,
				FloatRangeSliderAttribute: 1,
				FloatRangeSliderDrawer: 1,
				Game: 1,
				GameBehavior: 1,
				GameBehaviorCollection: 1,
				GameBoard: 1,
				GameObjectFactory: 1,
				GameScenario: 1,
				GameTile: 1,
				GameTileContent: 1,
				GameTileContentFactory: 1,
				GameTileContentType: 1,
				LaserTower: 1,
				MortarTower: 1,
				Shell: 1,
				State: 1,
				T: 1,
				TargetPoint: 1,
				Tower: 1,
				TowerType: 1,
				WarEntity: 1,
				WarFactory: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Tower Defense</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Scenarios</h1>
					<p>Waves of Enemies</p>
					<ul>
						<li>Support small, medium, and large enemies.</li>
						<li>Create game scenarios with multiple enemy waves.</li>
						<li>Separate asset configuration and gameplay state.</li>
						<li>Begin, pause, win, lose, and speed up games.</li>
						<li>Make scenarios repeat and go on forever.</li>
					</ul>
				</header>
				
				<p>This is the fifth installment of a tutorial series about creating a simple <a href="../index.html">tower defense</a> game. It makes it possible to create gameplay scenarios that spawn waves of varied enemies.</p>
				
				<p>This tutorial is made with Unity 2018.4.6f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>It's getting rather cozy.</figcaption>
				</figure>
				
				<section>
					<h2>More Enemies</h2>
					
					<p>Always spawning the same blue cube enemy isn't very interesting. The first step of creating more interesting gameplay scenarios is to support more than one kind of enemy.</p>
					
					<section>
						<h3>Enemy Configurations</h3>
						
						<p>There are many ways that we could make enemies unique, but we'll keep it very simple: we classify them as either small, medium, or large. Create an <code>EnemyType</code> enum to indicate this.</p>
						
						<pre><ins>public enum EnemyType {</ins>
	<ins>Small, Medium, Large</ins>
<ins>}</ins></pre>
						
						<p>Adjust <code>EnemyFactory</code> so it supports these three enemy types instead of a single one. All three enemies require the same configuration fields, so add a nested <code>EnemyConfig</code> class that contains them all, then add three configuration fields of that type to the factory. As this class is solely for configuration and we won't use it anywhere else we can simply make its fields public so the factory can access them. <code>EnemyConfig</code> doesn't have to be public itself.</p>
						
						<pre>public class EnemyFactory : GameObjectFactory {

	<ins>[System.Serializable]</ins>
	<ins>class EnemyConfig {</ins>

		<ins>public Enemy prefab = default;</ins>

		<ins>[FloatRangeSlider(0.5f, 2f)]</ins>
		<ins>public FloatRange scale = new FloatRange(1f);</ins>

		<ins>[FloatRangeSlider(0.2f, 5f)]</ins>
		<ins>public FloatRange speed = new FloatRange(1f);</ins>

		<ins>[FloatRangeSlider(-0.4f, 0.4f)]</ins>
		<ins>public FloatRange pathOffset = new FloatRange(0f);</ins>
	<ins>}</ins>
	
	<del>//[SerializeField]</del>
	<del>//Enemy prefab = default;</del>

	<del>//&hellip;</del>
	
	<del>//[SerializeField, FloatRangeSlider(-0.4f, 0.4f)]</del>
	<del>//FloatRange pathOffset = new FloatRange(0f);</del>

	<ins>[SerializeField]</ins>
	<ins>EnemyConfig small = default, medium = default, large = default;</ins>
	
	&hellip;
}</pre>
						
						<p>Let's also make health configurable per enemy, as it makes sense for larger enemies to have more than smaller ones.</p>
						
						<pre>		<ins>[FloatRangeSlider(10f, 1000f)]</ins>
		<ins>public FloatRange health = new FloatRange(100f);</ins></pre>
						
						<p>Add a type parameter to <code>Get</code> so it becomes possible to get a specific type of enemy, with medium as the default. Use the type to get the correct configuration&mdash;for which a separate method is convenient&mdash;and then create and initialize the enemy as before, with an added health argument.</p>
						
						<pre>	<ins>EnemyConfig GetConfig (EnemyType type) {</ins>
		<ins>switch (type) {</ins>
			<ins>case EnemyType.Small: return small;</ins>
			<ins>case EnemyType.Medium: return medium;</ins>
			<ins>case EnemyType.Large: return large;</ins>
		<ins>}</ins>
		<ins>Debug.Assert(false, "Unsupported enemy type!");</ins>
		<ins>return null;</ins>
	<ins>}</ins>

	public Enemy Get (<ins>EnemyType type = EnemyType.Medium</ins>) {
		<ins>EnemyConfig config = GetConfig(type);</ins>
		Enemy instance = CreateGameObjectInstance(<ins>config.</ins>prefab);
		instance.OriginFactory = this;
		instance.Initialize(
			<ins>config.</ins>scale.RandomValueInRange,
			<ins>config.</ins>speed.RandomValueInRange,
			<ins>config.</ins>pathOffset.RandomValueInRange<ins>,</ins>
			<ins>config.health.RandomValueInRange</ins>
		);
		return instance;
	}</pre>
						
						<p>Add the required health parameter to <code>Enemy.Initialize</code> and use that to set its health, instead of deriving it from the size.</p>
						
						<pre>	public void Initialize (
		float scale, float speed, float pathOffset<ins>, float health</ins>
	) {
		&hellip;
		Health = <ins>health</ins>;
	}</pre>
					</section>
					
					<section>
						<h3>Designing Different Enemies</h3>
						
						<p>How you design the three enemy types is up to you, but for this tutorial I kept is as simple as possible. I duplicated the original enemy prefab and used it for all three sizes, only changing their material: yellow for small, blue for medium, and red for large. I didn't change the scale of the cube prefab, I instead used the scale configuration of the factory to size them. I also gave them increasing health and decreasing speed, respectively.</p>
						
						<figure>
							<img src="more-enemies/factory.png" width="320" height="348">
							<figcaption>Factory for enemy cubes at three sizes.</figcaption>
						</figure>
						
						<p>The quickest way to make all types appear in the game is to change <code>Game.SpawnEnemy</code> so it gets a random enemy type instead of always a medium one.</p>
						
						<pre>	void SpawnEnemy () {
		GameTile spawnPoint =
			board.GetSpawnPoint(Random.Range(0, board.SpawnPointCount));
		Enemy enemy = enemyFactory.Get(<ins>(EnemyType)(Random.Range(0, 3)</ins>));
		enemy.SpawnOn(spawnPoint);
		enemies.Add(enemy);
	}</pre>
						
						<figure>
							<img src="more-enemies/board.png" width="230" height="230">
							<figcaption>A mix of enemy types.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>Multiple Factories</h3>
						
						<p>The enemy factory now defines a set of three enemies. Our current factory produces cubes at three sizes, but there's nothing stopping us from creating another factory that produces something else, like spheres at three sizes. We can change which enemies get spawned by assigning a different factory to the game, thereby switching to a different theme.</p>
						
						<figure>
							<img src="more-enemies/spheres.png" width="230" height="230">
							<figcaption>Sphere enemies.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Enemy Waves</h2>
					
					<p>The second step of creating gameplay scenarios is to no longer spawn enemies at a fixed frequency. Instead, enemies should be spawned in successive waves until the scenario is completed or the game is lost.</p>
					
					<section>
						<h3>Spawn Sequences</h3>
						
						<p>A single enemy wave consists of a group of enemies that are spawned one after the other, until the wave is complete. A wave can contain a mix of enemies and the delay between successive spawns can vary. To keep this simple to implement we start with a basic enemy spawn sequence that produces the same enemy type at a fixed frequency. A wave is then simply an list of such spawn sequences.</p>
						
						<p>Create an <code>EnemySpawnSequence</code> class to configure one such sequence. As it is fairly complex put it in its own file. The sequence needs to know which factory to use, which type of enemy to spawn, how many, and how quickly. To make configuration easy we'll represent the last option with a cooldown, expressing how much time must pass before the next enemy gets spawned. Note that this approach makes it possible to mix enemy factories in a wave.</p>
						
						<pre><ins>using UnityEngine;</ins>

<ins>[System.Serializable]</ins>
<ins>public class EnemySpawnSequence {</ins>

	<ins>[SerializeField]</ins>
	<ins>EnemyFactory factory = default;</ins>

	<ins>[SerializeField]</ins>
	<ins>EnemyType type = EnemyType.Medium;</ins>

	<ins>[SerializeField, Range(1, 100)]</ins>
	<ins>int amount = 1;</ins>

	<ins>[SerializeField, Range(0.1f, 10f)]</ins>
	<ins>float cooldown = 1f;</ins>
<ins>}</ins></pre>
					
					</section>
					
					<section>
						<h3>Waves</h3>
						
						<p>A wave is just an array of spawn sequences. Create an <code>EnemyWave</code> asset type for it, which starts with a single default sequence.</p>
						
						<pre><ins>using UnityEngine;</ins>

<ins>[CreateAssetMenu]</ins>
<ins>public class EnemyWave : ScriptableObject {</ins>

	<ins>[SerializeField]</ins>
	<ins>EnemySpawnSequence[] spawnSequences = {</ins>
		<ins>new EnemySpawnSequence()</ins>
	<ins>};</ins>
<ins>}</ins></pre>
						
						<p>Now we can design enemy waves. For example, I created a wave that spawns a bunch of cube enemies, starting with ten small ones at two per second, followed by five medium once per second, and finally a single large with a five-second cooldown.
						
						<figure>
							<img src="enemy-waves/cube-wave.png" width="320" height="376">
							<figcaption>A wave of cubes, increasing in size.</figcaption>
						</figure>
						
						<aside>
							<h3>Could we add a delay between sequences?</h3>
							<div>
								<p>You could do that indirectly. For example, to put a four-second delay between the small and medium cubes, reduce the amount of the small cubes by one and insert a sequence for a single small cube after it that has a four-second cooldown.</p>
								
								<figure>
									<img src="enemy-waves/extra-delay.png" width="320" height="272">
									<figcaption>Four-second delay between small and medium.</figcaption>
								</figure>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Scenarios</h3>
						
						<p>A gameplay scenario is created from a sequence of waves. Create a <code>GameScenario</code> asset type for that, with a single wave array, then use it to design a scenario.</p>
						
						<pre><ins>using UnityEngine;</ins>

<ins>[CreateAssetMenu]</ins>
<ins>public class GameScenario : ScriptableObject {</ins>

	<ins>[SerializeField]</ins>
	<ins>EnemyWave[] waves = {};</ins>
<ins>}</ins></pre>
						
						<p>For example, I created a scenario with two small-medium-large waves, first with cubes and then with spheres.
						
						<figure>
							<img src="enemy-waves/scenario.png" width="320" height="142">
							<figcaption>Scenario with two SML waves.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>Progressing Through a Sequence</h3>
						
						<p>The asset types are used to design scenarios, but as assets they're meant to contain data that doesn't change while the game is playing. But to progress through a scenario we have to keep track of its state somehow. One way to do this would be to duplicate the asset when used in play and have the duplicate keep track of its state. But we don't need to duplicate the entire asset, all we need is the state and a reference to the asset. So let's create a separate <code>State</code> class, first for <code>EnemySpawnSequence</code>. As it applies to the sequence only, make it a nested class. It's only valid when it has a reference to its sequence, so give it a constructor method with a sequence parameter.</p>
						
						<figure>
							<img src="enemy-waves/sequence-state.png" width="315" height="50">
							<figcaption>Nested state type references its sequence.</figcaption>
						</figure>
						
						<pre>public class EnemySpawnSequence {

	&hellip;

	<ins>public class State {</ins>

		<ins>EnemySpawnSequence sequence;</ins>

		<ins>public State (EnemySpawnSequence sequence) {</ins>
			<ins>this.sequence = sequence;</ins>
		<ins>}</ins>
	<ins>}</ins>
}</pre>
						
						<p>Whenever we want to begin progressing through a sequence, we need to get a new state instance for it. Add a <code>Begin</code> method to the sequence that constructs the state and returns it. That makes it the responsibility of whoever invoked <code>Begin</code> to hold on to the state, while the sequence itself remains stateless. It would even be possible to progress through the same sequence multiple times in parallel.</p>
						
						
						<pre>public class EnemySpawnSequence {

	&hellip;
	
	<ins>public State Begin () => new State(this);</ins>

	public class State { &hellip; }
}</pre>
						
						<p>To make the state survive hot reloads in the editor it needs to be serializable.</p>
						
						<pre>	<ins>[System.Serializable]</ins>
	public class State { &hellip; }</pre>
						
						<p>A downside of this approach is that we need to create a new state object each time a sequence is started. We can avoid memory allocations by making it as a struct instead of a class. This is fine as long as the state remains small. Just be aware that the state is a value type. Passing it around will copy it, so keep track of it in a single place.</p>
						
						<pre>	[System.Serializable]
	public <ins>struct</ins> State { &hellip; }</pre>
						
						<p>The state of a sequence consists of just two things: the spawned enemy count and the cooldown progression. Add a <code>Progress</code> method that increases the cooldown by the time delta and then drops it back down if it reached the configured value, just like the spawn progression in <code>Game.Update</code>. Increment the count each time that happens. Also, the cooldown must start at its maximum value so the sequence spawns without initial delay.</p>
						
						<pre>		<ins>int count;</ins>

		<ins>float cooldown;</ins>

		public State (EnemySpawnSequence sequence) {
			this.sequence = sequence;
			<ins>count = 0;</ins>
			<ins>cooldown = sequence.cooldown;</ins>
		}
		
		<ins>public void Progress () {</ins>
			<ins>cooldown += Time.deltaTime;</ins>
			<ins>while (cooldown >= sequence.cooldown) {</ins>
				<ins>cooldown -= sequence.cooldown;</ins>
				<ins>count += 1;</ins>
			<ins>}</ins>
		<ins>}</ins></pre>
						
						<figure>
							<img src="enemy-waves/state-data.png" width="315" height="74">
							<figcaption>State holds only required data.</figcaption>
						</figure>
						
						<aside>
							<h3>Can we access <code>EnemySpawnSequence.cooldown</code> in <code>State</code>?</h3>
							<div>
								<p>Yes, because <code>State</code> is defined in the same scope. Nested types thus know about the private members of their containing type.</p>
							</div>
						</aside>
						
						<p>Progression should continue until the desired amount of enemies have been spawned and the cooldown is complete. At that moment <code>Progress</code> should indicate completion, but it's likely that we end up overshooting the cooldown a bit. Thus we must return the extra time at that point, to be used to progress the next sequence. To make that work we have to turn the time delta into a parameter. We also have to indicate that we're not yet finished, which we can do by returning a negative value.</p>
						
						<pre>		public <ins>float</ins> Progress (<ins>float deltaTime</ins>) {
			cooldown += <ins>deltaTime</ins>;
			while (cooldown >= sequence.cooldown) {
				cooldown -= sequence.cooldown;
				<ins>if (count >= sequence.amount) {</ins>
					<ins>return cooldown;</ins>
				<ins>}</ins>
				count += 1;
			}
			<ins>return -1f;</ins>
		}</pre>
					</section>
					
					<section>
						<h3>Spawning Enemies Anywhere</h3>
						
						<p>To make it possible for sequences to spawn enemies we'll convert <code>Game.SpawnEnemy</code> into another public static method.</p>
						
						<pre>	<ins>public static</ins> void SpawnEnemy (<ins>EnemyFactory factory, EnemyType type</ins>) {
		GameTile spawnPoint = <ins>instance.</ins>board.GetSpawnPoint(
			Random.Range(0, <ins>instance.</ins>board.SpawnPointCount)
		);
		Enemy enemy = factory.Get(<ins>type</ins>);
		enemy.SpawnOn(spawnPoint);
		<ins>instance.</ins>enemies.Add(enemy);
	}</pre>
						
						<p>As <code>Game</code> will no longer spawn enemies itself we can remove its enemy factory, spawn speed, spawn progress, and the spawning code from <code>Update</code>.</p>
						
						<pre>	<del>//[SerializeField]</del>
	<del>//EnemyFactory enemyFactory = default;</del>
	
	&hellip;
	
	<del>//[SerializeField, Range(0.1f, 10f)]</del>
	<del>//float spawnSpeed = 1f;</del>

	<del>//float spawnProgress;</del>

	&hellip;
	
	void Update () {
		&hellip;
		<del>//spawnProgress += spawnSpeed * Time.deltaTime;</del>
		<del>//while (spawnProgress >= 1f) {</del>
		<del>//	spawnProgress -= 1f;</del>
		<del>//	SpawnEnemy();</del>
		<del>//}</del>
		&hellip;
	}</pre>
						
						<p>Invoke <code>Game.SpawnEnemy</code> in <code>EnemySpawnSequence.State.Progress</code> after increasing its count.</p>
						
						<pre>		public float Progress (float deltaTime) {
			cooldown += deltaTime;
			while (cooldown >= sequence.cooldown) {
				&hellip;
				count += 1;
				<ins>Game.SpawnEnemy(sequence.factory, sequence.type);</ins>
			}
			return -1f;
		}</pre>
						
					</section>
					
					<section>
						<h3>Progressing Through a Wave</h3>
						
						<p>We use the same approach for progressing through a sequence to progress through an entire wave. Give <code>EnemyWave</code> its own <code>Begin</code> method that returns a new instance of a nested <code>State</code> struct. In this case the state contains the wave index and the state of the active sequence, which we initialize by beginning the first sequence.</p>
						
						<figure>
							<img src="enemy-waves/wave-state.png" width="315" height="128">
							<figcaption>Wave state, containing sequence state.</figcaption>
						</figure>
						
						<pre>public class EnemyWave : ScriptableObject {

	[SerializeField]
	EnemySpawnSequence[] spawnSequences = {
		new EnemySpawnSequence()
	};

	<ins>public State Begin() => new State(this);</ins>

	<ins>[System.Serializable]</ins>
	<ins>public struct State {</ins>

		<ins>EnemyWave wave;</ins>

		<ins>int index;</ins>

		<ins>EnemySpawnSequence.State sequence;</ins>

		<ins>public State (EnemyWave wave) {</ins>
			<ins>this.wave = wave;</ins>
			<ins>index = 0;</ins>
			<ins>Debug.Assert(wave.spawnSequences.Length > 0, "Empty wave!");</ins>
			<ins>sequence = wave.spawnSequences[0].Begin();</ins>
		<ins>}</ins>
	}
}</pre>
						
						<p>Give <code>EnemyWave.State</code> a <code>Progress</code> method as well, using the same approach as before, with a few changes. Start with progressing the active sequence and replacing the time delta with the result of that invocation. As long as there is time remaining, move on to the next sequence if available and progress it. If no sequences remain then return the remaining time, otherwise return a negative value.</p>
						
						<pre>		<ins>public float Progress (float deltaTime) {</ins>
			<ins>deltaTime = sequence.Progress(deltaTime);</ins>
			<ins>while (deltaTime >= 0f) {</ins>
				<ins>if (++index >= wave.spawnSequences.Length) {</ins>
					<ins>return deltaTime;</ins>
				<ins>}</ins>
				<ins>sequence = wave.spawnSequences[index].Begin();</ins>
				<ins>deltaTime = sequence.Progress(deltaTime);</ins>
			<ins>}</ins>
			<ins>return -1f;</ins>
		<ins>}</ins></pre>
						
					</section>
					
					<section>
						<h3>Progressing Through a Scenario</h3>
						
						<p>Give <code>GameScenario</code> the same treatment. In this case the state contains the wave index and the active wave state.</p>
						
						<pre>public class GameScenario : ScriptableObject {

	[SerializeField]
	EnemyWave[] waves = {};

	<ins>public State Begin () => new State(this);</ins>

	<ins>[System.Serializable]</ins>
	<ins>public struct State {</ins>

		<ins>GameScenario scenario;</ins>

		<ins>int index;</ins>

		<ins>EnemyWave.State wave;</ins>

		<ins>public State (GameScenario scenario) {</ins>
			<ins>this.scenario = scenario;</ins>
			<ins>index = 0;</ins>
			<ins>Debug.Assert(scenario.waves.Length > 0, "Empty scenario!");</ins>
			<ins>wave = scenario.waves[0].Begin();</ins>
		<ins>}</ins>
	<ins>}</ins>
}</pre>
						
						<p>As we're at the top level, the <code>Progress</code> method doesn't require a parameter and we can directly use <code>Time.deltaTime</code>. We don't need to return any remaining time, but do need to indicate whether the scenario is finished or not. Return <code>false</code> when we've finished the final wave and <code>true</code> otherwise to indicate that the scenario is still active.</p>
						
						<pre>		<ins>public bool Progress () {</ins>
			<ins>float deltaTime = wave.Progress(Time.deltaTime);</ins>
			<ins>while (deltaTime >= 0f) {</ins>
				<ins>if (++index >= scenario.waves.Length) {</ins>
					<ins>return false;</ins>
				<ins>}</ins>
				<ins>wave = scenario.waves[index].Begin();</ins>
				<ins>deltaTime = wave.Progress(deltaTime);</ins>
			<ins>}</ins>
			<ins>return true;</ins>
		<ins>}</ins></pre>
						
					</section>
					
					<section>
						<h3>Playing a Scenario</h3>
						
						<p>Finally, to play a scenario <code>Game</code> needs a configuration field for a scenario and keep track of the its state. We'll simply begin the scenario when we awake and progress it in <code>Update</code> before updating the other game state.</p>
						
						<pre>	<ins>[SerializeField]</ins>
	<ins>GameScenario scenario = default;</ins>

	<ins>GameScenario.State activeScenario;</ins>
	
	&hellip;
	
	void Awake () {
		board.Initialize(boardSize, tileContentFactory);
		board.ShowGrid = true;
		<ins>activeScenario = scenario.Begin();</ins>
	}
	
	&hellip;
	
	void Update () {
		&hellip;

		<ins>activeScenario.Progress();</ins>

		enemies.GameUpdate();
		Physics.SyncTransforms();
		board.GameUpdate();
		nonEnemies.GameUpdate();
	}</pre>
						
						<p>From now on the configured scenario runs as soon as the game begins. It will progress until completion and then do nothing.</p>
						
						<figure>
							<div class="vid" style="width: 230px; height:230px;"><iframe src='https://gfycat.com/ifr/minorunimportantdutchsmoushond'></iframe></div>
							<figcaption>Two waves, with time scale set to 10.</figcaption>
						</figure>
						
					</section>
				</section>
				
				<section>
					<h2>Beginning and Ending Games</h2>
					
					<p>We can play a single scenario, but once it is finished no more enemies will appear. To keep the game going we'll have to make it possible to begin a new scenario, either manually or because the player won or lost the game. You could also make it possible to select from multiple scenarios, but that won't be part of the tutorial.</p>
					
					<section>
						<h3>Beginning a New Game</h3>
						
						<p>Ideally we could begin a new game at any moment. This requires cleaning up the current state of the entire game, which means that we have to clear multiple objects. First, add a <code>Clear</code> method to <code>GameBehaviorCollection</code> that recycles all its behaviors.</p>
						
						<pre>	<ins>public void Clear () {</ins>
		<ins>for (int i = 0; i &lt; behaviors.Count; i++) {</ins>
			<ins>behaviors[i].Recycle();</ins>
		<ins>}</ins>
		<ins>behaviors.Clear();</ins>
	<ins>}</ins></pre>
						
						<p>That assumes that all behaviors can be recycled, which is currently not the case. To make this work, add an abstract <code>Recycle</code> method to <code>GameBehavior</code>.</p>
						
						<pre>	<ins>public abstract void Recycle ();</ins></pre>
						
						<p>The <code>Recycle</code> method of <code>WarEntity</code> must now explicitly override it.</p>
						
						<pre>	public <ins>override</ins> void Recycle () {
		originFactory.Reclaim(this);
	}
</pre>
						
						<p><code>Enemy</code> doesn't have a <code>Recycle</code> method yet, so give it one. All it needs to do is have the factory reclaim it. Then invoke <code>Recycle</code> everywhere we currently directly access the factory.</p>
						
						<pre>	public override bool GameUpdate () {
		if (Health &lt;= 0f) {
			<del>//OriginFactory.Reclaim(this);</del>
			<ins>Recycle();</ins>
			return false;
		}

		progress += Time.deltaTime * progressFactor;
		while (progress >= 1f) {
			if (tileTo == null) {
				<del>//OriginFactory.Reclaim(this);</del>
				<ins>Recycle();</ins>
				return false;
			}
			&hellip;
		}
		&hellip;
	}

	<ins>public override void Recycle () {</ins>
		<ins>OriginFactory.Reclaim(this);</ins>
	<ins>}</ins></pre>
						
						<p><code>GameBoard</code> needs to be cleared as well, so give it a <code>Clear</code> method that empties all tiles, clears the spawn points and updating content, and sets the default destination and spawn point. We can then invoke <code>Clear</code> at the end of <code>Initialize</code> instead of repeating code.</p>
						
						<pre>	public void Initialize (
		Vector2Int size, GameTileContentFactory contentFactory
	) {
		&hellip;
		for (int i = 0, y = 0; y &lt; size.y; y++) {
			for (int x = 0; x &lt; size.x; x++, i++) {
				&hellip;

				<del>//tile.Content = contentFactory.Get(GameTileContentType.Empty);</del>
			}
		}

		<del>//ToggleDestination(tiles[tiles.Length / 2]);</del>
		<del>//ToggleSpawnPoint(tiles[0]);</del>
		<ins>Clear();</ins>
	}
	
	<ins>public void Clear () {</ins>
		<ins>foreach (GameTile tile in tiles) {</ins>
			<ins>tile.Content = contentFactory.Get(GameTileContentType.Empty);</ins>
		<ins>}</ins>
		<ins>spawnPoints.Clear();</ins>
		<ins>updatingContent.Clear();</ins>
		<ins>ToggleDestination(tiles[tiles.Length / 2]);</ins>
		<ins>ToggleSpawnPoint(tiles[0]);</ins>
	<ins>}</ins></pre>
						
						<p>Now we can add a <code>BeginNewGame</code> method to <code>Game</code> that clears the enemies, non-enemies, and board, and then begins a new scenario.</p>
						
						<pre>	<ins>void BeginNewGame () {</ins>
		<ins>enemies.Clear();</ins>
		<ins>nonEnemies.Clear();</ins>
		<ins>board.Clear();</ins>
		<ins>activeScenario = scenario.Begin();</ins>
	<ins>}</ins></pre>
						
						<p>Invoke this method in <code>Update</code> if the B key is pressed, before progressing the scenario.</p>
						
						<pre>	void Update () {
		&hellip;

		<ins>if (Input.GetKeyDown(KeyCode.B)) {</ins>
			<ins>BeginNewGame();</ins>
		<ins>}</ins>

		activeScenario.Progress();

		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Losing the Game</h3>
						
						<p>The goal of the game is to defeat all enemies before too many have reached their destination. How many enemies need to succeed to trigger defeat depends on the starting health of the player, for which we'll add a configuration field to <code>Game</code>. As we're counting enemies we use an integer, not a float.</p>
						
						<pre>	<ins>[SerializeField, Range(0, 100)]</ins>
	<ins>int startingPlayerHealth = 10;</ins></pre>
						
						<figure>
							<img src="beginning-and-ending-games/player-health.png" width="320" height="38">
							<figcaption>Player begins with 10 health.</figcaption>
						</figure>
						
						<p>When awaking or beginning a new game, set the player's current health to the starting value.</p>
						
						<pre>	<ins>int playerHealth;</ins>

	&hellip;
	
	void Awake () {
		<ins>playerHealth = startingPlayerHealth;</ins>
		&hellip;
	}
	
	void BeginNewGame () {
		<ins>playerHealth = startingPlayerHealth;</ins>
		&hellip;
	}</pre>
						
						<p>Add a public static <code>EnemyReachedDestination</code> method so enemies can inform <code>Game</code> that they reached their destination. When that happens decrement the player's health.</p>
						
						<pre>	<ins>public static void EnemyReachedDestination () {</ins>
		<ins>instance.playerHealth -= 1;</ins>
	<ins>}</ins></pre>
						
						<p>Invoke the method in <code>Enemy.GameUpdate</code> at the appropriate moment.</p>
						
						<pre>			if (tileTo == null) {
				<ins>Game.EnemyReachedDestination();</ins>
				Recycle();
				return false;
			}</pre>
						
						<p>We can now check for defeat in <code>Game.Update</code>. If the player's health is zero or less, trigger defeat. We'll simply log this fact and immediately begin a new game, before progressing the scenario. But only do this if the starting health is positive. That allows us to use zero for starting health, which makes defeat impossible, which is handy for scenario testing.</p>
						
						<pre>		<ins>if (playerHealth &lt;= 0 &amp;&amp; startingPlayerHealth > 0) {</ins>
			<ins>Debug.Log("Defeat!");</ins>
			<ins>BeginNewGame();</ins>
		<ins>}</ins>

		activeScenario.Progress();</pre>
						
					</section>
					
					<section>
						<h3>Winning the Game</h3>
						
						<p>The alternative to defeat is victory, which is achieved when the scenario is finished while the player is still alive. So when the result of <code>GameScenario.Progess</code> is <code>false</code> log victory, begin a new game, and immediately progress it.</p>
						
						<pre>		if (playerHealth &lt;= 0) {
			Debug.Log("Defeat!");
			BeginNewGame();
		}

		<ins>if (!</ins>activeScenario.Progress()<ins>) {</ins>
			<ins>Debug.Log("Victory!");</ins>
			<ins>BeginNewGame();</ins>
			<ins>activeScenario.Progress();</ins>
		<ins>}</ins></pre>
						
						<p>However, that will result in victory after the last cooldown has completed, even if there are still enemies on the board. We should delay victory until all enemies are gone, which we could do by also checking whether the enemy collection is empty, assuming it has an <code>IsEmpty</code> property.</p>
						
						<pre>		if (!activeScenario.Progress() <ins>&amp;&amp; enemies.IsEmpty</ins>) {
			Debug.Log("Victory!");
			BeginNewGame();
			activeScenario.Progress();
		}</pre>
						
						<p>Add the required property to <code>GameBehaviorCollection</code>.</p>
						
						<pre>	<ins>public bool IsEmpty => behaviors.Count == 0;</ins></pre>
					</section>
					
					<section>
						<h3>Controlling Time</h3>
						
						<p>Let's also make it possible to manipulate time, which aids both testing and is also often a gameplay feature. First, make <code>Game.Update</code> check whether the space bar was pressed and use that to pause or unpause the game. That can be done by toggling <code>Time.timeScale</code> between zero and 1. This doesn't alter the game logic but freezes everything in place. Alternatively, you could use a very low value like 0.01 instead of zero for an extreme slow motion.</p>
						
						<pre>	<ins>const float pausedTimeScale = 0f;</ins>
	
	&hellip;
	
	void Update () {
		&hellip;
		
		<ins>if (Input.GetKeyDown(KeyCode.Space)) {</ins>
			<ins>Time.timeScale =</ins>
				<ins>Time.timeScale > pausedTimeScale ? pausedTimeScale : 1f;</ins>
		<ins>}</ins>

		if (Input.GetKeyDown(KeyCode.B)) {
			BeginNewGame();
		}
		&hellip;
	}</pre>
						
						<p>Second, add a play speed configuration slider to <code>Game</code> so we can speed up time.</p>
						
						<pre>	<ins>[SerializeField, Range(1f, 10f)]</ins>
	<ins>float playSpeed = 1f;</ins></pre>
						
						<figure>
							<img src="beginning-and-ending-games/play-speed.png" width="320" height="38">
							<figcaption>Play speed.</figcaption>
						</figure>
						
						<p>If pause isn't toggled and the time scale isn't set to the paused value, make it equal to the play speed. Also, use the play speed instead of 1 when unpausing.</p>
						
						<pre>		if (Input.GetKeyDown(KeyCode.Space)) {
			Time.timeScale =
				Time.timeScale > pausedTimeScale ? pausedTimeScale : <ins>playSpeed</ins>;
		}
		<ins>else if (Time.timeScale > pausedTimeScale) {</ins>
			<ins>Time.timeScale = playSpeed;</ins>
		<ins>}</ins></pre>
						
					</section>
				</section>
				
				<section>
					<h2>Cyclic Scenarios</h2>
					
					<p>For some scenarios you might want to progress through all waves more than once. We can support that by making it possible for scenarios to repeat, cycling through all waves multiple times. You could further refine this to for example only repeat the last wave, but in this tutorial we'll simply repeat the entire scenario.</p>
					
					<section>
						<h3>Cycling through Waves</h3>
						
						<p>Add a configuration slider for the amount of cycles to <code>GameScenario</code>, set to 1 by default. Set the minimum to zero, which will make the scenario repeat without end. That would create a survival scenario that cannot be won, the point being to see how long the player can last.</p>
						
						<pre>	<ins>[SerializeField, Range(0, 10)]</ins>
	<ins>int cycles = 1;</ins></pre>
						
						<figure>
							<img src="cyclic-scenarios/cycles.png" width="320" height="38">
							<figcaption>Scenario with two cycles.</figcaption>
						</figure>
						
						<p><code>GameScenario.State</code> now has to keep track of its cycle number.</p>
						
						<pre>		int <ins>cycle,</ins> index;

		EnemyWave.State wave;

		public State (GameScenario scenario) {
			this.scenario = scenario;
			<ins>cycle = 0;</ins>
			index = 0;
			wave = scenario.waves[0].Begin();
		}</pre>
						
						<p>In <code>Progress</code>, when all waves have finished increment the cycle and only return <code>false</code> if we've gone through enough cycles. Otherwise set the wave index back to zero and keep going.</p>
						
						<pre>		public bool Progress () {
			float deltaTime = wave.Progress(Time.deltaTime);
			while (deltaTime >= 0f) {
				if (++index >= scenario.waves.Length) {
					<ins>if (++cycle >= scenario.cycles &amp;&amp; scenario.cycles > 0) {</ins>
						return false;
					<ins>}</ins>
					<ins>index = 0;</ins>
				}
				wave = scenario.waves[index].Begin();
				deltaTime = wave.Progress(deltaTime);
			}
			return true;
		}</pre>
						
					</section>
					
					<section>
						<h3>Speeding Up</h3>
						
						<p>If the player managed to beat a cycle once they should be able to beat it again without issue. We have to increase the difficulty to keep the scenario challenging. The simplest way to do that is by reducing all cooldowns in successive cycles. That makes enemies appear quicker and will inevitably overwhelm the player in a survival scenario.</p>
						
						<p>Add a configuration slider to <code>GameScenario</code> to control the speed-up per cycle. This value gets added to the time scale after each cycle for the purpose of advancing cooldown only. For example, with a speed-up of 0.5 the first cycle has cooldown speed &times;1, the second cycle has speed &times;1.5, the third &times;2, the fourth &times;2.5, and so on.</p>
						
						<pre>	<ins>[SerializeField, Range(0f, 1f)]</ins>
	<ins>float cycleSpeedUp = 0.5f;</ins></pre>
						
						<p>We now have to add the time scale to <code>GameScenario.State</code> as well. It always starts at 1 and is increased by the configured speed-up after each cycle. Use it to scale <code>Time.deltaTime</code> before progressing the wave.</p>
						
						<pre>		<ins>float timeScale;</ins>

		EnemyWave.State wave;

		public State (GameScenario scenario) {
			this.scenario = scenario;
			cycle = 0;
			index = 0;
			<ins>timeScale = 1f;</ins>
			wave = scenario.waves[0].Begin();
		}

		public bool Progress () {
			float deltaTime = wave.Progress(<ins>timeScale *</ins> Time.deltaTime);
			while (deltaTime >= 0f) {
				if (++index >= scenario.waves.Length) {
					if (++cycle >= scenario.cycles && scenario.cycles > 0) {
						return false;
					}
					index = 0;
					<ins>timeScale += scenario.cycleSpeedUp;</ins>
				}
				wave = scenario.waves[index].Begin();
				deltaTime = wave.Progress(deltaTime);
			}
			return true;
		}</pre>
						
						<figure>
							<div class="vid" style="width: 230px; height:230px;"><iframe src='https://gfycat.com/ifr/wellwornmerrycero'></iframe></div>
							<figcaption>Three cycles with increasing spawn speed; play speed 10.</figcaption>
						</figure>
						
						<p>The next tutorial is <a href="../animation/index.html">Animation</a>.</p>
					</section>
					
					<a href="https://bitbucket.org/catlikecodingunitytutorials/tower-defense-05-scenarios/" class="repository">repository</a>
					<a href="Scenarios.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>