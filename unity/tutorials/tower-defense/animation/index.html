<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/tower-defense/animation/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/tower-defense/animation/tutorial-image.jpg">
		<meta property="og:title" content="Animation">
		<meta property="og:description" content="A Unity Tower Defense tutorial about animating enemy movement, intro, outro, and death.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Animation</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/tower-defense/animation/#article",
				"headline": "Animation",
				"alternativeHeadline": "Lively Enemies",
				"datePublished": "2019-09-19",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Tower Defense tutorial about animating enemy movement, intro, outro, and death.",
				"image": "https://catlikecoding.com/unity/tutorials/tower-defense/animation/tutorial-image.jpg",
				"dependencies": "Unity 2018.4.9f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/tower-defense/", "name": "Tower Defense" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				Clip: 1,
				Direction: 1,
				DirectionChange: 1,
				DirectionExtensions: 1,
				Enemy: 1,
				EnemyAnimationConfig: 1,
				EnemyAnimator: 1,
				EnemyConfig: 1,
				EnemyFactory: 1,
				EnemySpawnSequence: 1,
				EnemyType: 1,
				EnemyWave: 1,
				Explosion: 1,
				FloatRange: 1,
				FloatRangeSlider: 1,
				FloatRangeSliderAttribute: 1,
				FloatRangeSliderDrawer: 1,
				Game: 1,
				GameBehavior: 1,
				GameBehaviorCollection: 1,
				GameBoard: 1,
				GameObjectFactory: 1,
				GameScenario: 1,
				GameTile: 1,
				GameTileContent: 1,
				GameTileContentFactory: 1,
				GameTileContentType: 1,
				LaserTower: 1,
				MortarTower: 1,
				Shell: 1,
				State: 1,
				T: 1,
				TargetPoint: 1,
				Tower: 1,
				TowerType: 1,
				WarEntity: 1,
				WarFactory: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Tower Defense</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Animation</h1>
					<p>Lively Enemies</p>
					<ul>
						<li>Record animations.</li>
						<li>Create playable graphs to animate enemies.</li>
						<li>Mix animations to transition between them.</li>
						<li>Use existing models and animations.</li>
					</ul>
				</header>
				
				<p>This is the sixth and final installment of a tutorial series about creating a simple <a href="../index.html">tower defense</a> game. It is about animating enemies, covering both recording new animations and importing existing assets.</p>
				
				<p>This tutorial is made with Unity 2018.4.9f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Enemies bouncing, walking, spinning, and falling apart.</figcaption>
				</figure>
				
				<section>
					<h2>Bouncing Enemies</h2>
					
					<p>Up to this point our enemies simply slide across the board. This can be fine for an abstract game that uses cubes and spheres for enemies, but even such enemies can be made more interesting by making them move in a more organic way. We could make them bounce by offsetting their vertical position with something like an absolute sine wave based on time, but the general approach is to use an animation clip. We'll use animations because that allows much more complex movement and also makes it possible to import existing animations.</p>
					
					<section>
						<h3>Animation Clip</h3>
						
						<p>We can create animation clips in the Unity editor by recording adjustments to an object hierarchy. Drag a medium enemy cube prefab instance into the scene, or a separate scene dedicated to animation recording. Then select the <em>Cube</em> child of the enemy's <em>Model</em> and open the animation window via <em>Window / Animation / Animation</em>.</p>
						
						<figure>
							<img src="bouncing-enemies/create-button.png" width="380" height="50">
							<figcaption>Create button.</figcaption>
						</figure>
						
						<p>Because we haven't already animated the cube, the <em>Animation</em> window displays a <em>Create</em> button. Pressing it will attach an <em>Animator</em> component to <em>Cube</em> and create two assets, an <em>Animation Controller</em> for the cube and an animation clip, which we'll name <em>Enemy Move</em>.</p>
						
						<figure>
							<img src="bouncing-enemies/animation-hierarchy.png" width="228" height="48">
							<figcaption>Animation and animator assets.</figcaption>
						</figure>
						
						<p>The animation clip asset contains the data for our animation, which is currently still empty. Selecting it will show a <em>Loop Time</em> toggle which is enabled by default, meaning that it represents a looping animation. This is correct as the movement animation should repeat as long as the enemy is in motion.</p>
						
						<figure>
							<img src="bouncing-enemies/animation-asset.png" width="320" height="194">
							<figcaption>Move animation asset.</figcaption>
						</figure>
						
						<p>The <em>Animator</em> component that got added to <em>Cube</em> has a reference to the animation controller asset that also got created.</p>
						
						<figure>
							<img src="bouncing-enemies/cube-with-animator.png" width="320" height="432">
							<figcaption>Cube with animator.</figcaption>
						</figure>
						
						<p>The controller is a state machine that can get very complex, but initially it only has an entry state that goes straight to the animation that we created, plus a catch-all any state. You can see those by opening the <em>Animator</em> window, which you can do by double-clicking the controller or pressing its <em>Open</em> button.</p>
						
						<figure>
							<img src="bouncing-enemies/animator.png" width="270" height="120">
							<figcaption>Animator graph.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Recording an Animation</h3>
						
						<p>To record the move animation, select <em>Cube</em> and press the red dot record button in the <em>Animation</em> window. We'll create a simple bounce with a duration of one second. Move the time line to 0:30, which represents half a second. Then increase the cube's vertical position from 0.25 to 0.75. That will create two key frames, one for the original position at 0:00 and the adjusted one at 0:30. After that, move the time line to 1:00, set the vertical position back to 0.25, and press the record button again to stop recording.</p>
						
						<figure>
							<img src="bouncing-enemies/position-keyframes.png" width="570" height="150">
							<figcaption>Three key frames for position.</figcaption>
						</figure>
						
						<p>You can preview the animation by pressing the play-animation button, a little to the right of the record button.</p>
						
						<figure>
							<div class="vid" style="width: 140px; height:155px;"><iframe src='https://gfycat.com/ifr/imperturbablewideekaltadeta'></iframe></div>
							<figcaption>Moving up and down.</figcaption>
						</figure>
						
						<p>The cube's position interpolates between the key frames, causing it to move up and down between 0.25 and 0.75. We can make it a bit more organic-looking by changing the trajectory into a parabola. Switch from <em>Dopesheet</em> to <em>Cuves</em> via the buttons at the bottom of the <em>Animation</em> window. That shows us the curves used to interpolate between the key frames. You can zoom in by changing the size of the scroll bars. Then select the key point for Y at 0:00 and drag its tangent up until it looks nice. Do the same for the key at 1:00. As the movement is supposed to be organic the tangents don't have to exactly mirror each other.</p>
						
						<figure>
							<img src="bouncing-enemies/parabola-curve.png" width="570" height="333" alt="animation">
							<div class="vid" style="width: 140px; height:155px;"><iframe src='https://gfycat.com/ifr/delicioussaneheterodontosaurus'></iframe></div>
							<figcaption>Bouncing with a parabola curve.</figcaption>
						</figure>
						
						<p>You could embellish the animation with scale adjustments and such, but this is good enough to make the enemies look alive.</p>
					</section>
					
					<section>
						<h3>Configuring Animations</h3>
						
						<p>Enemies can have different animations, even when using the same 3D model. Conversely, enemies with different models can have the same animations. So we'll make it possible to configure animation clips per enemy via a separate <code>EnemyAnimationConfig</code> asset type, so configurations can be easily shared. As we only have a move animation at this point, that's the only clip to store for now.</p>
						
						<pre><ins>using UnityEngine;</ins>

<ins>[CreateAssetMenu]</ins>
<ins>public class EnemyAnimationConfig : ScriptableObject {</ins>

	<ins>[SerializeField]</ins>
	<ins>AnimationClip move = default;</ins>

	<ins>public AnimationClip Move => move;</ins>
<ins>}</ins></pre>
						
						<p>Create one animation config asset and assign the move animation to it.</p>
						
						<figure>
							<img src="bouncing-enemies/enemy-animations.png" width="320" height="88">
							<figcaption>Enemy animation config asset.</figcaption>
						</figure>
						
						<p>Add a serializable field to <code>Enemy</code> for this configuration, then give all enemy prefabs a reference to our single animation config asset, as our animation works for both cubes and spheres.</p>
						
						<pre>	<ins>[SerializeField]</ins>
	<ins>EnemyAnimationConfig animationConfig = default;</ins></pre>
						
						<figure>
							<img src="bouncing-enemies/enemy-with-animation-config.png" width="320" height="76">
							<figcaption>Enemy with animation config.</figcaption>
						</figure>
						
					</section>
				</section>
				
				<section>
					<h2>Playing Animations</h2>
					
					<p>The animation controller can be used to animate enemies, but it is a rather heavy-handed and rigid approach for our simple enemy behavior. Besides that, there can be many enemies alive at the same time and they would all need their own controller, so the logic to control animations should be as simple as possible. Finally, we want to use different animations per enemy while they all share the same logic. So rather than rely on Unity's animation controller we'll create our own. Unity's animation controller is only needed to record animations.</p>
					
					<section>
						<h3>Enemy Animator</h3>
						
						<p><code>Enemy</code> can take care of animating itself, but the logic is still fairly complex, so we'll isolate it in a separate serializable <code>EnemyAnimator</code> struct type. It relies on types from the <code>UnityEngine.Animations</code> and <code>UnityEngine.Playables</code> namespaces, so we'll be using those.</p>
						
						<pre><ins>using UnityEngine;</ins>
<ins>using UnityEngine.Animations;</ins>
<ins>using UnityEngine.Playables;</ins>

<ins>[System.Serializable]</ins>
<ins>public struct EnemyAnimator {}</ins></pre>
						
						<p>Add a field for it to <code>Enemy</code>.</p>
						
						<pre>	<ins>EnemyAnimator animator;</ins></pre>
						
						<p>To do its work <code>EnemyAnimator</code> needs three public methods. First <code>Configure</code> to set up the animation state, for which we need an <code>Animator</code> component and animation configuration. Second <code>Play</code> to start playing, and third <code>Stop</code> to stop playing.</p>
						
						<pre>	<ins>public void Configure (Animator animator, EnemyAnimationConfig config) {}</ins>

	<ins>public void Play () {}</ins>

	<ins>public void Stop () {}</ins></pre>
						
						<p>In <code>Enemy</code>, stop playing in <code>Recycle</code> and start playing in <code>Initialize</code>.</p>
						
						<pre>	public override void Recycle () {
		<ins>animator.Stop();</ins>
		OriginFactory.Reclaim(this);
	}

	public void Initialize (
		float scale, float speed, float pathOffset, float health
	) {
		&hellip;
		<ins>animator.Play();</ins>
	}</pre>
						
						<p>We could also configure the animator in <code>Initialize</code>, but we only need to do it once so let's do it in <code>Awake</code> instead. That way no unneeded extra configuration happens if enemies were to be reused at some point.</p>
						
						<p>Rather than give all enemy prefabs an <code>Animator</code> component we'll create it programmatically here. Whatever we're animating has to be a child of the model, so add it to the first child of that object.</p>
						
						<pre>	<ins>void Awake () {</ins>
		<ins>animator.Configure(</ins>
			<ins>model.GetChild(0).gameObject.AddComponent&lt;Animator>(),</ins>
			<ins>animationConfig</ins>
		<ins>);</ins>
	<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Playable Graphs</h3>
						
						<p>Controlling the animation state of an object is done via a playable graph, which exists in native code and not in C#. We can control it via a <code>PlayableGraph</code> struct, which contains a reference to the native data. A graph is created via the static <code>PlayableGraph.Create</code> method. All <em>Playables</em> are created in a similar way.
						
						<pre>	<ins>PlayableGraph graph;</ins>

	public void Configure (Animator animator, EnemyAnimationConfig config) {
		<ins>graph = PlayableGraph.Create();</ins>
	}</pre>
						
						<p>Initially the graph is inert. We activate it by invoking <code>Play</code> on it and can stop it by invoking <code>Stop</code>. However, as we're not reusing enemies in this tutorial series we should invoke <code>Destroy</code> to get rid of the native graph data instead, otherwise it sticks around.</p>
						
						<pre>	public void Play () {
		<ins>graph.Play();</ins>
	}

	public void Stop () {
		<ins>graph.Destroy();</ins>
	}</pre>
						
						<p>Graphs can update themselves, but we should indicate how they should do this. We need animations linked to the game time, which is configured by invoking <code>SetTimeUpdateMode</code> with <code>DirectorUpdateMode.GameTime</code> after creating the graph.</p>
						
						<pre>		graph = PlayableGraph.Create();
		<ins>graph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);</ins></pre>
						
						<p>To play an animation clip we first have to create a playable representation of it, via <code>AnimationClipPlayable.Create</code>. We have to provide the graph it belongs to and the animation clip as arguments.</p>
						
						<pre>		graph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);

		<ins>var clip = AnimationClipPlayable.Create(graph, config.Move);</ins></pre>
						
						<p>Then we have to create an <code>AnimationPlayableOutput</code> for the graph, with an additional name and a reference to the animator component used for animation. Set the clip as the source for that output, via <code>SetSourcePlayable</code>. This will make our enemies bounce.</p>
						
						<pre>		var clip = AnimationClipPlayable.Create(graph, config.Move);

		<ins>var output = AnimationPlayableOutput.Create(graph, "Enemy", animator);</ins>
		<ins>output.SetSourcePlayable(clip);</ins></pre>
						
						<figure>
							<div class="vid" style="width: 155px; height:170px;"><iframe src='https://gfycat.com/ifr/mealyfantasticbushbaby'></iframe></div>
							<figcaption>Bouncing Enemies.</figcaption>
						</figure>
						
						<p>The medium cubes end up animating in lockstep because they spawn once per second, which matches the animation duration.</p>
						
						<aside>
							<h3>Why doesn't code completion provide useful documentation for <em>Playables</em>?</h3>
							<div>
								<p>The <em>Playables</em> API mostly consists of extension methods that work for generic <em>Playable</em> struct types. So there isn't much code documentation for specific types and methods. Because of this approach I'll also use <code>var</code> when storing <em>Playables</em> in variables.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Adjusting Animation Speed</h3>
						
						<p>Our move animation loops every second, which isn't appropriate for all enemies. For some it should play faster and for others slower. We'll make that possible by adding a speed parameter to our <code>Play</code> method. Grab the graph's output at index zero via <code>GetOutput</code>, get its playable source via <code>GetSourcePlayable</code> and invoke <code>SetSpeed</code> on it with the provided speed.</p>
						
						<pre>	public void Play (<ins>float speed</ins>) {
		<ins>graph.GetOutput(0).GetSourcePlayable().SetSpeed(speed);</ins>
		graph.Play();
	}</pre>
						
						<p>Supply the required speed in <code>Enemy.Initialize</code>. Faster enemies require a faster animation because they cover more ground. Also, larger enemies make bigger steps and thus require a slower animation speed. So we make the move animation speed equal to the enemy's speed divided by its scale.</p>
						
						<pre>	public void Initialize (
		float scale, float speed, float pathOffset, float health
	) {
		&hellip;
		animator.Play(<ins>speed / scale</ins>);
	}</pre>
						
						<figure>
							<div class="vid" style="width: 155px; height:170px;"><iframe src='https://gfycat.com/ifr/hiddensimplekiskadee'></iframe></div>
							<figcaption>Adjusted speed.</figcaption>
						</figure>
						
						<p>As a bonus, because the medium cubes don't all have the exact same speed they no longer animate in exact lockstep.</p>
					</section>
					
					<section>
						<h3>Visualizing Playable Graphs</h3>
						
						<p>If you want to visually inspect the generated playable graphs you can do so by importing the <em>PlayableGraph Visualizer</em> package via <em>Window / Package Manager</em>. Its current version is 0.2.1, which is a preview version so you have to enable <em>Show preview packages</em> under <em>Advanced</em> to see it. After importing you can open the visualizer via <em>Window / Analysis / PlayableGraph Visualizer</em> and enter play mode. You won't be able to select specific graph instances because they don't have unique names, but it's enough to see the graph structure.</p>
						
						<figure>
							<img src="playing-animations/visualizer.png" width="500" height="270">
							<figcaption>PlayableGraph visualizer.</figcaption>
						</figure>
						
						<p>One thing you'll notice is that while graphs are only created in play mode they stick around after play mode has been exited. That happens when enemies are destroyed on play exit. We can solve this by adding a public <code>Destroy</code> method to <code>EnemyAnimator</code> that destroys the graph. At this point we can also change <code>Stop</code> so it stops rather than destroys the graph, to support future reuse.</p>
						
						<pre>	public void Stop () {
		graph.<ins>Stop</ins>();
	}
	
	<ins>public void Destroy () {</ins>
		<ins>graph.Destroy();</ins>
	<ins>}</ins></pre>
						
						<p>Add an <code>OnDestoy</code> method to <code>Enemy</code> that destroys the animator to always get rid of the graphs.</p>
						
						<pre>	<ins>void OnDestroy () {</ins>
		<ins>animator.Destroy();</ins>
	<ins>}</ins></pre>
					</section>
				</section>
				
				<section>
					<h2>Intro and Outro</h2>
					
					<p>Bouncing enemies look more lively than sliding ones, but the animation clashes with the sudden appearance and disappearance of enemies when they are spawned and reach their destination. We can make that look much better by adding an intro and outro animation.</p>
					
					<section>
						<h3>Animations</h3>
						
						<p>To create additional animations go back to the enemy instances set up for animation recording. Select <em>Cube</em> and then open the dropdown menu in the <em>Animation</em> window that's currently set to <em>Enemy Move</em>. Choose <em>Create New Clip...</em> twice, creating an <em>Enemy Intro</em> and <em>Enemy Outro</em> animation.</p>
						
						<p>For the intro, set the scale and position at 0:00 to zero and to their original values at 0:30. Do it the other way around for the outro, but this time the duration is one second. Also, give it a lively twirl by increasing its vertical position to 1.25 and settings its Y rotation to 360&deg;.</p>
						
						<figure>
							<div class="vid" style="width: 110px; height:145px;"><iframe src='https://gfycat.com/ifr/hauntinglargegerenuk'></iframe></div>
							<div class="vid" style="width: 110px; height:145px;"><iframe src='https://gfycat.com/ifr/temptingsoftlarva'></iframe></div>
							<figcaption>Intro and outro.</figcaption>
						</figure>
						
						<p>The animation control has also gained extra states for the new animations, which are disconnected from its graph. That's fine because we only use the animation controller to record animations.</p>
						
						<figure>
							<img src="intro-and-outro/animator.png" width="300" height="130">
							<figcaption>Animator with intro and outro states.</figcaption>
						</figure>
						
						<p>Add support for the intro and outro animations to <code>EnemyAnimationConfig</code>.</p>
						
						<pre>	[SerializeField]
	AnimationClip move = default<ins>, intro = default, outro = default</ins>;

	public AnimationClip Move => move;

	<ins>public AnimationClip Intro => intro;</ins>

	<ins>public AnimationClip Outro => outro;</ins></pre>
						
						<figure>
							<img src="intro-and-outro/animation-config.png" width="320" height="56">
							<figcaption>Configuration with intro and outro.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Mixing Animation Clips</h3>
						
						<p>To support multiple animations we have to add an animation mixer to <code>EnemyAnimator</code>. Give it an <code>AnimationMixerPlayable</code> field to keep track of it.</p>
						
						<pre>	<ins>AnimationMixerPlayable mixer;</ins></pre>
						
						<p>We now also have to create a mixer in <code>Configure</code>. Besides the graph, also provide the amount of animation clips&mdash;which is now 3&mdash;as an argument to its <code>Create</code> method. Then make the mixer the source for the output.</p>
						
						<pre>	public void Configure (Animator animator, EnemyAnimationConfig config) {
		graph = PlayableGraph.Create();
		graph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);
		<ins>mixer = AnimationMixerPlayable.Create(graph, 3);</ins>

		var clip = AnimationClipPlayable.Create(graph, config.Move);

		var output = AnimationPlayableOutput.Create(graph, "Enemy", animator);
		output.SetSourcePlayable(<ins>mixer</ins>);
	}</pre>
						
						<p>Each clip gets its own fixed index in the mixer. Let's define them with an enum type nested in <code>EnemyAnimator</code>. Make it public so <code>Enemy</code> can access it later.</p>
						
						<pre>	<ins>public enum Clip { Move, Intro, Outro }</ins></pre>
						
						<p>The easiest way to add a clip to a mixer is by invoking <code>ConnectInput</code> on the mixer with the clip's index and the playable clip as arguments. A third argument specifies the output index of the clip, which is always zero. Do this for all three clips in <code>Configure</code>.</p>
						
						<pre>	public void Configure (Animator animator, EnemyAnimationConfig config) {
		graph = PlayableGraph.Create();
		graph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);
		mixer = AnimationMixerPlayable.Create(graph, 3);

		var clip = AnimationClipPlayable.Create(graph, config.Move);
		<ins>mixer.ConnectInput((int)Clip.Move, clip, 0);</ins>

		<ins>clip = AnimationClipPlayable.Create(graph, config.Intro);</ins>
		<ins>mixer.ConnectInput((int)Clip.Intro, clip, 0);</ins>

		<ins>clip = AnimationClipPlayable.Create(graph, config.Outro);</ins>
		<ins>mixer.ConnectInput((int)Clip.Outro, clip, 0);</ins>

		var output = AnimationPlayableOutput.Create(graph, "Enemy", animator);
		output.SetSourcePlayable(mixer);
	}</pre>
						
						<figure>
							<img src="intro-and-outro/visualizer-multiple-clips.png" width="480" height="260">
							<figcaption>Visualizer showing a mixer with three clips.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Switching Between Clips</h3>
						
						<p>The mixer blends all its clips based on their weights, which are zero by default. We only need one active clip at a time, which we accomplish by setting its weight to 1 and all other weights to zero. It's handy to keep track of the currently active clip, so add a property for that. Make the getter public so <code>Enemy</code> can also access it.</p>
						
						<pre>	<ins>public Clip CurrentClip { get; private set; }</ins></pre>
						
						<p>Now replace the <code>Play</code> method with a more specific <code>PlayIntro</code> method. It doesn't need a speed, instead it invokes <code>SetInputWeight</code> on the mixer with the intro index to set the clip's weight to 1, sets the current clip, and plays the graph.</p>
						
						<pre>	<del>//public void Play (float speed) {</del>
	<del>//	graph.GetOutput(0).GetSourcePlayable().SetSpeed(speed);</del>
	<del>//	graph.Play();</del>
	<del>//}</del>

	<ins>public void PlayIntro () {</ins>
		<ins>SetWeight(Clip.Intro, 1f);</ins>
		<ins>CurrentClip = Clip.Intro;</ins>
		<ins>graph.Play();</ins>
	<ins>}</ins>
	
	<ins>void SetWeight (Clip clip, float weight) {</ins>
		<ins>mixer.SetInputWeight((int)clip, weight);</ins>
	<ins>}</ins></pre>
						
						<p>Then add a <code>PlayMove</code> method with a speed parameter. It sets the current clip's weight to zero&mdash;in case you insert animations between intro and movement later&mdash;and the move clip's weight to 1, sets the speed, and updates the current clip. The playable handle for a specific clip can be retrieved by invoking <code>GetInput</code> on the mixer with the appropriate index.</p>
						
						<pre>	<ins>public void PlayMove (float speed) {</ins>
		<ins>SetWeight(CurrentClip, 0f);</ins>
		<ins>SetWeight(Clip.Move, 1f);</ins>
		<ins>GetPlayable(Clip.Move).SetSpeed(speed);</ins>
		<ins>CurrentClip = Clip.Move;</ins>
	<ins>}</ins>
	
	<ins>Playable GetPlayable (Clip clip) {</ins>
		<ins>return mixer.GetInput((int)clip);</ins>
	<ins>}</ins></pre>
						
						<p>And also add a <code>PlayOutro</code> method that switches to the outro clip.</p>
						
						<pre>	<ins>public void PlayOutro () {</ins>
		<ins>SetWeight(CurrentClip, 0f);</ins>
		<ins>SetWeight(Clip.Outro, 1f);</ins>
		<ins>CurrentClip = Clip.Outro;</ins>
	<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Playing the Intro</h3>
						
						<p>Adjust <code>Enemy.Initialize</code> so it invokes <code>PlayIntro</code> instead of <code>Play</code>.</p>
						
						<pre>	public void Initialize (
		float scale, float speed, float pathOffset, float health
	) {
		&hellip;
		animator.<ins>PlayIntro()</ins>;
	}</pre>
						
						<p>We have to delay moving until the intro animation is done. <code>EnemyAnimator</code> can check this by grabbing the current clip of the mixer and invoking <code>IsDone</code> on it. Expose this via a property.</p>
						
						<pre>	<ins>public bool IsDone => GetPlayable(CurrentClip).IsDone();</ins></pre>
						
						<p>Now we have to check at the start of <code>Enemy.GameUpdate</code> whether we're currently playing the intro clip. If so and it's not done skip the rest of the method, otherwise invoke <code>PlayMove</code> with the speed and keep going.</p>
						
						<pre>	public override bool GameUpdate () {
		<ins>if (animator.CurrentClip == EnemyAnimator.Clip.Intro) {</ins>
			<ins>if (!animator.IsDone) {</ins>
				<ins>return true;</ins>
			<ins>}</ins>
			<ins>animator.PlayMove(speed / Scale);</ins>
		<ins>}</ins>

		&hellip;
	}</pre>
						
						<p>As this means that we delay updating the enemy position we have to make sure that it is set correctly in <code>PrepareIntro</code>.</p>
						
						<pre>	void PrepareIntro () {
		positionFrom = tileFrom.transform.localPosition;
		<ins>transform.localPosition = positionFrom;</ins>
		&hellip;
	}</pre>
						
						<p>We now get enemies that are stuck in a repeating intro animation. The first step to fix this is disabling the <em>Loop Time</em> option of the intro animation clip.</p>
						
						<figure>
							<img src="intro-and-outro/no-looping.png" width="320" height="56">
							<figcaption>No looping.</figcaption>
						</figure>
						
						<p>But this is not enough. Because we're creating a playable graph ourselves we have to explicitly set the duration of non-looping clips if we need to detect when they're done. In <code>EnemyAnimator.Configure</code>, invoke <code>SetDuration</code> on the intro clip, providing the length of its clip as an argument.</p>
						
						<pre>		clip = AnimationClipPlayable.Create(graph, config.Intro);
		<ins>clip.SetDuration(config.Intro.length);</ins>
		mixer.ConnectInput((int)Clip.Intro, clip, 0);</pre>
						
						<figure>
							<div class="vid" style="width: 215px; height:170px;"><iframe src='https://gfycat.com/ifr/smallevergreenalleycat'></iframe></div>
							<figcaption>Intro then move.</figcaption>
						</figure>
						
						<p>Enemies now progress go from into to move, but there is a discontinuity as part of the movement gets skipped. That happens because time passes for all clips, no matter their weight. We can solve this by pausing the move clip when we create it in <code>Configure</code> and play it in <code>PlayMove</code>.</p>
						
						<pre>	public void Configure (Animator animator, EnemyAnimationConfig config) {
		&hellip;

		var clip = AnimationClipPlayable.Create(graph, config.Move);
		<ins>clip.Pause();</ins>
		mixer.ConnectInput((int)Clip.Move, clip, 0);

		&hellip;
	}
	
	&hellip;
	
	public void PlayMove (float speed) {
		SetWeight(CurrentClip, 0f);
		SetWeight(Clip.Move, 1f);
		<del>//GetPlayable(Clip.Move).SetSpeed(speed);</del>
		<ins>var clip = GetPlayable(Clip.Move);</ins>
		<ins>clip.SetSpeed(speed);</ins>
		<ins>clip.Play();</ins>
		CurrentClip = Clip.Move;
	}</pre>
						
						<figure>
							<div class="vid" style="width: 215px; height:170px;"><iframe src='https://gfycat.com/ifr/thankfuloblongeasternnewt'></iframe></div>
							<figcaption>Move begins after intro.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>Playing the Outro</h3>
						
						<p>The outro clip requires a similar treatment. Disable its <em>Loop Time</em> option and set its duration it in <code>Configure</code>. Also pause it initially, like the move animation.</p>
						
						<pre>		clip = AnimationClipPlayable.Create(graph, config.Outro);
		<ins>clip.SetDuration(config.Outro.length);</ins>
		<ins>clip.Pause();</ins>
		mixer.ConnectInput((int)Clip.Outro, clip, 0);</pre>
						
						<p>Play the clip in <code>PlayOutro</code>.</p>
						
						<pre>	public void PlayOutro () {
		SetWeight(CurrentClip, 0f);
		SetWeight(Clip.Outro, 1f);
		<ins>GetPlayable(Clip.Outro).Play()</ins>
		CurrentClip = Clip.Outro;
	}</pre>
						
						<p>To make the outro play, invoke <code>PlayOutro</code> in <code>Enemy.GameUpdate</code> instead if recycling it when the destination has been reached. Also return <code>true</code> so it keeps getting updated.</p>
						
						<pre>	public override bool GameUpdate () {
		&hellip;

		progress += Time.deltaTime * progressFactor;
		while (progress >= 1f) {
			if (tileTo == null) {
				Game.EnemyReachedDestination();
				<del>//Recycle();</del>
				<ins>animator.PlayOutro();</ins>
				return <ins>true</ins>;
			}
			&hellip;
		}
		&hellip;
	}</pre>
					
					<p>Now we also have to check whether the outro is playing at the start of <code>GameUpdate</code>. If so we're either done and can recycle or must keep playing and return <code>true</code>.</p>
					
					<pre>		if (animator.CurrentClip == EnemyAnimator.Clip.Intro) {
			if (!animator.IsDone) {
				return true;
			}
			animator.PlayMove(speed / Scale);
		}
		<ins>else if (animator.CurrentClip == EnemyAnimator.Clip.Outro) {</ins>
			<ins>if (animator.IsDone) {</ins>
				<ins>Recycle();</ins>
				<ins>return false;</ins>
			<ins>}</ins>
			<ins>return true;</ins>
		<ins>}</ins></pre>
						
						<figure>
							<div class="vid" style="width: 215px; height:170px;"><iframe src='https://gfycat.com/ifr/yellowsomekinglet'></iframe></div>
							<figcaption>Intro, move, and outro.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Animation Transitions</h2>
					
					<p>The transition from intro to move is correct, but the transition from move to outro has problems. Whether move and outro animations align depends on the enemy's speed and distance traveled, which varies. The only way to get rid of the hard transition between these animations is to blend them.</p>
					
					<section>
						<h3>Beginning a Transition</h3>
						
						<p>We blend between two animation by linearly interpolating their weights, the previous clip's decreasing from 1 and the current clip's increasing from zero. To keep track of this transition <code>EnemyAnimator</code> has to keep track of the previous clip and the progress of the transition.</p>
						
						<pre>	<ins>Clip previousClip;</ins>

	<ins>float transitionProgress;</ins></pre>
						
						<p>Add a <code>BeginTransition</code> method with the next clip enum value as a parameter. It has to make the current clip the previous one, set the new current clip, set the transition progress to zero, and play the now current clip.
						
						<pre>	<ins>void BeginTransition (Clip nextClip) {</ins>
		<ins>previousClip = CurrentClip;</ins>
		<ins>CurrentClip = nextClip;</ins>
		<ins>transitionProgress = 0f;</ins>
		<ins>GetPlayable(nextClip).Play();</ins>
	<ins>}</ins></pre>
						
						<p>Invoke this method both in <code>PlayMove</code> and <code>PlayOutro</code> with the appropriate clip. Besides setting the move speed, that's all they now have to do.</p>
						
						<pre>	public void PlayMove (float speed) {
		<ins>GetPlayable(Clip.Move).SetSpeed(speed);</ins>
		<ins>BeginTransition(Clip.Move);</ins>
	}

	public void PlayOutro () {
		<ins>BeginTransition(Clip.Outro);</ins>
	}</pre>
						
						<p>We also blend from intro to move because they're not guaranteed to line up, that's just the case for our simple enemy animations.</p>
					</section>
					
					<section>
						<h3>Progressing a Transition</h3>
						
						<p>Progressing a transition needs to happen every game update, so add a public <code>GameUpdate</code> method to <code>EnemyAnimator</code>. Have it increase the progress by the time multiplied by some transition speed. The transition should be quick, so let's use 5 for a duration of 0.2 seconds.</p>
						
						<p>If the transition is complete, set the current clip's weight to 1. Also set the previous clip's weight to zero and pause it. Otherwise make the weights equal to the progress and 1 minus the progress, respectively.</p>
						
						<pre>	<ins>const float transitionSpeed = 5f;</ins>
	
	&hellip;
	
	<ins>public void GameUpdate () {</ins>
		<ins>transitionProgress += Time.deltaTime * transitionSpeed;</ins>
		<ins>if (transitionProgress >= 1f) {</ins>
			<ins>SetWeight(CurrentClip, 1f);</ins>
			<ins>SetWeight(previousClip, 0f);</ins>
			<ins>GetPlayable(previousClip).Pause();</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>SetWeight(CurrentClip, transitionProgress);</ins>
			<ins>SetWeight(previousClip, 1f - transitionProgress);</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>This only has to be done when there is a transition in progress. We can use a progress value of &minus;1 to indicate that there is no transition.</p>
						
						<pre>	public void GameUpdate () {
		<ins>if (transitionProgress >= 0f) {</ins>
			transitionProgress += Time.deltaTime * transitionSpeed;
			if (transitionProgress >= 1f) {
				<ins>transitionProgress = -1f;</ins>
				SetWeight(CurrentClip, 1f);
				SetWeight(previousClip, 0f);
			}
			else {
				SetWeight(CurrentClip, transitionProgress);
				SetWeight(previousClip, 1f - transitionProgress);
			}
		<ins>}</ins>
	}

	public void PlayIntro () {
		&hellip;
		<ins>transitionProgress = -1f;</ins>
	}</pre>
						
						<p>Invoke the animator's <code>GameUpdate</code> method at the start of <code>Enemy.GameUpdate</code> to enable transitions.</p>
						
						<pre>	public override bool GameUpdate () {
		<ins>animator.GameUpdate();</ins>

		&hellip;
	}</pre>
						
						<figure>
							<div class="vid" style="width: 215px; height:170px;"><iframe src='https://gfycat.com/ifr/flowerydaringcondor'></iframe></div>
							<figcaption>With animation transitions.</figcaption>
						</figure>

					</section>
					
					
				</section>
				
				<section>
					<h2>Dying Enemies</h2>
					
					<p>Intro, move, and outro animation now work and blend correctly. The next step is to add an animation for when an enemy dies.
					
					<section>
						<h3>Dying Animation</h3>
						
						<p>Create a new animation for a dying enemy. Like the outro animation, the dying animation can get rid of the enemy by reducing its scale to zero. Rather then adding a levitating whirl, give it a more appropriate animation, like rolling over. Let's increase the Z position to 0.5 in half a second while increasing the X rotation to 90&deg; at the same time. Then drop the scale and Y position to zero in the next half second. When finished, add it to <code>EnemyAnimationConfig</code>.</p>
						
						<pre>	[SerializeField]
	AnimationClip
		move = default, intro = default, outro = default<ins>, dying = default</ins>;

	public AnimationClip Move => move;

	public AnimationClip Intro => intro;

	public AnimationClip Outro => outro;

	<ins>public AnimationClip Dying => dying;</ins></pre>
						
						<figure>
							<img src="dying-enemies/configuration.png" width="320" height="74" alt="configuration">
							<div class="vid" style="width: 145px; height:100px;"><iframe src='https://gfycat.com/ifr/jitteryexcellentgalapagospenguin'></iframe></div>
							<figcaption>Dying animation.</figcaption>
						</figure>
						
						<p>Add support for it to <code>EnemyAnimator</code> as well, by adding a fourth value to the enum, creating its clip in <code>Configure</code>, and adding a <code>PlayDying</code> method that begins the appropriate transition.</p>
						
						<pre>	public enum Clip { Move, Intro, Outro<ins>, Dying</ins> }

	&hellip;

	public void Configure (Animator animator, EnemyAnimationConfig config) {
		graph = PlayableGraph.Create();
		graph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);
		mixer = AnimationMixerPlayable.Create(graph, <ins>4</ins>);

		&hellip;

		<ins>clip = AnimationClipPlayable.Create(graph, config.Dying);</ins>
		<ins>clip.SetDuration(config.Dying.length);</ins>
		<ins>clip.Pause();</ins>
		<ins>mixer.ConnectInput((int)Clip.Dying, clip, 0);</ins>

		var output = AnimationPlayableOutput.Create(graph, "Enemy", animator);
		output.SetSourcePlayable(mixer);
	}

	&hellip;
	
	<ins>public void PlayDying () {</ins>
		<ins>BeginTransition(Clip.Dying);</ins>
	<ins>}</ins></pre>
						
					</section>
					
					<section>
						<h3>No More Instantaneous Death</h3>
						
						<p>Instead of immediately recycling in <code>Enemy.GameUpdate</code> when the health has been dropped to zero, invoke <code>PlayDying</code> and return <code>true</code>. As the dying clip comes after the outro clip, we can catch both cases by checking whether the current clip is at least the outro clip instead of an exact match.</p>
						
						<pre>	public override bool GameUpdate () {
		animator.GameUpdate();

		if (animator.CurrentClip == EnemyAnimator.Clip.Intro) {
			&hellip;
		}
		else if (animator.CurrentClip <ins>>=</ins> EnemyAnimator.Clip.Outro) {
			if (animator.IsDone) {
				Recycle();
				return false;
			}
			return true;
		}

		if (Health &lt;= 0f) {
			<del>//Recycle();</del>
			<ins>animator.PlayDying();</ins>
			return <ins>true</ins>;
		}
		
		&hellip;
	}</pre>
						
						<figure>
							<div class="vid" style="width: 305px; height:175px;"><iframe src='https://gfycat.com/ifr/bigopenhamadryas'></iframe></div>
							<figcaption>Enemy dying en route.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Only Target Moving Enemies</h3>
						
						<p>Towers are not aware of the state of the enemy, so will keep targeting it even though it is already dying. This is also the case for enemies that are playing their outro, even through they will no longer die. And enemies playing their intro also won't immediately die, though they could as soon as they start moving. To keep this simple and also efficient from a gameplay perspective, let's enforce that towers only target and damage enemies that are moving.</p>
						
						<p>We can make it impossible to target an enemy by disabling its collider. Add a collider field to <code>Enemy</code> for this purpose. We could make it configurable via the editor, but let's give it a public setter property instead, which should only be invoked once.</p>
						
						<pre>	<ins>Collider targetPointCollider;</ins>

	<ins>public Collider TargetPointCollider {</ins>
		<ins>set {</ins>
			<ins>Debug.Assert(targetPointCollider == null, "Redefined collider!");</ins>
			<ins>targetPointCollider = value;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
					
					<p><code>TargetPoint</code> is attached to the same game object that has the collider, so when it awakens grab the collider and assign it to the enemy.</p>
					
					<pre>	void Awake () {
		&hellip;
		<ins>Enemy€.TargetPointCollider = GetComponent&lt;Collider>();</ins>
	}</pre>
						
						<p>Disable the collider in <code>Enemy.Initialize</code>, as we begin with playing the intro.</p>
						
						<pre>	public void Initialize (
		float scale, float speed, float pathOffset, float health
	) {
		&hellip;
		animator.PlayIntro();
		<ins>targetPointCollider.enabled = false;</ins>
	}</pre>
						
						<p>Also disable the collider in <code>GameUpdate</code> when playing the dying or outro animations, and enable it when playing the move animation.</p>
						
						<pre>	public override bool GameUpdate () {
		animator.GameUpdate();

		if (animator.CurrentClip == EnemyAnimator.Clip.Intro) {
			if (!animator.IsDone) {
				return true;
			}
			animator.PlayMove(speed / Scale);
			<ins>targetPointCollider.enabled = true;</ins>
		}
		else if (animator.CurrentClip >= EnemyAnimator.Clip.Outro) {
			&hellip;
		}

		if (Health &lt;= 0f) {
			animator.PlayDying();
			<ins>targetPointCollider.enabled = false;</ins>
			return true;
		}

		progress += Time.deltaTime * progressFactor;
		while (progress >= 1f) {
			if (tileTo == null) {
				Game.EnemyReachedDestination();
				animator.PlayOutro();
				<ins>targetPointCollider.enabled = false;</ins>
				return true;
			}
			&hellip;
		}
		&hellip;
	}</pre>
						
						<p>We also have to make sure that towers stop tracking targets that are no longer valid. Give <code>Enemy</code> a property that indicates whether it is a valid target, which is the case when it's moving.</p>
						
						<pre>	<ins>public bool IsValidTarget => animator.CurrentClip == EnemyAnimator.Clip.Move;</ins></pre>
						
						<p>If this is not the case then <code>Tower.TrackTarget</code> must return <code>false</code>.</p>
						
						<pre>	protected bool TrackTarget (ref TargetPoint target) {
		if (target == null <ins>|| !target.Enemy.IsValidTarget</ins>) {
			return false;
		}
		&hellip;
	}</pre>
						
						<figure>
							<div class="vid" style="width: 305px; height:175px;"><iframe src='https://gfycat.com/ifr/anxiousthoseharrierhawk'></iframe></div>
							<figcaption>Switching targets immediately.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Importing Models and Animations</h2>
					
					<p>While it is possible to create simple animations in the Unity editor, they're usually imported along with 3D models. You either created them yourself in a separate program or got them from somewhere else, like the asset store. As an example, I'll import the grenadier from Unity's <em>3D Game Kit</em>.</p>
					
					<section>
						<h3>Grenadier</h3>
						
						<p>Go to the asset store and search for <em>3D Game Kit - Character Pack</em> from <em>Unity Technologies</em>. Download and then import it. You can suffice with importing only the grenadier model and its dependencies. Do not get the entire <em>3D Game Kit</em> package as it is huge and it will mess up your project.</p>
						
						<p>The grenadier is far too large for our game. Scale it down by selecting the model, going to the <em>Model</em> tab and reducing its <em>Scale Factor</em> to 0.25. You also have to do this for all animations that we end up using, because the model will break apart otherwise.</p>
						
						<figure>
							<img src="importing-models-and-animations/grenadier-import-settings.png" width="320" height="122">
							<figcaption>Grenadier scale factor set to 0.25.</figcaption>
						</figure>
						
						<p>Create an enemy prefab with the grenadier as its model, instead of a cube or sphere. Add the <code>TargetPoint</code> and collider to the <em>Grenadier_Sphere</em> object in the skeleton hierarchy, as that's its center of mass. Set the collider's scale to 0.125, because we haven't scaled the model as we already did that when importing.</p>
						
						<figure>
							<img src="importing-models-and-animations/grenadier-model.png" width="140" height="164" alt="model">
							<img src="importing-models-and-animations/grenadier-hierarchy.png" width="226" height="164" alt="hierarchy">
							<figcaption>Grenadier enemy.</figcaption>
						</figure>
						
						<p>At this point we can already use the grenadier enemy, for example by simply replacing the cube enemies in an existing scenario wave. But it looks rather silly, as the grenadiers bounce around in their default T pose and are levitating.</p>
						
						<figure>
							<div class="vid" style="width: 290px; height:200px;"><iframe src='https://gfycat.com/ifr/saltybountifullabradorretriever'></iframe></div>
							<figcaption>Grenadier with standard animations.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>Animation Selection</h3>
						
						<p>Give the grenadier its own animation configuration. We can use the <em>GrenadierWalk</em> animation for movement, <em>GrenadierCloseRangeAttack</em> for both intro and outro, and <em>GrenadierDeath</em> for dying. All are found under the <em>AnimationClips</em> folder inside assets with an <em>@</em> in front of their name. Make sure that the scale factor for all these assets is set to 0.25. Also, go to their <em>Animation</em> tab and remove all entries under <em>Events</em> as leaving them in will cause errors.</p>
						
						<p>Unfortunately we cannot directly use the <em>GrenadierWalk</em> animation, because it has forward movement baked in, while we need an animation that walks in place. So duplicate that animation clip and select it. All we have to do it find the <em>Grenadier_Root : Position</em> row in the left part of the <em>Animation</em> window and delete it, via the <em>Remove Properties</em> option in its context menu.</p>
						
						<figure>
							<img src="importing-models-and-animations/grenadier-animations.png" width="320" height="142" alt="animations">
							<div class="vid" style="width: 275px; height:175px;"><iframe src='https://gfycat.com/ifr/snarlingperfecthalibut'></iframe></div>
							<figcaption>Grenadier animations.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Adjusting Walk Speed</h3>
						
						<p>The grenadier's walk speed doesn't match its in-game speed, which causes sliding feet even when moving straight ahead. This happens because the animation clip doesn't cover one unit per second. We'll compensate for this by adding a move animation speed configuration option to <code>EnemyAnimationConfig</code>, set to 1 by default.</p>
						
						<pre>	<ins>[SerializeField]</ins>
	<ins>float moveAnimationSpeed = 1f;</ins>

	&hellip;
	
	<ins>public float MoveAnimationSpeed => moveAnimationSpeed;</ins></pre>
						
						<p>Factor this value into the move speed in <code>Enemy.GameUpdate</code>.</p>
						
						<pre>			animator.PlayMove(<ins>animationConfig.MoveAnimationSpeed *</ins> speed / Scale);</pre>
						
						<p>In case of the grenadier we have to double the animation speed to make it line up.</p>
						
						<figure>
							<img src="importing-models-and-animations/move-animation-speed.png" width="320" height="114" alt="config">
							<div class="vid" style="width: 275px; height:120px;"><iframe src='https://gfycat.com/ifr/spanishcelebratedblackrhino'></iframe></div>
							<figcaption>Move animation speed set to 2.</figcaption>
						</figure>
						
						<p>Note that the grenadier also has an animation for running. You could create a separate enemy prefab with a running animation for fast grenadiers.</p>
					</section>
					
					<section>
						<h3>Appearing and Disappearing</h3>
						
						<p>The grenadier doesn't have any animations that shrink or grow it. While it is possible to edit the existing animations to incorporate scaling, this is annoying work and needs to be redone each time new animations are imported. It's more convenient to create separate animations for appearing and disappearing and mix those with the existing ones.</p>
						
						<p>Create two new animation, one that scales from 0 to 1 for and another that does the reverse, both in half a second. You can use the cube enemy set up for animation recording for this. Then add configuration options for them to <code>EnemyAnimationConfig</code>.</p>
						
						<pre>	<ins>[SerializeField]</ins>
	<ins>AnimationClip appear = default, disappear = default;</ins></pre>
						
						<p>Select these animations for the grenadier config. Don't do this for the cubes and spheres, as they already appear and disappear on their own.</p>
						
						<figure>
							<img src="importing-models-and-animations/appear-disappear-config.png" width="320" height="56">
							<figcaption>Appear and disappear animations configured.</figcaption>
						</figure>
						
						<p>Have <code>EnemyAnimator</code> keep track of whether it has an appear and disappear clips, separately for most flexibility. Also add them to the enum.</p>
						
						<pre>	public enum Clip { Move, Intro, Outro, Dying<ins>, Appear, Disappear</ins> }
	
	&hellip;
	
	<ins>bool hasAppearClip, hasDisappearClip;</ins></pre>
						
						<p>In <code>Config</code>, increase the amount of clips to six if we have at least one of them. Then create the appropriate playable clips.</p>
						
						<pre>	public void Configure (Animator animator, EnemyAnimationConfig config) {
		<ins>hasAppearClip = config.Appear;</ins>
		<ins>hasDisappearClip = config.Disappear;</ins>

		graph = PlayableGraph.Create();
		graph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);
		mixer = AnimationMixerPlayable.Create(
			<ins>graph, hasAppearClip || hasDisappearClip ? 6 :</ins> 4
		);

		&hellip;

		<ins>if (hasAppearClip) {</ins>
			<ins>clip = AnimationClipPlayable.Create(graph, config.Appear);</ins>
			<ins>clip.SetDuration(config.Appear.length);</ins>
			<ins>clip.Pause();</ins>
			<ins>mixer.ConnectInput((int)Clip.Appear, clip, 0);</ins>
		<ins>}</ins>

		<ins>if (hasDisappearClip) {</ins>
			<ins>clip = AnimationClipPlayable.Create(graph, config.Disappear);</ins>
			<ins>clip.SetDuration(config.Disappear.length);</ins>
			<ins>clip.Pause();</ins>
			<ins>mixer.ConnectInput((int)Clip.Disappear, clip, 0);</ins>
		<ins>}</ins>

		var output = AnimationPlayableOutput.Create(graph, "Enemy", animator);
		output.SetSourcePlayable(mixer);
	}</pre>
						
						<p>When playing the intro, also play the appear clip at full weight if it exists. That means two clips have weight 1, which works fine as long as they don't both animate the same properties. So it only works correctly if the imported animation doesn't scale its root, which it typically doesn't.</p>
						
						<pre>	public void PlayIntro () {
		&hellip;

		<ins>if (hasAppearClip) {</ins>
			<ins>GetPlayable(Clip.Appear).Play();</ins>
			<ins>SetWeight(Clip.Appear, 1f);</ins>
		<ins>}</ins>
	}</pre>
						
						<p>When movement begins we no longer need the appear clip, so set its weight to zero in <code>PlayMove</code> if needed.</p>
						
						<pre>	public void PlayMove (float speed) {
		GetPlayable(Clip.Move).SetSpeed(speed);
		BeginTransition(Clip.Move);

		<ins>if (hasAppearClip) {</ins>
			<ins>SetWeight(Clip.Appear, 0f);</ins>
		<ins>}</ins>
	}</pre>
						
						<p>When playing the outro or dying animation we now also have to play the disappear clip if it exists. But we have to delay that clip&mdash;we assume that the disappear clip is the shortest&mdash;so both end at the same time. That's done by invoking <code>SetDelay</code> on the clip with a duration equal to the other clip's duration minus the disappear duration.</p>
						
						<pre>	public void PlayOutro () {
		BeginTransition(Clip.Outro);

		<ins>if (hasDisappearClip) {</ins>
			<ins>PlayDisappearFor(Clip.Outro);</ins>
		<ins>}</ins>
	}

	public void PlayDying () {
		BeginTransition(Clip.Dying);

		<ins>if (hasDisappearClip) {</ins>
			<ins>PlayDisappearFor(Clip.Dying);</ins>
		<ins>}</ins>
	}

	&hellip;

	<ins>void PlayDisappearFor (Clip otherClip) {</ins>
		<ins>var clip = GetPlayable(Clip.Disappear);</ins>
		<ins>clip.Play();</ins>
		<ins>clip.SetDelay(GetPlayable(otherClip).GetDuration() - clip.GetDuration());</ins>
		<ins>SetWeight(Clip.Disappear, 1f);</ins>
	<ins>}</ins></pre>
						
						<figure>
							<div class="vid" style="width: 275px; height:160px;"><iframe src='https://gfycat.com/ifr/cheerfulsmoggycassowary'></iframe></div>
							<figcaption>Appearing and disappearing.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Surviving a Hot Reload</h2>
					
					<p>The only problem with using <code>PlayableGraph</code> is that is isn't serializable. This isn't an issue in a build, but animations will stop in the editor when a hot reload happens. As enemies rely on detecting the end of animations to progress, they can become stuck. So it's not just a visual glitch. We have to recover from a hot reload to keep the game functional.</p>
					
					<section>
						<h3>Recreating the Playable Graph</h3>
						
						<p><code>EnemyAnimator</code> is serializable, but its graph becomes nonfunctional after the native data is lost during it hot reload. We can detect this by invoking <code>IsValid</code> on the graph. Wrap that in a public property so the enemy can also detect it. We only need this in the editor, so we can make the code conditional on that.</p>
						
						<pre><ins>#if UNITY_EDITOR</ins>
	<ins>public bool IsValid => graph.IsValid();</ins>
<ins>#endif</ins></pre>
						
						<p>To restore the animation state after a hot reload we have to create a new graph. Add a <code>RestorAfterHotReload</code> method for that, which invokes <code>Configure</code>, sets the move speed, sets the current clip's weight to 1, and plays that clip and the graph. This doesn't recover transitions, but those are purely cosmetic and the game freezes during a hot reload anyway.</p>
						
						<pre><ins>#if UNITY_EDITOR</ins>
	<ins>public void RestoreAfterHotReload (</ins>
		<ins>Animator animator, EnemyAnimationConfig config, float speed</ins>
	<ins>) {</ins>
		<ins>Configure(animator, config);</ins>
		<ins>GetPlayable(Clip.Move).SetSpeed(speed);</ins>
		<ins>var clip = GetPlayable(CurrentClip);</ins>
		<ins>clip.Play();</ins>
		<ins>SetWeight(CurrentClip, 1f);</ins>
		<ins>graph.Play();</ins>
	<ins>}</ins>
<ins>#endif</ins></pre>
						
						<p><code>Enemy.GameUpdate</code> now has to restore the animator if it isn't valid before it does anything else.</p>
						
						<pre>	public override bool GameUpdate () {
<ins>#if UNITY_EDITOR</ins>
		<ins>if (!animator.IsValid) {</ins>
			<ins>animator.RestoreAfterHotReload(</ins>
				<ins>model.GetChild(0).GetComponent&lt;Animator>(),</ins>
				<ins>animationConfig,</ins>
				<ins>animationConfig.MoveAnimationSpeed * speed / Scale</ins>
			<ins>);</ins>
		<ins>}</ins>
<ins>#endif</ins>
		animator.GameUpdate();

		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Restoring Clip Time</h3>
						
						<p>Enemies now keep their animation, but its time gets set back to zero. To keep the time <code>EnemyAnimator</code> has to keep track of it and set it when restoring. The time is kept track of with a double instead of a float, for higher precision.</p>
						
						<pre><ins>#if UNITY_EDITOR</ins>
	<ins>double clipTime;</ins>
<ins>#endif</ins></pre>
						
						<pre>	public void RestoreAfterHotReload (
		Animator animator, EnemyAnimationConfig config, float speed
	) {
		Configure(animator, config);
		GetPlayable(Clip.Move).SetSpeed(speed);
		SetWeight(CurrentClip, 1f);
		var clip = GetPlayable(CurrentClip);
		<ins>clip.SetTime(clipTime);</ins>
		clip.Play();
		graph.Play();
	}</pre>
						
						<p>To keep the time up to date it has to be retrieved at the end of <code>GameUpdate</code>.</p>
						
						<pre>	public void GameUpdate () {
		&hellip;
<ins>#if UNITY_EDITOR</ins>
		<ins>clipTime = GetPlayable(CurrentClip).GetTime();</ins>
<ins>#endif</ins>
	}</pre>
						
					</section>
					
					<section>
						<h3>Appear and Disappear Restoration</h3>
						
						<p>We can also restore the appear animation. If we're restoring the intro clip and the appear clip exists, then activate the appear clip with the same time as the current clip.</p>
						
						<pre>	public void RestoreAfterHotReload (
		Animator animator, EnemyAnimationConfig config, float speed
	) {
		&hellip;
		<ins>if (CurrentClip == Clip.Intro && hasAppearClip) {</ins>
			<ins>clip = GetPlayable(Clip.Appear);</ins>
			<ins>clip.SetTime(clipTime);</ins>
			<ins>clip.Play();</ins>
			<ins>SetWeight(Clip.Appear, 1f);</ins>
		<ins>}</ins>
	}</pre>
						
						<p>The disappear clip works the same, but when we're restoring the outro and dying animation. In this case the disappear delay has to be reduced by the current clip time. If the delay is still positive then that's the remaining delay. If it's negative then that means the disappear animation was already playing and its time is equal to the negated delay.</p>
						
						<pre>		if (CurrentClip == Clip.Intro && hasAppearClip) {
			&hellip;
		}
		<ins>else if (CurrentClip >= Clip.Outro && hasDisappearClip) {</ins>
			<ins>clip = GetPlayable(Clip.Disappear);</ins>
			<ins>clip.Play();</ins>
			<ins>double delay =</ins>
				<ins>GetPlayable(CurrentClip).GetDuration() -</ins>
				<ins>clip.GetDuration() -</ins>
				<ins>clipTime;</ins>
			<ins>if (delay >= 0f) {</ins>
				<ins>clip.SetDelay(delay);</ins>
			<ins>}</ins>
			<ins>else {</ins>
				<ins>clip.SetTime(-delay);</ins>
			<ins>}</ins>
			<ins>SetWeight(Clip.Disappear, 1f);</ins>
		<ins>}</ins></pre>
						
						<p>This concludes the Tower Defense tutorial series. You can use it as a starting point for your own game or turn it into something else. You could add sound, a GUI, save/load functionality, more tower types, other game tile content, and so on.</p>
						
						<aside>
							<h3>How do I make the graph work with enemy reuse?</h3>
							<div>
								<p>Before playing the graph again you'll have to set the time all clips to zero and pause them. The weights of the last active clips must also become zero. Finally, the done state of non-looping clips has to be reset, by invoking <code>SetDone(false)</code> on them.</p>
							</div>
						</aside>
					</section>
					
					<a href="https://bitbucket.org/catlikecodingunitytutorials/tower-defense-06-animation/" class="repository">repository</a>
					<a href="Animation.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>