<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/flow/directional-flow/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/flow/directional-flow/tutorial-image.jpg">
		<meta property="og:title" content="Directional Flow">
		<meta property="og:description" content="A Unity Flow tutorial about creating ripples aligned with a flow vector field.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Directional Flow</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/flow/directional-flow/#article",
				"headline": "Directional Flow",
				"alternativeHeadline": "Tiling Liquid",
				"datePublished": "2018-06-29",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Flow tutorial about creating ripples aligned with a flow vector field.",
				"image": "https://catlikecoding.com/unity/tutorials/flow/directional-flow/tutorial-image.jpg",
				"dependencies": "Unity 2017.4.4f1",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/flow/", "name": "Flow" }}
				]
			}
		}</script>
		<script>
			var customTypes = {};
			
			var defaultCodeClass = 'shader';
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Flow</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Directional Flow</h1>
					<p>Tiling Liquid</p>
					<ul>
						<li>Align a texture with the flow direction.</li>
						<li>Partition the surface into tiles.</li>
						<li>Seamlessly blend tiles.</li>
						<li>Obfuscate visual artifacts.</li>
					</ul>
				</header>
				
				<p>This is the second tutorial in a series about creating the appearance of <a href="../index.html">flowing materials</a>. It comes after <a href="../texture-distortion/index.html">Texture Distortion</a> and is about aligning patterns with the flow, instead of distorting them.
				
				<p>This tutorial is made with Unity 2017.4.4f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Ripples going with the flow.</figcaption>
				</figure>
				
				<section>
					<h2>Anisotropic Patterns</h2>
					
					<p>When distorting a texture to simulate flow, it can end up getting stretched or squashed in any direction. This means that it must look good no matter how it gets deformed. This is only possible with isotropic patterns. Isotropic means that the image appears similar in all directions. This is the case for the water texture that we used in the <a href="../texture-distortion/index.html">previous tutorial</a>.</p>
					
					<section>
						<h3>Rippling Water</h3>
						
						<p>While the illusion of flow can be convincing, the patterns created by distorting an isotropic pattern do not look like real water. This is most obvious when observing a still image of the effect, instead of an animation. You can't really tell what the flow direction is supposed to be. That's because the alignment of the waves and ripples is wrong. They're elongated along the flow direction, instead of being perpendicular to it.</p>
						
						<figure>
							<img src="anisotropic-patterns/isotropic.jpg" width="360" height="160">
							<figcaption>Distorting an isotropic pattern, with black albedo.</figcaption>
						</figure>
						
						<p>The distortion effect works best for either very turbulent or very sluggish flows. It doesn't work well for more calm flows that manifest clear ripple patterns, because such ripples have a clear direction to them. They're anisotropic. <a href="anisotropic-patterns/ripples-derivative-height.png">Here</a> is an alternative water texture containing such ripples. It's made the same way as the other texture, but with a different pattern, and the derivatives are scaled by a factor of 0.025 relative to the height data.</p>
						
						<figure>
							<img src="anisotropic-patterns/ripples-derivative-height.png" width="256" height="256">
							<figcaption>Derivative plus height map for ripples.</figcaption>
						</figure>
						
						<p>Import the texture, make sure that it's not in sRGB mode, and use it for the pattern of the distortion effect.</p>
						
						<figure>
							<img src="anisotropic-patterns/anisotropic.jpg" width="360" height="160">
							<figcaption>Distorting an anisotropic pattern.</figcaption>
						</figure>
						
						<p>There is now a clear visual direction, even when there is no animation. However, the pattern isn't aligned with the flow, so the implied direction is incorrect. We have to use a different approach if we want to visualize proper ripples.</p>
					</section>
					
					<section>
						<h3>Directional Flow Shader</h3>
						
						<p>In this tutorial we'll create a different flow shader. Instead of distorting a texture, it will align it with the flow. Duplicate the <em>DistortionFlow</em> shader and rename it to <code>DirectionalFlow</code>. We'll leave all parameters the same, except that we won't use the jump parameters, so remove those. Also, we won't bother with an albedo texture, so the derivative-height data can be supplied via the main texture. And we won't need noise to offset a phase blend, so we're only interested in the RG channels of the flow map.</p>
						
						<p>We'll start by reducing the <code>surf</code> function to just sampling the derivative-height data, using the squared height for albedo and setting the normal vector.</p>
						
						<pre>Shader "Custom/DirectionalFlow" {
	Properties {
		_Color ("Color", Color) = (1,1,1,1)
		[NoScaleOffset] _MainTex ("Deriv (AG) Height (B)", 2D) = "black" {}
		[NoScaleOffset] _FlowMap ("Flow (RG)", 2D) = "black" {}
		_Tiling ("Tiling", Float) = 1
		_Speed ("Speed", Float) = 1
		_FlowStrength ("Flow Strength", Float) = 1
		_HeightScale ("Height Scale, Constant", Float) = 0.25
		_HeightScaleModulated ("Height Scale, Modulated", Float) = 0.75
		_Glossiness ("Smoothness", Range(0,1)) = 0.5
		_Metallic ("Metallic", Range(0,1)) = 0.0
	}
	SubShader {
		Tags { "RenderType"="Opaque" }
		LOD 200

		CGPROGRAM
		#pragma surface surf Standard fullforwardshadows
		#pragma target 3.0
		
		#include "Flow.cginc"

		sampler2D _MainTex, _FlowMap;
		float _Tiling, _Speed, _FlowStrength;
		float _HeightScale, _HeightScaleModulated;

		struct Input {
			float2 uv_MainTex;
		};

		half _Glossiness;
		half _Metallic;
		fixed4 _Color;

		float3 UnpackDerivativeHeight (float4 textureData) {
			float3 dh = textureData.agb;
			dh.xy = dh.xy * 2 - 1;
			return dh;
		}

		void surf (Input IN, inout SurfaceOutputStandard o) {
			float2 uv = IN.uv_MainTex * _Tiling;
			float3 dh = UnpackDerivativeHeight(tex2D(_MainTex, uv));
			fixed4 c = dh.z * dh.z * _Color;
			o.Albedo = c.rgb;
			o.Normal = normalize(float3(-dh.xy, 1));
			o.Metallic = _Metallic;
			o.Smoothness = _Glossiness;
			o.Alpha = c.a;
		}
		ENDCG
	}
	FallBack "Diffuse"
}</pre>
						
						<p>Create a material with this shader, using the same settings as the distortion material, except now using the ripple pattern and with tiling set to 1. When applied to the quad, we end up with simply the ripple pattern. The pattern is aligned to correspond with a flow along the V axis. The default is that it flows up, but as the pattern is symmetrical in works in the opposite direction too.</p>
						
						<figure>
							<img alt="material" src="anisotropic-patterns/material.png" width="320" height="410"><br>
							<img alt="quad" src="anisotropic-patterns/quad.jpg" width="360" height="160">
							<figcaption>Directional flow material.</figcaption>
						</figure>
					</section>
					
					<a href="anisotropic-patterns/anisotropic-patterns.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Aligning With the Flow</h2>
					
					<p>Now that we have an anisotropic pattern, we need to find a way to align it with a flow direction. We'll first try this with a fixed and controlled direction, and once that's working move on to using the flow map.</p>
					
					<section>
						<h3>UV for Directional Flow</h3>
						
						<p>Aligning a texture with a direction is a matter of transforming UV coordinates. This is a fundamental operation useful for flow simulation, so we'll add a function for that to our <em>Flow</em> include file. Name it <code>DirectionalFlowUV</code>. It needs the original UV coordinates and a flow vector as parameters. Also give it tiling and time parameters, similar to the <code>FlowUVW</code> function. As it won't perform deformation that requires a time reset, no phase data nor a time-blending weight are involved.</p>
						
						<pre><ins>float2 DirectionalFlowUV (</ins>
	<ins>float2 uv, float2 flowVector, float tiling, float time</ins>
<ins>) {}</ins></pre>
						
						<p>We begin by simply scrolling up, moving the pattern in the positive V direction, by subtracting the time from the V coordinate. Then apply the tiling.</p>
						
						<pre>float2 DirectionalFlowUVW (
	float2 uv, float2 flowVector, float tiling, float time
) {
	<ins>uv.y -= time;</ins>
	<ins>return uv * tiling;</ins>
}</pre>
						
						<p>Use this function in our shader to get the final flow UV coordinates. We'll supply it with <code>float(0, 1)</code> as the flow vector&mdash;`[[0],[1]]` representing the default orientation&mdash;the tiling property, and the time modulated by the speed. Then we use the result to sample the pattern.</p>
						
						<pre>		void surf (Input IN, inout SurfaceOutputStandard o) {
			<del>//float2 uv = IN.uv_MainTex * _Tiling;</del>
			<ins>float time = _Time.y * _Speed;</ins>
			<ins>float2 uvFlow = DirectionalFlowUV(</ins>
				<ins>IN.uv_MainTex, float2(0, 1), _Tiling, time</ins>
			<ins>);</ins>
			float3 dh = UnpackDerivativeHeight(tex2D(_MainTex, <ins>uvFlow</ins>));
			&hellip;
		}</pre>
						
						<p>The result is the same as before, but with movement.</p>
						
						<figure>
							<div class="vid" style="width: 360px; height:160px;"><iframe src='https://gfycat.com/ifr/EqualLankyBrahmanbull'></iframe></div>
							<figcaption>Sliding ripple pattern.</figcaption>
						</figure>

					</section>
					
					<section>
						<h3>Texture Rotation</h3>
						
						<p>To rotate UV coordinates, we need a 2D rotation matrix, as described in the <a href="../../rendering/part-1">Rendering 1, Matrices</a> tutorial. If the flow vector `[[x],[y]]` is of unit length, then it represents a point on the unit circle. As `[[0],[1]]` corresponds to no rotation, the X coordinate represents the sine of some rotation angle `theta` (theta), while the Y coordinate represents the cosine of the same angle. Also, the flow vector `[[1],[0]]` represents flow in the U direction, to the right. So the flow vector can be interpreted as `[[sin theta],[cos theta]]` for a clockwise rotation.</p>
						
						<p>The <a href="../../rendering/part-1">Rendering 1, Matrices</a> tutorial defined a 2D rotation matrix as `[[cos theta,-sin theta],[sin theta,cos theta]]`, but that represents a counterclockwise rotation. As we need a clockwise rotation, we have to flip the sign of `sin theta`, which gives us the final rotation matrix `[[y,x],[-x,y]]`.</p>
						
						<p>Because our flow map doesn't contain vectors of unit length, we have to normalize them first. Then construct the matrix using that direction vector, via the <code>float2x2</code> construction function. Multiply that matrix with the original UV coordinates, using the <code>mul</code> function. After that's done the time offset and tiling should be applied.</p>
						
						<pre>float2 DirectionalFlowUV (
	float2 uv, float2 flowVector, float tiling, float time
) {
	<ins>float2 dir = normalize(flowVector.xy);</ins>
	<ins>uv = mul(float2x2(dir.y, dir.x, -dir.x, dir.y), uv);</ins>
	uv.y -= time;
	return uv * tiling;
}</pre>
						
						<p>Let's test whether this works, by using the flow vector `[[1],[1]]`. That should result in a pattern that's rotated 45&deg; clockwise.</p>
						
						<pre>			float2 uvFlow = DirectionalFlowUV(
				IN.uv_MainTex, float2(<ins>1</ins>, 1), _Tiling, time
			);</pre>
						
						<figure>
							<img src="aligning-with-the-flow/counterclockwise.jpg" width="360" height="160">
							<figcaption>Rotated 45&deg; counterclockwise.</figcaption>
						</figure>
						
						<p>We get a counterclockwise rotation instead. That's because we're not rotating the pattern itself, but the UV coordinates. To get the correct result, we have to rotate them in the opposite direction, just like we have to subtract the time to scroll in a positive direction. So we have to use the counterclockwise rotation matrix after all.</p>
						
						<pre>	uv = mul(float2x2(dir.y, <ins>-dir.x</ins>, <ins>dir.x</ins>, dir.y), uv);</pre>
						
						<figure>
							<img src="aligning-with-the-flow/clockwise.jpg" width="360" height="160">
							<figcaption>Rotated 45&deg; clockwise.</figcaption>
						</figure>
						
						<p>To make sure that all flow vectors are now converted to correct rotations, let's rotate based on time, using `[[sin time],[cos time]]`. Set the material's speed to zero so the only movement is causes by the rotation, otherwise it's hard to interpret the movement.</p>
						
						<pre>			float uvFlow = DirectionalFlowUV(
				IN.uv_MainTex, float2(<ins>sin(_Time.y)</ins>, <ins>cos(_Time.y)</ins>), _Tiling, time
			);</pre>
						
						<figure>
							<div class="vid" style="width: 360px; height:160px;"><iframe src='https://gfycat.com/ifr/WarlikeRecentGuernseycow'></iframe></div>
							<figcaption>Rotating clockwise.</figcaption>
						</figure>
						
						<p>The rotation works as it should. The animation also reveals that the rotation is centered on the bottom left of the quad, which corresponds to the origin of the UV space. While we could offset the rotation so it is centered on another point, this isn't necessary.</p>
					</section>
					
					<section>
						<h3>Rotating Derivatives</h3>
						
						<p>Although the pattern rotates correctly, there is something wrong with the normal vectors. This might not be immediately obvious, but it becomes glaring once you pay attention to how the surface should look. It's easiest to visualize by using the derivatives to colorize the material.</p>
						
						<pre>			o.Albedo = <ins>dh; //c.rgb</ins>;</pre>
						
						<p>At zero rotation&mdash;due to the anisotropic pattern&mdash;we mostly see green, with little red. Blue can be ignored, because that's the height.</p>
						
						<figure>
							<img src="aligning-with-the-flow/derivatives.jpg" width="360" height="160">
							<figcaption>Derivatives at 0&deg; rotation.</figcaption>
						</figure>
						
						<p>What colors do we see when the pattern is rotated 90&deg;?</p>
						
						<figure>
							<img src="aligning-with-the-flow/derivatives-incorrect.jpg" width="360" height="160">
							<figcaption>Incorrect derivatives at 90&deg; rotation.</figcaption>
						</figure>
						
						<p>We still see the same colors. This would be correct if it was just color data. But these are derivatives, which represent surface curvature. When the surface rotates, so should its curvature, but that's not happening. This means that the lighting is affected by changes in position, but not rotation.</p>
						
						<p>To keep the lighting correct, we have to rotate the normal vectors, which is the same as rotating the derivatives. As <code>DirectionalFlowUV</code> is responsible for the rotation, it makes sense that it also gives us the matrix to use for vector rotation. Let's make that possible by adding an output parameter to it. In this case, we do need the proper clockwise rotation matrix.</p>
						
						<pre>float2 DirectionalFlowUV (
	float2 uv, float2 flowVector, float tiling, float time<ins>,</ins>
	<ins>out float2x2 rotation</ins>
) {
	float2 dir = normalize(flowVector.xy);
	<ins>rotation = float2x2(dir.y, dir.x, -dir.x, dir.y);</ins>
	uv = mul(float2x2(dir.y, -dir.x, dir.x, dir.y), uv);
	uv.y -= time;
	return uv * tiling;
}</pre>
						
						<p>Supply a variable for this new output, then use it to rotate the derivatives that we sample later, with another matrix multiplication.</p>
						
						<pre>			float time = _Time.y * _Speed;
			<ins>float2x2 derivRotation;</ins>
			float2 uvFlow = DirectionalFlowUV(
				IN.uv_MainTex, float2(sin(_Time.y), cos(_Time.y)), _Tiling, time<ins>,</ins>
				<ins>derivRotation</ins>
			);
			float3 dh = UnpackDerivativeHeight(tex2D(_MainTex, uvFlow));
			<ins>dh.xy = mul(derivRotation, dh.xy);</ins></pre>
						
						<figure>
							<img src="aligning-with-the-flow/derivatives-correct.jpg" width="360" height="160">
							<figcaption>Correct derivatives at 90&deg; rotation.</figcaption>
						</figure>
						
						<p>Now that the derivatives rotate as well, the colors change too. At 90&deg; rotation, red and green have swapped. Now we can restore the original color.</p>
						
						<pre>			o.Albedo = <ins>c.rgb</ins>;</pre>
						
						<figure>
							<div class="vid" style="width: 360px; height:160px;"><iframe src='https://gfycat.com/ifr/TimelyClearcutEastsiberianlaika'></iframe></div>
							<figcaption>Correctly rotating normal vectors.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Sampling the Flow</h3>
						
						<p>The next step is to use the flow map to control the rotation. Sample the map and supply its data to <code>DirectionalFlowUV</code>.</p>
						
						<pre>			<ins>float2 flow = tex2D(_FlowMap, IN.uv_MainTex).rg;</ins>
			<ins>flow = flow.xy * 2 - 1;</ins>
			float2 uvFlow = DirectionalFlowUV(
				IN.uv_MainTex, <ins>flow</ins>, _Tiling, time,
				derivRotation
			);</pre>
						
						<p>But because we normalize the flow vectors, we lose the speed information. Fortunately, we stored the speed in the flow map's B channel, so we can pass that to <code>DirectionalFlowUV</code> as well. Adjust and rename its parameter for that, then modulate the time with the speed before adding it.</p>
						
						<pre>float2 DirectionalFlowUV (
	float2 uv, <ins>float3 flowVectorAndSpeed</ins>, float tiling, float time,
	out float2x2 rotation
) {
	float2 dir = normalize(<ins>flowVectorAndSpeed</ins>.xy);
	rotation = float2x2(dir.y, dir.x, -dir.x, dir.y);
	uv = mul(float2x2(dir.y, -dir.x, dir.x, dir.y), uv);
	uv.y -= time <ins>* flowVectorAndSpeed.z</ins>;
	return uv * tiling;
}</pre>
						
						<p>Retrieve the speed data and pass it to the function. But before that, let's also modulate it with the <em>Flow Strength</em> shader property. The distortion shader uses this property to control the amount of distortion, but it also affects the animation speed. While we don't really need to do this in the directional shader, it makes it easier to configure the exact same speed for both shaders. That is convenient when comparing the effects.</p>
						
						<pre>			<ins>float3</ins> flow = tex2D(_FlowMap, IN.uv_MainTex).<ins>rgb</ins>;
			flow<ins>.xy</ins> = flow.xy * 2 - 1;
			<ins>flow.z *= _FlowStrength;</ins>
			float2 uvFlow = DirectionalFlowUV(
				IN.uv_MainTex, flow, _Tiling, time,
				derivRotation
			);</pre>
						
						<figure>
							<img src="aligning-with-the-flow/sampled-flow.jpg" width="360" height="160">
							<figcaption>Sampled flow.</figcaption>
						</figure>
						
						<p>Unfortunately&mdash;like with the distortion shader&mdash;we get a heavily distorted an unusable result. Rotating each fragment independently rips the pattern apart. This wasn't a problem when we used a uniform direction. We'll have to come up with a solution.</p>
					</section>
					
					<a href="aligning-with-the-flow/aligning-with-the-flow.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Tiled Flow</h2>
					
					<p>The distortion approach had a temporal problem, because we were forced to reset the distortion at some point, to keep the pattern intact. We hid that by blending between two different phases across time. The directional approach has this problem too, but it's of a different nature. While the pattern breaks up more as time progresses, it's already destroyed at time zero, without any animation. So resetting time won't help.</p>
					
					<figure>
						<img src="tiled-flow/distortion-without-movement.jpg" width="360" height="160">
						<figcaption>Distortion without any movement, speed 0.</figcaption>
					</figure>
					
					<p>Instead, there is a discontinuity where there is a difference in orientation. This is a spatial problem, not a temporal one. The solution is once again to hide the problem by blending. But now we have to blend in space, not time. And we're dealing with a 2D surface, not with 1D time, so it will be more complex.</p>
					
					<p>What we'll do is try to find a compromise between the perfect result of a uniform flow and the desired result of using a different flow direction per fragment. That compromise is to divide the surface into regions. We'll simply use a grid of square tiles. Each tile has a uniform flow, so won't suffer from any distortion. Then we'll blend each tile with its neighbors, to hide the discontinuities between them. This approach was first publicly described by Frans van Hoesel in 2010, as the <em>Tiled Directional Flow</em> algorithm. We'll create a variant of it.</p>
					
					<section>
						<h3>Flow Grid</h3>
						
						<p>To split the surface into tiles, we need to decide on a grid resolution. We'll make that configurable via a shader property, using a default of 10.</p>
						
						<pre>		_Tiling ("Tiling", Float) = 1
		<ins>_GridResolution ("Grid Resolution", Float) = 10</ins></pre>
						
						<figure>
							<img src="tiled-flow/grid-resolution.png" width="320" height="38">
							<figcaption>Grid resolution set to 10.</figcaption>
						</figure>
						
						<p>Cutting the flow map into tiles can be done by multiplying the UV used for sampling the map by the grid resolution, then discarding the fractional part. That gives us tiles with fixed UV coordinates, from 0 up to the grid resolution. To convert that back to a range from 0 to 1, divide by the tiled coordinates by the grid resolution.</p>
						
						<figure>
							<img src="tiled-flow/staircase.png" width="150" height="150">
							<figcaption>Functions `x` and `floor(10x)/10`.</figcaption>
						</figure>
						
						<pre>		float _Tiling, <ins>_GridResolution,</ins> _Speed, _FlowStrength;
		float _HeightScale, _HeightScaleModulated;

		&hellip;

		void surf (Input IN, inout SurfaceOutputStandard o) {
			float time = _Time.y * _Speed;
			float2x2 derivRotation;
			<ins>float2 uvTiled =</ins>
				<ins>floor(IN.uv_MainTex * _GridResolution) / _GridResolution;</ins>
			float3 flow = tex2D(_FlowMap, <ins>uvTiled</ins>).rgb;
			&hellip;
		}</pre>
						
						<figure>
							<img src="tiled-flow/flow-grid.jpg" width="360" height="160">
							<figcaption>One flow direction per grid cell.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Blending Cells</h3>
						
						<p>At this point we have clearly distinguishable grid cells, each containing an undistorted pattern. The next step is to blend them. This requires us to sample multiple cells per fragment. So let's move the code to compute the derivative plus height data to a new <code>FlowCell</code> function. Initally, all it needs are the original UV coordinates and the scaled time.</p>
						
						<pre>		<ins><ins>float3 FlowCell (float2 uv, float time) {</ins></ins>
		    float2x2 derivRotation;
			float2 uvTiled =
				floor(<ins>uv</ins> * _GridResolution) / _GridResolution;
			float3 flow = tex2D(_FlowMap, uvTiled).rgb;
			flow.xy = flow.xy * 2 - 1;
			flow.z *= _FlowStrength;
			float2 uvFlow = DirectionalFlowUV(
				<ins>uv</ins>, flow, _Tiling, time,
				derivRotation
			);
			float3 dh = UnpackDerivativeHeight(tex2D(_MainTex, uvFlow));
			dh.xy = mul(derivRotation, dh.xy);
			<ins>return dh;</ins>
		<ins>}</ins>

		void surf (Input IN, inout SurfaceOutputStandard o) {
			float time = _Time.y * _Speed;
			<del>//float2x2 derivRotation;</del>
			<del>//&hellip;</del>
			<del>//dh.xy = mul(derivRotation, dh.xy);</del>
			float2 uv = <ins>IN.uv_MainTex</ins>;
			<ins>float3 dh = FlowCell(uv, time);</ins>
			fixed4 c = dh.z * dh.z * _Color;
			&hellip;
		}</pre>
						
						<p>Sampling a different cell can be done by adding an offset before flooring the UV coordinates to find the fixed flow. Add a parameter for that to <code>FlowCell</code>.</p>
						
						<pre>		float3 FlowCell (float2 uv, <ins>float2 offset,</ins> float time) {
		    float2x2 derivRotation;
			float2 uvTiled =
				floor(uv * _GridResolution <ins>+ offset</ins>) / _GridResolution;
			&hellip;
		}</pre>
						
						<p>Let's first try an offset of one unit in the U dimension. That means that we end up sampling one cell to the right, visually shifting the flow data one step to the left.</p>
						
						<pre>			float3 dh = FlowCell(uv, <ins>float2(1, 0),</ins> time);</pre>
						
						<figure>
							<img src="tiled-flow/cell-offset.jpg" width="360" height="160">
							<figcaption>Cells offset one step to the right.</figcaption>
						</figure>
						
						<p>To blend the cells horizontally, we have to sample both the original and the offset cell per tile. We'll designate the original data as A and the offset data as B. First, let's just average them, giving each a weight of 0.5 and summing that.</p>
						
						<pre>			<ins>float3 dhA = FlowCell(uv, float2(0, 0), time);</ins>
			float3 <ins>dhB</ins> = FlowCell(uv, float2(1, 0), time);
			<ins>float3 dh = dhA * 0.5 + dhB * 0.5;</ins></pre>
						
						<figure>
							<img src="tiled-flow/averaged-cells.jpg" width="360" height="160">
							<figcaption>Averaged cells.</figcaption>
						</figure>
						
						<p>Each tile now contains the same amount of A and B everywhere. Next, we have to transition from A to B along the U dimension. We can do this by linearly interpolating between A and B. The fractional part of the scaled U coordinate is the value `t` that we can use to interpolate the weights. Let's visualize it, by using it as the albedo.</p>
						
						<pre>			float3 dhA = FlowCell(uv, float2(0, 0), time);
			float3 dhB = FlowCell(uv, float2(1, 0), time);

			<ins>float t = frac(uv.x * _GridResolution);</ins>

			float3 dh = dhA * 0.5 + dhB * 0.5;
			fixed4 c = dh.z * dh.z * _Color;
			o.Albedo = <ins>t; // c.rgb</ins>;</pre>
						
						<figure>
							<img src="tiled-flow/interpolation-basis.jpg" width="360" height="160">
							<figcaption>Interpolation basis.</figcaption>
						</figure>
						
						<p>The A cell starts at full strength on the left side of each tile, where `t` is zero. And it should be gone when `t` reaches 1 on the right side. So the weight of A is `t-1`. B is the other way around, so its weight is simply `t`.</p>
						
						<pre>			float3 dhA = FlowCell(uv, float2(0, 0), time);
			float3 dhB = FlowCell(uv, float2(1, 0), time);

			float t = frac(uv.x * _GridResolution);
			<ins>float wA = 1 - t;</ins>
			<ins>float wB = t;</ins>

			float3 dh = dhA * <ins>wA</ins> + dhB * <ins>wB</ins>;
			fixed4 c = dh.z * dh.z * _Color;
			o.Albedo = <ins>c.rgb</ins>;</pre>
						
						<figure>
							<img src="tiled-flow/interpolated-cells.jpg" width="360" height="160">
							<figcaption>Horizontally interpolated cells.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Overlapping Cells</h3>
						
						<p>Although interpolation between the cells should eliminate the horizontal discontinuity, we can still see lines that make the grid obvious. These lines are artifacts caused by the sudden jump of the UV coordinates used to sample the flow map. The suddenly large UV delta triggers the GPU to select a different mipmap level along the grid line, corrupting the flow data. While we could eliminate these artifacts by eliminating mipmaps, this isn't desirable. It would be better if we could hide them some other way.</p>
						
						<p>We can hide the lines by making sure that the cell weights are zero at their edges, which is where the artifact lines are. But the weight function `t` reset each tile, so we have sawtooth waves that are both 0 and 1 on the edge. Thus although one side is always fine, the other suffers from the artifacts.</p>
						
						<figure>
							<img src="tiled-flow/sawtooth.png" width="450" height="150">
							<figcaption>Sawtooth waves are both 0 and 1 at grid lines.</figcaption>
						</figure>
						
						<p>To solve this problem, we have to overlap the cells. That way we can alternate between them and use one to hide the artifacts of the other. First, halve the offset of the second cell. It's most convenient to do this inside <code>FlowCell</code>, so we can keep using whole numbers for the offset argument. The shader compiler will get rid of the extra calculations away.</p>
						
						<pre>		float3 FlowCell (float2 uv, float2 offset, float time) {
		    <ins>offset *= 0.5;</ins>
			&hellip;
		}</pre>
						
						<figure>
							<img src="tiled-flow/overlapping-cells.jpg" width="360" height="160">
							<figcaption>Overlapping cells.</figcaption>
						</figure>
						
						<p>The horizontal cells are now overlapping, occurring at twice the frequency than the tiles that we actually use. Next, we have to correctly blend between the cells again. This is done by replacing `t` with `|2t-1|`, turning it into a triangle wave that is zero on both sides of a tile and 1 in the middle.</p>
						
						<figure>
							<img src="tiled-flow/triangle-wave.png" width="450" height="150">
							<figcaption>Triangle waves always have the same value at grid lines, either 0 or 1.</figcaption>
						</figure>
						
						<p>The result of this change is that the weight of A is now zero on both sides of each tile. It is at full strength halfway. And it's the other way around for B, which has zero weight in the middle of each tile. And because we offset B by only half a tile now, that's exactly where its artifact line would've shown up.</p>
						
						<pre>			float t = <ins>abs(2 *</ins> frac(uv.x * _GridResolution) <ins>- 1)</ins>;
			float wA = 1 - t;
			float wB = t;</pre>
						
						<figure>
							<img src="tiled-flow/blended-cells.jpg" width="360" height="160">
							<figcaption>Cells blended horizontally without artifacts.</figcaption>
						</figure>
						
						<p>Now that we can blend without artifacts, let's also do this vertically. Add cells C and D, both offset by one step in the V dimension relative to A and B.</p>
						
						<pre>			float3 dhA = FlowCell(uv, float2(0, 0), time);
			float3 dhB = FlowCell(uv, float2(1, 0), time);
			<ins>float3 dhC = FlowCell(uv, float2(0, 1), time);</ins>
			<ins>float3 dhD = FlowCell(uv, float2(1, 1), time);</ins>

			float t = abs(2 * frac(uv.x * _GridResolution) - 1);
			float wA = 1 - t;
			float wB = t;
			<ins>float wC = 1 - t;</ins>
			<ins>float wD = t;</ins>

			float3 dh = dhA * wA + dhB * wB <ins>+ dhC * wC + dhD * wD</ins>;</pre>
						
						<p>The weights of A and B must now be multiplied by `1-t` in the V dimension, and by `t` for C and D. Each dimension gets its own `t` value, which we can do by changing it to <code>float2</code> and deriving it from both UV coordinates.</p>
						
						<pre>			<ins>float2</ins> t = abs(2 * frac(<ins>uv</ins> * _GridResolution) - 1);
			float wA = <ins>(1 - t.x) * (1 - t.y)</ins>;
			float wB = <ins>t.x * (1 - t.y)</ins>;
			float wC = <ins>(1 - t.x) * t.y</ins>;
			float wD = <ins>t.x * t.y</ins>;</pre>
						
						<figure>
							<img src="tiled-flow/blended-cells-both-dimensions.jpg" width="360" height="160">
							<figcaption>Blending in both dimensions.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Sampling At Cell Centers</h3>
						
						<p>Currently, we're sampling the flow at the bottom left corner of each tile. But that doesn't line up with the way that we blend the cells. The result is a misaligned blend between flow data, which makes the grid more obvious than it should be. Instead, we should sample the flow at the center of each cell, where its weight is 1. In the case of cell A, that's in the middle of each tile, so its sample point needs to be shifted there. The same is true for B, at least in the V dimension. Because B is already offset by half a tile in the U dimension, it doesn't need a horizontal shift. And C and D are fine in the V dimension, but C needs a horizontal shift.</p>
						
						<p>In general, we have to shift half a tile when there isn't an offset, and vice versa. We can conveniently do this in <code>FlowCell</code> by taking 1 minus the unscaled offset and halving that. Then add that to the UV coordinates after flooring, before the division.</p>
						
						<pre>		    <ins>float2 shift = 1 - offset;</ins>
		    <ins>shift *= 0.5;</ins>
		    offset *= 0.5;
			float2 uvTiled =
				<ins>(</ins>floor(uv * _GridResolution + offset) <ins>+ shift)</ins> / _GridResolution;</pre>
						
						<figure>
							<img src="tiled-flow/centered-flow.jpg" width="360" height="160">
							<figcaption>Centered flow samples.</figcaption>
						</figure>
						
						<p>We're now correctly using the flow data, but how accurate we are depends on the grid resolution. The higher the resolution, the smoother the flow curves. But we cannot make the resolution too high, because that doesn't allow room for the ripple pattern to show up.</p>
						
						<figure>
							<img src="tiled-flow/tiling-1-grid-30.jpg" width="360" height="160">
							<figcaption>Tiling 1, grid resolution 30.</figcaption>
						</figure>
						
						<p>Increasing the tiling allows the resolution to go higher, but also makes the ripples smaller. You have to find a balance that works best for each situation. For example, a tiling of 5 combined with a grid resolution of 30 works well for the images in this tutorial. That makes it possible to see the flow, without the ripples becoming to small to see.</p>
						
						<figure>
							<img alt="10" src="tiled-flow/tiling-5-grid-10.jpg" width="360" height="160">
							<img alt="30" src="tiled-flow/tiling-5-grid-30.jpg" width="360" height="160">
							<figcaption>Tiling 5, grid resolution 10 and 30.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>Scaling the Waves</h3>
						
						<p>Like we did for the distortion effect, let's also scale the strength of the derivative and height data, both using a constant factor and modulated by the flow strength.</p>
						
						<pre>		float3 FlowCell (float2 uv, float2 offset, float time) {
		    &hellip;
			dh.xy = mul(derivRotation, dh.xy);
			<ins>dh *= flow.z * _HeightScaleModulated + _HeightScale;</ins>
			return dh;
		}</pre>
						
						<figure>
							<img src="tiled-flow/scaled-height.jpg" width="360" height="160">
							<figcaption>Scaled by flow speed.</figcaption>
						</figure>
						
						<p>Because of our spatial approach, it is now also possible to scale the pattern size based on the flow speed as well. Rapidly flowing streams have many small ripples, while slower regions have fewer larger ripples. We can support this by factoring the flow speed into the tiling.</p>
						
						<pre>			flow.z *= _FlowStrength;
			<ins>float tiling = flow.z * _Tiling;</ins>
			float2 uvFlow = DirectionalFlowUV(
				uv, flow, <ins>tiling</ins>, time,
				derivRotation
			);</pre>
						
						<figure>
							<img src="tiled-flow/scaled-pattern.jpg" width="360" height="160">
							<figcaption>Ripple pattern scaled by flow speed.</figcaption>
						</figure>
						
						<p>This degenerates when the flow speed is very low&mdash;which is the case because we use a flow strength of 0.1&mdash;because the pattern becomes far too large. Only a very small region of the ripple pattern fits in each cell.</p>
						
						<p>We can still scale the pattern, just in moderation. We can do this the same way that we scale the height, by making a property both for constant and modulated tiling. I'll set the constant tiling to 3 and the modulated tiling to 50. The modulate tiling has be to so high to compensate for the low flow speed.</p>
						
						<pre>		_Tiling ("Tiling, Constant", Float) = 1
		<ins>_TilingModulated ("Tiling, Modulated", Float) = 1</ins></pre>
						
						<figure>
							<img src="tiled-flow/tiling.png" width="320" height="38">
							<figcaption>Constant tiling 3 and modulated tiling 50.</figcaption>
						</figure>
						
						<p>The final tiling becomes equal to the flow speed multiplied with the modulated tiling, plus the original constant tiling.</p>
						
						<pre>		float _Tiling, <ins>_TilingModulated,</ins> _GridResolution, _Speed, _FlowStrength;
		float _HeightScale, _HeightScaleModulated;

		&hellip;

		float3 FlowCell (float2 uv, float2 offset, float time) {
		    &hellip;
			float tiling = flow.z * <ins>_TilingModulated +</ins> _Tiling;
			&hellip;
		}</pre>
						
						<figure>
							<div class="vid" style="width: 360px; height:160px;"><iframe src='https://gfycat.com/ifr/SociableSkeletalBlackbuck'></iframe></div>
							<figcaption>Constant and modulated tiling.</figcaption>
						</figure>
					</section>
					
					<a href="tiled-flow/tiled-flow.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Hiding Artifacts</h2>
					
					<p>Although our directional flow shader is now functionally complete, there are unfortunately still some artifacts. While they're not always obvious, they still warrant attention.</p>
					
					<p>The most immediately obvious artifacts are visible tiling where the flow direction changes fairly quickly. This is quite pronounced for our flow map, because it has a lot of twists and turns. This can be solved by increasing the grid resolution, but will also require an increase of the tiling.</p>
					
					<figure>
						<img src="hiding-artifacts/increased-resolution.jpg" width="320" height="38">
						<figcaption>Increased grid resolution and tiling.</figcaption>
					</figure>
					
					<section>
						<h3>Nearly Uniform Flow</h3>
						
						<p>The really problematic artifacts appear in regions where there isn't much change in the flow. If the flow is truly uniform, then the tiling of the pattern cannot be hidden. To see this, force tiled UV coordinates to zero, so the same flow data is used everywhere.</p>
						
						<pre>			float3 flow = tex2D(_FlowMap, uvTiled <ins>* 0</ins>).rgb;</pre>
						
						<figure>
							<img src="hiding-artifacts/uniform.jpg" width="320" height="38">
							<figcaption>uniform flow.</figcaption>
						</figure>
							
						<p>The visible tiling can be removed by simply using a larger ripple pattern, but that has its limits. The only way to truly prevent this is by ensuring there is at least some variety, maybe by adding noise when generating a flow map. This is a fine approach, because liquids rarely flow perfectly uniform. There are usually hidden or submerged factors that influence the flow in some way. So let's consider a mostly uniform flow, like a slowly curving current. We can see such a situation by temporarily scaling the flow sampling by 0.1.</p>
						
						<pre>			float3 flow = tex2D(_FlowMap, uvTiled * <ins>0.1</ins>).rgb;</pre>
						
						<p>It is possible to spot pulsing patterns that match the flow during animation, but those are hard to notice with a quick glance. A more obvious manifestation of this problem shows up when setting the speed to zero. Suddenly, we can see streaks appear, caused by nearly the same region of the ripple pattern repeating with a slight offset, rotation, and scale.</p>
						
						<figure>
							<img src="hiding-artifacts/flow-map-scaled.jpg" width="320" height="38">
							<figcaption>Scaled flow map.</figcaption>
						</figure>
						
						<p>Compression of the flow map and texture filtering can help mask these artifacts somewhat. When using an uncompressed flow map, the artifacts change and can become even more pronounced.</p>
						
						<figure>
							<img src="hiding-artifacts/flow-map-uncompressed.jpg" width="320" height="38">
							<figcaption>Flow map without compression.</figcaption>
						</figure>
						
						<p>These problems are causes by quick pattern repetition. While decreasing the grid resolution helps to reduce this, it also makes the flow less smooth. Fortunately, we can obfuscate the repetition by jittering the UV coordinates when sampling the pattern per cell. Simply adding the cell offset suffices.</p>
						
						<pre>			float2 uvFlow = DirectionalFlowUV(
				uv <ins>+ offset</ins>, flow, tiling, time,
				derivRotation
			);</pre>
						
						<figure>
							<img src="hiding-artifacts/pattern-offset.jpg" width="320" height="38">
							<figcaption>With a pattern offset.</figcaption>
						</figure>
						
						<p>As this increases the difference between cell patterns, it also adds more apparent animation. This makes the ripples more animated.</p>
					</section>
					
					<section>
						<h3>Spotting the Grid</h3>
						
						<p>There is another kind of artifact, caused by blending between cells. If the difference in direction or speed is large enough, the tiling can become obvious. For example, set the grid resolution to 3 while we're still zoomed in on the flow map.</p>
						
						<figure>
							<img src="hiding-artifacts/grid-resolution-3.jpg" width="320" height="38">
							<figcaption>Grid resolution 3.</figcaption>
						</figure>
						
						<p>There are now clearly distinguishable tiles that are darker or lighter. This is caused by the different flow speeds per tile. But that's not the most problematic part. We can eliminate this by using a black color.</p>
						
						<figure>
							<img src="hiding-artifacts/black.jpg" width="320" height="38">
							<figcaption>Black color.</figcaption>
						</figure>
						
						<p>It is still possible to see the grid, when you pay attention to the specular reflections. That's because regions where cells are blended are flatter than those that are dominated by a single cell. As a result, specular reflections vary in a grid pattern. As this pattern is static, it stands out even more when the ripples are animated.</p>
						
						<figure>
							<div class="vid" style="width: 360px; height:160px;"><iframe src='https://gfycat.com/ifr/RewardingLastFinnishspitz'></iframe></div>
							<figcaption>Watch the highlights.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Mixing Grids</h3>
						
						<p>There is no easy way to get rid of the specular artifacts, like we couldn't completely eliminate the phase blend artifacts of the distortion effect, just obfuscate it with noise. In this case, perturbing the grid with noise won't make it less obvious. Also, smoothing the blend function won't eliminate them, in fact any change will make them more obvious.</p>
						
						<p>The only way to eliminate the artifacts is to get rid of the transition between uniform and mixed regions, but that is impossible. The next best thing is to smudge the difference.</p>
						
						<p>What we can do is sample the entire grid twice. If we offset the second grid by a quarter tile, then its sharpest regions correspond to the other grid's blurriest areas, and vice versa. If we then average those two grids, then we end up with a much more uniform blend.</p>
						
						<p>Move the code that samples and combines the four cells to a new <code>FlowGrid</code> function.</p>
						
						<pre>		<ins>float3 FlowGrid (float2 uv, float time) {</ins>
		    float3 dhA = FlowCell(uv, float2(0, 0), time);
			float3 dhB = FlowCell(uv, float2(1, 0), time);
			float3 dhC = FlowCell(uv, float2(0, 1), time);
			float3 dhD = FlowCell(uv, float2(1, 1), time);

			float2 t = abs(2 * frac(uv * _GridResolution) - 1);
			float wA = (1 - t.x) * (1 - t.y);
			float wB = t.x * (1 - t.y);
			float wC = (1 - t.x) * t.y;
			float wD = t.x * t.y;

			<ins>return</ins> dhA * wA + dhB * wB + dhC * wC + dhD * wD;
		<ins>}</ins>

		void surf (Input IN, inout SurfaceOutputStandard o) {
			float time = _Time.y * _Speed;
			float2 uv = IN.uv_MainTex;
			<del>//float3 dhA = FlowCell(uv, float2(0, 0), time);</del>
			<del>//&hellip;</del>
			<del>//float3 dh = dhA * wA + dhB * wB + dhC * wC + dhD * wD;</del>
			<ins>float3 dh = FlowGrid(uv, time);</ins>
			fixed4 c = dh.z * dh.z * _Color;
			&hellip;
		}</pre>
						
						<p>We're now going to sample two grids, just like we sampled two phases for the distortion effect. Again, we can use a boolean parameter to indicate whether we want variant A or variant B. Then sample both and average them.</p>
						
						<pre>		float3 FlowGrid (float2 uv, float time<ins>, bool gridB</ins>) {
		    &hellip;
		}

		void surf (Input IN, inout SurfaceOutputStandard o) {
			&hellip;
			float3 dh = FlowGrid(uv, time<ins>, false</ins>);
			<ins>dh = (dh + FlowGrid(uv, time, true)) * 0.5;</ins>
			&hellip;
		}</pre>
						
						<p>In case of variant B, we have to shift the weight function. Add a quarter after scaling, before taking the fractional part.</p>
						
						<pre>			float2 t = <ins>uv * _GridResolution</ins>;
			<ins>if (gridB) {</ins>
			    <ins>t += 0.25;</ins>
			<ins>}</ins>
			t = abs(2 * frac(<ins>t</ins>) - 1);</pre>
						
						<p>We also have to tell <code>FlowCell</code> which variant we need. The alternative grid has to be offset by a quarter, and the sample shift has to be offset in the other direction to compensate.</p>
						
						<pre>		float3 FlowCell (float2 uv, float2 offset, float time<ins>, float gridB</ins>) {
		    float2 shift = 1 - offset;
		    shift *= 0.5;
		    offset *= 0.5;
		    <ins>if (gridB) {</ins>
		        <ins>offset += 0.25;</ins>
		        <ins>shift -= 0.25;</ins>
		    <ins>}</ins>
			&hellip;
		}
		
		float3 FlowGrid (float2 uv, float time, bool gridB) {
		    float3 dhA = FlowCell(uv, float2(0, 0), time<ins>, gridB</ins>);
			float3 dhB = FlowCell(uv, float2(1, 0), time<ins>, gridB</ins>);
			float3 dhC = FlowCell(uv, float2(0, 1), time<ins>, gridB</ins>);
			float3 dhD = FlowCell(uv, float2(1, 1), time<ins>, gridB</ins>);
			&hellip;
		}</pre>
						
						<figure>
							<div class="vid" style="width: 360px; height:160px;"><iframe src='https://gfycat.com/ifr/SeveralBlondBeardeddragon'></iframe></div>
							<figcaption>Obfuscated Grid.</figcaption>
						</figure>
						
						<p>This doesn't entirely eliminate the problem, but makes it a lot less obvious.</p>
					</section>
					
					<section>
						<h3>Optional Mixing</h3>
						
						<p>Combining two grids is a lot more work than just using a single one. If the grid isn't obvious&mdash;for example because there aren't many specular reflections&mdash;then you might get away with a single grid. So let's make dual grids optional. This also makes it easier to compare both approaches. We'll make this possible by adding a toggle to our shader. This is an integer property with the <code>Toggle</code> attribute. This attribute requires a keyword as an argument, for which we'll use <code>_DUAL_GRID</code>.</p>
						
						<pre>		[NoScaleOffset] _FlowMap ("Flow (RG)", 2D) = "black" {}
		<ins>[Toggle(_DUAL_GRID)] _DualGrid ("Dual Grid", Int) = 0</ins>
		_Tiling ("Tiling, Constant", Float) = 1</pre>
						
						<figure>
							<img src="hiding-artifacts/dual-grid-toggle.png" width="320" height="112">
							<figcaption>Dual grid enabled.</figcaption>
						</figure>
						
						<p>The integer portion of the property is not used by the shader, only the keyword matters. When the property is checked via the inspector, that keyword is defined, otherwise it isn't.</p>
						
						<p>Add the <code>#pragma shader_feature _DUAL_GRID</code> statement to the shader, directly below the <code>#pragma target 3.0</code> one. This instructs Unity to compile two variants of our shader. One with and one without the keyword enabled. Which one gets used depends on whether the material has the property checked.</p>
						
						<pre>		#pragma target 3.0

		<ins>#pragma shader_feature _DUAL_GRID</ins>

		#include "Flow.cginc"</pre>
						
						<p>The line of code that samples the second grid and averages both of them now has to only be included when the keyword is defined. That's done be enclosing it between pre-processor <code>#if</code> and <code>#endif</code> directives. The <code>#if</code> is followed by <code>defined(_DUAL_GRID)</code>, which checks whether the keyword is defined. Only then will the code be included. This is a pre-processing step of the compilation process. One shader variant has that line of code in it, the other doesn't.</p>
						
						<pre>			float3 dh = FlowGrid(uv, time, false);
			<ins>#if defined(_DUAL_GRID)</ins>
				dh = (dh + FlowGrid(uv, time, true)) * 0.5;
			<ins>#endif</ins>
			fixed4 c = dh.z * dh.z * _Color;</pre>
						
						<figure>
							<div class="vid" style="width: 360px; height:160px;"><iframe src='https://gfycat.com/ifr/CraftySkinnyHarlequinbug'></iframe></div>
							<figcaption>Toggling dual grid mode.</figcaption>
						</figure>
						
						<p>Finally, remove the temporary scaling of the flow map.</p>
						
						<pre>			float3 flow = tex2D(_FlowMap, <ins>uvTiled</ins>).rgb;</pre>
						
						<p>Dual grids also gives us a little more wiggle room when playing with the tiling scale.</p>
						
						<figure>
							<img alt="material" src="hiding-artifacts/material-settings.png" width="320" height="350"><br>
							<div class="vid" style="width: 360px; height:160px;"><iframe src='https://gfycat.com/ifr/InfatuatedScratchyHoneybee'></iframe></div>
							<figcaption>Tweaked and colored flow.</figcaption>
						</figure>
						
						<p>The next tutorial is <a href="../waves/index.html">Waves</a>.</p>
					</section>
					
					<a href="hiding-artifacts/hiding-artifacts.unitypackage" download rel="nofollow">unitypackage</a>
					<a href="Directional-Flow.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>