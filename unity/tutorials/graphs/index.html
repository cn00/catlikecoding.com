<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/basics/building-a-graph/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/basics/building-a-graph/tutorial-image.jpg">
		<meta property="og:title" content="Building a Graph">
		<meta property="og:description" content="A Unity Basics tutorial about using a line of cubes to create an animated graph.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Building a Graph</title>
		<link href="../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../site.webmanifest">
		<link rel="mask-icon" href="../../../safari-pinned-tab.svg" color="#aa0000">
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/basics/building-a-graph/#article",
				"headline": "Building a Graph",
				"alternativeHeadline": "Visualizing Math",
				"datePublished": "2017-11-13",
				"dateModified": "2021-05-18",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Basics tutorial about using a line of cubes to create an animated graph.",
				"image": "https://catlikecoding.com/unity/tutorials/basics/building-a-graph/tutorial-image.jpg",
				"dependencies": "Unity 2020.3.6f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/basics/", "name": "Basics" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				Graph: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../index.html"><img src="../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../index.html">Catlike Coding</a></li>
					<li><a href="../../index.html">Unity</a></li>
					<li><a href="../../tutorials">Tutorials</a></li>
					<li><a href="../basics/index.html">Basics</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Building a Graph</h1>
					<p>Visualizing Math</p>
					<ul>
						<li>Create a prefab.</li>
						<li>Instantiate multiple cubes.</li>
						<li>Show a mathematical function.</li>
						<li>Create a surface shader and shader graph.</li>
						<li>Animate the graph.</li>
					</ul>
				</header>
				
				<p>This is the second tutorial in a series about learning the <a href="../basics/index.html">basics</a> of working with Unity. This time we'll use game objects to build a graph, so we can show mathematical formulas. We'll also make the function time-dependent, creating an animating graph.</p>
				
				<p>This tutorial is made with Unity 2020.3.6f1.</p>
				
				<figure>
					<img src="../basics/building-a-graph/tutorial-image.jpg" width="512" height="256">
					<figcaption>Using cubes to show a sine wave.</figcaption>
				</figure>
				
				<section>
					<h2>Creating a Line of Cubes</h2>
					
					<p>A good understanding of mathematics is essential when programming. At its most fundamental level math is the manipulation of symbols that represent numbers. Solving an equation boils down to rewriting one set of symbols so it becomes another&mdash;usually shorter&mdash;set of symbols. The rules of mathematics dictate how this rewriting can be done.</p>
					
					<p>For example, we have the function `f(x)=x+1`. We can substitute a number for its `x` parameter, say 3. That leads to `f(3)=3+1=4`. We provided 3 as an input argument and ended up with 4 as the output. We can say that the function maps 3 to 4. A shorter way to write this would be as an input-output pair, like (3,4). We can create many pairs of the form `(x,f(x))`, for example (5,6) and (8,9) and (1,2) and (6,7). But it is easier to understand the function when we order the pairs by the input number. (1,2) and (2,3) and (3,4) and so on.</p>
					
					<p>The function `f(x)=x+1` is easy to understand. `f(x)=(x-1)^4+5x^3-8x^2+3x` is harder. We could write down a few input-output pairs, but that likely won't give us a good grasp of the mapping it represents. We're going to need many points, close together. That will end up as a sea of numbers, which are hard to parse. Instead, we could interpret the pairs as two-dimensional coordinates of the form `[[x],[f(x)]]`. This is a 2D vector where the top number represents the horizontal coordinate, on the X axis, and the bottom number represents the vertical coordinate, on the Y axis. In other words, `y = f(x)`. We can plot these points on a surface. If we use enough points that are very close together we end up with a line. The result is a graph.</p>
					
					<figure>
						<img src="../basics/building-a-graph/creating-a-line-of-cubes/graph.png" width="400" height="400">
						<figcaption>Graph with `x` between &minus;2 and 2, made with <a href="https://www.desmos.com/calculator/di84egsf7a">Desmos</a>.</figcaption>
					</figure>
					
					<p>Looking at a graph can quickly give us an idea of how a function behaves. It's a handy tool, so let's create one in Unity. We'll start with a new project, as described in the first section of the <a href="../clock/index.html">previous tutorial</a>.</p>
					
					<section>
						<h3>Prefabs</h3>
						
						<p>Graphs are created by placing points at the appropriate coordinates. To do this, we need a 3D visualization of a point. We'll simply use Unity's default cube game object for this. Add one to the scene and name it <em translate="no">Point</em>. Remove its <code>BoxCollider</code> component, as we won't use physics.</p>
						
						<aside>
							<h3>Are cubes the best way to visualize graphs?</h3>
							<div>
								<p>You could also use a particle system or line segments, but individual cubes are the simplest to use.</p>
							</div>
						</aside>
						
						<p>We will be using a custom component to create many instances of this cube and position them correctly. In order to do this we'll turn the cube into a game object template. Drag the cube from the hierarchy window into the project window. This will create a new asset, known as a prefab. It is a pre-fabricated game object that exists in the project, not in a scene.</p>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/prefab-project-one-column.png" width="100" height="70" alt="one column"><br>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/prefab-project-two-column.png" width="360" height="94" alt="two column">
							<figcaption>Point prefab asset, one and two column layout.</figcaption>
						</figure>
						
						<p>The game object that we used to create the prefab still exists in the scene, but is now a prefab instance. It has a blue icon in the hierarchy window and an arrow to its right side. The header of its inspector also indicates that it is a prefab and displays a few more controls. The position and rotation are now displayed with bold text, which indicates that the values of the instance override the prefab's. Any other changes that you make to the instance will also be indicated this way.</p>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/prefab-instance-hierarchy.png" width="277" height="66" alt="hierarchy"><br>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/prefab-instance-inspector.png" width="320" height="267" alt="inspector">
							<figcaption>Point prefab instance.</figcaption>
						</figure>
						
						<p>When selecting the prefab asset its inspector will show its root game object and a big button to open the prefab.</p>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/prefab-inspector.png" width="320" height="366">
							<figcaption>Prefab asset inspector.</figcaption>
						</figure>
						
						<p>Clicking the <em translate="no">Open Prefab</em> button will make the scene window show a scene that contains nothing but the prefab's object hierarchy. You can also get there via the <em translate="no">Open</em> button of an instance, the right arrow next to an instance in the hierarchy window, or by double-clicking the asset in the project window. This is useful when a prefab has a complex hierarchy, but this isn't the case for our simple point prefab.</p>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/prefab-hierarchy.png" width="277" height="45">
							<figcaption>Hierarchy window for our prefab.</figcaption>
						</figure>
						
						<p>You can exit the prefab's scene via the arrow to the left of its name in the hierarchy window.</p>
						
						<aside>
							<h3>Why is the background of the prefab scene uniform dark blue?</h3>
							<div>
								<p>If you open a prefab instance that's part of a scene then the scene window will display its surroundings depending on the <em>Context</em> settings shown at the top of the window. If you open the prefab asset then there is no context. In the case of assets the skybox is disabled by default in the prefab scene, along with some other things. You can configure this via the scene window's toolbar, just like you can for the regular scene window. The skybox can be toggled via the dropdown menu that looks like a stack with a star on top of it. Notice how the scene toolbar settings change when you jump in and out of prefab asset mode.</p>
							</div>
						</aside>
						
						<p>Prefabs are a handy way to configure game objects. If you change the prefab asset all instances of it in any scene are changed in the same way. For example, changing the prefab's scale will also change the scale of the cube that's still in the scene. However, each instance uses its own position and rotation. Also, game object instances can be modified, which overrides the prefab's values. Note that the relationship between prefab and instance is broken while in play mode.</p>
						
						<p>We're going to use a script to create instances of the prefab, which means that we no longer need the prefab instance that is currently in the scene. So delete it, either via <em translate="no">Edit / Delete</em>, the indicated keyboard shortcut, or its context menu in the hierarchy window.</p>
					</section>
					
					<section>
						<h3>Graph Component</h3>
						
						<p>We need a C# script to generate a graph with our point prefab. Create one and name it <code>Graph</code>.</p>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/graph-asset.png" width="110" height="84">
							<figcaption>Graph C# asset in Scripts folder.</figcaption>
						</figure>
						
						<p>We begin with a simple class that extends <code>MonoBehaviour</code> so it can be used as a component for game objects. Give it a serializable field to hold a reference to a prefab for instantiating points, named <code>pointPrefab</code>. We'll need access to the <code>Transform</code> component to position the points, so make that the field's type.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public class Graph : MonoBehaviour {</ins>

	<ins>[SerializeField]</ins>
	<ins>Transform pointPrefab;</ins>
<ins>}</ins></pre>
						
						<p>Add an empty game object to the scene and name it <em translate="no">Graph</em>. Make sure that its position and rotation are zero, and that its scale is 1. Add our <code>Graph</code> component to this object. Then drag our prefab asset onto the <em translate="no">Point Prefab</em> field of the graph. It now holds a reference to the prefab's <code>Transform</code> component.</p>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/graph-with-prefab.png" width="320" height="225">
							<figcaption>Graph game object with reference to prefab.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Instantiating Prefabs</h3>
						
						<p>Instantiating a game object is done via the <code>Object.Instantiate</code> method. This is a publicly available method of Unity's <code>Object</code> type, which <code>Graph</code> indirectly inherited by extending <code>MonoBehaviour</code>. The <code>Instantiate</code> method clones whatever Unity object is passed to it as an argument. In the case of a prefab, it will result in an instance being added to the current scene. Let's do this when our <code>Graph</code> component awakens.</p>
						
						<pre translate="no">public class Graph : MonoBehaviour {

	[SerializeField]
	Transform pointPrefab;
	
	<ins>void Awake () {</ins>
		<ins>Instantiate(pointPrefab);</ins>
	<ins>}</ins>
}</pre>
						
						<aside>
							<h3>What is the full inheritance chain of <code>MonoBehaviour</code>?</h3>
							<div>
								<p><code>MonoBehaviour</code> extends <code>Behaviour</code>, which extends <code>Component</code>, which extends <code>Object</code>.</p>
							</div>
						</aside>
						
						<p>If we enter play mode now a single instance of the <em translate="no">Point</em> prefab will be spawned at the world origin. Its name is the same as the prefab's, with <em translate="no">(Clone)</em> appended to it.</p>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/instantiated-prefab.png" width="240" height="240">
							<figcaption>Instantiated prefab, looking down the Z axis in the scene window.</figcaption>
						</figure>
						
						<aside>
							<h3>Can you have the scene window open while in play mode?</h3>
							<div>
								<p>Yes, but Unity always forces the game window to the foreground when play mode is entered. If the game window shares a panel with a scene window then that scene window will be hidden. But you can switch back to the scene window while still in play mode. Also, you can configure the editor layout so one or more game and scene windows are visible at the same time. Keep in mind that Unity has to render all these windows, so the more you have open the slower things get.</p>
							</div>
						</aside>
						
						<p>To place the point somewhere else we need to adjust the position of the instance. The <code>Instantiate</code> method gives us a reference to whatever it created. Because we gave it a reference to a <code>Transform</code> component, that's what we get in return. Let's keep track of it with a variable.</p>
						
						<pre translate="no">	void Awake () {
		<ins>Transform point =</ins> Instantiate(pointPrefab);
	}</pre>
						
						<p>In the <a href="../clock/index.html">previous tutorial</a> we rotated the clock arms by assigned a quaternion to the <code>localRotation</code> property of the pivot's <code>Transform</code>. Changing the position works the same way, except that we have to assign a 3D vector to the <code>localPosition</code> property instead.</p>
						
						<p>3D vectors are created with the <code>Vector3</code> struct type. For example, let's set the X coordinate of our point to 1, leaving its Y and Z coordinates at zero. <code>Vector3</code> has a <code>right</code> property that gives us such a vector. Use it to set the point's position.</p>
						
						<pre translate="no">		Transform point = Instantiate(pointPrefab);
		<ins>point.localPosition = Vector3.right;</ins></pre>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/one-unit-to-the-right.png" width="340" height="180">
							<figcaption>Cube one unit to the right.</figcaption>
						</figure>
												
						<p>When entering play mode now we still get one cube, just at a slightly different position. Let's instantiate a second one and place it an additional step to the right. This can be done by multiplying the right vector by 2. Repeat the instantiation and positioning, then add the multiplication to the new code.</p>
						
						<pre translate="no">	void Awake () {
		Transform point = Instantiate(pointPrefab);
		point.localPosition = Vector3.right;

		<ins>Transform point = Instantiate(pointPrefab);</ins>
		<ins>point.localPosition = Vector3.right * 2f;</ins>
	}</pre>
						
						<aside>
							<h3>Can we multiply structs and numbers?</h3>
							<div>
								<p>Normally you cannot, but it is possible to define such functionality. This is done by creating a method with a special syntax, so it can be invoked as if it were a multiplication. In this case, what appears to be a simple multiplication is actually a method invocation, something like <code>Vector3.Multiply(Vector3.right, 2f)</code> The result is a vector equal to the <code>right</code> vector with all its components doubled.</p>
								
								<p>Being able to use methods as if they were simple operations makes writing code faster and easier to read. It is not essential, but nice to have, just like being able to implicitly use namespaces. Such convenient syntax is known as syntactic sugar.</p>
								
								<p>Having said that, methods should only be used as operators if they strictly match the original meaning of that operator. In the case of vectors some mathematical operators are well-defined, so it's fine for those.</p>
							</div>
						</aside>
						
						<p>This code will produce a compiler error, because we attempt to define the <code>point</code> variable twice. If we want to use another variable we have to give it a different name. Alternatively, we reuse the variable that we already have. We don't need to hold on to a reference to the first point once we're done with it, so assign the new point to the same variable.</p>
						
						<pre translate="no">		Transform point = Instantiate(pointPrefab);
		point.localPosition = Vector3.right;

<del>//		Transform point = Instantiate(pointPrefab);</del>
		<ins>point = Instantiate(pointPrefab);</ins>
		point.localPosition = Vector3.right * 2f;</pre>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/two-instances.png" width="310" height="112">
							<figcaption>Two instances, with X coordinates 1 and 2.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Code Loops</h3>
						
						<p>Let's create more points, until we have ten. We could repeat the same code eight more times, but that would be very inefficient programming. Ideally, we only write the code for one point and instruct the program to execute it multiple times, with slight variation.</p>
						
						<p>The <code>while</code> statement can be used to cause a block of code to repeat. Apply it to the first two statements of our method and remove the other statements.</p>
						
						<pre translate="no">	void Awake () {
		<ins>while {</ins>
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right;
		<ins>}</ins>
<del>//		point = Instantiate(pointPrefab);</del>
<del>//		point.localPosition = Vector3.right * 2f;</del>
	}</pre>
						
						<p>The <code>while</code> keyword must be followed by an expression within round brackets. The code block following <code>while</code> will only get executed if the expression evaluates as true. Afterwards, the program will loop back to the <code>while</code> statement. If at that point the expression again evaluates as true, the code block will be executed again. This repeats until the expression evaluates as false. Then the program skips the code block following the <code>while</code> statement and continues below it.</p>
						
						<p>So we have to add an expression after <code>while</code>. We must be careful to make sure that the loop doesn't repeat forever. Infinite loops cause programs to get stuck, requiring manual termination by the user. The safest possible expression that compiles is simply <code>false</code>.</p>
						
						<pre translate="no">		while <ins>(false)</ins> {
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right;
		}</pre>
						
						<aside>
							<h3>Can we define <code>point</code> inside the loop?</h3>
							<div>
								<p>Yes. Although the code gets repeated, we've defined the variable only once. It gets reused each iteration of the loop, like we manually did earlier.</p>
								
								<p>You could also define <code>point</code> before the loop. That allows you to use the variable outside the loop as well. Otherwise, its scope is limited to the block of the <code>while</code> loop.</p>
							</div>
						</aside>
						
						<p>Limiting the loop can be done by keeping track of how many times we've repeated the code. We can use an integer variable to keep track of this. It's type is <code>int</code>. It will contain the iteration number of the loop, so let's name it <code>i</code>. It's initial value is zero. To be able to use it in the <code>while</code> expression it must be defined above it.</p>
						
						
						
						<pre translate="no">		<ins>int i = 0;</ins>
		while (false) {
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right;
		}</pre>
						
						<p>Each iteration, increase the number by one, by setting it to itself plus 1.</p>
						
						<pre translate="no">		int i = 0;
		while (false) {
			<ins>i = i + 1;</ins>
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right;
		}</pre>
						
						<p>Now <code>i</code> becomes 1 at the start of the first iteration, 2 at the start of the second iteration, and so on. But the <code>while</code> expression is evaluated before each iteration. So right before the first iteration <code>i</code> is zero, it's 1 before the second, and so on. So after the tenth iteration <code>i</code> is ten. At this point we want to stop the loop, so its expression should evaluate as false. In other words, we should continue as long as <code>i</code> is less than ten. Mathematically, that's expressed as `i &lt; 10`. It is written the same in code, with the <code>&lt;</code> less-than operator.</p>
						
						<pre translate="no">		int i = 0;
		while (<ins>i &lt; 10</ins>) {
			i = i + 1;
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right;
		}</pre>
						
						<p>Now we'll get ten cubes after entering play mode. But they all end up at the same position. To put them in a row along the X axis multiply the <code>right</code> vector by <code>i</code>.</p>
						
						<pre translate="no">			point.localPosition = Vector3.right <ins>* i</ins>;</pre>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/ten-cubes.png" width="384" height="80">
							<figcaption>Ten cubes in a row along the X axis.</figcaption>
						</figure>
						
						<p>Note that currently the first cube ends up with an X coordinate of 1 and the last cube ends up with 10. Let's change this so we begin at zero, positioning the first cube at the origin. We can shift all points one unit to the left by multiplying <code>right</code> by <code>(i - 1)</code> instead of <code>i</code>. However, we could skip that extra subtraction by increasing <code>i</code> at the end of the block, after the multiplication, instead of at the beginning.</p>
						
						<pre translate="no">		while (i &lt; 10) {
<del>//			i = i + 1;</del>
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right * i;
			<ins>i = i + 1;</ins>
		}</pre>
					</section>
					
					<section>
						<h3>Concise Syntax</h3>
						
						<p>Because looping a certain amount of times is so common, it is convenient to keep the code for a loop concise. Some syntactic sugar can help us with that.</p>
						
						<p>First, let's consider incrementing the iteration number. When an operation of the form <code>x = x * y</code> is performed, it can be shortened to <code>x *= y</code>. This works for all operators that act on two operands.</p>
						
						<pre translate="no"><del>//			i = i + 1;</del>
			<ins>i += 1;</ins></pre>
						
						<p>Going even further, when incrementing or decrementing a number by 1, this can be shortened to <code>++x</code> or <code>--x</code>.</p>
						
						<pre translate="no"><del>//			i += 1;</del>
			<ins>++i;</ins></pre>
						
						<p>One property of assignment statements is that they can also be used as expressions. This means that you could write something like <code>y = (x += 3)</code>. That would increase <code>x</code> by three and assign the result of that to <code>y</code> as well. This suggests that we could increment <code>i</code> inside the <code>while</code> expression, shortening the code block.</p>
						
						<pre translate="no">		while (<ins>++</ins>i &lt; 10) {
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right * i;
<del>//			++i;</del>
		}</pre>
						
						<p>However, now we're incrementing <code>i</code> before the comparison, instead of afterwards, which would lead to one less iteration. Specifically for situations like this, the increment and decrement operators can also be placed after a variable, instead of before it. The result of that expression is the original value, before it was changed.</p>
						
						<pre translate="no"><del>//		while (++i &lt; 10) {</del>
		<ins>while (i++ &lt; 10) {</ins>
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right * i;
		}</pre>
						
						<p>Although the <code>while</code> statement works for all kinds of loops, there is an alternative syntax particularly suited for iterating over ranges. It is the <code>for</code> loop. It works like <code>while</code>, except that both the iterator variable declaration and its comparison are contained within round brackets, separated by a semicolon.</p>
						
						<pre translate="no"><del>//		int i = 0;</del>
<del>//		while (i++ &lt; 10) {</del>
		<ins>for (int i = 0; i++ &lt; 10) {</ins>
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right * i;
		}</pre>
						
						<p>That would produce a compiler error, because there is also a third part for incrementing the iterator, after another semicolon, keeping it separate from the comparison. This part gets performed at the end of each iteration.</p>
						
						<pre translate="no"><del>//		for (int i = 0; i++ &lt; 10) {</del>
		<ins>for (int i = 0; i &lt; 10; i++) {</ins>
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right * i;
		}</pre>
						
						<aside>
							<h3>Why use <code>i++</code> and not <code>++i</code> in the <code>for</code> loop?</h3>
							<div>
								<p>As the increment expression is not used for anything else, it doesn't matter which version we use. We could've also used <code>i += 1</code> or <code>i = i + 1</code>.</p>
								
								<p>The classical for loop has the form <code>for (int i = 0; i &lt; someLimit; i++)</code>. You will encounter that code fragment in a lot of programs and scripts.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Changing the Domain</h3>
						
						<p>Currently, our points are given X coordinates 0 through 9. This isn't a convenient range when working with functions. Often, a range of 0&ndash;1 is used for X. Or when working with functions that are centered around zero, a range of &minus;1&ndash;1. Let's reposition our points accordingly.</p>
						
						<p>Positioning ten cubes along a line segment two units long will cause them to overlap. To prevent this, we're going to reduce their scale. Each cube has size 1 in each dimension by default, so to make them fit we have to reduce their scale to `2/10 = 1/5`. We can do this by setting each point's local scale to the <code>Vector3.one</code> property divided by five. Division is done with the <code>/</code> slash operator.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; 10; i++) {
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right * i;
			<ins>point.localScale = Vector3.one / 5f;</ins>
		}</pre>
						
						<p>You can get a better view of the relative position of the cubes by switching the scene window to orthographic projection, which ignores perspective. Clicking the label under the axis widget at the top right of the scene window toggles between orthographic and perspective mode. The white cubes are also easier to see if you turn off the skybox via the scene window toolbar.</p>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/small-cubes.png" width="364" height="106">
							<figcaption>Small cubes, seen in orthographic scene window without skybox.</figcaption>
						</figure>
						
						<p>To bring the cubes back together again, divide their positions by five as well.</p>
						
						<pre translate="no">			point.localPosition = Vector3.right * i <ins>/ 5f</ins>;</pre>
						
						<p>This makes them cover the 0&ndash;2 range. To turn that into the &minus;1&ndash;1 range, subtract 1 before scaling the vector. Use round brackets to indicate the operation order of the math expression.</p>
						
						<pre translate="no">			point.localPosition = Vector3.right * <ins>(</ins>i / 5f <ins>- 1f)</ins>;</pre>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/from-1-to-08.png" width="260" height="64">
							<figcaption>From &minus;1 to 0.8.</figcaption>
						</figure>
						
						<p>Now the first cube has X coordinate &minus;1, while the last has X coordinate 0.8. However, the cube size is 0.2. As the cube is centered on its position, the left side of the first cube is at &minus;1.1, while the right side of the last cube is at 0.9. To neatly fill the &minus;1&ndash;1 range with our cubes we have to shift them half a cube to the right. This can be done by adding 0.5 to <code>i</code> before dividing it.</p>
						
						<pre translate="no">			point.localPosition = Vector3.right * (<ins>(</ins>i <ins>+ 0.5f)</ins> / 5f - 1f);</pre>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/from-1-to-1.png" width="260" height="64">
							<figcaption>Filling the &minus;1&ndash;1 range.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Hoisting the Vectors out of the Loop</h3>
						
						<p>Although all the cubes have the same scale we calculate it again in every iteration of the loop. We don't have to do this, the scale is invariant. Instead, we could calculate it once before the loop, store it in a <code>scale</code> variable, and use that in the loop.</p>
						
						<pre translate="no">	void Awake () {
		<ins>var scale = Vector3.one / 5f;</ins>
		for (int i = 0; i &lt; 10; i++) {
			Transform point = Instantiate(pointPrefab);
			point.localPosition = Vector3.right * ((i + 0.5f) / 5f - 1f);
			point.localScale = <ins>scale</ins>;
		}
	}</pre>
						
						<p>We could also define a variable for the position before the loop. As we're creating a line along the X axis, we only need to adjust the X coordinate of the position inside the loop. So we no longer have to multiply by <code>Vector3.right</code>.</p>
						
						<pre translate="no">		<ins>Vector3 position;</ins>
		var scale = Vector3.one / 5f;
		for (int i = 0; i &lt; 10; i++) {
			Transform point = Instantiate(pointPrefab);
			<del>//point.localPosition = Vector3.right * ((i + 0.5f) / 5f - 1f);</del>
			<ins>position.x = (i + 0.5f) / 5f - 1f;</ins>
			<ins>point.localPosition = position</ins>;
			point.localScale = scale;
		}</pre>
						
						<aside>
							<h3>Can we change a vector's components individually?</h3>
							<div>
								<p>The <code>Vector3</code> struct has three floating-point fields: <code>x</code>, <code>y</code>, and <code>z</code>. These fields are public, so we can change them.</p>
								
								<p>Because structs behave like simple values, the idea is that they should be immutable. Once constructed, they should't change. If you want to use a different value, assign a new struct to the field or variable, like we do with numbers. If we say that `x = 3` and later that `x = 5`, we've assigned a different number to `x`. We didn't modify the number 3 itself to become a 5. However, the vector types of Unity are mutable. This is done both for convenience and performance, because individual vector components are often manipulated independently.</p>
								
								<p>To get an idea of how to work with mutable vectors, you can consider the use of <code>Vector3</code> a convenient substitute for using three separate <code>float</code> values. You can access them independently, yet also copy and assign them as a group.</p>
							</div>
						</aside>

						
						<p>This will result in a compiler error, complaining about the use of an unassigned variable. This happens because we're assigning <code>position</code> to something while we haven't set its Y and Z coordinates yet. We can fix this by initially setting <code>position</code> to a zero vector, by assigning <code>Vector3.zero</code> to it.</p>
						
						<pre translate="no">
		<del>//Vector3 position;</del>
		<ins>var position = Vector3.zero;</ins>
		var scale = Vector3.one / 5f;</pre>
					</section>
					
					<section>
						<h3>Using X to Define Y</h3>
						
						<p>The idea is that the positions of our cubes are defined as `[[x],[f(x)],[0]]`, so we can use them to display a function. At this point the Y coordinates are always zero, which represents the trivial function `f(x) = 0`. To show a different function we have to determine the Y coordinate inside the loop, instead of before it. Let's begin by making Y equal to X, representing the function `f(x)=x`.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; 10; i++) {
			Transform point = Instantiate(pointPrefab);
			position.x = (i + 0.5f) / 5f - 1f;
			<ins>position.y = position.x;</ins>
			point.localPosition = position;
			point.localScale = scale;
		}</pre>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/y-equals-x.png" width="240" height="240">
							<figcaption>Y equals X.</figcaption>
						</figure>
						
						<p>A slightly less obvious function would be `f(x)=x^2`, which defines a parabola with its minimum at zero.</p>
						
						<pre translate="no">			position.y = position.x <ins>* position.x</ins>;</pre>
						
						<figure>
							<img src="../basics/building-a-graph/creating-a-line-of-cubes/y-equals-x-squared.png" width="240" height="240">
							<figcaption>Y equals X squared.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Creating More Cubes</h2>
					
					<p>Although we have a functional graph at this point, it is ugly. Because we're only using ten cubes the suggested line looks very blocky and discrete. It would look better if we used more and smaller cubes.</p>
					
					<section>
						<h3>Variable Resolution</h3>
						
						<p>Instead of using a fixed amount of cubes we can make it configurable. To make this possible add a serializable integer field for the resolution to <code>Graph</code>. Give it a default of 10, which is what we're using now.</p>
						
						<pre translate="no">	[SerializeField]
	Transform pointPrefab;

	<ins>[SerializeField]</ins>
	<ins>int resolution = 10;</ins></pre>
						
						<figure>
							<img src="../basics/building-a-graph/creating-more-cubes/configurable-resolution.png" width="320" height="92">
							<figcaption>Configurable resolution.</figcaption>
						</figure>
						
						<p>Now we can adjust the graph's resolution by changing it via the inspector. However, not all integers are valid resolutions. At minimum they have to be positive. We can instruct the inspector to enforce a range for our resolution. This is done by attaching the <code>Range</code> attribute to it. We could either put both attributes of <code>resolution</code> between their own square brackets or combine then in a single comma-separated attribute list. Let's do the latter.</p>
						
						<pre translate="no">	[SerializeField<ins>, Range</ins>]
	int resolution = 10;</pre>
						
						<p>The inspector checks whether a field has a <code>Range</code> attribute attached to it. If so, it will constrain the value and also show a slider. However, to do this it needs to know the allowed range. So <code>Range</code> requires two arguments&mdash;like a method&mdash;for the minimum and maximum value. Let's use 10 and 100.</p>
						
						<pre translate="no">	[SerializeField, Range<ins>(10, 100)</ins>]
	int resolution = 10;</pre>
						
						<figure>
							<img src="../basics/building-a-graph/creating-more-cubes/resolution-slider.png" width="320" height="92">
							<figcaption>Resolution slider set to 50.</figcaption>
						</figure>
						
						<aside>
							<h3>Does this guarantee that <code>resolution</code> is constrained to 10&ndash;100?</h3>
							<div>
								<p>All the <code>Range</code> attribute does is instruct the inspector to use a slider with that range. It doesn't affect <code>resolution</code> in any other way. So we could write code to assign it a value that is out of range, but we won't do that.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Variable Instantiation</h3>
						
						<p>To make use of the configured resolution we have to change how many cubes we instantiate. Instead of looping a fixed amount of times in <code>Awake</code>, the amount of iterations is now constrained by <code>resolution</code> instead of always <code>10</code>. So if the resolution is set to 50 we'll get 50 cubes after entering play mode.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; <ins>resolution</ins>; i++) {
			&hellip;
		}</pre>
						
						<aside>
							<h3>What does <code>&hellip;</code> mean?</h3>
							<div>
								<p>It's an indication that I omitted some code that didn't change.</p>
							</div>
						</aside>
						
						<p>We also have to adjust the scale and positions of the cubes to keep them inside the &minus;1&ndash;1 domain. The size of each step that we have to make per iteration is now two divided by the resolution. Store this value in a variable and use it to calculate the scale of the cubes and their X coordinates.</p>
						
						<pre translate="no">		<ins>float step = 2f / resolution;</ins>
		var position = Vector3.zero;
		var scale = Vector3.one <ins>* step</ins>;
		for (int i = 0; i &lt; resolution; i++) {
			Transform point = Instantiate(pointPrefab);
			position.x = (i + 0.5f) <ins>* step</ins> - 1f;
			&hellip;
		}</pre>
						
						<figure>
							<img src="../basics/building-a-graph/creating-more-cubes/resolution-50.png" width="240" height="240">
							<figcaption>Using resolution 50.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Setting the Parent</h3>
						
						<p>After entering play mode with resolution 50 a lot of instantiated cubes show up in the scene, and thus also in the project window.</p>
						
						<figure>
							<img src="../basics/building-a-graph/creating-more-cubes/many-root-objects.png" width="277" height="188">
							<figcaption>Points are root objects.</figcaption>
						</figure>
						
						<p>These points are currently root objects, but it makes sense for them to be children of the graph object. We can set up this relationship after instantiating a point, by invoking the <code>SetParent</code> method of its <code>Transform</code> component, passing it the desired parent <code>Transform</code>. We can get the graph object's <code>Transform</code> component via the <code>transform</code> property of <code>Graph</code>, which it inherited from <code>Component</code>. Do this at the end of the loop's block.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; resolution; i++) {
			&hellip;
			<ins>point.SetParent(transform);</ins>
		}</pre>
						
						<figure>
							<img src="../basics/building-a-graph/creating-more-cubes/child-objects.png" width="277" height="140">
							<figcaption>Points are children of the graph.</figcaption>
						</figure>
						
						<p>When a new parent is set Unity will attempt to keep the object at its original world position, rotation, and scale. We don't need this in our case. We can signal this by passing <code>false</code> as a second argument to <code>SetParent</code>.</p>
						
						<pre translate="no">			point.SetParent(transform<ins>, false</ins>);</pre>
					</section>
				</section>
				
				<section>
					<h2>Coloring the Graph</h2>
					
					<p>A white graph isn't pretty to look at. We could use another solid color, but that isn't very interesting either. It's more interesting to use a point's position to determine its color.</p>
					
					<p>A straightforward way to adjust the color of each cube would be to set the color property of its material. We can do this in the loop. As each cube will get a different color, this means that we would end up with one unique material instance per object. And when we animate the graph later we'd have to adjust these materials all the time as well. While this works, it isn't very efficient. It would be much better if we could use a single material that directly uses the position as its color. Unfortunately, Unity doesn't have such a material. So let's make our own.</p>
					
					<section>
						<h3>Creating a Surface Shader</h3>
						
						<p>The GPU runs shader programs to render 3D objects. Unity's material assets determine which shader is used and allows its properties to be configured. We need to create a custom shader to get the functionality that we want. Create one via <em translate="no">Assets / Create / Shader / Standard Surface Shader</em> and name it <em translate="no">Point Surface</em>.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/point-surface-one-column.png" width="150" height="100" alt="one column"><br>
							<img src="../basics/building-a-graph/coloring-the-graph/point-surface-two-column.png" width="370" height="94" alt="two column">
							<figcaption>Shader grouped with prefab in Point folder, one and two column layout.</figcaption>
						</figure>
						
						<p>We now have a shader asset, which you can open like a script. Our shader file contains code to define a surface shader, which uses different syntax than C#. It contains a surface shader template, but we'll delete everything and start from scratch to create a minimal shader.</p>
						
						<aside>
							<h3>How do surface shaders work?</h3>
							<div>
								<p>Unity provides a framework to quickly generate shaders that perform default lighting calculations, which you can influence by adjusting certain values. Such shaders are known as surface shaders. Unfortunately they only work for the default render pipeline. We'll cover the Universal render pipeline later.</p>
							</div>
						</aside>
						
						<p>Unity has its own syntax for shader assets, which is overall roughly like C# but it's a mix of different languages. It begins with the <code class="shader">Shader</code> keyword followed by a string defining a menu item for the shader. Strings are written inside double quotes. We'll use <em translate="no">Graph/Point Surface</em>. After that comes a code block for the shader's contents.</p>
						
						<pre class="shader" translate="no"><ins>Shader "Graph/Point Surface" {}</ins></pre>
						
						<p>Shaders can have multiple sub-shaders, each defined by the <code class="shader">SubShader</code> keyword followed by a code block. We only need one.</p>
						
						<pre class="shader" translate="no">Shader "Graph/Point Surface" {

	<ins>SubShader {}</ins>
}</pre>
						
						<p>Below the sub-shader we also want to add a fallback to the standard diffuse shader, by writing <code class="shader">FallBack "Diffuse"</code>. </p>
						
						<pre class="shader" translate="no">Shader "Graph/Point Surface" {
	
	SubShader {}
	
	<ins>FallBack "Diffuse"</ins>
}</pre>
						
						<p>The sub-shader of a surface shader needs a code section written in a hybrid of CG and HLSL, two shader languages. This code must be enclosed by the <code class="shader">CGPROGRAM</code> and <code class="shader">ENDCG</code> keywords.</p>
						
						<pre class="shader" translate="no">	SubShader {
		<ins>CGPROGRAM</ins>
		<ins>ENDCG</ins>
	}</pre>
						
						<p>The first needed statement is a compiler directive, known as a pragma. It's written as <code class="shader">#pragma</code> followed by a directive. In this case we need <code class="shader">#pragma surface ConfigureSurface Standard fullforwardshadows</code>, which instructs the shader compiler to generate a surface shader with standard lighting and full support for shadows. <code class="shader">ConfigureSurface</code> refers to a method used to configure the shader, which we'll have to create.</p>
						
						<pre class="shader" translate="no">		CGPROGRAM
		<ins>#pragma surface ConfigureSurface Standard fullforwardshadows</ins>
		ENDCG</pre>
						
						<aside>
							<h3>What does pragma mean?</h3>
							<div>
								<p>The word pragma comes from Greek and refers to an action, or something that needs to be done. It's used in many programming languages to issue special compiler directives.</p>
							</div>
						</aside>
						
						<p>We follow that with the <code>#pragma target 3.0</code> directive, which sets a minimum for the shader's target level and quality.</p>
						
						<pre class="shader" translate="no">		CGPROGRAM
		#pragma surface ConfigureSurface Standard fullforwardshadows
		<ins>#pragma target 3.0</ins>
		ENDCG</pre>
						
						<p>We're going to color our points based on their world position. To make this work in a surface shader we have to define the input structure for our configuration function. It has to be written as <code class="shader">struct Input</code> followed by a code block and then a semicolon. Inside the block we declare a single struct field, specifically <code class="shader">float3 worldPos</code>. It will contain the world position of what gets rendered. The <code class="shader">float3</code> type is the shader equivalent of the <code>Vector3</code> struct.</p>
						
						<pre class="shader" translate="no">		CGPROGRAM
		#pragma surface ConfigureSurface Standard fullforwardshadows
		#pragma target 3.0

		<ins>struct Input {</ins>
			<ins>float3 worldPos;</ins>
		<ins>};</ins>
		ENDCG</pre>
						
						<aside>
							<h3>Does this mean that moving the graph would affect its color?</h3>
							<div>
								<p>Yes. With this approach the coloring will only be correct as long as we leave the <em translate="no">Graph</em> object where it is: at the world origin, with no rotation, and scale 1.</p>
								
								<p>Also note that this position is determined per vertex. In our case, that is for each corner of a cube. The color will be interpolated across the cube's faces. The larger the cubes are, the more obvious this color transition will be.</p>
							</div>
						</aside>
						
						<p>Below that we define our <code class="shader">ConfigureSurface</code> method, although in the case of shaders it's always referred to as a function, not as a method. It is a <code>void</code> function with two parameters. First is an input parameter that has the <code class="shader">Input</code> type that we just defined. The second parameter is the surface configuration data, with the type <code class="shader">SurfaceOutputStandard</code>.</p>
						
						<pre class="shader" translate="no">		struct Input {
			float3 worldPos;
		};

		<ins>void ConfigureSurface (Input input, SurfaceOutputStandard surface) {}</ins></pre>
						
						<p>The second parameter must have the <code class="shader">inout</code> keyword written in front of its type, which indicates that it's both passed to the function and used for the result of the function.</p>
						
						<pre class="shader" translate="no">		void ConfigureSurface (Input input, <ins>inout</ins> SurfaceOutputStandard surface) {}</pre>
						
						<p>Now that we have a functioning shader create a material for it, named <em translate="no">Point Surface</em>. Set it to use our shader, by selecting <em translate="no">Graph / Point Surface</em> via the <em translate="no">Shader</em> dropdown list in the header of its inspector.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/point-surface-material.png" width="320" height="140">
							<figcaption>Point surface material.</figcaption>
						</figure>
						
						<p>The material is currently solid matte black. We can make it look more like the default material by setting <code class="shader">surface.Smoothness</code> to 0.5 in our configuration function. When writing shader code we do not have to add the f suffix to <code class="shader">float</code> values.</p>
						
						<pre class="shader" translate="no">		void ConfigureSurface (Input input, inout SurfaceOutputStandard surface) {
			<ins>surface.Smoothness = 0.5;</ins>
		}</pre>
						
						<p>Now the material is no longer perfectly matte. You can see this in the small material preview in the inspector's header, or in the resizable preview at its bottom.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/material-preview.png" width="320" height="124">
							<figcaption>Material preview with average smoothness.</figcaption>
						</figure>
						
						<p>We can also make smoothness configurable, as if adding a field for it and using that in the function. The default style is to prefix shader configuration options with an underscore and capitalize the next letter, so we'll use <code class="shader">_Smoothness</code>.</p>
						
						<pre class="shader" translate="no">		<ins>float _Smoothness;</ins>

		void ConfigureSurface (Input input, inout SurfaceOutputStandard surface) {
			surface.Smoothness = <ins>_Smoothness</ins>;
		}</pre>
						
						<p>To make this configuration option appear in the editor we have to add a <code class="shader">Properties</code> block at the top of the shader, above the sub-shader. Write <code class="shader">_Smoothness</code> in there, followed by <code class="shader">("Smoothness", Range(0,1)) = 0.5</code>. This gives it the <em translate="no">Smoothness</em> label, exposes it as a slider with the 0&ndash;1 range, and sets its default to 0.5.</p>
						
						<pre class="shader" translate="no">Shader "Graph/Point Surface" {

	<ins>Properties {</ins>
		<ins>_Smoothness ("Smoothness", Range(0,1)) = 0.5</ins>
	<ins>}</ins>
	
	SubShader {
		&hellip;
	}
}</pre>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/configurable-smoothness.png" width="320" height="160">
							<figcaption>Configurable smoothness.</figcaption>
						</figure>
						
						<p>Make our <em translate="no">Cube</em> prefab asset use this material instead of the default one. That will turn the points black.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/black-points.png" width="240" height="240">
							<figcaption>Black points.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Coloring Based on World Position</h3>
						
						<p>To adjust the color of our points we have to modify <code class="shader">surface.Albedo</code>. As both albedo and the world position have three components we can directly use the position for albedo.</p>
						
						<pre translate="no" class="shader">		void ConfigureSurface (Input input, inout SurfaceOutputStandard surface) {
			<ins>surface.Albedo = input.worldPos;</ins>
			surface.Smoothness = _Smoothness;
		}</pre>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/colored-points.png" width="240" height="240">
							<figcaption>Colored points.</figcaption>
						</figure>
						
						<aside>
							<h3>What does albedo mean?</h3>
							<div>
								<p>Albedo means whiteness in Latin. It's a measure of how much light is diffusely reflected by a surface. If albedo isn't fully white then part of the light energy gets absorbed instead of reflected.</p>
							</div>
						</aside>
						
						<p>Now the world X position controls the point's red color component, the Y position controls the green color component, and Z controls blue. But our graph's X domain is &minus;1&ndash;1, and negative color components make no sense. So we have to halve the position and then add &frac12; to make the colors fit the domain. We can do this for all three dimension at once.</p>
						
						<pre translate="no" class="shader">			surface.Albedo = input.worldPos <ins>* 0.5 + 0.5</ins>;</pre>
						
						
						<p>To get a better sense of whether the colors are correct let's change <code>Graph.Awake</code> so we display the function `f(x)=x^3` which makes Y go from &minus;1 to 1 as well.</p>
						
						<pre translate="no">			position.y = position.x * position.x <ins>* position.x</ins>;</pre>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/x-cubed.png" width="240" height="240">
							<figcaption>X cubed, bluish.</figcaption>
						</figure>
						
						<p>The result is bluish because all cube faces have Z coordinates close to zero, which sets their blue color component close to 0.5. We can eliminate blue by only including the red and green channels when setting the albedo. This can be done in shaders by only assigning to <code class="shader">surface.Albedo.rg</code> and only using <code class="shader">input.worldPos.xy</code>. That way the blue component stays zero.</p>
						
						<pre class="shader" translate="no">			surface.Albedo<ins>.rg</ins> = input.worldPos<ins>.xy</ins> * 0.5 + 0.5;</pre>
						
						<p>As red plus green results in yellow this will make the points start near black at the bottom left, turn green as Y initially increases quicker than X, turn yellow as X catches up, turn slightly orange as X increases faster, and finally end near bright yellow at the top right.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/x-cubed-green-yellow.png" width="240" height="240">
							<figcaption>X cubed, from green to yellow.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Universal Render Pipeline</h3>
						
						<p>Besides the default render pipeline Unity also has the Universal and High-Definition render pipelines, URP and HDRP for short. Both render pipelines have different features and limitations. The current default render pipeline is still functional, but its feature set is frozen. In a few years URP will likely become the default. So let's make our graph also work with URP.</p>
						
						<p>If you aren't using URP yet go to the package manager and install the latest <em translate="no">Universal RP</em> package verified for your Unity version. In my case that's 10.4.0.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/urp-installed.png" width="700" height="175">
							<figcaption>URP package installed.</figcaption>
						</figure>
						
						<aside>
							<h3>Where can I find URP in the package manager?</h3>
							<div>
								<p>Make sure that you've set the package filter to <em translate="no">Unity Registry</em> and not <em translate="no">In Project</em>. Then search for <em translate="no">universal</em> or scroll down the list until you find it.</p>
							</div>
						</aside>
						
						<p>This doesn't automatically make Unity use the URP. We first have to create an asset for it, via <em translate="no">Assets / Create / Rendering / Universal Render Pipeline / Pipeline Asset (Forward Renderer)</em>. I named it <em translate="no">URP</em>. This will also automatically create another asset for a renderer, in my case named <em translate="no">URP_Renderer</em>.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/urp-assets-one-column.png" width="150" height="50" alt="one column"><br>
							<img src="../basics/building-a-graph/coloring-the-graph/urp-assets-two-column.png" width="340" height="86" alt="two column">
							<figcaption>URP assets in separate folder, one and two column layout.</figcaption>
						</figure>
						
						<p>Next, go to the <em translate="no">Graphics</em> section of the project settings and assign the URP asset to the <em translate="no">Scriptable Renderer Pipeline Settings</em> field.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/urp-used.png" width="464" height="124">
							<figcaption>Using the URP.</figcaption>
						</figure>
						
						<p>To switch back to the default render pipeline later simply set <em translate="no">Scriptable Renderer Pipeline Settings</em> to <em translate="no">None</em>. This can only be done in the editor, the render pipeline cannot be changed in a built stand-alone app.</p>
						
						<aside>
							<h3>What about HDRP?</h3>
							<div>
								<p>HDRP is a much more complex render pipeline. I won't cover it in my tutorials.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Creating a Shader Graph</h3>
						
						<p>Our current material only works with the default render pipeline, not URP. So when URP is used it is replaced with Unity's error material, which is solid magenta.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/error-material.png" width="240" height="240">
							<figcaption>Cubes have become magenta.</figcaption>
						</figure>
						
						<p>We have to create a separate shader for the URP. We could write one ourselves, but that's currently very hard and likely to break when upgrading to a newer URP version. The best approach is to use Unity's shader graph package to visually design a shader. URP depends on this package so it was automatically installed along with the URP package.</p>
						
						<p>Create a new shader graph via <em translate="no">Assets / Create / Shader / Universal Render Pipeline / Lit Shader Graph</em> and name it <em translate="no">Point URP</em>.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/point-urp-one-column.png" width="150" height="98" alt="one column"><br>
							<img src="../basics/building-a-graph/coloring-the-graph/point-urp-two-column.png" width="490" height="88" alt="two column">
							<figcaption>Point URP shader graph asset, one and two column layout.</figcaption>
						</figure>
						
						<p>The graph can be opened by double-clicking its asset in the project window or by pressing the <em translate="no">Open Shader Editor</em> button in its inspector. This opens a shader graph window for it, which might be cluttered by multiple nodes and panels. These are the blackboard, graph inspector, and main preview panels, which can be resized and can also be hidden via toolbar buttons. There are also two linked nodes: a <em>Vertex</em> node and a <em>Fragment</em> node. These two are used to configure the output of the shader graph.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/default-lit-shader-graph.png" width="530" height="430">
							<figcaption>Default lit shader graph with everything visible.</figcaption>
						</figure>
						
						<p>A shader graph consists of nodes that represent data or operations. Currently, the <em translate="no">Smoothness</em> value of the <em>Fragment</em> node is set to 0.5. To make it a configurable shader property press the plus button on the <em translate="no">Point URP</em> backboard panel, choose <em translate="no">Float</em>, and name the new entry <em>Smoothness</em>. That adds a rounded button to the blackboard that represents the property. Select it and switch the graph inspector to its <em>Node Settings</em> tab to see the configuration of this property.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/smoothness-property-default.png" width="450" height="306">
							<figcaption>Smoothness property with default settings.</figcaption>
						</figure>
						
						<p><em>Reference</em> is the name by which the property is known internally. This corresponds to how we named the property field <em>_Smoothness</em> in our surface shader code, so let's use the same internal name here as well. Then set the default value below it to 0.5. Make sure that its <em translate="no">Exposed</em> toggle option is enabled, as this controls whether materials gets a shader property for it. Finally, to make it appear as a slider change its <em translate="no">Mode</em> to <em translate="no">Slider</em>.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/smoothness-property-configured.png" width="244" height="210">
							<figcaption>Smoothness property configured.</figcaption>
						</figure>
						
						<p>Next, drag the rounded <em translate="no">Smoothness</em> button from the blackboard onto an open space in the graph. That will add a smoothness node to the graph. Connect it to the <em translate="no">Smoothness</em> input of the <em translate="no">PRB Master</em> node by dragging from one of their dots to the other. This creates a link between them.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/smoothness-connected.png" width="290" height="230">
							<figcaption>Smoothness connected.</figcaption>
						</figure>
						
						<p>Now you can save the graph via the <em translate="no">Save Asset</em> toolbar button and create a material named <em translate="no">Point URP</em> that uses it. The shader's menu item is <em translate="no">Shader Graphs / Point URP</em>. Then make the <em translate="no">Point</em> prefab use that material instead of <em translate="no">Point Surface</em>.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/point-urp-material.png" width="320" height="180">
							<figcaption>Material for URP using our shader graph.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Programming with Nodes</h3>
						
						<p>To color the points we have to start with a position node. Create one by opening a context menu on an empty part of the graph and choosing <em translate="no">New Node</em> from it. Select <em translate="no">Input / Geometry / Position</em> or just search for <em translate="no">Position</em>.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/world-position-node.png" width="166" height="250">
							<figcaption>World position node.</figcaption>
						</figure>
						
						<p>We now have a position node, which is set to world space by default. You can collapse its preview visualization by pressing the upward arrow that appears when you hover the cursor over it.</p>
						
						<p>Use the same approach to create a <em translate="no">Multiply</em> and an <em translate="no">Add</em> node. Use these to scale the position's XY components by 0.5 and then add 0.5, while setting Z to zero. These nodes adapt their input types depending on what they're connected to. So first connect the nodes and then fill in their constant inputs. Then connect the result to the <em translate="no">Base Color</em> input of <em>Fragment</em>.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/colored-shader-graph.png" width="590" height="220">
							<figcaption>Colored shader graph.</figcaption>
						</figure>
						
						<p>You can compact the visual size of the <em>Multiply</em> and <em>Add</em> nodes by pressing the arrow that appear in their top right corner if you hover over them. That hides all their inputs and outputs that aren't connected to anther node. This removes a lot of clutter. You can also delete components of the <em>Vertex</em> and <em>Fragment</em> nodes via their context menu. This way you can hide everything that keeps its default value.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/compacted-shader-graph.png" width="580" height="194">
							<figcaption>Compacted shader graph.</figcaption>
						</figure>
						
						<p>After saving the shader asset we now get the same colored points in play mode that we got when using the default render pipeline. Besides that, a debug updater appears in a separate <em translate="no">DontDestroyOnLoad</em> scene in play mode. This is for debugging URP and can be ignored.</p>
						
						<figure>
							<img src="../basics/building-a-graph/coloring-the-graph/urp-debug-updater.png" width="282" height="98">
							<figcaption>URP debug updater in play mode.</figcaption>
						</figure>
						
						<p>From this point you can use either the default render pipeline or the URP. After switching from one to the other you'll also have to change the material of the <em translate="no">Point</em> prefab otherwise it will be magenta. If you're curious about the shader code that is generated from the graph you can get to it via the <em translate="no">View Generated Shader</em> button of the graph's inspector.</p>
					</section>
				</section>
				
				<section>
					<h2>Animating the Graph</h2>
					
					<p>Displaying a static graph is useful, but a moving graph is more interesting to look at. So let's add support for animating functions. This is done by including time as an additional function parameter, using functions of the form `f(x,t)` instead of just `f(x)`, where `t` is the time.</p>
					
					<section>
						<h3>Keeping Track of the Points</h3>
						
						<p>To animate the graph we'll have to adjust its points as time progresses. We could do this by deleting all points and creating new ones each update, but that's an inefficient way to do this. It's much better to keep using the same points, adjusting their positions each update. To make this possible we're going to use a field to keep a reference to our points. Add a <code>points</code> field to <code>Graph</code> of type <code>Transform</code>.</p>
						
						<pre translate="no">	[SerializeField, Range(10, 100)]
	int resolution = 10;
	
	<ins>Transform points;</ins></pre>
						
						<p>This field allows us to reference a single point, but we need access to all of them. We can turn our field into an array by putting empty square brackets behind its type.</p>
						
						<pre translate="no">	Transform<ins>[]</ins> points;</pre>
						
						<p>The <code>points</code> field is now a reference to an array, whose elements are of type <code>Transform</code>. Arrays are objects, not simple values. We have to explicitly create such an object and make our field reference it. This is done by writing <code>new</code> followed by the array type, so <code>new Transform[]</code> in our case. Create the array in <code>Awake</code>, before our loop, and assign it to <code>points</code>.</p>
						
						<pre translate="no">		<ins>points = new Transform[];</ins>
		for (int i = 0; i &lt; resolution; i++) {
			&hellip;
		}</pre>
						
						<p>When creating an array we have to specify its length. This defines how many elements it has, which cannot be changed after it has been created. The length is written inside the square brackets when constructing the array. Make it equal to the resolution of the graph.</p>
						
						<pre translate="no">		points = new Transform[<ins>resolution</ins>];</pre>
						
						<p>Now we can fill the array with references to our points. Accessing an array element is done by writing its index between square brackets behind the array reference. Array indices start at zero for the first element, just like the iteration counter of our loop. So we can use that to assign to the appropriate array element.</p>
						
						<pre translate="no">		points = new Transform[resolution];
		for (int i = 0; i &lt; resolution; i++) {
			Transform point = Instantiate(pointPrefab);
			<ins>points[i] = point;</ins>
			&hellip;
		}</pre>
						
						<p>If we're assigning the same thing multiple times in a row, we can chain these assignments together because the result of an assignment expression is what was assigned, as explained in the previous tutorial.</p>
						
						<pre>			Transform point = <ins>points[i] =</ins> Instantiate(pointPrefab);
			<del>//points[i] = point;</del></pre>
						
						<p>We're now looping through our array of points. Because the array's length is the same as the resolution, we could also use that to constrain our loop. Each array has a <code>Length</code> property for this purpose, so let's use that.</p>
						
						<pre translate="no">		points = new Transform[resolution];
		for (int i = 0; i &lt; <ins>points.Length</ins>; i++) {
			…
		}</pre>
					</section>
					
					<section>
						<h3>Updating the Points</h3>
						
						<p>To adjust the graph each frame we need to set the Y coordinates of the points in an <code>Update</code> method. So we no longer need to calculate them in <code>Awake</code>. We can still set the X coordinates here because we won't change them.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; points.Length; i++) {
			Transform point = points[i] = Instantiate(pointPrefab);
			position.x = (i + 0.5f) * step - 1f;
<del>//			position.y = position.x * position.x * position.x;</del>
			&hellip;
		}</pre>
						
						<p>Add an <code>Update</code> method with a <code>for</code> loop just like <code>Awake</code> has, but without any code in its block yet.</p>
						
						<pre translate="no">	void Awake () {
		&hellip;
	}
	
	<ins>void Update () {</ins>
		<ins>for (int i = 0; i &lt; points.Length; i++) {}</ins>
	<ins>}</ins></pre>
						
						<p>We'll begin each iteration of the loop by getting a reference to the current array element and storing it in a variable.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; points.Length; i++) {
			<ins>Transform point = points[i];</ins>
		}</pre>
						
						<p>After that we retrieve the point's local position and store it in a variable as well.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; points.Length; i++) {
			Transform point = points[i];
			<ins>Vector3 position = point.localPosition;</ins>
		}</pre>
						
						<p>Now we can set the position's Y coordinate, based on X, as we did earlier.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; points.Length; i++) {
			Transform point = points[i];
			Vector3 position = point.localPosition;
			<ins>position.y = position.x * position.x * position.x;</ins>
		}</pre>
						
						<p>Because the position is a struct we only adjusted the local variable's value. To apply it to the point we have to set its position again.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; points.Length; i++) {
			Transform point = points[i];
			Vector3 position = point.localPosition;
			position.y = position.x * position.x * position.x;
			<ins>point.localPosition = position;</ins>
		}</pre>
						
						<aside>
							<h3>Couldn't we directly set <code>point.localPosition.y</code>?</h3>
							<div>
								<p>If <code>localPosition</code> were a public field then we could directly set the Y coordinate of the point's position. However, <code>localPosition</code> is a property. It passes a copy of the vector value to us, or copies what we assign to it. So we'd end up adjusting a local vector value, which doesn't affect the point's position at all. As we haven't explicitly stored it in a variable first, the operation would be meaningless and will produce a compiler error.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Showing a Sine Wave</h3>
						
						<p>From now on, while in play mode, the points of our graph get positioned every frame. We don't notice this yet because they always end up at the same positions. We have to incorporate the time into the function in order to make it change. However, simply adding the time will cause the function to rise and quickly disappear out of view. To prevent this from happening we have to use a function that changes but remains within a fixed range. The sine function is ideal for this, so we'll use `f(x)=sin(x)`. We can use the <code>Mathf.Sin</code> method to compute it.</p>
						
						<pre translate="no">			position.y = <ins>Mathf.Sin(position.x)</ins>;</pre>
						
						<figure>
							<img src="../basics/building-a-graph/animating-the-graph/sin-x.png" width="240" height="240">
							<figcaption>The sine of X, from &minus;1 to 1.</figcaption>
						</figure>
						
						<aside>
							<h3>What's <code>Mathf</code>?</h3>
							<div>
								<p>It is a struct in the <code>UnityEngine</code> namespace that contains a collection of mathematical functions and constants. As it works with floating-point numbers its type name was given the <em>f</em> suffix.</p>
							</div>
						</aside>
						
						<p>The sine wave oscillates between &minus;1 and 1. It repeats every 2&pi;&mdash;pronounced as two pie&mdash;units, which means that it has a period of roughly 6.28. As our graph's X coordinates are between &minus;1 and 1 we currently see less than a third of the repeating pattern. To see it in its entirety scale X by &pi; so we end up with `f(x)=sin(pix)`. We can use the <code>Mathf.PI</code> constant as an approximation of &pi;.</p>
						
						<pre translate="no">			position.y = Mathf.Sin(<ins>Mathf.PI *</ins> position.x);</pre>
						
						<figure>
							<img src="../basics/building-a-graph/animating-the-graph/sin-pix.png" width="240" height="240">
							<figcaption>The sine of &pi;X.</figcaption>
						</figure>
						
						<aside>
							<h3>What's a sine wave and &pi;?</h3>
							<div>
								<p>The sine is a trigonometric function, operating on an angle. In our case, the most useful example is a circle with radius 1, the unit circle. Each point on the circle has an angle `theta`&mdash;theta&mdash;associated with it, as well as a 2D position. One way to define the coordinates of those positions is `[[sin(theta)],[sin(theta+pi/2)]]`. This represents starting at the top of the circle and going around it in a clockwise direction. Instead of `sin(theta+pi/2)` you can also use the cosine, leading to `[[sin(theta)],[cos(theta)]]`.</p>
								
								<figure>
									<img src="../basics/building-a-graph/animating-the-graph/sin-cos-pix.png" width="600" height="400">
									<figcaption>Sine and cosine of &pi;X.</figcaption>
								</figure>
								
								<p>The angle `theta` is expressed in radians, which corresponds to the distance traveled along the circumference of the unit circle. At the halfway point the traveled distance is equal to &pi;, which is roughly 3.14. So the entire circumference has a length of 2&pi;. In other words, &pi; is the ratio between a circle's circumference and its diameter.</p>
							</div>
						</aside>
						
						<p>To animate this function, add the current game time to X before calculating the sine function. It's found via <code>Time.time</code>. If we scale the time by &pi; as well the function will repeat every two seconds. So use `f(x,t)=sin(pi(x+t))`, where `t` is the elapsed game time. This will advance the sine wave as time progresses, shifting it in the negative X direction.</p>
						
						<pre translate="no">			position.y = Mathf.Sin(Mathf.PI * <ins>(</ins>position.x <ins>+ Time.time)</ins>);</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/weepyagreeableboutu?controls=0'></iframe></div>
							<figcaption>Animated sine wave.</figcaption>
						</figure>
						
						<p>Because the value of <code>Time.time</code> is the same for each iteration of the loop we can hoist the property invocation outside of it.</p>
						
						<pre translate="no">		<ins>float time = Time.time;</ins>
		for (int i = 0; i &lt; points.Length; i++) {
			Transform point = points[i];
			Vector3 position = point.localPosition;
			position.y = Mathf.Sin(Mathf.PI * (position.x + <ins>time</ins>));
			point.localPosition = position;
		}</pre>
					</section>
					
					<section>
						<h3>Clamping the Colors</h3>
						
						<p>The sine wave's amplitude is 1, which means that the lowest and highest positions that our points attain are &minus;1 and 1. However, because the points are cubes with a size they extend a bit beyond this range. Thus we can get colors with green components that are negative or greater than 1. While this isn't noticeable let's be correct and clamp the colors to ensure that they remain in the 0&ndash;1 range.</p>
						
						<p>We can do this for our surface shader by passing the generated color through the <code class="shader">saturate</code> function. This is a special function that clamps all components to 0&ndash;1. It is a common operation in shaders known as saturation, hence its name.</p>
						
						<pre class="shader" translate="no">			surface.Albedo.rg = <ins>saturate(</ins>input.worldPos.xy * 0.5 + 0.5<ins>)</ins>;</pre>
						
						<p>The same can be done in the shader graph with the <em translate="no">Saturate</em> node.</p>
						
						<figure>
							<img src="../basics/building-a-graph/animating-the-graph/saturated-shader-graph.png" width="460" height="190">
							<figcaption>Saturated color in shader graph.</figcaption>
						</figure>
						
						<p>The next tutorial is <a href="../basics/mathematical-surfaces/index.html">Mathematical Surfaces</a>.</p>
					</section>
					
					<a href="../license/index.html" class="license">license</a>
			<a href="https://bitbucket.org/catlikecodingunitytutorials/basics-02-building-a-graph/" class="repository">repository</a>
					<a href="../basics/building-a-graph/Building-a-Graph.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../tutorials.js"></script>
	</body>
</html>