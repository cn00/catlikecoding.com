<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/custom-srp/point-and-spot-lights/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/custom-srp/point-and-spot-lights/tutorial-image.jpg">
		<meta property="og:title" content="Point and Spot Lights">
		<meta property="og:description" content="A Unity Custom SRP tutorial about including lighting for point and spot lights.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Point and Spot Lights</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/custom-srp/point-and-spot-lights/#article",
				"headline": "Point and Spot Lights",
				"alternativeHeadline": "Lights with Limited Influence",
				"datePublished": "2020-05-31",
				"dateModified": "2021-01-26",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Custom SRP tutorial about including lighting for point and spot lights.",
				"image": "https://catlikecoding.com/unity/tutorials/custom-srp/point-and-spot-lights/tutorial-image.jpg",
				"dependencies": "Unity 2019.2.21f1",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/custom-srp/", "name": "Custom SRP" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				CameraRenderer: 1,
				CascadeBlendMode: 1,
				CustomLightEditor: 1,
				CustomRenderPipeline: 1,
				CustomRenderPipelineAsset: 1,
				CustomShaderGUI: 1,
				Directional: 1,
				DirectionalShadowData: 1,
				FilterMode: 1,
				InputConfig: 1,
				Lighting: 1,
				MeshBall: 1,
				OtherShadowData: 1,
				PerObjectMaterialProperties: 1,
				ShadowedDirLight: 1,
				ShadowData: 1,
				Shadows: 1,
				ShadowMask: 1,
				ShadowMode: 1,
				ShadowSettings: 1,
				TextureSize: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Custom SRP</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Point and Spot Lights</h1>
					<p>Lights with Limited Influence</p>
					<ul>
						<li>Support more light types than only directional.</li>
						<li>Include realtime point and spot lights.</li>
						<li>Bake lighting and shadows for point and spot lights.</li>
						<li>Limit rendering to max 8 other lights per object.</li>
					</ul>
				</header>
				
				<p>This is the ninth part of a tutorial series about creating a <a href="../index.html">custom scriptable render pipeline</a>. It adds support for both realtime and baked point and spot lights, but no realtime shadows yet.</p>
				
				<p>This tutorial is made with Unity 2019.2.21f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>A party of point and spot lights.</figcaption>
				</figure>
				
				<section>
					<h2>Point Lights</h2>
					
					<p>We've only worked with directional lights so far because those lights affect everything and have unlimited range. Other light types are different. They're not assumed to be infinitely far away, thus they have a position and the intensity varies. This requires extra work to set up and render, which is why we'll create separate code for that. We start with point lights, which are infinitely small points that shed light in all directions equally.</p>
					
					<section>
						<h3>Other Light Data</h3>
						
						<p>Like with directional lights, we can only support a limited amount of other lights. Scenes often contain a lot of lights that aren't directional, because their effective range is limited. Usually only a subset of all other lights are visible for any given frame. The maximum we can support thus applies to a single frame, not to the entire scene. If we end up with more visible lights than the maximum some will simply be omitted. Unity sorts the visible light list based on importance, so which lights get omitted is consistent as long as the visible lights don't change. But if they do change&mdash;either due to camera movement or some other change&mdash; this can result in obvious light popping. So we don't want to use a maximum that is too low. Let's allow up to 64 simultaneous other lights, defined as another constant in <code>Lighting</code>.</p>
						
						<pre translate="no">	const int maxDirLightCount = 4<ins>, maxOtherLightCount = 64</ins>;</pre>
						
						<p>Just like for directional lights, we need to send the light count and light colors to the GPU for the other light types. In this case we also need to send the light positions. Add shader property names and vector array fields to make this possible.</p>
						
						<pre translate="no">	<ins>static int</ins>
		<ins>otherLightCountId = Shader.PropertyToID("_OtherLightCount"),</ins>
		<ins>otherLightColorsId = Shader.PropertyToID("_OtherLightColors"),</ins>
		<ins>otherLightPositionsId = Shader.PropertyToID("_OtherLightPositions");</ins>

	<ins>static Vector4[]</ins>
		<ins>otherLightColors = new Vector4[maxOtherLightCount],</ins>
		<ins>otherLightPositions = new Vector4[maxOtherLightCount];</ins></pre>
						
						<p>In <code>SetupLights</code>, keep track of the other light count along with the directional light count. After looping over the visible lights, send all data to the GPU. But we don't need to bother with sending the arrays if we end up with zero other lights. Also, it can now also make sense to only have other lights and no directional lights, so we might skip sending the directional arrays as well. We do always need to send the light counts.</p>
						
						<pre translate="no">	void SetupLights () {
		NativeArray&lt;VisibleLight> visibleLights = cullingResults.visibleLights;
		int dirLightCount = 0<ins>, otherLightCount = 0</ins>;
		for (int i = 0; i &lt; visibleLights.Length; i++) {
			&hellip;
		}

		buffer.SetGlobalInt(dirLightCountId, dirLightCount);
		<ins>if (dirLightCount > 0) {</ins>
			buffer.SetGlobalVectorArray(dirLightColorsId, dirLightColors);
			buffer.SetGlobalVectorArray(dirLightDirectionsId, dirLightDirections);
			buffer.SetGlobalVectorArray(dirLightShadowDataId, dirLightShadowData);
		<ins>}</ins>

		<ins>buffer.SetGlobalInt(otherLightCountId, otherLightCount);</ins>
		<ins>if (otherLightCount > 0) {</ins>
			<ins>buffer.SetGlobalVectorArray(otherLightColorsId, otherLightColors);</ins>
			<ins>buffer.SetGlobalVectorArray(</ins>
				<ins>otherLightPositionsId, otherLightPositions</ins>
			<ins>);</ins>
		<ins>}</ins>
	}</pre>
						
						<p>On the shader side, define the other light max and new data in <em translate="no">Light</em> as well.</p>
						
						<pre class="shader" translate="no">#define MAX_DIRECTIONAL_LIGHT_COUNT 4
<ins>#define MAX_OTHER_LIGHT_COUNT 64</ins>

CBUFFER_START(_CustomLight)
	int _DirectionalLightCount;
	float4 _DirectionalLightColors[MAX_DIRECTIONAL_LIGHT_COUNT];
	float4 _DirectionalLightDirections[MAX_DIRECTIONAL_LIGHT_COUNT];
	float4 _DirectionalLightShadowData[MAX_DIRECTIONAL_LIGHT_COUNT];

	<ins>int _OtherLightCount;</ins>
	<ins>float4 _OtherLightColors[MAX_OTHER_LIGHT_COUNT];</ins>
	<ins>float4 _OtherLightPositions[MAX_OTHER_LIGHT_COUNT];</ins>
CBUFFER_END</pre>
						
						<p>And let's already define a <code class="shader">GetOtherLightCount</code> function that we'll need to use later.</p>
						
						<pre translate="no"><ins>int GetOtherLightCount () {</ins>
	<ins>return _OtherLightCount;</ins>
<ins>}</ins></pre>
						
					</section>
					
					<section>
						<h3>Point Light Setup</h3>
						
						<p>Create a <code>SetupPointLight</code> method in <code>Lighting</code> to set up the color and position for a point light. Give it the same  parameters as <code>SetupDirectionalLight</code>. The color is set the same way. The position works like the directional light's direction, except that we need the last column of the local-to-world matrix instead of the third.</p>
						
						<pre translate="no">	<ins>void SetupPointLight (int index, ref VisibleLight visibleLight) {</ins>
		<ins>otherLightColors[index] = visibleLight.finalColor;</ins>
		<ins>otherLightPositions[index] = visibleLight.localToWorldMatrix.GetColumn(3);</ins>
	<ins>}</ins></pre>
						
						<p>Now we have to adjust the loop in <code>SetupLights</code> so it distinguishes between directional and point lights. We should no longer end the loop once we reach the maximum amount of directional lights. Instead, we skip further directional lights and keep going. And we have to do the same for point lights, taking the max for other lights into account. Let's use a <code>switch</code> statement to program this.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; visibleLights.Length; i++) {
			VisibleLight visibleLight = visibleLights[i];
			<del>//if (visibleLight.lightType == LightType.Directional) {</del>
			<del>//	SetupDirectionalLight(dirLightCount++, ref visibleLight);</del>
			<del>//	if (dirLightCount >= maxDirLightCount) {</del>
			<del>//		break;</del>
			<del>//	}</del>
			<del>//}</del>
			<ins>switch (visibleLight.lightType) {</ins>
				<ins>case LightType.Directional€:</ins>
					<ins>if (dirLightCount &lt; maxDirLightCount) {</ins>
						<ins>SetupDirectionalLight(dirLightCount++, ref visibleLight);</ins>
					<ins>}</ins>
					<ins>break;</ins>
				<ins>case LightType.Point:</ins>
					<ins>if (otherLightCount &lt; maxOtherLightCount) {</ins>
						<ins>SetupPointLight(otherLightCount++, ref visibleLight);</ins>
					<ins>}</ins>
					<ins>break;</ins>
			<ins>}</ins>
		}</pre>
						
					</section>
					
					<section>
						<h3>Shading</h3>
						
						<p>All data necessary to support point lights is now available to the shader. To make use of it we add a <code class="shader">GetOtherLight</code> function to <em translate="no">Light</em>, with the same parameters as <code class="shader">GetDirectionalLight</code>. In this case the light's direction varies per fragment. We find it by normalizing the light ray from the surface position to the light. We don't support shadows at this point, so the attenuation is 1.</p>
						
						<pre class="shader" translate="no"><ins>Light GetOtherLight (int index, Surface surfaceWS, ShadowData shadowData) {</ins>
	<ins>Light light;</ins>
	<ins>light.color = _OtherLightColors[index].rgb;</ins>
	<ins>float3 ray = _OtherLightPositions[index].xyz - surfaceWS.position;</ins>
	<ins>light.direction = normalize(ray);</ins>
	<ins>light.attenuation = 1.0;</ins>
	<ins>return light;</ins>
<ins>}</ins></pre>
						
						<p>To apply the new lighting add a loop for all other lights after the one for directional lights in <code class="shader">GetLighting</code>. Although the loops are separate, we have to use a different name for their iterator variables, other we'll get shader compiler warnings in some cases. So I use <code>j</code> instead of <code>i</code> for the second one.</p>
						
						<pre class="shader" translate="no">float3 GetLighting (Surface surfaceWS, BRDF brdf, GI gi) {
	ShadowData shadowData = GetShadowData(surfaceWS);
	shadowData.shadowMask = gi.shadowMask;
	
	float3 color = IndirectBRDF(surfaceWS, brdf, gi.diffuse, gi.specular);
	for (int i = 0; i &lt; GetDirectionalLightCount(); i++) {
		Light light = GetDirectionalLight(i, surfaceWS, shadowData);
		color += GetLighting(surfaceWS, brdf, light);
	}

	<ins>for (int j = 0; j &lt; GetOtherLightCount(); j++) {</ins>
		<ins>Light light = GetOtherLight(j, surfaceWS, shadowData);</ins>
		<ins>color += GetLighting(surfaceWS, brdf, light);</ins>
	<ins>}</ins>
	return color;
}</pre>
						
						<figure>
							<img src="point-lights/point-lights.png" width="380" height="200">
							<figcaption>Only point lights; no environment lighting.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Distance Attenuation</h3>
						
						<p>Our point lights are now functional, but they are far too bright. As light travels away from its source it spreads out, becoming less concentrated and thus less bright the further it goes. The light's intensity is `i/d^2` where `i` is the configured intensity and `d` is the distance. This is known as the inverse-square law. Note that this means that at a distance less than 1 the intensity is greater than configured. It get extremely bright very close to the light's position. Earlier we inferred that the final light color that we use represents the amount observed when reflected from a perfectly white diffuse surface fragment illuminated head-on. This is true for directional lights, but for other light types it's also specifically for fragments that are exactly at distance 1 from the light.</p>
						
						<figure>
							<img src="point-lights/distance-attenuation-graph.png" width="100" height="100">
							<figcaption>Distance attenuation curve.</figcaption>
						</figure>
						
						<p>Apply the distance attenuation by calculating the square light distance and use the inverse of that as attenuation. To prevent a potential division by zero, set the minimum of the square distance to a tiny positive value.</p>
						
						<pre class="shader" translate="no">	<ins>float distanceSqr = max(dot(ray, ray), 0.00001);</ins>
	light.attenuation = 1.0 <ins>/ distanceSqr</ins>;</pre>
						
						<figure>
							<img src="point-lights/distance-attenuation.png" width="380" height="200">
							<figcaption>Light fades with distance.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>Light Range</h3>
						
						<p>Although the point light intensity now quickly attenuates, their light still theoretically affects everything, even though it is usually not perceivable. Diffuse reflections become unnoticeable fast, while specular reflections are still visible at greater distances.</p>
						
						<p>To make rendering practical, we'll use a maximum light range, beyond which we force the light intensity to zero. This isn't realistic, but otherwise all lights would always count as visible, no matter their distance. With an added range the point lights are contained by a bounding sphere, defined by their position and range.</p>
						
						<p>We don't suddenly cut off the light at the sphere's boundary, instead we'll smoothly fade it out by aplying a range attenuation. Unity's Universal RP and lightmapper use `max(0, 1-(d^2/r^2)^2)^2` where `r` is the light range, so we'll use the same function as well.</p>
						
						<figure>
							<img src="point-lights/range-attenuation-graph.png" width="100" height="100">
							<figcaption>Range attenuation curve.</figcaption>
						</figure>
						
						<p>We can store the range in the fourth component of the light position. To reduce work in the shader, store `1/r^2` instead, again making sure to avoid a division by zero.</p>
						
						<pre translate="no">	void SetupPointLight (int index, ref VisibleLight visibleLight) {
		otherLightColors[index] = visibleLight.finalColor;
		<ins>Vector4 position = visibleLight.localToWorldMatrix.GetColumn(3);</ins>
		<ins>position.w =</ins>
			<ins>1f / Mathf.Max(visibleLight.range * visibleLight.range, 0.00001f);</ins>
		otherLightPositions[index] = <ins>position</ins>;
	}</pre>
						
						<p>Then include the range attenuation in <code class="shader">GetOtherLight</code>.</p>
						
						<pre class="shader" translate="no">	float distanceSqr = max(dot(ray, ray), 0.00001);
	<ins>float rangeAttenuation = Square(</ins>
		<ins>saturate(1.0 - Square(distanceSqr * _OtherLightPositions[index].w))</ins>
	<ins>);</ins>
	light.attenuation = <ins>rangeAttenuation</ins> / distanceSqr;</pre>
						
						<figure>
							<img src="point-lights/range-attenuation.png" width="380" height="200">
							<figcaption>Range and distance attenuation.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Spot Lights</h2>
					
					<p>We'll also support spot lights. The difference between a point and a spot light is that the latter's light is restricted to a cone. Effectively, it's a point light that's enclosed by an occluding sphere with a hole in it. The size of the hole determines the size of the light cone.</p>
					
					<section>
						<h3>Direction</h3>
						
						<p>A spot light has a direction as well as a position, so add a shader property name and array for directions of other lights to <code>Lighting</code>.</p>
						
						<pre translate="no">	static int
		otherLightCountId = Shader.PropertyToID("_OtherLightCount"),
		otherLightColorsId = Shader.PropertyToID("_OtherLightColors"),
		otherLightPositionsId = Shader.PropertyToID("_OtherLightPositions")<ins>,</ins>
		<ins>otherLightDirectionsId = Shader.PropertyToID("_OtherLightDirections")</ins>;

	static Vector4[]
		otherLightColors = new Vector4[maxOtherLightCount],
		otherLightPositions = new Vector4[maxOtherLightCount]<ins>,</ins>
		<ins>otherLightDirections = new Vector4[maxOtherLightCount]</ins>;</pre>
						
						<p>Send the new data to the GPU in <code>SetupLights</code>.</p>
						
						<pre translate="no">			buffer.SetGlobalVectorArray(
				otherLightPositionsId, otherLightPositions
			);
			<ins>buffer.SetGlobalVectorArray(</ins>
				<ins>otherLightDirectionsId, otherLightDirections</ins>
			<ins>);</ins></pre>
						
						<p>Create a <code>SetupSpotLight</code> method that's a copy of <code>SetupPointLight</code>, except that it also stores the light direction. We can use the negated third column of the local-to-world matrix for this, similar to directional lights.</p>
						
						<pre translate="no">	<ins>void SetupSpotLight (int index, ref VisibleLight visibleLight) {</ins>
		<ins>otherLightColors[index] = visibleLight.finalColor;</ins>
		<ins>Vector4 position = visibleLight.localToWorldMatrix.GetColumn(3);</ins>
		<ins>position.w =</ins>
			<ins>1f / Mathf.Max(visibleLight.range * visibleLight.range, 0.00001f);</ins>
		<ins>otherLightPositions[index] = position;</ins>
		<ins>otherLightDirections[index] =</ins>
			<ins>-visibleLight.localToWorldMatrix.GetColumn(2);</ins>
	<ins>}</ins></pre>
						
						<p>Then include a case for spot lights in the <code>SetupLights</code> loop.</p>
						
						<pre translate="no">				case LightType.Point:
					if (otherLightCount &lt; maxOtherLightCount) {
						SetupPointLight(otherLightCount++, ref visibleLight);
					}
					break;
				<ins>case LightType.Spot:</ins>
					<ins>if (otherLightCount &lt; maxOtherLightCount) {</ins>
						<ins>SetupSpotLight(otherLightCount++, ref visibleLight);</ins>
					<ins>}</ins>
					<ins>break;</ins></pre>
						
						<p>On the shader side, add the new data to the buffer in <em translate="no">Light</em>.</p>
						
						<pre class="shader" translate="no">	float4 _OtherLightPositions[MAX_OTHER_LIGHT_COUNT];
	<ins>float4 _OtherLightDirections[MAX_OTHER_LIGHT_COUNT];</ins></pre>
						
						<p>And apply the spot attenuation in <code class="shader">GetOtherLight</code>. We start by simply using the saturated dot product of the spot and the light direction. That will attenuate the light so it reaches zero at a 90&deg; spot angle, illuminating everything in front of the light.</p>
						
						<pre class="shader" translate="no">	<ins>float spotAttenuation =</ins>
		<ins>saturate(dot(_OtherLightDirections[index].xyz, light.direction));</ins>
	light.attenuation = <ins>spotAttenuation *</ins> rangeAttenuation / distanceSqr;</pre>
						
						<figure>
							<img src="spot-lights/spot-lights.png" width="420" height="200">
							<figcaption>Spot lights.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Spot Angle</h3>
						
						<p>Spot lights have an angle to control how wide their light cone is. This angle is measured from its middle, so a 90&deg; angle would look like what we have right now. Besides that, there's also a separate inner angle that controls when the light starts attenuating. The Universal RP and lightmapper do this by scaling and adding something to the dot product before saturating, then squaring the result. Specifically, the formula is `saturate(da + b)^2` where `d` is the dot product, `a=1/(cos(r_i/2)-cos(r_o/2))` and `b=-cos(r_o/2)a`. Here `r_i` and `r_o` and the inner and outer angles, in radians.</p>
						
						<figure>
							<img src="spot-lights/spot-angle-attenuation-graph.png" width="100" height="100">
							<figcaption>Angle attenuation with inner 0&deg;, 20&deg;, 45&deg;, 70&deg; and outer 90&deg;.</figcaption>
						</figure>
						
						<p>The function can also be written as `saturate((d-cos(r_o/2))/(cos(r_i/2)-cos(r_o/2)))^2` but is decomposed this way so we can calculate `a` and `b` in <code>Lighting</code> and send them to the shader via a new spot angles array. So define the array and its property name.</p>
						
						<pre translate="no">	static int
		otherLightCountId = Shader.PropertyToID("_OtherLightCount"),
		otherLightColorsId = Shader.PropertyToID("_OtherLightColors"),
		otherLightPositionsId = Shader.PropertyToID("_OtherLightPositions"),
		otherLightDirectionsId = Shader.PropertyToID("_OtherLightDirections")<ins>,</ins>
		<ins>otherLightSpotAnglesId = Shader.PropertyToID("_OtherLightSpotAngles")</ins>;

	static Vector4[]
		otherLightColors = new Vector4[maxOtherLightCount],
		otherLightPositions = new Vector4[maxOtherLightCount],
		otherLightDirections = new Vector4[maxOtherLightCount]<ins>,</ins>
		<ins>otherLightSpotAngles = new Vector4[maxOtherLightCount]</ins>;</pre>
						
						<p>Copy the array to the GPU in <code>SetupLights</code>.</p>
						
						<pre translate="no">			buffer.SetGlobalVectorArray(
				otherLightDirectionsId, otherLightDirections
			);
			<ins>buffer.SetGlobalVectorArray(</ins>
				<ins>otherLightSpotAnglesId, otherLightSpotAngles</ins>
			<ins>);</ins></pre>
						
						<p>And calculate the values in <code>SetupSpotLight</code>, storing them in the X and Y components of the spot angles array. The outer angle is made available via the <code>spotAngle</code> property of the <code>VisibleLight</code> struct. However, for the inner angle we need to first retrieve the <code>Light</code> game object via its <code>light</code> property, which in turn has an <code>innerSpotAngle</code> property.</p>
						
						<pre translate="no">	void SetupSpotLight (int index, ref VisibleLight visibleLight) {
		&hellip;

		<ins>Light light = visibleLight.light;</ins>
		<ins>float innerCos = Mathf.Cos(Mathf.Deg2Rad * 0.5f * light.innerSpotAngle);</ins>
		<ins>float outerCos = Mathf.Cos(Mathf.Deg2Rad * 0.5f * visibleLight.spotAngle);</ins>
		<ins>float angleRangeInv = 1f / Mathf.Max(innerCos - outerCos, 0.001f);</ins>
		<ins>otherLightSpots[index] = new Vector4(</ins>
			<ins>angleRangeInv, -outerCos * angleRangeInv</ins>
		<ins>);</ins>
	}</pre>
						
						<aside>
							<h3>Why isn't the inner angle stored in <code>VisibleLight</code>?</h3>
							<div>
								<p>The configurable inner angle is a recent addition to Unity. The <code>VisibleLight</code> struct probably doesn't have it because it would change its size and require refactoring of Unity internal code.</p>
							</div>
						</aside>
						
						<p>Back to the shader, add the new array in <em translate="no">Light</em>.</p>
						
						<pre class="shader" translate="no">	float4 _OtherLightDirections[MAX_OTHER_LIGHT_COUNT];
	<ins>float4 _OtherLightSpotAngles[MAX_OTHER_LIGHT_COUNT];</ins></pre>
						
						<p>And adjust the spot attenuation in <code class="shader">GetOtherLight</code>.</p>
						
						<pre class="shader" translate="no">	<ins>float4 spotAngles = _OtherLightSpotAngles[index];</ins>
	float spotAttenuation = <ins>Square(</ins>
		saturate(dot(_OtherLightDirections[index].xyz, light.direction) <ins>*</ins>
		<ins>spotAngles.x + spotAngles.y</ins>)
	<ins>)</ins>;
	light.attenuation = spotAttenuation * rangeAttenuation / distanceSqr;</pre>
						
						<figure>
							<img src="spot-lights/spot-angle-attenuation.png" width="420" height="200">
							<figcaption>Angle attenuation in use.</figcaption>
						</figure>
						
						<p>Finally, to make sure that point lights aren't affected by the angle attenuation calculation set their spot angle values to 0 and 1.</p>
						
						<pre translate="no">	void SetupPointLight (int index, ref VisibleLight visibleLight) {
		&hellip;
		<ins>otherLightSpotAngles[index] = new Vector4(0f, 1f);</ins>
	}</pre>
					</section>
					<section>
						<h3>Configuring Inner Angles</h3>
						
						<p>Spot lights always had a configurable outer angle, but a separate inner angle didn't exist until the Universal RP was introduced. As a result the default inspector for lights doesn't expose the inner angle. RPs could modify lights further, so it's possible to override the default inspector for lights. That's done by creating an editor script that extends <code>LightEditor</code> and giving it the <code>CustomEditorForRenderPipeline</code> attribute. The first argument of this attribute must be the <code>Light</code> type. The second argument must be the type of the RP asset for which we want to override the inspector. Let's create such a script, name it <code>CustomLightEditor</code>, and put it in the <em translate="no">Custom RP / Editor</em> folder. Also give it the <code>CanEditMultipleObjects</code> so it works with multiple lights selected.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>
<ins>using UnityEditor;</ins>

<ins>[CanEditMultipleObjects]</ins>
<ins>[CustomEditorForRenderPipeline(typeof(Light), typeof(CustomRenderPipelineAsset))]</ins>
<ins>public class CustomLightEditor : LightEditor {}</ins></pre>
						
						<p>To replace the inspector we have to override the <code>OnInspectorGUI</code> method. But we're going to do the minimum amount of work to expose the inner angle, so we begin by invoking the base method to draw the default inspector as normal.</p>
						
						<pre translate="no">	<ins>public override void OnInspectorGUI() {</ins>
		<ins>base.OnInspectorGUI();</ins>
	<ins>}</ins></pre>
						
						<p>After that we check whether only spot lights are selected. We can do so via a convenient subclass property named <code>settings</code>, which provides access to the serialized properties of the editor selection. Use it to check that we don't have multiple different light types and that the type is <code>LightType.Spot</code>. If so, invoke <code>DrawInnerAndOuterSpotAngle</code> on the setting to add an inner-outer spot angle slider underneath the default inspector. Afterwards, invoke <code>ApplyModifiedProperties</code> to apply any changes made with that slider.</p>
						
						<pre translate="no">		base.OnInspectorGUI();
		<ins>if (</ins>
			<ins>!settings.lightType.hasMultipleDifferentValues &amp;&amp;</ins>
			<ins>(LightType)settings.lightType.enumValueIndex == LightType.Spot</ins>
		<ins>)</ins>
		<ins>{</ins>
			<ins>settings.DrawInnerAndOuterSpotAngle();</ins>
			<ins>settings.ApplyModifiedProperties();</ins>
		<ins>}</ins></pre>
						
						<figure>
							<img src="spot-lights/inner-outer-spot-angle-slider.png" width="320" height="88" alt="inspector"><br>
							<img src="spot-lights/different-inner-angles.png" width="420" height="150" alt="scene">
							<figcaption>Different inner angles.</figcaption>
						</figure>
						
					</section>
					
				</section>
				
				<section>
					<h2>Baked Light and Shadows</h2>
					
					<p>We won't cover realtime shadows for point and spot lights in this tutorial, but we will support baking these light types now.</p>
					
					<section>
						<h3>Fully Baked</h3>
						
						<p>Fully baking point and spot lights is simply a matter of setting their <em translate="no">Mode</em> to <em translate="no">Baked</em>. Note that their <em translate="no">Shadow Type</em> is set to <em translate="no">None</em> by default, so change that to something else if you want them to be baked with shadows.</p>
						
						<figure>
							<img src="baked-light-and-shadows/realtime.png" width="420" height="220" alt="realtime"><br>
							<img src="baked-light-and-shadows/baked-too-bright.png" width="420" height="220" alt="baked">
							<figcaption>Realtime and baked, only one point and spot light.</figcaption>
						</figure>
						
						<p>Although this is enough to bake these lights, it turns out that they are far too bright when baked. This happens because Unity uses an incorrect light falloff by default, matching the results of the legacy RP.</p>
					</section>
					
					<section>
						<h3>Lights Delegate</h3>
						
						<p>We can tell Unity to use a different falloff, by providing a delegate to a method that should get invoked before Unity performs lightmapping in the editor. To do so, turn <code>CustomRenderPipeline</code> into a partial class and invoke a currently nonexistent <code>InitializeForEditor</code> method at the end of its constructor.</p>
						
						<pre translate="no">public <ins>partial</ins> class CustomRenderPipeline : RenderPipeline {

	&hellip;

	public CustomRenderPipeline (
		bool useDynamicBatching, bool useGPUInstancing, bool useSRPBatcher,
		ShadowSettings shadowSettings
	) {
		&hellip;
		<ins>InitializeForEditor();</ins>
	}

	&hellip;
}</pre>
						
						<p>Then create another editor-specific partial class for it&mdash;just like for <code>CameraRenderer</code>&mdash;that defines an dummy for the new method. Besides the <code>UnityEngine</code> namespace, we also need to use <code>Unity.Collections</code> and <code>UnityEngine.Experimental.GlobalIllumination</code>. This will cause a type clash for <code>LightType</code>, so explicitly use the <code>UnityEngine.LightType</code> for it.</p>
						
						<pre translate="no"><ins>using Unity.Collections;</ins>
<ins>using UnityEngine;</ins>
<ins>using UnityEngine.Experimental.GlobalIllumination;</ins>
<ins>using LightType = UnityEngine.LightType;</ins>

<ins>public partial class CustomRenderPipeline {</ins>

	<ins>partial void InitializeForEditor ();</ins>
<ins>}</ins></pre>
						
						<p>For the editor only, we have to override how the lightmapper sets up its light data. That's done by providing it with a delegate to a method that transfers data from an input <code>Light</code> array to a <code>NativeArray&lt;LightDataGI></code> output. The delegate's type is <code>Lightmapping.RequestLightsDelegate</code> and we'll define the method with a lambda expression as we won't need it anywhere else.</p>
						
						<pre translate="no">partial void InitializeForEditor ();
	
<ins>#if UNITY_EDITOR</ins>

	<ins>static Lightmapping.RequestLightsDelegate lightsDelegate =</ins>
		<ins>(Light[] lights, NativeArray&lt;LightDataGI> output) => {};</ins>

<ins>#endif</ins></pre>
						
						<p>We have to configure a <code>LightDataGI</code> struct for each light and add it to the output. We'll have to use special code for each light type, so use a <code>switch</code> statement in a loop for this. By default we invoke <code>InitNoBake</code> with the light's instance ID on the light data, which instructs Unity to not bake the light.</p>
						
						<pre translate="no">	static Lightmapping.RequestLightsDelegate lightsDelegate =
		(Light[] lights, NativeArray&lt;LightDataGI> output) => {
			<ins>var lightData = new LightDataGI();</ins>
			<ins>for (int i = 0; i &lt; lights.Length; i++) {</ins>
				<ins>Light light = lights[i];</ins>
				<ins>switch (light.type) {</ins>
					<ins>default:</ins>
						<ins>lightData.InitNoBake(light.GetInstanceID());</ins>
						<ins>break;</ins>
				<ins>}</ins>
				<ins>output[i] = lightData;</ins>
			<ins>}</ins>
		};</pre>
						
						<p>Next, per supported light type we have to construct a dedicated light struct, invoke <code>LightmapperUtils.Extract</code> with the light and a reference to the struct as arguments, then invoke <code>Init</code> on the light data, passing the struct by reference. Do this for directional, point, spot, and area lights.</p>
						
						<pre translate="no">				switch (light.type) {
					<ins>case LightType.Directional€:</ins>
						<ins>var directionalLight = new DirectionalLight();</ins>
						<ins>LightmapperUtils.Extract(light, ref directionalLight);</ins>
						<ins>lightData.Init(ref directionalLight);</ins>
						<ins>break;</ins>
					<ins>case LightType.Point:</ins>
						<ins>var pointLight = new PointLight();</ins>
						<ins>LightmapperUtils.Extract(light, ref pointLight);</ins>
						<ins>lightData.Init(ref pointLight);</ins>
						<ins>break;</ins>
					<ins>case LightType.Spot:</ins>
						<ins>var spotLight = new SpotLight();</ins>
						<ins>LightmapperUtils.Extract(light, ref spotLight);</ins>
						<ins>lightData.Init(ref spotLight);</ins>
						<ins>break;</ins>
					<ins>case LightType.Area:</ins>
						<ins>var rectangleLight = new RectangleLight();</ins>
						<ins>LightmapperUtils.Extract(light, ref rectangleLight);</ins>
						<ins>lightData.Init(ref rectangleLight);</ins>
						<ins>break;</ins>
					default:
						lightData.InitNoBake(light.GetInstanceID());
						break;
				}</pre>
						
						<p>We don't support realtime area lights, so let's force their light mode to baked if they exist.</p>
						
						<pre translate="no">					case LightType.Area:
						var rectangleLight = new RectangleLight();
						LightmapperUtils.Extract(light, ref rectangleLight);
						<ins>rectangleLight.mode = LightMode.Baked;</ins>
						lightData.Init(ref rectangleLight);
						break;</pre>
						
						<p>That was just boilerplate code that we had to include. The point of all this is that we can now set the falloff type of the light data to <code>FalloffType.InverseSquared</code> for all lights.</p>
						
						<pre translate="no">				<ins>lightData.falloff = FalloffType.InverseSquared;</ins>
				output[i] = lightData;</pre>
						
						<p>To have Unity invoke our code create an editor version of <code>InitializeForEditor</code> that invokes <code>Lightmapping.SetDelegate</code> with our delegate as an argument.</p>
						
						<pre translate="no">	partial void InitializeForEditor ();
	
#if UNITY_EDITOR

	<ins>partial void InitializeForEditor () {</ins>
		<ins>Lightmapping.SetDelegate(lightsDelegate);</ins>
	<ins>}</ins></pre>
						
						<p>We also have to clean up and reset the delegate when our pipeline gets disposed. That's done by overriding the <code>Dispose</code> method, having it invoke its base implementation, followed by <code>Lightmapping.ResetDelegate</code>.</p>
						
						<pre translate="no">	partial void InitializeForEditor () {
		Lightmapping.SetDelegate(lightsDelegate);
	}

	<ins>protected override void Dispose (bool disposing) {</ins>
		<ins>base.Dispose(disposing);</ins>
		<ins>Lightmapping.ResetDelegate();</ins>
	<ins>}</ins></pre>
						
						<figure>
							<img src="baked-light-and-shadows/baked-correct-falloff.png" width="420" height="220">
							<figcaption>Baked with correct falloff.</figcaption>
						</figure>
						
						<p>Unfortunately the Unity 2019.2 lightmapper doesn't support a custom inner falloff angle for spotlights. It's possible to set the inner spot angle, but it gets ignored.</p>
						
						<aside>
							<h3>Can the lightmapper use the inner spot angle in later version of Unity?</h3>
							<div>
								<p>Yes, starting with Unity 2019.3 <code>AngularFalloffType</code> exists and you can do this:</p>
								
								<pre translate="no">					case LightType.Spot:
						var spotLight = new SpotLight();
						LightmapperUtils.Extract(light, ref spotLight);
						spotLight.innerConeAngle =
							light.innerSpotAngle * Mathf.Deg2Rad;
						spotLight.angularFalloff =
							AngularFalloffType.AnalyticAndInnerAngle;
						lightData.Init(ref spotLight);
						break;</pre>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Shadow Mask</h3>
						
						<p>The shadows of point and spot lights can also be baked into the shadow mask, by setting their <em translate="no">Mode</em> to <em translate="no">Mixed</em>. Each lights gets a channel, just like directional lights. But because their range is limited it is possible for multiple lights to use the same channel, as long as they don't overlap. Thus the shadow mask can support an arbitrary amount of lights, but only up to four per texel. If multiple lights end up overlapping while trying to claim the same channel then the least important lights will be forced to <em translate="no">Baked</em> mode until there is no longer a conflict.</p>
						
						<figure>
							<img src="baked-light-and-shadows/shadow-mask.png" width="350" height="140">
							<figcaption>Shadow mask with a point and a spot light.</figcaption>
						</figure>
						
						<p>To use the shadow mask for point and spot lights, add a <code>ReserveOtherShadows</code> method to <code>Shadows</code>. It works like <code>ReserveDirectionalShadows</code>, except that we only care for the shadow mask mode and only have to configure the shadow strength and mask channel.</p>
						
						<pre translate="no">	<ins>public Vector4 ReserveOtherShadows (Light light, int visibleLightIndex) {</ins>
		<ins>if (light.shadows != LightShadows.None && light.shadowStrength > 0f) {</ins>
			<ins>LightBakingOutput lightBaking = light.bakingOutput;</ins>
			<ins>if (</ins>
				<ins>lightBaking.lightmapBakeType == LightmapBakeType.Mixed &amp;&amp;</ins>
				<ins>lightBaking.mixedLightingMode == MixedLightingMode.Shadowmask</ins>
			<ins>) {</ins>
				<ins>useShadowMask = true;</ins>
				<ins>return new Vector4(</ins>
					<ins>light.shadowStrength, 0f, 0f,</ins>
					<ins>lightBaking.occlusionMaskChannel</ins>
				<ins>);</ins>
			<ins>}</ins>
		<ins>}</ins>
		<ins>return new Vector4(0f, 0f, 0f, -1f);</ins>
	<ins>}</ins></pre>
						
						<p>Add a shader property name and array for the shadow data to <code>Lighting</code>.</p>
						
						<pre translate="no">	static int
		otherLightCountId = Shader.PropertyToID("_OtherLightCount"),
		otherLightColorsId = Shader.PropertyToID("_OtherLightColors"),
		otherLightPositionsId = Shader.PropertyToID("_OtherLightPositions"),
		otherLightDirectionsId = Shader.PropertyToID("_OtherLightDirections"),
		otherLightSpotAnglesId = Shader.PropertyToID("_OtherLightSpotAngles")<ins>,</ins>
		<ins>otherLightShadowDataId = Shader.PropertyToID("_OtherLightShadowData")</ins>;

	static Vector4[]
		otherLightColors = new Vector4[maxOtherLightCount],
		otherLightPositions = new Vector4[maxOtherLightCount],
		otherLightDirections = new Vector4[maxOtherLightCount],
		otherLightSpotAngles = new Vector4[maxOtherLightCount]<ins>,</ins>
		<ins>otherLightShadowData = new Vector4[maxOtherLightCount]</ins>;</pre>
						
						<p>Send it to the GPU in <code>SetupLights</code>.</p>
						
						<pre translate="no">			buffer.SetGlobalVectorArray(
				otherLightSpotAnglesId, otherLightSpotAngles
			);
			<ins>buffer.SetGlobalVectorArray(</ins>
				<ins>otherLightShadowDataId, otherLightShadowData</ins>
			<ins>);</ins></pre>
						
						<p>And configure the data in <code>SetupPointLight</code> and <code>SetupSpotLight</code>.</p>
						
						<pre translate="no">	void SetupPointLight (int index, ref VisibleLight visibleLight) {
		&hellip;
		<ins>Light light = visibleLight.light;</ins>
		<ins>otherLightShadowData[index] = shadows.ReserveOtherShadows(light, index);</ins>
	}

	void SetupSpotLight (int index, ref VisibleLight visibleLight) {
		&hellip;
		<ins>otherLightShadowData[index] = shadows.ReserveOtherShadows(light, index);</ins>
	}</pre>
						
						<p>On the shader side, add an <code>OtherShadowData</code> struct and <code>GetOtherShadowAttenuation</code> function to <em translate="no">Shadows</em>. Again we use the same approach as for directional shadows, except that we only have the strength and mask channel. If the strength is positive then we always invoke <code>GetBakedShadow</code>, otherwise there are no shadows.</p>
						
						<pre class="shader" translate="no"><ins>struct OtherShadowData {</ins>
	<ins>float strength;</ins>
	<ins>int shadowMaskChannel;</ins>
<ins>};</ins>

<ins>float GetOtherShadowAttenuation (</ins>
	<ins>OtherShadowData other, ShadowData global, Surface surfaceWS</ins>
<ins>) {</ins>
	<ins>#if !defined(_RECEIVE_SHADOWS)</ins>
		<ins>return 1.0;</ins>
	<ins>#endif</ins>
	
	<ins>float shadow;</ins>
	<ins>if (other.strength > 0.0) {</ins>
		<ins>shadow = GetBakedShadow(</ins>
			<ins>global.shadowMask, other.shadowMaskChannel, other.strength</ins>
		<ins>);</ins>
	<ins>}</ins>
	<ins>else {</ins>
		<ins>shadow = 1.0;</ins>
	<ins>}</ins>
	<ins>return shadow;</ins>
<ins>}</ins></pre>
						
						<p>In <em translate="no">Light</em>, add the shadow data and factor it into the attenuation in <code>GetOtherLight</code>.</p>
						
						<pre class="shader" translate="no">CBUFFER_START(_CustomLight)
	&hellip;
	<ins>float4 _OtherLightShadowData[MAX_OTHER_LIGHT_COUNT];</ins>
CBUFFER_END

&hellip;			

<ins>OtherShadowData GetOtherShadowData (int lightIndex) {</ins>
	<ins>OtherShadowData data;</ins>
	<ins>data.strength = _OtherLightShadowData[lightIndex].x;</ins>
	<ins>data.shadowMaskChannel = _OtherLightShadowData[lightIndex].w;</ins>
	<ins>return data;</ins>
<ins>}</ins>

Light GetOtherLight (int index, Surface surfaceWS, ShadowData shadowData) {
	&hellip;
	
	<ins>OtherShadowData otherShadowData = GetOtherShadowData(index);</ins>
	light.attenuation =
		<ins>GetOtherShadowAttenuation(otherShadowData, shadowData, surfaceWS) *</ins>
		spotAttenuation * rangeAttenuation / distanceSqr;
	return light;
}</pre>
						
						<figure>
							<img src="baked-light-and-shadows/mixed-mode.png" width="420" height="220">
							<figcaption>Point and spot light with baked shadows.</figcaption>
						</figure>
					</section>
					
				</section>
				
				<section>
					<h2>Lights Per Object</h2>
					
					<p>Currently all visible lights are evaluated for every fragment that gets rendered. This is fine for directional lights, but it's unnecessary work for other lights that are out of range of a fragment. Usually each point or spot light only affects a small portion of all fragments, so there's a lot of work done for nothing, which can affect performance significantly. In order to support many lights with good performance we have to somehow reduce the amount of lights are evaluated per fragment. There are multiple approaches for this, of which the simplest is to use Unity's per-object light indices.</p>
					
					<p>The idea is that Unity determines which lights affect each object and sends this information to the GPU. Then we can evaluate only the relevant lights when rendering each object, ignoring the rest. Thus the lights are determined on a per-object basis, not per fragment. This usually works fine for small objects but isn't ideal for large ones, because if a light only affects a small portion of an object it will get evaluated for its entire surface. Also, there is a limit to how many lights can affect each object, so large objects are more prone to lack some lighting.</p>
					
					<p>Because per-object light indices aren't ideal and can miss some lighting we'll make it optional. That way it's also possible to easily compare both visuals and performance.</p>
					
					<aside>
						<h3>Didn't Unity's per-object light indices code break a lot?</h3>
						<div>
							<p>Yes, it's been broken a few times since Unity 2018, sometimes for months, causing many bugs. That's another reasons to make it optional.</p>
						</div>
					</aside>
					
					<section>
						<h3>Per-Object Light Data</h3>
						
						<p>Add a boolean parameter to <code>CameraRenderer.DrawVisibleGeometry</code> to indicate whether lights-per-object mode should be used. If so, enable the <code>PerObjectData.LightData</code> and <code>PerObjectData.LightIndices</code> flags for the per-object data of the drawing settings.</p>
						
						<pre translate="no">	void DrawVisibleGeometry (
		bool useDynamicBatching, bool useGPUInstancing<ins>, bool useLightsPerObject</ins>
	) {
		<ins>PerObjectData lightsPerObjectFlags = useLightsPerObject ?</ins>
			<ins>PerObjectData.LightData | PerObjectData.LightIndices :</ins>
			<ins>PerObjectData.None;</ins>
		var sortingSettings = new SortingSettings(camera) {
			criteria = SortingCriteria.CommonOpaque
		};
		var drawingSettings = new DrawingSettings(
			unlitShaderTagId, sortingSettings
		) {
			enableDynamicBatching = useDynamicBatching,
			enableInstancing = useGPUInstancing,
			perObjectData =
				PerObjectData.ReflectionProbes |
				PerObjectData.Lightmaps | PerObjectData.ShadowMask |
				PerObjectData.LightProbe | PerObjectData.OcclusionProbe |
				PerObjectData.LightProbeProxyVolume |
				PerObjectData.OcclusionProbeProxyVolume <ins>|</ins>
				<ins>lightsPerObjectFlags</ins>
		};
		&hellip;
	}</pre>
						
						<p>The same parameter must be added to <code>Render</code>, so it can be passed to <code>DrawVisibleGeometry</code>.</p>
						
						<pre translate="no">	public void Render (
		ScriptableRenderContext context, Camera camera,
		bool useDynamicBatching, bool useGPUInstancing, <ins>bool useLightsPerObject,</ins>
		ShadowSettings shadowSettings
	) {
		&hellip;
		DrawVisibleGeometry(
			useDynamicBatching, useGPUInstancing<ins>, useLightsPerObject</ins>
		);
		&hellip;
	}</pre>
						
						<p>And we must also keep track of and pass along the mode in <code>CustomRenderPipeline</code>, like the other boolean options.
						
						<pre translate="no">	bool useDynamicBatching, useGPUInstancing<ins>, useLightsPerObject</ins>;

	ShadowSettings shadowSettings;

	public CustomRenderPipeline (
		bool useDynamicBatching, bool useGPUInstancing, bool useSRPBatcher,
		<ins>bool useLightsPerObject,</ins> ShadowSettings shadowSettings
	) {
		this.shadowSettings = shadowSettings;
		this.useDynamicBatching = useDynamicBatching;
		this.useGPUInstancing = useGPUInstancing;
		<ins>this.useLightsPerObject = useLightsPerObject;</ins>
		&hellip;
	}

	protected override void Render (
		ScriptableRenderContext context, Camera[] cameras
	) {
		foreach (Camera camera in cameras) {
			renderer.Render(
				context, camera,
				useDynamicBatching, useGPUInstancing, <ins>useLightsPerObject,</ins>
				shadowSettings
			);
		}
	}</pre>
						
						<p>Finally, add the toggle option to <code>CustomRenderPipelineAsset</code>.</p>
						
						<pre translate="no">	[SerializeField]
	bool
		useDynamicBatching = true,
		useGPUInstancing = true,
		useSRPBatcher = true<ins>,</ins>
		<ins>useLightsPerObject = true</ins>;

	[SerializeField]
	ShadowSettings shadows = default;

	protected override RenderPipeline CreatePipeline () {
		return new CustomRenderPipeline(
			useDynamicBatching, useGPUInstancing, useSRPBatcher,
			<ins>useLightsPerObject,</ins> shadows
		);
	}</pre>
						
						<figure>
							<img src="lights-per-object/lights-per-object-toggle.png" width="320" height="38">
							<figcaption>Lights per object enabled.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Sanitizing Light Indices</h3>
						
						<p>Unity simply creates a list of all active lights per object, roughly sorted by their importance. This list includes all lights regardless of their visibility and also contains directional lights. We have to sanitize these lists so only the indices of visible non-directional lights remain. We do this in <code>Lighting.SetupLights</code>, so add a lights-per-object parameter to that method, and to <code>Lighting.Setup</code> to pass it along.</p>
						
						<pre translate="no">	public void Setup (
		ScriptableRenderContext context, CullingResults cullingResults,
		ShadowSettings shadowSettings<ins>, bool useLightsPerObject</ins>
	) {
		&hellip;
		SetupLights(<ins>useLightsPerObject</ins>);
		&hellip;
	}

	&hellip;

	void SetupLights (<ins>bool useLightsPerObject</ins>) { &hellip; }</pre>
						
						<p>Then add the mode as an argument for <code>Setup</code> in <code>CameraRenderer.Render</code>.</p>
						
						<pre translate="no">		lighting.Setup(
			context, cullingResults, shadowSettings<ins>, useLightsPerObject</ins>
		);</pre>
						
						<p>In <code>Lighting.SetupLights</code>, before we loop to the visible lights, retrieve the light index map from the culling results. This is done by invoking <code>GetLightIndexMap</code> with <code>Allocator.Temp</code> as an argument, which gives us a temporary <code>NativeArray&lt;int></code> that contains light indices, matching the visible light indices plus all other active lights in the scene.</p>
						
						<pre translate="no">		<ins>NativeArray&lt;int> indexMap =</ins>
			<ins>cullingResults.GetLightIndexMap(Allocator.Temp);</ins>
		NativeArray&lt;VisibleLight> visibleLights = cullingResults.visibleLights;</pre>
						
						<p>We only need to retrieve this data  when we use lights per object. As the native array is a struct we initialize it to its default value otherwise, which doesn't allocate anything.</p>
						
						<pre translate="no">		NativeArray&lt;int> indexMap = <ins>useLightsPerObject ?</ins>
			cullingResults.GetLightIndexMap(Allocator.Temp) <ins>: default;</ins></pre>
						
						<p>We only need the indices for point and spot lights that we include, all other lights should be skipped. We communicate this to Unity by setting the indices off all other lights to &minus;1. We also have to change the indices of the remaining lights to match ours. Set the new index only if we retrieved the map.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; visibleLights.Length; i++) {
			<ins>int newIndex = -1;</ins>
			VisibleLight visibleLight = visibleLights[i];
			switch (visibleLight.lightType) {
				&hellip;
				case LightType.Point:
					if (otherLightCount &lt; maxOtherLightCount) {
						<ins>newIndex = otherLightCount;</ins>
						SetupPointLight(otherLightCount++, ref visibleLight);
					}
					break;
				case LightType.Spot:
					if (otherLightCount &lt; maxOtherLightCount) {
						<ins>newIndex = otherLightCount;</ins>
						SetupSpotLight(otherLightCount++, ref visibleLight);
					}
					break;
			}
			<ins>if (useLightsPerObject) {</ins>
				<ins>indexMap[i] = newIndex;</ins>
			<ins>}</ins>
		}</pre>
						
						<p>We also have to eliminate the indices of all lights that aren't visible. Do this with a second loop that continues after the first one, if we use lights per object.</p>
						
						<pre translate="no">		<ins>int i;</ins>
		for (<ins>i = 0</ins>; i &lt; visibleLights.Length; i++) {
			&hellip;
		}

		<ins>if (useLightsPerObject) {</ins>
			<ins>for (; i &lt; indexMap.Length; i++) {</ins>
				<ins>indexMap[i] = -1;</ins>
			<ins>}</ins>
		<ins>}</ins></pre>
						
						<p>When we're done we have to send the adjusted index map back to Unity, by invoking <code>SetLightIndexMap</code> on the culling results. The index map is no longer needed after that, so we should deallocate it by invoking <code>Dispose</code> on it.</p>
						
						<pre translate="no">		<ins>if (useLightsPerObject) {</ins>
			for (; i &lt; indexMap.Length; i++) {
				indexMap[i] = -1;
			}
			<ins>cullingResults.SetLightIndexMap(indexMap);</ins>
			<ins>indexMap.Dispose();</ins>
		<ins>}</ins></pre>
						
						<p>Finally, we'll use a different shader variant when lights per object are used. We signal this by enabling or disabling the <em translate="no">_LIGHTS_PER_OBJECT</em> shader keyword, as appropriate.</p>
						
						<pre translate="no">	<ins>static string lightsPerObjectKeyword = "_LIGHTS_PER_OBJECT";</ins>
	
	&hellip;
	
	void SetupLights (bool useLightsPerObject) {
		&hellip;

		if (useLightsPerObject) {
			for (; i &lt; indexMap.Length; i++) {
				indexMap[i] = -1;
			}
			cullingResults.SetLightIndexMap(indexMap);
			indexMap.Dispose();
			<ins>Shader.EnableKeyword(lightsPerObjectKeyword);</ins>
		}
		<ins>else {</ins>
			<ins>Shader.DisableKeyword(lightsPerObjectKeyword);</ins>
		<ins>}</ins>
		
		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Using the Indices</h3>
						
						<p>To use the light indices, add the relevant multi-compile pragma to the <em translate="no">CustomLit</em> pass of our <em translate="no">Lit</em> shader.</p>
						
						<pre class="shader" translate="no">			<ins>#pragma multi_compile _ _LIGHTS_PER_OBJECT</ins></pre>
						
						<p>The required data is part of the <code class="shader">UnityPerDraw</code> buffer and consists of two <code class="shader">real4</code> values that must be defined directly after <code class="shader">unity_WorldTransformParams</code>. First is <code class="shader">unity_LightData</code>, which contains the amount of lights in its Y component. After that comes <code class="shader">unity_LightIndices</code>, which is an array of length two. Each channel of the two vectors contains a light index, so up to eight are supported per object.</p>
						
						<pre class="shader" translate="no">	real4 unity_WorldTransformParams;

	<ins>real4 unity_LightData;</ins>
	<ins>real4 unity_LightIndices[2];</ins></pre>
						
						<p>Use an alternative loop for the other lights in <code class="shader">GetLighting</code> if <em translate="no">_LIGHTS_PER_OBJECT</em> is defined. In this case the amount of lights is found via <code class="shader">unity_LightData.y</code> and the light index has to be retrieved from the appropriate element and component of <code class="shader">unity_LightIndices</code>. We can get the correct vector by dividing the iterator by 4 and the correct component via modulo 4.</p>
						
						<pre class="shader" translate="no">	<ins>#if defined(_LIGHTS_PER_OBJECT)</ins>
		<ins>for (int j = 0; j &lt; unity_LightData.y; j++) {</ins>
			<ins>int lightIndex = unity_LightIndices[j / 4][j % 4];</ins>
			<ins>Light light = GetOtherLight(lightIndex, surfaceWS, shadowData);</ins>
			<ins>color += GetLighting(surfaceWS, brdf, light);</ins>
		<ins>}</ins>
	<ins>#else</ins>
		for (int j = 0; j &lt; GetOtherLightCount(); j++) {
			Light light = GetOtherLight(j, surfaceWS, shadowData);
			color += GetLighting(surfaceWS, brdf, light);
		}
	<ins>#endif</ins></pre>
						
						<p>However, although only up to eight light indices are available the provided light count doesn't take this limit into consideration. So we have to limit the loop to eight iterations explicitly.</p>
						
						<pre class="shader" translate="no">		for (int j = 0; j &lt; <ins>min(</ins>unity_LightData.y<ins>, 8)</ins>; j++) { &hellip; }</pre>
						
						<p>At this point the shader compiler might complain that the integer division and modulo operations are slow, at least when compiling for D3D. The unsigned equivalent operations are more efficient. We can signal that the value's sign can be ignored by casting <code class="shader">j</code> to <code class="shader">uint</code> when performing the operations.</p>
						
						<pre class="shader" translate="no">			int lightIndex = unity_LightIndices[<ins>(uint)</ins>j / 4][<ins>(uint)</ins>j % 4];</pre>
						
						<aside>
							<h3>Isn't there a buffered approach that isn't limited to eight lights per object?</h3>
							<div>
								<p>There was, but that code has been disabled since Unity 2018.3 and has been partially removed from the Universal RP. It's been dead code for more than a year, so I wouldn't rely on it.</p>
							</div>
						</aside>
						
						<figure>
							<img src="lights-per-object/all-lights.png" width="420" height="200" alt="all"><br>
							<img src="lights-per-object/max-8-per-object.png" width="420" height="200" alt="max 8">
							<figcaption>Lights-per-object disabled and enabled.</figcaption>
						</figure>
						
						<p>Note that with lights-per-object enabled GPU instancing is less efficient, because only objects whose light counts and index lists match are grouped. The SRP batcher isn't affected, because each object still gets its own optimized draw call.</p>
						
						<p>The next tutorial is <a href="../point-and-spot-shadows/index.html">Point and Spot Shadows</a>.</p>
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/custom-srp-09-point-and-spot-lights/" class="repository">repository</a>
					<a href="Point-and-Spot-Lights.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>