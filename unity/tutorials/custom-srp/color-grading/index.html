<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/custom-srp/color-grading/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/custom-srp/color-grading/tutorial-image.jpg">
		<meta property="og:title" content="Color Grading">
		<meta property="og:description" content="A Unity Custom SRP tutorial about adding various tools for color grading.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Color Grading</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/custom-srp/color-grading/#article",
				"headline": "Color Grading",
				"alternativeHeadline": "Playing with Colors",
				"datePublished": "2020-09-29",
				"dateModified": "2020-11-27",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Custom SRP tutorial about adding various tools for color grading.",
				"image": "https://catlikecoding.com/unity/tutorials/custom-srp/color-grading/tutorial-image.jpg",
				"dependencies": "Unity 2019.4.10f1",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/custom-srp/", "name": "Custom SRP" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				BloomSettings: 1,
				CameraRenderer: 1,
				CascadeBlendMode: 1,
				ChannelMixerSettings: 1,
				ColorAdjustmentsSettings: 1,
				ColorLUTResolution: 1,
				CustomLightEditor: 1,
				CustomRenderPipeline: 1,
				CustomRenderPipelineAsset: 1,
				CustomShaderGUI: 1,
				Directional: 1,
				DirectionalShadowData: 1,
				FilterMode: 1,
				InputConfig: 1,
				Lighting: 1,
				MeshBall: 1,
				Mode: 1,
				Other: 1,
				OtherShadowData: 1,
				Pass: 1,
				PerObjectMaterialProperties: 1,
				PostFXSettings: 1,
				PostFXStack: 1,
				ShadowedDirLight: 1,
				ShadowedOtherLight: 1,
				ShadowData: 1,
				Shadows: 1,
				ShadowsMidtonesHighlightsSettings: 1,
				ShadowMask: 1,
				ShadowMode: 1,
				ShadowSettings: 1,
				SplitToningSettings: 1,
				TextureSize: 1,
				ToneMappingSettings: 1,
				WhiteBalanceSettings: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Custom SRP</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Color Grading</h1>
					<p>Playing with Colors</p>
					<ul>
						<li>Perform color grading.</li>
						<li>Duplicate multiple URP/HDRP color grading tools.</li>
						<li>Use a color LUT.</li>
					</ul>
				</header>
				
				<p>This is the 13th part of a tutorial series about creating a <a href="../index.html">custom scriptable render pipeline</a>. This time we'll add various tools for color grading.</p>
				
				<p>This tutorial is made with Unity 2019.4.10f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Tweaking colors to create a mood.</figcaption>
				</figure>
				
				<section>
					<h2>Color Adjustments</h2>
					
					<p>Currently we only apply tone mapping to the final image, to bring HDR colors in visible LDR range. But this is not the only reason to adjust the colors of an image. There are roughly three steps of color adjustments for video, photos, and digital images. First comes color correction, which aims to make the image match what we would see if we observed the scene, compensating for the limitations of the medium. Second comes color grading, which is about achieving a desired look or feel that doesn't match the original scene and needn't be realistic. These two steps are often merged into one color grading step. After that comes tone mapping, to map HDR colors to the display range.</p>
					
					<p>With only tone mapping applied the image tends to become less colorful except when it's very bright. ACES increases the contrast of dark colors a bit, but it's no substitute for color grading. This tutorial uses neutral tone mapping as a basis.</p>
					
					<figure>
						<img src="color-adjustments/without-adjustments.png" width="320" height="200">
						<figcaption>Image without color adjustments, neutral tone mapping.</figcaption>
					</figure>
					
					<section>
						<h3>Color Grading Before Tone Mapping</h3>
						
						<p>Color grading happens before tone mapping. Add a function for it to <em>PostFXStackPasses</em>, before the tone mapping passes. Initially only have it limit the color components to 60.</p>
						
						<pre class="shader"><ins>float3 ColorGrade (float3 color) {</ins>
	<ins>color = min(color, 60.0);</ins>
	<ins>return color;</ins>
<ins>}</ins></pre>
						
						<p>Invoke this function in the tone mapping passes instead of limiting the color there. Also add a new pass for no tone mapping, but with color grading.</p>
						
						<pre class="shader"><ins>float4 ToneMappingNonePassFragment (Varyings input) : SV_TARGET {</ins>
	<ins>float4 color = GetSource(input.screenUV);</ins>
	<ins>color.rgb = ColorGrade(color.rgb);</ins>
	<ins>return color;</ins>
<ins>}</ins>

float4 ToneMappingACESPassFragment (Varyings input) : SV_TARGET {
	float4 color = GetSource(input.screenUV);
	color.rgb = <ins>ColorGrade(color.rgb);</ins>
	color.rgb = AcesTonemap(unity_to_ACES(color.rgb));
	return color;
}

float4 ToneMappingNeutralPassFragment (Varyings input) : SV_TARGET {
	float4 color = GetSource(input.screenUV);
	color.rgb = <ins>ColorGrade(color.rgb);</ins>
	color.rgb = NeutralTonemap(color.rgb);
	return color;
}

float4 ToneMappingReinhardPassFragment (Varyings input) : SV_TARGET {
	float4 color = GetSource(input.screenUV);
	color.rgb = <ins>ColorGrade(color.rgb);</ins>
	color.rgb /= color.rgb + 1.0;
	return color;
}</pre>
						
						<p>Add the same pass to the shader and the <code>PostFXStack.Pass</code> enum, before the other tone mapping passes. Then adjust <code>PostFXStack.DoToneMapping</code> so the <em>None</em> mode uses its own pass instead of <em>Copy</em>.</p>
						
						<pre>	void DoToneMapping(int sourceId) {
		PostFXSettings.ToneMappingSettings.Mode mode = settings.ToneMapping.mode;
		Pass pass = <ins>Pass.ToneMappingNone + (int)mode</ins>;
		Draw(sourceId, BuiltinRenderTextureType.CameraTarget, pass);
	}</pre>
						
						<p>The <code>ToneMappingSettings.Mode</code> enum must now start at zero.</p>
						
						<pre>	public struct ToneMappingSettings {

		public enum Mode { <ins>None</ins>, ACES, Neutral, Reinhard }

		public Mode mode;
	}</pre>
					</section>
					
					<section>
						<h3>Settings</h3>
						
						<p>We're going to copy the functionality of the <em>Color Adjustments</em> post-processing tool of URP and HDRP. The first step is to add a configuration struct for it to <code>PostFXSettings</code>. I added <code>using System</code> because we'll need to add the <code>Serializable</code> attribute a bunch more times.</p>
						
						<pre><ins>using System;</ins>
using UnityEngine;

[CreateAssetMenu(menuName = "Rendering/Custom Post FX Settings")]
public class PostFXSettings : ScriptableObject {

	&hellip;

	<ins>[Serializable]</ins>
	<ins>public struct ColorAdjustmentsSettings {}</ins>

	<ins>[SerializeField]</ins>
	<ins>ColorAdjustmentsSettings colorAdjustments = default;</ins>

	<ins>public ColorAdjustmentsSettings ColorAdjustments => colorAdjustments;</ins>

	&hellip;
}</pre>
						
						<p>The color grading functionality of URP and HDRP is identical. We'll add the same configuration options for color grading, in the same order. First is <em>Post Exposure</em>, an unconstrained float. After that comes <em>Contrast</em>, a slider going from &minus;100 to 100. The next option is <em>Color Filter</em>, which is an HDR color without alpha. Next up is <em>Hue Shift</em>, another slider but going from &minus;180&deg; to +180&deg;. The last option is <em>Saturation</em>, again a slider from &minus;100 to 100.</p>
						
						<pre>	public struct ColorAdjustmentsSettings {

		<ins>public float postExposure;</ins>

		<ins>[Range(-100f, 100f)]</ins>
		<ins>public float contrast;</ins>

		<ins>[ColorUsage(false, true)]</ins>
		<ins>public Color colorFilter;</ins>

		<ins>[Range(-180f, 180f)]</ins>
		<ins>public float hueShift;</ins>

		<ins>[Range(-100f, 100f)]</ins>
		<ins>public float saturation;</ins>
	}</pre>
						
						<p>The default values are all zero, except the color filter should be white. These settings won't change the image.</p>
						
						<pre>	ColorAdjustmentsSettings colorAdjustments = <ins>new ColorAdjustmentsSettings {</ins>
		<ins>colorFilter = Color.white</ins>
	<ins>}</ins>;</pre>
						
						<figure>
							<img src="color-adjustments/settings.png" width="320" height="160">
							<figcaption>Settings for color adjustments.</figcaption>
						</figure>
						
						<p>We're doing color grading and tone mapping at the same time, so refactor rename <code>PostFXStack.DoToneMapping</code> to <code>DoColorGradingAndToneMapping</code>. We'll also be accessing the inner types of <code>PostFXSettings</code> a lot here, so let's add <code>using static PostFXSettings</code> to keep the code shorter. Then add a <code>ConfigureColorAdjustments</code> method in which we grab the color adjustment settings and invoke it at the start of <code>DoColorGradingAndToneMapping</code>.</p>
						
						<pre>using UnityEngine;
using UnityEngine.Rendering;
<ins>using static PostFXSettings;</ins>

public partial class PostFXStack {
	
	&hellip;
	
	<ins>void ConfigureColorAdjustments () {</ins>
		<ins>ColorAdjustmentsSettings colorAdjustments = settings.ColorAdjustments;</ins>
	<ins>}</ins>

	void <ins>DoColorGradingAndToneMapping</ins> (int sourceId) {
		<ins>ConfigureColorAdjustments();</ins>

		<ins>ToneMappingSettings</ins>.Mode mode = settings.ToneMapping.mode;
		Pass pass = Pass.ToneMappingNone + (int)mode;
		Draw(sourceId, BuiltinRenderTextureType.CameraTarget, pass);
	}
	
	&hellip;
}</pre>
						
						<aside>
							<h3>What does <code>using static</code> do?</h3>
							<div>
								<p>It's similar to using a namespace, but for a type. It makes all constant, static, and type members of a class or struct directly accessible without fully qualifying them.</p>
							</div>
						</aside>
						
						<p>We can suffice with setting a shader vector and color for the color adjustments. The color adjustments vector components are the exposure, contrast, hue shift, and saturation. Exposure is measured in stops, which means that we have to raise 2 to the power of the configured exposure value. Also convert contrast and saturation to the 0&ndash;2 range and hue shift to &minus;1&ndash;1. The filter must be in linear linear color space.</p>
						
						<p>I won't show the addition of the accompanying shader property identifiers.</p>
						
						<pre>		ColorAdjustmentsSettings colorAdjustments = settings.ColorAdjustments;
		<ins>buffer.SetGlobalVector(colorAdjustmentsId, new Vector4(</ins>
			<ins>Mathf.Pow(2f, colorAdjustments.postExposure),</ins>
			<ins>colorAdjustments.contrast * 0.01f + 1f,</ins>
			<ins>colorAdjustments.hueShift * (1f / 360f),</ins>
			<ins>colorAdjustments.saturation * 0.01f + 1f</ins>
		<ins>));</ins>
		<ins>buffer.SetGlobalColor(colorFilterId, colorAdjustments.colorFilter.linear);</ins></pre>
						
					</section>
					
					<section>
						<h3>Post Exposure</h3>
						
						<p>On the shader side, add the vector and color. We'll put every adjustment in its own function and start with the post exposure. Create a <code class="shader">ColorGradePostExposure</code> function that multiplies the color with the exposure value. Then apply exposure in <code class="shader">ColorGrade</code> after limiting the color.</p>
						
						<pre class="shader"><ins>float4 _ColorAdjustments;</ins>
<ins>float4 _ColorFilter;</ins>

<ins>float3 ColorGradePostExposure (float3 color) {</ins>
	<ins>return color * _ColorAdjustments.x;</ins>
<ins>}</ins>

float3 ColorGrade (float3 color) {
	color = min(color, 60.0);
	<ins>color = ColorGradePostExposure(color);</ins>
	return color;
}</pre>
						
						<figure>
							<img src="color-adjustments/post-exposure-minus-2.png" width="320" height="200" alt="minus 2">
							<img src="color-adjustments/post-exposure-plus-2.png" width="320" height="200" alt="plus 2">
							<figcaption>Post exposure &minus;2 and 2.</figcaption>
						</figure>
						
						<p>The idea of post-exposure is that it mimics a camera's exposure, but is applied after all other post-effects, immediately before all other color grading. It is a nonrealistic artistic tool that can be used to tweak exposure without influencing other effects, like bloom.</p>
					</section>
					
					<section>
						<h3>Contrast</h3>
						
						<p>The second adjustment is contrast. We apply it by subtracting uniform mid gray from the color, then scaling by the contrast, and adding mid gray to that. Use <code class="shader">ACEScc_MIDGRAY</code> for the gray color.</p>
						
						<aside>
							<h3>What's ACEScc?</h3>
							<div>
								<p>ACEScc is a logarithmic subset of ACES color space. The mid gray value is 0.4135884.</p>
							</div>
						</aside>
						
						<pre class="shader"><ins>float3 ColorGradingContrast (float3 color) {</ins>
	<ins>return (color - ACEScc_MIDGRAY) * _ColorAdjustments.y + ACEScc_MIDGRAY;</ins>
<ins>}</ins>

float3 ColorGrade (float3 color) {
	color = min(color, 60.0);
	color = ColorGradePostExposure(color);
	<ins>color = ColorGradingContrast(color);</ins>
	return color;
}</pre>
						
						<p>For best results this coversion is done in Log C instead of linear color space. We can convert from linear to Log C with the <code class="shader">LinearToLogC</code> function from the <em>Color</em> Core Library file and back with the <code class="shader">LogCToLinear</code> function.</p>
						
						<pre class="shader">float3 ColorGradingContrast (float3 color) {
	<ins>color = LinearToLogC(color);</ins>
	<ins>color =</ins> (color - ACEScc_MIDGRAY) * _ColorAdjustments.y + ACEScc_MIDGRAY;
	return <ins>LogCToLinear(color);</ins>
}</pre>
						
						<figure>
							<img src="color-adjustments/logc.png" width="160" height="200" alt="minus 50">
							<figcaption>Linear and Log C.</figcaption>
						</figure>
						
						<p>When contrast is increased this can lead to negative color components, which can mess up later adjustments. So eliminate negative values after adjusting contrast in <code class="shader">ColorGrade</code>.</p>
						
						<pre class="shader">	color = ColorGradingContrast(color);
	<ins>color = max(color, 0.0);</ins></pre>
						
						<figure>
							<img src="color-adjustments/contrast-minus-50.png" width="320" height="200" alt="minus 50">
							<img src="color-adjustments/contrast-plus-50.png" width="320" height="200" alt="plus 50">
							<figcaption>Contrast &minus;50 and 50.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Color Filter</h3>
						
						<p>The color filter comes next, simply multiply it with the color. It works fine with for negative values, so we can apply it before eliminating them.</p>
						
						<pre class="shader"><ins>float3 ColorGradeColorFilter (float3 color) {</ins>
	<ins>return color * _ColorFilter.rgb;</ins>
<ins>}</ins>

float3 ColorGrade (float3 color) {
	color = min(color, 60.0);
	color = ColorGradePostExposure(color);
	color = ColorGradingContrast(color);
	<ins>color = ColorGradeColorFilter(color);</ins>
	color = max(color, 0.0);
	return color;
}</pre>
						
						<figure>
							<img src="color-adjustments/color-filter.png" width="320" height="200">
							<figcaption>Light cyan color filter, eliminating most red light.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Hue Shift</h3>
						
						<p>URP and HDRP perform the hue shift after the color filter and we'll use the same adjustment order. The color's hue is adjusted by converting the color format from RGB to HSV via <code class="shader">RgbToHsv</code>, adding the hue shift to H, and converting back via <code class="shader">HsvToRgb</code>. Because hue is defined on a 0&ndash;1 color wheel we have to wrap it around if it goes out of range. We can use <code class="shdaer">RotateHue</code> for that, passing it the adjusted hue, zero, and 1 as arguments. This must happen after negative values are eliminated.</p>
						
						<pre class="shader"><ins>float3 ColorGradingHueShift (float3 color) {</ins>
	<ins>color = RgbToHsv(color);</ins>
	<ins>float hue = color.x + _ColorAdjustments.z;</ins>
	<ins>color.x = RotateHue(hue, 0.0, 1.0);</ins>
	<ins>return HsvToRgb(color);</ins>
<ins>}</ins>

float3 ColorGrade (float3 color) {
	color = min(color, 60.0);
	color = ColorGradePostExposure(color);
	color = ColorGradingContrast(color);
	color = ColorGradeColorFilter(color);
	color = max(color, 0.0);
	<ins>color = ColorGradingHueShift(color);</ins>
	return color;
}</pre>
						
						<figure>
							<img src="color-adjustments/hue-shift.png" width="320" height="200">
							<figcaption>180&deg; hue shift.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Saturation</h3>
						
						<p>The last adjustment is saturation. First get the color's luminance with help of the <code class="shader">Luminance</code> function. The result is then calculated like contrast, except with luminance instead of mid gray and not in Log C. This can again produce negative values, so remove those from the final result of <code class="shader">ColorGrade</code>.</p>
						
						<pre class="shader"><ins>float3 ColorGradingSaturation (float3 color) {</ins>
	<ins>float luminance = Luminance(color);</ins>
	<ins>return (color - luminance) * _ColorAdjustments.w + luminance;</ins>
<ins>}</ins>

float3 ColorGrade (float3 color) {
	color = min(color, 60.0);
	color = ColorGradePostExposure(color);
	color = ColorGradingContrast(color);
	color = ColorGradeColorFilter(color);
	color = max(color, 0.0);
	color = ColorGradingHueShift(color);
	<ins>color = ColorGradingSaturation(color);</ins>
	return <ins>max(</ins>color<ins>, 0.0)</ins>;
}</pre>
						
						<figure>
							<img src="color-adjustments/saturation-minus-100.png" width="320" height="200" alt="minus 100">
							<img src="color-adjustments/saturation-plus-100.png" width="320" height="200" alt="plus 100">
							<figcaption>Saturation &minus;100 and 100.</figcaption>
						</figure>
					</section>
					
				</section>
				
				<section>
					<h2>More Controls</h2>
					
					<p>The color adjustments tool isn't the only color grading option offered by URP and HDRP. We'll add support for a few more, once again copying Unity's approach.</p>
					
					<section>
						<h3>White Balance</h3>
						
						<p>The white balance tool makes it possible to adjust the perceived temperature of the image. It has two sliders for the &minus;100&ndash;100 range. The first is <em>Temperature</em>, for making the image cooler or warmer. The second is <em>Tint</em>, used for tweaking the temperature-shifted color. Add a settings struct for it to <code>PostFXSettings</code>, with zeros as defaults.</p>
						
						<pre>	<ins>[Serializable]</ins>
	<ins>public struct WhiteBalanceSettings {</ins>

		<ins>[Range(-100f, 100f)]</ins>
		<ins>public float temperature, tint;</ins>
	<ins>}</ins>

	<ins>[SerializeField]</ins>
	<ins>WhiteBalanceSettings whiteBalance = default;</ins>

	<ins>public WhiteBalanceSettings WhiteBalance => whiteBalance;</ins></pre>
						
						<figure>
							<img src="more-controls/white-balance-settings.png" width="320" height="82">
							<figcaption>White balance settings.</figcaption>
						</figure>
						
						<p>We can suffice with a single vector shader property, which we can get by invoking <code>ColorUtils.ColorBalanceToLMSCoeffs</code> from the Core Library, passing it the temperature and tint. Set it in a dedicated configuration method in <code>PostFXStack</code> and invoke if after <code>ConfigureColorAdjustments</code> in <code>DoColorGradingAndToneMapping</code>.</p>
						
						<pre>	<ins>void ConfigureWhiteBalance () {</ins>
		<ins>WhiteBalanceSettings whiteBalance = settings.WhiteBalance;</ins>
		<ins>buffer.SetGlobalVector(whiteBalanceId, ColorUtils.ColorBalanceToLMSCoeffs(</ins>
			<ins>whiteBalance.temperature, whiteBalance.tint</ins>
		<ins>));</ins>
	<ins>}</ins>
	
	void DoColorGradingAndToneMapping (int sourceId) {
		ConfigureColorAdjustments();
		<ins>ConfigureWhiteBalance();</ins>

		&hellip;
	}</pre>
						
						<p>On the shader side we apply the white balance by multiplying the color with the vector in LMS color space. We can convert to LMS and back using the <code class="shader">LinearToLMS</code> and <code class="shader">LMSToLinear</code> functions. Apply it after post exposure and before contrast.</p>
						
						<pre class="shader">float4 _ColorAdjustments;
float4 _ColorFilter;
<ins>float4 _WhiteBalance;</ins>

float3 ColorGradePostExposure (float3 color) { &hellip; }

<ins>float3 ColorGradeWhiteBalance (float3 color) {</ins>
	<ins>color = LinearToLMS(color);</ins>
	<ins>color *= _WhiteBalance.rgb;</ins>
	<ins>return LMSToLinear(color);</ins>
<ins>}</ins>

&hellip;

float3 ColorGrade (float3 color) {
	color = min(color, 60.0);
	color = ColorGradePostExposure(color);
	<ins>color = ColorGradeWhiteBalance(color);</ins>
	color = ColorGradingContrast(color);
	&hellip;
}</pre>
						
						<aside>
							<h3>What's LMS color space?</h3>
							<div>
								<p>It describes colors as the responses of the three photoreceptor cone types in the human eye.</p>
							</div>
						</aside>
						
						<p>A cold temperature makes the image blue, while a warm temperature makes it yellow. Typically small adjustments are used, but I show extreme values to make the effect obvious.</p>
						
						<figure>
							<img src="more-controls/temperature-minus-100.png" width="320" height="200" alt="minus 100">
							<img src="more-controls/temperature-plus-100.png" width="320" height="200" alt="plus 100">
							<figcaption>Temperature &minus;100 and 100.</figcaption>
						</figure>
						
						<p>The tint can be used to compensate for undesired color balance, pushing the image toward either green or magenta.</p>
						
						<figure>
							<img src="more-controls/tint-minus-100.png" width="320" height="200" alt="minus 100">
							<img src="more-controls/tint-plus-100.png" width="320" height="200" alt="plus 100">
							<figcaption>Tint &minus;100 and 100.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Split Toning</h3>
						
						<p>The split-toning tool is used to tint shadows and highlights of an image separately. A typical example is to push shadows toward cool blue and highlights toward warm orange.</p>
						
						<p>Create a settings struct for it with a two LDR colors without alpha, for shadows and highlights. Their default is gray. Also include a balance &minus;100&ndash;100 slider, with zero as default.</p>
						
						<pre>	<ins>[Serializable]</ins>
	<ins>public struct SplitToningSettings {</ins>

		<ins>[ColorUsage(false)]</ins>
		<ins>public Color shadows, highlights;</ins>

		<ins>[Range(-100f, 100f)]</ins>
		<ins>public float balance;</ins>
	<ins>}</ins>

	<ins>[SerializeField]</ins>
	<ins>SplitToningSettings splitToning = new SplitToningSettings {</ins>
		<ins>shadows = Color.gray,</ins>
		<ins>highlights = Color.gray</ins>
	<ins>};</ins>

	<ins>public SplitToningSettings SplitToning => splitToning;</ins></pre>
						
						<figure>
							<img src="more-controls/split-toning-settings.png" width="320" height="102">
							<figcaption>Split toning settings.</figcaption>
						</figure>
						
						<p>Send both colors to the shader in <code>PostFXStack</code>, keeping them in gamma space. The balance value can be stored in the fourth component of one of the colors, scaled to the &minus;1&ndash;1 range.</p>
						
						<pre>	<ins>void ConfigureSplitToning () {</ins>
		<ins>SplitToningSettings splitToning = settings.SplitToning;</ins>
		<ins>Color splitColor = splitToning.shadows;</ins>
		<ins>splitColor.a = splitToning.balance * 0.01f;</ins>
		<ins>buffer.SetGlobalColor(splitToningShadowsId, splitColor);</ins>
		<ins>buffer.SetGlobalColor(splitToningHighlightsId, splitToning.highlights);</ins>
	<ins>}</ins>
	
	void DoColorGradingAndToneMapping (int sourceId) {
		ConfigureColorAdjustments();
		ConfigureWhiteBalance();
		<ins>ConfigureSplitToning();</ins>

		&hellip;
	}</pre>
						
						<p>On the shader side we'll perform split-toning in approximate gamma space, raising the color to the inverse of 2.2 beforehand and to 2.2 afterwards. This is done to match the split-toning of Adobe products. The adjustment is made after the color filter, after negative values have been eliminated.</p>
						
						<pre class="shader">float4 _WhiteBalance;
<ins>float4 _SplitToningShadows, _SplitToningHighlights;</ins>

&hellip;

<ins>float3 ColorGradeSplitToning (float3 color) {</ins>
	<ins>color = PositivePow(color, 1.0 / 2.2);</ins>
	<ins>return PositivePow(color, 2.2);</ins>
<ins>}</ins>

&hellip;

float3 ColorGrade (float3 color) {
	&hellip;
	color = ColorGradeColorFilter(color);
	color = max(color, 0.0);
	<ins>color = ColorGradeSplitToning(color);</ins>
	&hellip;
}</pre>
						
						<p>We apply the tones by performing a soft-light blend between the color and the shadows tint, followed by the highlights tint. We can use the <code class="shader">SoftLight</code> function for this, twice.</p>
						
						<pre class="shader">float3 ColorGradeSplitToning (float3 color) {
	color = PositivePow(color, 1.0 / 2.2);
	<ins>float3 shadows = _SplitToningShadows.rgb;</ins>
	<ins>float3 highlights = _SplitToningHighlights.rgb;</ins>
	<ins>color = SoftLight(color, shadows);</ins>
	<ins>color = SoftLight(color, highlights);</ins>
	return PositivePow(color, 2.2);
}</pre>
						
						<p>We limit the tints to their respective regions by interpolating them between neutral 0.5 and themselves before blending. For highlights we do that based on the saturated luminance plus the balance, again saturated. For shadows we use the reverse.</p>
						
						<pre class="shader">	<ins>float t = saturate(Luminance(saturate(color)) + _SplitToningShadows.w);</ins>
	float3 shadows = <ins>lerp(0.5,</ins> _SplitToningShadows.rgb<ins>, 1.0 - t)</ins>;
	float3 highlights = <ins>lerp(0.5,</ins> _SplitToningHighlights.rgb<ins>, t)</ins>;
	color = SoftLight(color, shadows);
	color = SoftLight(color, highlights);</pre>
						
						<figure>
							<img src="more-controls/split-toning-blue-orange.png" width="320" height="200" alt="split toning">
							<img src="color-adjustments/without-adjustments.png" width="320" height="200" alt="neutral">
							<figcaption>Split toning with blue and orange, and without adjustments for comparison.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Channel Mixer</h3>
						
						<p>Another tool that we'll support is the channel mixer. It allows you to combine input RGB values to create a new RGB value. For example, you could swap R and G, subtract B from G, or add G to R to push green toward yellow.</p>
						
						<p>The mixer is essentially a 3&times;3 conversion matrix, with the identity matrix as default. We can use three <code>Vector3</code> values, for the red, green, and blue configuration. Unity's control shows a separate tab per color, with &minus;100&ndash;100 sliders per input channel, but we'll simply display the vectors directly. The rows are for the output colors and the XYZ columns are the RGB inputs.</p>
						
						<pre>	<ins>[Serializable]</ins>
	<ins>public struct ChannelMixerSettings {</ins>

		<ins>public Vector3 red, green, blue;</ins>
	<ins>}</ins>
	
	<ins>[SerializeField]</ins>
	<ins>ChannelMixerSettings channelMixer = new ChannelMixerSettings {</ins>
		<ins>red = Vector3.right,</ins>
		<ins>green = Vector3.up,</ins>
		<ins>blue = Vector3.forward</ins>
	<ins>};</ins>

	<ins>public ChannelMixerSettings ChannelMixer => channelMixer;</ins></pre>
						
						<figure>
							<img src="more-controls/channel-mixer-settings.png" width="320" height="162">
							<figcaption>Channel mixer set to identity matrix.</figcaption>
						</figure>
						
						<p>Send these three vectors to the GPU.</p>
						
						<pre>	<ins>void ConfigureChannelMixer () {</ins>
		<ins>ChannelMixerSettings channelMixer = settings.ChannelMixer;</ins>
		<ins>buffer.SetGlobalVector(channelMixerRedId, channelMixer.red);</ins>
		<ins>buffer.SetGlobalVector(channelMixerGreenId, channelMixer.green);</ins>
		<ins>buffer.SetGlobalVector(channelMixerBlueId, channelMixer.blue);</ins>
	<ins>}</ins>

	void DoColorGradingAndToneMapping (int sourceId) {
		&hellip;
		ConfigureSplitToning();
		<ins>ConfigureChannelMixer();</ins>
		&hellip;
	}</pre>
						
						<p>And perform the matrix multiplication in the shader. Do this after split-toning. Let's eliminate negatives again afterwards, because negative weights could produce negative color channels.</p>
						
						<pre class="shader">float4 _SplitToningShadows, _SplitToningHighlights;
<ins>float4 _ChannelMixerRed, _ChannelMixerGreen, _ChannelMixerBlue;</ins>

&hellip;

<ins>float3 ColorGradingChannelMixer (float3 color) {</ins>
	<ins>return mul(</ins>
		<ins>float3x3(_ChannelMixerRed.rgb, _ChannelMixerGreen.rgb, _ChannelMixerBlue.rgb),</ins>
		<ins>color</ins>
	<ins>);</ins>
<ins>}</ins>

float3 ColorGrade (float3 color) {
	&hellip;
	ColorGradeSplitToning(color);
	<ins>color = ColorGradingChannelMixer(color);</ins>
	<ins>color = max(color, 0.0);</ins>
	color = ColorGradingHueShift(color);
	&hellip;
}</pre>
						
						<figure>
							<img src="more-controls/mixed-channels-inspector.png" width="320" height="140" alt="inspector"><br>
							<img src="more-controls/mixed-channels-scene.png" width="320" height="102" alt="scene">
							<figcaption>Green split between GB and blue split between RGB.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Shadows Midtones Highlights</h3>
						
						<p>The final tool that we'll support is <em>Shadows Midtones Highlights</em>. It works like split-toning, except that it also allows adjustment of the midtones and decouples the shadow and highlight regions, making them configurable.</p>
						
						<p>Unity's control shows color wheels and a visualization of the zone weights, but we'll make do with three HDR color fields and four sliders, for the start and end of the shadow and highlight transition zones. The shadow strength decreases from its start to end, while the highlight strength increases from its start to end. We'll use the 0&ndash;2 range so we can go into HDR a bit. The colors are white by default and we'll use the same zone defaults as Unity, which is 0&ndash;0.3 for shadows and 0.55&ndash;1 for highlights.</p>
						
						<pre>	<ins>[Serializable]</ins>
	<ins>public struct ShadowsMidtonesHighlightsSettings {</ins>

		<ins>[ColorUsage(false, true)]</ins>
		<ins>public Color shadows, midtones, highlights;</ins>

		<ins>[Range(0f, 2f)]</ins>
		<ins>public float shadowsStart, shadowsEnd, highlightsStart, highLightsEnd;</ins>
	<ins>}</ins>

	<ins>[SerializeField]</ins>
	<ins>ShadowsMidtonesHighlightsSettings</ins>
		<ins>shadowsMidtonesHighlights = new ShadowsMidtonesHighlightsSettings {</ins>
			<ins>shadows = Color.white,</ins>
			<ins>midtones = Color.white,</ins>
			<ins>highlights = Color.white,</ins>
			<ins>shadowsEnd = 0.3f,</ins>
			<ins>highlightsStart = 0.55f,</ins>
			<ins>highLightsEnd = 1f</ins>
		<ins>};</ins>

	<ins>public ShadowsMidtonesHighlightsSettings ShadowsMidtonesHighlights =></ins>
		<ins>shadowsMidtonesHighlights;</ins></pre>
						
						<figure>
							<img src="more-controls/shadows-midtones-highlights-settings.png" width="320" height="182">
							<figcaption>Shadows midtones highlights settings.</figcaption>
						</figure>
						
						<aside>
							<h3>Why can't we use color wheels?</h3>
							<div>
								<p>Unity doesn't have a default color wheel editor widget that can be included in an editor. URP and HDRP both contain their own&mdash;though equivalent&mdash;versions. The GUI for the zones is also custom.</p>
							</div>
						</aside>
						
						<p>Send the three colors to the GPU, converted to linear space. The zone ranges can be packed in a single vector.</p>
						
						<pre>	<ins>void ConfigureShadowsMidtonesHighlights () {</ins>
		<ins>ShadowsMidtonesHighlightsSettings smh = settings.ShadowsMidtonesHighlights;</ins>
		<ins>buffer.SetGlobalColor(smhShadowsId, smh.shadows.linear);</ins>
		<ins>buffer.SetGlobalColor(smhMidtonesId, smh.midtones.linear);</ins>
		<ins>buffer.SetGlobalColor(smhHighlightsId, smh.highlights.linear);</ins>
		<ins>buffer.SetGlobalVector(smhRangeId, new Vector4(</ins>
			<ins>smh.shadowsStart, smh.shadowsEnd, smh.highlightsStart, smh.highLightsEnd</ins>
		<ins>));</ins>
	<ins>}</ins>

	void DoColorGradingAndToneMapping (int sourceId) {
		ConfigureColorAdjustments();
		ConfigureWhiteBalance();
		ConfigureSplitToning();
		ConfigureChannelMixer();
		<ins>ConfigureShadowsMidtonesHighlights();</ins>

		&hellip;
	}</pre>
						
						<p>In the shader we multiply the color by the three colors separately, each scaled by their own weight, summing the results. The weights are based on luminance. The shadow weight starts at 1 and decreases to zero between its start and end, using the <code class="shader">smoothstep</code> function. The highlights weight increase from zero to one instead. And the midtones weight is equal to one minus the other two weights. The idea is that the shadows and highlights regions don't overlap&mdash;or just a little&mdash;so the midtones weight will never becomes negative. We don't enforce this in the inspector however, just like we don't enforce that start comes before end.</p>
						
						<pre class="shader">float4 _ChannelMixerRed, _ChannelMixerGreen, _ChannelMixerBlue;
<ins>float4 _SMHShadows, _SMHMidtones, _SMHHighlights, _SMHRange;</ins>

&hellip;

<ins>float3 ColorGradingShadowsMidtonesHighlights (float3 color) {</ins>
	<ins>float luminance = Luminance(color);</ins>
	<ins>float shadowsWeight = 1.0 - smoothstep(_SMHRange.x, _SMHRange.y, luminance);</ins>
	<ins>float highlightsWeight = smoothstep(_SMHRange.z, _SMHRange.w, luminance);</ins>
	<ins>float midtonesWeight = 1.0 - shadowsWeight - highlightsWeight;</ins>
	<ins>return</ins>
		<ins>color * _SMHShadows.rgb * shadowsWeight +</ins>
		<ins>color * _SMHMidtones.rgb * midtonesWeight +</ins>
		<ins>color * _SMHHighlights.rgb * highlightsWeight;</ins>
<ins>}</ins>

float3 ColorGrade (float3 color) {
	&hellip;
	color = ColorGradingChannelMixer(color);
	color = max(color, 0.0);
	<ins>color = ColorGradingShadowsMidtonesHighlights(color);</ins>
	&hellip;
}</pre>
						
						<figure>
							<img src="more-controls/shadows-midtones-highlights-adjusted.png" width="320" height="200">
							<figcaption>Blue shadows, pink midtones, and yellow highlights.</figcaption>
						</figure>
						
						<p>The color wheels of Unity's control work the same, except that they constrain the input colors and allow more precise dragging. Adjust the colors with the HVS color picker mode to somewhat mimic this functionality, without the constraints.</p>
						
						<aside>
							<h3>What about the <em>Color Curves</em> tool and the <em>Lift Gamma Gain</em> tool?</h3>
							<div>
								<p><em>Color Curves</em> is a powerful tool which can be used for many effects, including desaturating everything except a single color. However, it relies on a custom curve editor, which would be a lot of work to reproduce. So it's not included in this tutorial.</p>
								
								<p>Unity's <em>Lift Gamma Gain</em> tool works similar as <em>Shadows Midtones Highlights</em>, but is less intuitive and relies on some conversions before applying a scale-offset-power adjustment to the color. So I only included one of them.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>ACES Color Spaces</h3>
						
						<p>When ACES tone mapping is used Unity performs most color grading in ACES color spaces instead of linear color space, to produce better results. Let's do this as well.</p>
						
						<p>Post exposure and white balance are always applied in linear space. Contrast is where it diverges. Add a boolean <code class="shader">useACES</code> parameter to <code class="shader">ColorGradingContrast</code>. If ACES is used first convert from linear to ACES and then to ACEScc color space instead of to Log C. We can do this via <code class="shader">unity_to_ACES</code> and <code class="shader">ACES_to_ACEScc</code>. Afer adjusting contrast convert to ACEScg via <code class="shader">ACEScc_to_ACES</code> and <code class="shader">ACES_to_ACEScg</code> instead of going back to linear space.</p>
						
						<aside>
							<h3>What's ACEScg?</h3>
							<div>
								<p>ACEScg is a linear subset of ACES color space.</p>
							</div>
						</aside>
						
						<pre class="shader">float3 ColorGradingContrast (float3 color<ins>, bool useACES</ins>) {
	color = <ins>useACES ? ACES_to_ACEScc(unity_to_ACES(color)) :</ins> LinearToLogC(color);
	color = (color - ACEScc_MIDGRAY) * _ColorAdjustments.y + ACEScc_MIDGRAY;
	return <ins>useACES ? ACES_to_ACEScg(ACEScc_to_ACES(color)) :</ins> LogCToLinear(color);
}</pre>
						
						<p>From now on we're either in linear or ACEScg color space after the color grading contrast step. Everything still works the same, except that luminance should be calculated with <code class="shader">AcesLuminance</code> in ACEScg space. Introduce a <code>Luminance</code> function variant that invokes the correct function based on whether ACES is used.</p>
						
						<pre class="shader"><ins>float Luminance (float3 color, bool useACES) {</ins>
	<ins>return useACES ? AcesLuminance(color) : Luminance(color);</ins>
<ins>}</ins></pre>
						
						<p><code class="shader">ColorGradeSplitToning</code> uses luminance, to give it a <code class="shader">useACES</code> parameter and pass it to <code class="shader">Luminance</code>.</p>
						
						<pre class="shader">float3 ColorGradeSplitToning (float3 color<ins>, bool useACES</ins>) {
	color = PositivePow(color, 1.0 / 2.2);
	float t = saturate(Luminance(saturate(color)<ins>, useACES</ins>) + _SplitToningShadows.w);
	&hellip;
}</pre>
						
						<p>Do the same for <code class="shader">ColorGradingShadowsMidtonesHighlights</code>.</p>
						
						<pre class="shader">float3 ColorGradingShadowsMidtonesHighlights (float3 color<ins>, bool useACES</ins>) {
	<ins>float luminance = Luminance(color, useACES);</ins>
	&hellip;
}</pre>
						
						<p>And for <code class="shader">ColorGradingSaturation</code>.</p>
						
						<pre class="shader">float3 ColorGradingSaturation (float3 color<ins>, bool useACES</ins>) {
	float luminance = Luminance(color<ins>, useACES</ins>);
	return luminance + _ColorAdjustments.w * (color - luminance);
}</pre>
						
						<p>Then add the parameter to <code class="shader">ColorGrade</code> as well, this time set to false by default. Pass it to the functions that need it. The final color should be converted to ACES color space via <code class="shader">ACEScg_to_ACES</code> when appropriate.</p>
						
						<pre class="shader">float3 ColorGrade (float3 color<ins>, bool useACES = false</ins>) {
	color = min(color, 60.0);
	color = ColorGradePostExposure(color);
	color = ColorGradeWhiteBalance(color);
	color = ColorGradingContrast(color<ins>, useACES</ins>);
	color = ColorGradeColorFilter(color);
	color = max(color, 0.0);
	ColorGradeSplitToning(color<ins>, useACES</ins>);
	color = ColorGradingChannelMixer(color);
	color = max(color, 0.0);
	color = ColorGradingShadowsMidtonesHighlights(color<ins>, useACES</ins>);
	color = ColorGradingHueShift(color);
	color = ColorGradingSaturation(color<ins>, useACES</ins>);
	return max(<ins>useACES ? ACEScg_to_ACES(color)</ins> : color, 0.0);
}</pre>
						
						<p>Now adjust <code class="shader">ToneMappingACESPassFragment</code> so it indicates that it uses ACES. As the result of <code class="shader">ColorGrade</code> will be in ACES color space it can be passed directly to <code class="shader">ACESTonemap</code>.</p>
						
						<pre class="shader">float4 ToneMappingACESPassFragment (Varyings input) : SV_TARGET {
	float4 color = GetSource(input.screenUV);
	color.rgb = ColorGrade(color.rgb<ins>, true</ins>);
	color.rgb = AcesTonemap(<ins>color.rgb</ins>);
	return color;
}</pre>
						
						<p>To illustrate the difference here is a comparison using ACES tone mapping with increased contrast and adjusted shadows, midtones, and highlights.</p>
						
						<figure>
							<img src="more-controls/aces-aces.png" width="320" height="200" alt="ACES">
							<img src="more-controls/aces-linear.png" width="320" height="200" alt="linear">
							<figcaption>ACES tone mapping with color grading in ACES and linear color spaces.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>LUT</h2>
					
					<p>Performing all color grading steps per pixel is a lot of work. We could make may variants that only apply the steps that alter something, but that would requires lots of keywords or passes. What we can do instead is bake color grading into a lookup table&mdash;LUT for short&mdash;and sample it to convert colors. The LUT is a 3D texture, typically 32&times;32&times;32. Filling that texture and sampling it later is much less work than performing color grading directly on the entire image. URP and HDRP use the same approach.</p>
					
					<section>
						<h3>LUT Resolution</h3>
						
						<p>Typically a color LUT resolution of 32 is enough, but let's make it configurable. This is a quality setting that we'll add to <code>CustomRenderPipelineAsset</code> and then use for all color grading. We'll use an enum to offer 16, 32, and 64 as options, then pass it to the pipeline constructor as an integer.</p>
						
						<pre>	<ins>public enum ColorLUTResolution { _16 = 16, _32 = 32, _64 = 64 }</ins>

	<ins>[SerializeField]</ins>
	<ins>ColorLUTResolution colorLUTResolution = ColorLUTResolution._32;</ins>

	protected override RenderPipeline CreatePipeline () {
		return new CustomRenderPipeline(
			allowHDR, useDynamicBatching, useGPUInstancing, useSRPBatcher,
			useLightsPerObject, shadows, postFXSettings<ins>, (int)colorLUTResolution</ins>
		);
	}</pre>
						
						<aside>
							<h3>Why not allow an arbitrary resolution?</h3>
							<div>
								<p>URP and HDRP allow arbitrary LUT resolutions up to 65, but LUT sampling can go wrong when not using powers of two for the approach that we'll use. URP suffers from this as well.</p>
							</div>
						</aside>
						
						<p>Keep track of the color LUT resolution in <code>CustomRenderPipeline</code> and pass it to the <code>CameraRenderer.Render</code> method.</p>
						
						<pre>	<ins>int colorLUTResolution;</ins>

	public CustomRenderPipeline (
		&hellip;
		PostFXSettings postFXSettings<ins>, int colorLUTResolution</ins>
	) {
		<ins>this.colorLUTResolution = colorLUTResolution;</ins>
		&hellip;
	}

	protected override void Render (ScriptableRenderContext context, Camera[] cameras) {
		foreach (Camera camera in cameras) {
			renderer.Render(
				context, camera, allowHDR,
				useDynamicBatching, useGPUInstancing, useLightsPerObject,
				shadowSettings, postFXSettings<ins>, colorLUTResolution</ins>
			);
		}
	}</pre>
						
						<p>Which passes it to <code>PostFXStack.Setup</code>.</p>
						
						<pre>	public void Render (
		ScriptableRenderContext context, Camera camera, bool allowHDR,
		bool useDynamicBatching, bool useGPUInstancing, bool useLightsPerObject,
		ShadowSettings shadowSettings, PostFXSettings postFXSettings<ins>,</ins>
		<ins>int colorLUTResolution</ins>
	) {
		&hellip;
		postFXStack.Setup(context, camera, postFXSettings, useHDR<ins>, colorLUTResolution</ins>);
		&hellip;
	}</pre>
						
						<p>And <code>PostFXStack</code> keeps track of it.</p>
						
						<pre>	<ins>int colorLUTResolution;</ins>

	&hellip;

	public void Setup (
		ScriptableRenderContext context, Camera camera, PostFXSettings settings,
		bool useHDR<ins>, int colorLUTResolution</ins>
	) {
		<ins>this.colorLUTResolution = colorLUTResolution;</ins>
		&hellip;
	}</pre>
						
						<figure>
							<img src="lut/color-lut-resolution.png" width="320" height="42">
							<figcaption>Color LUT resolution.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Rendering to a 2D LUT Texture</h3>
						
						<p>The LUT is 3D, but a regular shader cannot render to a 3D texture. So we'll use a wide 2D texture instead to simulate a 3D texture, by placing 2D slices in a row. Thus the LUT texture's height is equal to the configured resolution and its width is equal to the resolution squared. Get a temporary render texture with that size, using the default HDR format. Do this after configuring color grading in <code>DoColorGradingAndToneMapping</code>.</p>
						
						<pre>		ConfigureShadowsMidtonesHighlights();

		<ins>int lutHeight = colorLUTResolution;</ins>
		<ins>int lutWidth = lutHeight * lutHeight;</ins>
		<ins>buffer.GetTemporaryRT(</ins>
			<ins>colorGradingLUTId, lutWidth, lutHeight, 0,</ins>
			<ins>FilterMode.Bilinear, RenderTextureFormat.DefaultHDR</ins>
		<ins>);</ins></pre>
						
						<p>From now on we'll render both color grading and tone mapping to the LUT. Rename the existing tone-mapping passes accordingly, so <em>ToneMappingNone</em> becomes <em>ColorGradingNone</em> and so on. Then draw to the LUT instead of the camera target, using the appropriate pass. Afterwards copy the source to the camera target to get the unadjusted image as the final result and release the LUT.</p>
						
						<pre>		ToneMappingSettings.Mode mode = settings.ToneMapping.mode;
		Pass pass = Pass.<ins>ColorGradingNone</ins> + (int)mode;
		Draw(sourceId, <ins>colorGradingLUTId</ins>, pass);
		
		<ins>Draw(sourceId, BuiltinRenderTextureType.CameraTarget, Pass.Copy);</ins>
		<ins>buffer.ReleaseTemporaryRT(colorGradingLUTId);</ins></pre>
						
						<p>We're now bypassing color grading and tone mapping, but the frame debugger reveals that we draw a flattened version of the image before the final copy.</p>
						
						<figure>
							<img src="lut/flattened-image.png" width="512" height="16">
							<figcaption>Flattened image.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>LUT Color Matrix</h3>
						
						<p>To create an appropriate LUT we need to fill it with a color conversion matrix. We do that by adjusting the color grading pass functions to use a color derived from the UV coordinates instead of sampling the source texture. Add a <code class="shader">GetColorGradedLUT</code>, which gets the color and also immediately performs color grading. Then the pass functions only have to apply tone mapping on top of that.</p>
						
						<pre class="shader"><ins>float3 GetColorGradedLUT (float2 uv, bool useACES = false) {</ins>
	<ins>float3 color = float3(uv, 0.0);</ins>
	<ins>return ColorGrade(color, useACES);</ins>
<ins>}</ins>

float4 ColorGradingNonePassFragment (Varyings input) : SV_TARGET {
	<ins>float3 color = GetColorGradedLUT(input.screenUV);</ins>
	<ins>return float4(color, 1.0);</ins>
}

float4 ColorGradingACESPassFragment (Varyings input) : SV_TARGET {
	<ins>float3 color = GetColorGradedLUT(input.screenUV, true);</ins>
	<ins>color = AcesTonemap(color);</ins>
	<ins>return float4(color, 1.0);</ins>
}

float4 ColorGradingNeutralPassFragment (Varyings input) : SV_TARGET {
	<ins>float3 color = GetColorGradedLUT(input.screenUV);</ins>
	<ins>color = NeutralTonemap(color);</ins>
	<ins>return float4(color, 1.0);</ins>
}

float4 ColorGradingReinhardPassFragment (Varyings input) : SV_TARGET {
	<ins>float3 color = GetColorGradedLUT(input.screenUV);</ins>
	<ins>color /= color + 1.0;</ins>
	<ins>return float4(color, 1.0);</ins>
}</pre>
						
						<p>We can find the LUT input color via the <code class="shader">GetLutStripValue</code> function. It requires the UV coordinates and a color grading lut parameters vector that we need to send to the GPU.</p>
						
						<pre class="shader"><ins>float4 _ColorGradingLUTParameters;</ins>

<ins>float3 GetColorGradedLUT (float2 uv, bool useACES = false) {</ins>
	<ins>float3 color = GetLutStripValue(uv, _ColorGradingLUTParameters);</ins>
	<ins>return ColorGrade(color, useACES);</ins>
<ins>}</ins></pre>
						
						<p>The four vector parameter values are the LUT height, 0.5 divided by the width, 0.5 divided by the height, and the height divided by itself minus one.</p>
						
						<pre>		buffer.GetTemporaryRT(
			colorGradingLUTId, lutWidth, lutHeight, 0,
			FilterMode.Bilinear, RenderTextureFormat.DefaultHDR
		);
		<ins>buffer.SetGlobalVector(colorGradingLUTParametersId, new Vector4(</ins>
			<ins>lutHeight, 0.5f / lutWidth, 0.5f / lutHeight, lutHeight / (lutHeight - 1f)</ins>
		<ins>));</ins></pre>
						
						<figure>
							<img src="lut/lut-none.png" width="512" height="16" alt="none">
							<img src="lut/lut-aces.png" width="512" height="16" alt="ACES">
							<img src="lut/lut-reinhard.png" width="512" height="16" alt="Reinhard">
							<figcaption>LUTs without color grading, with no, ACES, and Reinhard tone mapping.</figcaption>
						</figure>
						
						<aside>
							<h3>Doesn't URP do tone mapping separately?</h3>
							<div>
								<p>URP bakes both color grading and tone mapping into the LUT for HDR rendering, but does tone mapping separately for LDR rendering. However, tone mapping doesn't make much sense for LDR rendering, so I gave it no special treatment.</p>
								
								<p>Besides that URP uses the LDR RBGA format for LDR LUTs, but I always use the same default HDR format to keep things simple.</p>
								
								<p>Unity also keeps the post exposure out of the LUT, but I simply put everything in it.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Log C LUT</h3>
						
						<p>The LUT matrix that we get is in linear color space and only covers the 0&ndash;1 range. To support HDR we have to extend this range. We can do this by interpreting the input color as being in Log C space. That extends the range to just below 59.</p>
						
						<figure>
							<img src="lut/linear-logc.png" width="160" height="160">
							<figcaption>Stored linear and Log C intensities.</figcaption>
						</figure>
						
						<pre class="shader">float3 GetColorGradedLUT (float2 uv, bool useACES = false) {
	float3 color = GetLutStripValue(uv, _ColorGradingLUTParameters);
	return ColorGrade(<ins>LogCToLinear(color)</ins>, useACES);
}</pre>
						
						<figure>
							<img src="lut/lut-logc-none.png" width="512" height="16" alt="none">
							<img src="lut/lut-logc-aces.png" width="512" height="16" alt="ACES">
							<img src="lut/lut-logc-reinhard.png" width="512" height="16" alt="Reinhard">
							<figcaption>LogC colors with no, ACES, and Reinhard tone mapping.</figcaption>
						</figure>
						
						<p>Compared to linear space Log C adds a little more resolution to the darkest values. It overtakes the linear value at roughly 0.5. After that the intensity rises quickly so the matrix resolution decreases a lot. This is needed to cover HDR values, but if we don't need those it's better stick with linear space, otherwise almost half of the resolution is wasted. Add a boolean to the shader to control this.</p>
						
						<pre class="shader"><ins>bool _ColorGradingLUTInLogC;</ins>

float3 GetColorGradedLUT (float2 uv, bool useACES = false) {
	float3 color = GetLutStripValue(uv, _ColorGradingLUTParameters);
	return ColorGrade(<ins>_ColorGradingLUTInLogC ?</ins> LogCToLinear(color) <ins>: color</ins>, useACES);
}</pre>
						
						<p>Enable Log C mode only if HDR is used and tone mapping is applied.</p>
						
						<pre>		ToneMappingSettings.Mode mode = settings.ToneMapping.mode;
		Pass pass = Pass.ColorGradingNone + (int)mode;
		<ins>buffer.SetGlobalFloat(</ins>
			<ins>colorGradingLUTInLogId, useHDR &amp;&amp; pass != Pass.ColorGradingNone ? 1f : 0f</ins>
		<ins>);</ins>
		Draw(sourceId, colorGradingLUTId, pass);</pre>
						
						<p>Because we're no longer relying on the rendered image we no longer need to limit the range to 60. It's already limited by the range of the LUT.</p>
						
						<pre class="shader">float3 ColorGrade (float3 color, bool useACES = false) {
	<del>//color = min(color, 60.0);</del>
	&hellip;
}</pre>
						
						<aside>
							<h3>Do we still need to specify a source texture for the LUT pass?</h3>
							<div>
								<p>We don't use it, but <code>Draw</code> expects a source, so we still have to pass it something.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Final Pass</h3>
						
						<p>To apply the LUT we introduce a new final pass. All it needs to do is get the source color and apply the color grading LUT to it. Do that in a separate <code class="shader">ApplyColorGradingLUT</code> function.</p>
						
						<pre class="shader"><ins>float3 ApplyColorGradingLUT (float3 color) {</ins>
	<ins>return color;</ins>
<ins>}</ins>

<ins>float4 FinalPassFragment (Varyings input) : SV_TARGET {</ins>
	<ins>float4 color = GetSource(input.screenUV);</ins>
	<ins>color.rgb = ApplyColorGradingLUT(color.rgb);</ins>
	<ins>return color;</ins>
<ins>}</ins></pre>
						
						<p>We can apply the LUT via the <code class="shader">ApplyLut2D</code> function, which takes care of interpreting the 2D LUT strip as a 3D texture. It needs the LUT texture and sampler state as arguments, followed by the saturated input color&mdash;either in linear or Log C space as appropriate&mdash;and finally a parameters vector again, though this time with only three components.</p>
						
						<pre class="shader"><ins>TEXTURE2D(_ColorGradingLUT);</ins>

float3 ApplyColorGradingLUT (float3 color) {
	return <ins>ApplyLut2D(</ins>
		<ins>TEXTURE2D_ARGS(_ColorGradingLUT, sampler_linear_clamp),</ins>
		<ins>saturate(_ColorGradingLUTInLogC ? LinearToLogC(color) : color),</ins>
		<ins>_ColorGradingLUTParameters.xyz</ins>
	<ins>)</ins>;
}</pre>
						
						<p>In this case the parameter values are one divided by the LUT width, one divided by the height, and the height minus one. Set those before the final draw, now using the final pass.</p>
						
						<pre>		<ins>buffer.SetGlobalVector(colorGradingLUTParametersId,</ins>
			<ins>new Vector4(1f / lutWidth, 1f / lutHeight, lutHeight - 1f)</ins>
		<ins>);</ins>
		Draw(sourceId, BuiltinRenderTextureType.CameraTarget, Pass.<ins>Final</ins>);
		buffer.ReleaseTemporaryRT(colorGradingLUTId);</pre>
						
						<aside>
							<h3>Do we have to recreate the LUT each frame?</h3>
							<div>
								<p>Only color grading and tone mapping a LUT texture already is a lot less work than doing it for all pixels of the rendered image separately. A further optimization would be to cache the LUT. However, determining whether a LUT refresh is needed can get complex, especially when different settings per camera or blending settings are supported. So we stick to the simple approach of recreating the LUT each time a camera gets rendered. URP and HDRP do this as well.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>LUT Banding</h3>
						
						<p>Although we're now using a LUT for both color grading and tone mapping the result should be the same as before. However, because the LUT has a finite resolution and we sample it with bilinear interpolation it converts otherwise smooth color transitions into linear bands. This is usually not noticeable for resolution 32 LUTs, but banding can become visible in regions with extreme HDR color gradients. An example is the falloff of the intensity-200 spotlight in the tone-mapping scene of the previous tutorial, which illuminates a uniform white surface.</p>
						
						<figure>
							<img src="lut/banding-16.png" width="400" height="240" alt="16">
							<img src="lut/banding-32.png" width="400" height="240" alt="32">
							<figcaption>Color banding, LUT resolution 16 and 32.</figcaption>
						</figure>
						
						<p>The banding can be made very obvious by temporarily switching to a <code class="shader">sampler_point_clamp</code> sampler state. This turns off interpolation inside the 2D slices of our LUT. There's still interpolation between adjacent slices because <code class="shader">ApplyLut2D</code> simulates a 3D texture by sampling two slices and blending between them.</p>
						
						<figure>
							<img src="lut/banding-clamp-16.png" width="400" height="240" alt="16">
							<img src="lut/banding-clamp-32.png" width="400" height="240" alt="32">
							<figcaption>Point sampling, LUT resolution 16 and 32.</figcaption>
						</figure>
						
						<p>If banding is too noticeable you can increase resolution to 64, but a little variety in color is usually enough to hide it. If you go hunting for banding artifacts in very subtle color transitions you're more likely to find banding due to 8-bit frame buffer limitations, which is not caused by the LUT and can be mitigated via dithering, but that's another topic.</p>
						
						<p>The next tutorial is <a href="../multiple-cameras/index.html">Multiple Cameras</a>.</p>
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/custom-srp-13-color-grading/" class="repository">repository</a>
					<a href="Color-Grading.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>