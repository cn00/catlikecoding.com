<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/custom-srp/complex-maps/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/custom-srp/complex-maps/tutorial-image.jpg">
		<meta property="og:title" content="Complex Maps">
		<meta property="og:description" content="A Unity Custom SRP tutorial about supporting mask, detail, and normal maps.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Complex Maps</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/custom-srp/complex-maps/#article",
				"headline": "Complex Maps",
				"alternativeHeadline": "Masks, Details, and Normals",
				"datePublished": "2020-04-30",
				"dateModified": "2021-01-19",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Custom SRP tutorial about supporting mask, detail, and normal maps.",
				"image": "https://catlikecoding.com/unity/tutorials/custom-srp/complex-maps/tutorial-image.jpg",
				"dependencies": "Unity 2019.2.21f1",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/custom-srp/", "name": "Custom SRP" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				CameraRenderer: 1,
				CascadeBlendMode: 1,
				CustomRenderPipeline: 1,
				CustomRenderPipelineAsset: 1,
				CustomShaderGUI: 1,
				Directional: 1,
				DirectionalShadowData: 1,
				FilterMode: 1,
				InputConfig: 1,
				Lighting: 1,
				MeshBall: 1,
				PerObjectMaterialProperties: 1,
				ShadowedDirLight: 1,
				ShadowData: 1,
				Shadows: 1,
				ShadowMask: 1,
				ShadowMode: 1,
				ShadowSettings: 1,
				TextureSize: 1
			};
			
			var defaultCodeClass = "shader";
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Custom SRP</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Complex Maps</h1>
					<p>Masks, Details, and Normals</p>
					<ul>
						<li>Create a circuitry-like material.</li>
						<li>Add support for a MODS mask map.</li>
						<li>Introduce a secondary detail map.</li>
						<li>Perform tangent-space normal mapping.</li>
					</ul>
				</header>
				
				<p>This is the eighth part of a tutorial series about creating a <a href="../index.html">custom scriptable render pipeline</a>. It makes it possible to create complex surfaces by adding support for mask, detail, and normal maps.</p>
				
				<p>This tutorial is made with Unity 2019.2.21f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>An artistic impression of circuitry.</figcaption>
				</figure>
								
				<section>
					<h2>Circuitry Material</h2>
					
					<p>Up to this point we've always used very simple materials to test our RP. But it should also support complex materials so we can represent more interesting surfaces. In this tutorial we'll create an artistic circuitry-like material, with the help of a few textures.</p>
					
					<section>
						<h3>Albedo</h3>
						
						<p>The basis of our material is its <a href="circuitry-material/circuitry-albedo.png">albedo map</a>. It consists of a few layers of different shades of green with gold on top. Each color area is uniform, except for some brown stains, which makes it easier to distinguish the details that we'll add later.</p>
						
						<figure>
							<img src="circuitry-material/circuitry-albedo.png" width="256" height="256">
							<figcaption>Albedo map.</figcaption>
						</figure>
						
						<p>Create a new material with our <em translate="no">Lit</em> shader, using this albedo map. I set its tiling to 2 by 1 so the square texture wraps around a sphere without getting stretched too much. The poles of the default sphere will always get deformed a lot, which cannot be prevented.</p>
						
						<figure>
							<img src="circuitry-material/albedo-inspector.png" width="320" height="92" alt="inspector"><br>
							<img src="circuitry-material/albedo-scene.png" width="260" height="260" alt="scene">
							<figcaption>Circuitry sphere.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Emission</h3>
						
						<p>We already support emission maps, so let's use <a href="circuitry-material/circuitry-emission.png">one</a> that adds a light blue illuminating pattern on top of the golden circuitry.</p>
						
						<figure>
							<img src="circuitry-material/circuitry-emission.png" width="256" height="256">
							<figcaption>Emission map.</figcaption>
						</figure>
						
						<p>Assign it to the material and set the emission color to white so it becomes visible.</p>
						
						<figure>
							<img src="circuitry-material/emission-inspector.png" width="320" height="92" alt="inspector"><br>
							<img src="circuitry-material/emission-scene-light.png" width="260" height="260" alt="scene light">
							<img src="circuitry-material/emission-scene-dark.png" width="260" height="260" alt="scene dark">
							<figcaption>Emissive circuitry.</figcaption>
						</figure>
					</section>
					
				</section>
				
				<section>
					<h2>Mask Map</h2>
					
					<p>Right now we cannot do much else to make our material more interesting. The golden circuitry is supposed to be metallic while the green board isn't, but we can currently only configure uniform metallic and smoothness values. We need additional maps to support varying them across the surface.</p>
					
					<figure>
						<img src="mask-map/metallic-smooth.png" width="260" height="260">
						<figcaption>Metallic 1 and smoothness 0.95.</figcaption>
					</figure>
					
					<section>
						<h3>MODS</h3>
						
						<p>We could add a separate map for metallic and another for smoothness, but both only require a single channel each, so we could combine them in a single map. This map is known as a mask map, its individual channels masking different shader properties. We'll use the same format as Unity's HDRP, which is a MODS map. This stand for Metallic, Occlusion, Detail, and Smoothness, stored in the RGBA channels in that order.</p>
						
						<p><a href="mask-map/circuitry-mask-mods.png">Here</a> is such a map for our circuitry. It has data in all its channels, but for the moment we'll only use its R and A channels. As this texture contains mask data instead of colors make sure that its <em translate="no">sRGB (Color Texture)</em> texture import property is disabled. Not doing this would lead to the GPU incorrectly applying a gamma-to-linear conversion when sampling the texture.</p>
						
						<figure>
							<img src="mask-map/circuitry-mask-mods.png" width="256" height="256">
							<figcaption>Mask MODS map.</figcaption>
						</figure>
						
						<p>Add a property for the mask map to <em translate="no">Lit</em>. Because it's a mask we'll use white as the default, which changes nothing.</p>
						
						<pre translate="no">		<ins>[NoScaleOffset] _MaskMap("Mask (MODS)", 2D) = "white" {}</ins>
		_Metallic ("Metallic", Range(0, 1)) = 0
		_Smoothness ("Smoothness", Range(0, 1)) = 0.5</pre>
						
						<figure>
							<img src="mask-map/mask-inspector.png" width="320" height="110">
							<figcaption>Mask shader property.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Mask Input</h3>
						
						<p>Add a <code>GetMask</code> function to <em translate="no">LitInput</em> that simply samples the mask texture and returns it.</p>
						
						<pre translate="no">TEXTURE2D(_BaseMap);
<ins>TEXTURE2D(_MaskMap);</ins>
&hellip;

<ins>float4 GetMask (float2 baseUV) {</ins>
	<ins>return SAMPLE_TEXTURE2D(_MaskMap, sampler_BaseMap, baseUV);</ins>
<ins>}</ins></pre>
						
						<p>Let's also tidy up the <code>LitInput</code> code a bit before we proceed. Define an <code>INPUT_PROP</code> macro with a name parameter to provide a shorthand for using the <code>UNITY_ACCESS_INSTANCED_PROP</code> macro.</p>
						
						<pre translate="no"><ins>#define INPUT_PROP(name) UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, name)</ins></pre>
						
						<p>Now we can simplify the code of all getter functions. I've only shown the change for retrieving <code>_BaseMap_ST</code> in <code>GetBase</code>.</p>
						
						<pre translate="no">	float4 baseST = <ins>INPUT_PROP(</ins>_BaseMap_ST);</pre>
						
						<p>This change can also be applied to the code in <em translate="no">UnlitInput</em>.</p>
					</section>
					
					<section>
						<h3>Metallic</h3>
						
						<p><em translate="no">LitPass</em> shouldn't need to know whether some properties rely on the mask map or not. The individual functions can retrieve the mask when needed. Do so in <code>GetMetallic</code>, masking its result with the mask's R channel via multiplication.</p>
						
						<pre translate="no">float GetMetallic (float2 baseUV) {
	<ins>float metallic =</ins> INPUT_PROP(_Metallic);
	<ins>metallic *= GetMask(baseUV).r;</ins>
	<ins>return metallic;</ins>
}</pre>
						
						<figure>
							<img src="mask-map/metallic-scene.png" width="260" height="260">
							<figcaption>Only golden circuitry is metallic.</figcaption>
						</figure>
						
						<p>Metallic maps are usually mostly binary. In our case the golden circuitry is fully metallic and the green board isn't. The golden stained areas are an exception, being a little less metallic.</p>
					</section>
					
					<section>
						<h3>Smoothness</h3>
						
						<p>Do this same thing in <code>GetSmoothness</code>, this time relying on the mask's A channel. The golden circuitry is quite smooth while the green board isn't.</p>
						
						<pre translate="no">float GetSmoothness (float2 baseUV) {
	<ins>float smoothness =</ins> INPUT_PROP(_Smoothness);
	<ins>smoothness *= GetMask(baseUV).a;</ins>
	<ins>return smoothness;</ins>
}</pre>
						
						<figure>
							<img src="mask-map/smoothness-scene.png" width="260" height="260">
							<figcaption>Smoothness map in use.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Occlusion</h3>
						
						<p>The mask's G channel contains occlusion data. The idea is that small receded areas like gaps and holes are mostly shadowed by the rest of an object, but if those features are represented by a texture only this gets ignored by lighting. The missing occlusion data is provided by the mask. Add a new <code>GetOcclusion</code> function to get it, initially always returning zero to demonstrate its maximum effect.</p>
						
						<pre translate="no"><ins>float GetOcclusion (float2 baseUV) {</ins>
	<ins>return 0.0;</ins>
<ins>}</ins></pre>
						
						<p>Add the occlusion data to the <code>Surface</code> struct.</p>
						
						<pre translate="no">struct Surface {
	&hellip;
	<ins>float occlusion;</ins>
	float smoothness;
	float fresnelStrength;
	float dither;
};</pre>
						
						<p>And initialize it in <code>LitPassFragment</code>.</p>
						
						<pre translate="no">	surface.metallic = GetMetallic(input.baseUV);
	<ins>surface.occlusion = GetOcclusion(input.baseUV);</ins>
	surface.smoothness = GetSmoothness(input.baseUV);</pre>
						
						<p>The idea is that occlusion only applies to indirect environmental lighting. Direct light is unaffected, so gaps don't remain dark when a light source is pointed directly at them. Thus we use occlusion to modulate the result of <code>IndirectBRDF</code> only.</p>
						
						<pre translate="no">float3 IndirectBRDF (
	Surface surface, BRDF brdf, float3 diffuse, float3 specular
) {
	&hellip;
	
    return <ins>(</ins>diffuse * brdf.diffuse + reflection<ins>) * surface.occlusion</ins>;
}</pre>
						
						<figure>
							<img src="mask-map/fully-occluded.png" width="260" height="260">
							<figcaption>Fully occluded.</figcaption>
						</figure>
						
						<p>After having verified that it works have <code>GetOcclusion</code> return the G channel of the mask.</p>
						
						<pre translate="no">float GetOcclusion (float2 baseUV) {
	return <ins>GetMask(baseUV).g</ins>;
}</pre>
						
						<figure>
							<img src="mask-map/occlusion-scene.png" width="260" height="260">
							<figcaption>Occlusion map in use.</figcaption>
						</figure>
						
						<p>Some parts of the green board are lower than others, thus they should be occluded a bit. The areas are large and the occlusion map is at maximum strength to make the effect clearly visible, but the result is too strong to make sense. Rather than create another mask map with better occlusion data let's add an occlusion strength slider property to our shader.</p>
						
						<pre translate="no">		[NoScaleOffset] _MaskMap("Mask (MODS)", 2D) = "white" {}
		_Metallic ("Metallic", Range(0, 1)) = 0
		<ins>_Occlusion ("Occlusion", Range(0, 1)) = 1</ins>
		_Smoothness ("Smoothness", Range(0, 1)) = 0.5</pre>
						
						<figure>
							<img src="mask-map/occlusion-inspector.png" width="320" height="55">
							<figcaption>Occlusion slider; reduced to 0.5.</figcaption>
						</figure>
						
						<p>Add it to the <code>UnityPerMaterial</code> buffer.</p>
						
						<pre translate="no">UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
	&hellip;
	<ins>UNITY_DEFINE_INSTANCED_PROP(float, _Occlusion)</ins>
	UNITY_DEFINE_INSTANCED_PROP(float, _Smoothness)
	UNITY_DEFINE_INSTANCED_PROP(float, _Fresnel)
UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</pre>
						
						<p>Then adjust <code>GetOcclusion</code> so it modulates the mask with the property. In this case the slider controls the strength of the mask, so if it's set to zero the mask should be fully ignored. We can do this by interpolating between the mask and 1 based on the strength.</p>
						
						<pre translate="no">float GetOcclusion (float2 baseUV) {
	<ins>float strength = INPUT_PROP(_Occlusion);</ins>
	<ins>float occlusion = GetMask(baseUV).g;</ins>
	<ins>occlusion = lerp(occlusion, 1.0, strength);</ins>
	<ins>return occlusion;</ins>
}</pre>
						
						<figure>
							<img src="mask-map/occlusion-half-strength.png" width="260" height="260">
							<figcaption>Occlusion at half strength.</figcaption>
						</figure>
						
					</section>
				</section>
				
				<section>
					<h2>Detail Map</h2>
					
					<p>The next step is to add some details to our material. We do this by sampling a detail texture with a higher tiling than the base map and combining it with the base and mask data. This makes the surface more interesting and also provides higher-resolution information when the surface is viewed up close, where the base map on its own would appear pixelated.</p>
					
					<p>Details are supposed to only modify surface properties a little, so once again we'll combine data in a single non-color map. The HDRP uses a ANySNx format, which means it stores albedo modulation in R, smoothness modulation in B, and a detail normal vector's XY components in AG. But <a href="detail-map/circuitry-detail.png">our map</a> won't contain normal vectors, so we only use the RB channels. Thus it's an RGB texture, not RGBA.</p>
					
					<figure>
						<img src="detail-map/circuitry-detail.png" width="256" height="256">
						<figcaption>Detail map; not sRGB.</figcaption>
					</figure>
					
					<section>
						<h3>Detail UV coordinates</h3>
						
						<p>Because the detail map is supposed to use a higher tiling than the base map it needs its own tiling and offset. Add a material property for it, this time without the <code>NoScaleOffset</code> attribute. Its default should cause no change, which we get by using <em translate="no">linearGrey</em>, as values of 0.5 will be considered neutral.</p>
						
						<pre translate="no">		[NoScaleOffset] _EmissionMap("Emission", 2D) = "white" {}
		[HDR] _EmissionColor("Emission", Color) = (0.0, 0.0, 0.0, 0.0)

		<ins>_DetailMap("Details", 2D) = "linearGrey" {}</ins></pre>
						
						<figure>
							<img src="detail-map/detail-map-inspector.png" width="304" height="88">
							<figcaption>Detail map property; tiling four times as much.</figcaption>
						</figure>
						
						<aside>
							<h3>Can't we just scale the base UV?</h3>
							<div>
								<p>Yes, that is also possible and can even be convenient. But using completely separate UV coordinates for the details provides maximum flexibility. It also makes it possible to use a detail map without relying on a base map, although that would be rare.</p>
							</div>
						</aside>
						
						<p>Add the required texture, sampler state, and scale-offset properties to <em translate="no">LitInput</em>, along with a <code>TransformDetailUV</code> function to transform the detail texture coordinates.</p>
						
						<pre translate="no"><ins>TEXTURE2D(_DetailMap);</ins>
<ins>SAMPLER(sampler_DetailMap);</ins>

UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
	UNITY_DEFINE_INSTANCED_PROP(float4, _BaseMap_ST)
	<ins>UNITY_DEFINE_INSTANCED_PROP(float4, _DetailMap_ST)</ins>
	&hellip;
UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)

&hellip;

<ins>float2 TransformDetailUV (float2 detailUV) {</ins>
	<ins>float4 detailST = INPUT_PROP(_DetailMap_ST);</ins>
	<ins>return detailUV * detailST.xy + detailST.zw;</ins>
<ins>}</ins></pre>
						
						<p>Then add a <code>GetDetail</code> function to retrieve all detail data, given detail UV.</p>
						
						<pre translate="no"><ins>float4 GetDetail (float2 detailUV) {</ins>
	<ins>float4 map = SAMPLE_TEXTURE2D(_DetailMap, sampler_DetailMap, detailUV);</ins>
	<ins>return map;</ins>
<ins>}</ins></pre>
						
						<p>Transform the coordinates in <code>LitPassVertex</code> and pass them along via <code>Varyings</code>.</p>
						
						<pre translate="no">struct Varyings {
	&hellip;
	float2 baseUV : VAR_BASE_UV;
	<ins>float2 detailUV : VAR_DETAIL_UV;</ins>
	&hellip;
};

Varyings LitPassVertex (Attributes input) {
	&hellip;
	output.baseUV = TransformBaseUV(input.baseUV);
	<ins>output.detailUV = TransformDetailUV(input.baseUV);</ins>
	return output;
}</pre>
					</section>
					
					<section>
						<h3>Detailed Albedo</h3>
						
						<p>To add details to albedo we have to add a parameter for the detail UV to <code>GetBase</code>, which we'll set to zero by default so existing code doesn't break. Begin by simply adding all detail direct to the base map, before factoring in the color tint.</p>
						
						<pre translate="no">float4 GetBase (float2 baseUV<ins>, float2 detailUV = 0.0</ins>) {
	float4 map = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, baseUV);
	float4 color = INPUT_PROP(_BaseColor);
	
	<ins>float4 detail = GetDetail(detailUV);</ins>
	<ins>map += detail;</ins>
	
	return map * color;
}</pre>
						
						<p>Then pass the detail UV to it in <code>LitPassFragment</code>.</p>
						
						<pre translate="no">	float4 base = GetBase(input.baseUV<ins>, input.detailUV</ins>);</pre>
						
						<figure>
							<img src="detail-map/albedo-added.png" width="260" height="260">
							<figcaption>Albedo details added.</figcaption>
						</figure>
						
						<p>This confirms that the detail data gets sampled correctly, but we're not interpreting it correctly yet. First, values of 0.5 are neutral. Higher values should increase or brighten, while lower values should decrease or darken. The first step to make this work is converting the detail value range from 0&ndash;1 to &minus;1&ndash;1 in <code>GetDetail</code>.</p>
						
						<pre translate="no">float4 GetDetail (float2 detailUV) {
	float4 map = SAMPLE_TEXTURE2D(_DetailMap, sampler_DetailMap, detailUV);
	return map <ins>* 2.0 - 1.0</ins>;
}</pre>
						
						<p>Second, only the R channel affects albedo, pushing it toward either black or white. This can be done by interpolating the color with either 0 or 1, depending on the sign of the detail. The interpolator is then the absolute detail value. This should only affect albedo, not the base's alpha channel.</p>
						
						<pre translate="no">	<ins>float</ins> detail = GetDetail(detailUV)<ins>.r</ins>;
	<del>//map += detail;</del>
	<ins>map.rgb = lerp(map.rgb, detail &lt; 0.0 ? 0.0 : 1.0, abs(detail));</ins></pre>
						
						<figure>
							<img src="detail-map/albedo-interpolated.png" width="260" height="260">
							<figcaption>Albedo interpolated.</figcaption>
						</figure>
						
						<p>This works and is very obvious, because our detail map is very strong. But the brightening effect appear stronger than the darkening effect. That's because we're applying the modification in linear space. Doing it in gamma space would better match a visually equal distribution. We can approximate this by interpolating the square root of the albedo, and squaring afterwards.</p>
						
						<pre translate="no">	map.rgb = lerp(<ins>sqrt(map.rgb)</ins>, detail &lt; 0.0 ? 0.0 : 1.0, abs(detail));
	<ins>map.rgb *= map.rgb;</ins></pre>
						
						<figure>
							<img src="detail-map/albedo-perceptual.png" width="260" height="260">
							<figcaption>Perceptual interpolation; darkening appears stronger.</figcaption>
						</figure>
						
						<p>The details currently get applied to the entire surface, but the idea is that most of the golden circuitry is unaffected. That's what the detail mask is for, stored in the B channel of the mask map. We can apply it by factoring it into the interpolator.</p>
						
						<pre translate="no">	<ins>float mask = GetMask(baseUV).b;</ins>
	map.rgb = lerp(sqrt(map.rgb), detail &lt; 0.0 ? 0.0 : 1.0, abs(detail) <ins>* mask</ins>);</pre>
						
						<figure>
							<img src="detail-map/albedo-detail-masked.png" width="260" height="260">
							<figcaption>Masked details.</figcaption>
						</figure>
						
						<p>Our details are at maximum possible strength, which is far too strong. Let's introduce a detail albedo strength slider property to scale them down.</p>
						
						<pre translate="no">		_DetailMap("Details", 2D) = "linearGrey" {}
		<ins>_DetailAlbedo("Detail Albedo", Range(0, 1)) = 1</ins></pre>
						
						<p>Add it to <code>UnityPerMaterial</code> and multiply it with the detail in <code>GetBase</code>.</p>
						
						<pre translate="no">UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
	&hellip;
	<ins>UNITY_DEFINE_INSTANCED_PROP(float, _DetailAlbedo)</ins>
UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)

&hellip;

float4 GetBase (float2 baseUV, float2 detailUV = 0.0) {
	&hellip;
	float detail = GetDetail(detailUV).r <ins>* INPUT_PROP(_DetailAlbedo)</ins>;
	&hellip;
}</pre>
						
						<figure>
							<img src="detail-map/detail-albedo-inspector.png" width="304" height="92" alt="inspector"><br>
							<img src="detail-map/detail-albedo-scene.png" width="260" height="260" alt="scene">
							<figcaption>Albedo details scaled down to 0.2.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>Detailed Smoothness</h3>
						
						<p>Adding details to smoothness works the same way. First, add a strength slider property for it as well.</p>
						
						<pre translate="no">		_DetailAlbedo("Detail Albedo", Range(0, 1)) = 1
		<ins>_DetailSmoothness("Detail Smoothness", Range(0, 1)) = 1</ins></pre>
						
						<p>Then add the property to <code>UnityPerMaterial</code>, retrieve the scaled detail in <code>GetSmoothness</code>, and interpolate in the same way. This time we need the B channel of the detail map.</p>
						
						<pre translate="no">UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
	&hellip;
	<ins>UNITY_DEFINE_INSTANCED_PROP(float, _DetailSmoothness)</ins>
UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)

&hellip;

float GetSmoothness (float2 baseUV, float2 detailUV = 0.0) {
	float smoothness = INPUT_PROP(_Smoothness);
	smoothness *= GetMask(baseUV).a;

	<ins>float detail = GetDetail(detailUV).b * INPUT_PROP(_DetailSmoothness);</ins>
	<ins>float mask = GetMask(baseUV).b;</ins>
	<ins>smoothness = lerp(smoothness, detail &lt; 0.0 ? 0.0 : 1.0, abs(detail) * mask);</ins>
	
	return smoothness;
}</pre>
						
						<p>Have <code>LitPassFragment</code> pass the detail UV to <code>GetSmoothness</code> as well.</p>
						
						<pre translate="no">	surface.smoothness = GetSmoothness(input.baseUV<ins>, input.detailUV</ins>);</pre>
						
						<figure>
							<img src="detail-map/detail-smoothness-inspector.png" width="320" height="40" alt="inspector"><br>
							<img src="detail-map/detail-smoothness-scene-02.png" width="260" height="260" alt="scene 0.2">
							<img src="detail-map/detail-smoothness-scene-10.png" width="260" height="260" alt="scene 1.0">
							<figcaption>Smoothness details; at 0.2 and full strength.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>Fading Details</h3>
						
						<p>Details only matter when they are sufficiently large, visually. Details shouldn't be applied when they're too small, because that can produce a noisy result. Mip mapping blurs the data as usual, but for details we want to go a step further and fade them out as well.</p>
						
						<figure>
							<img src="detail-map/not-faded.png" width="500" height="200">
							<figcaption>Details at full strength.</figcaption>
						</figure>
						
						<p>Unity can fade details automatically for us, if we enabled the <em translate="no">Fadeout Mip Maps</em> import option of our detail texture. A range slider will show up, which controls at which mip level the fading starts and ends. Unity simply interpolates the mip maps to gray, which means the map becomes neutral. For this to work the texture's <em translate="no">Filter Mode</em> must be set to <em translate="no">Trilinear</em>, which should happen automatically.</p>
						
						<figure>
							<img src="detail-map/faded-inspector.png" width="320" height="80" alt="inspector">
							<img src="detail-map/faded-scene.png" width="500" height="200" alt="scene">
							<figcaption>Fading details.</figcaption>
						</figure>
					</section>
					
				</section>
				
				<section>
					<h2>Normal Maps</h2>
					
					<p>Even though we've made our surface a lot more complex it still appears flat, because it is. Lighting interacts with the surface normal, which gets smoothly interpolated across every triangle. Our surface would be much more believable if lighting also interacts with its smaller features. We can do that by adding support for normal maps.</p>
					
					<p>Typically normal maps are generated from a high-polygon-density 3D model which gets baked to a lower-poly model for realtime use. The normal vectors of high-poly geometry that are lost get baked in a normal map. Alternatively, the normal map is generated procedurally. <a href="normal-maps/circuitry-normal.png">Here</a> is such a map for our circuitry. Set its <em translate="no">Texture Type</em> to <em translate="no">Normal map</em> after importing it.</p>
					
					<figure>
						<img src="normal-maps/circuitry-normal.png" width="256" height="256">
						<figcaption>Normal map.</figcaption>
					</figure>
					
					<p>This map follows the standard tangent-space normal map convention of storing the up axis&ndash;designated as Z in this case&mdash;in the B channel, while the right and forward XY axes are stored in RG. Just like the detail map the &minus;1-1 range of normal components are converted so 0.5 is the midpoint. Thus flat areas appear bluish.</p>
					
					<section>
						<h3>Sampling Normals</h3>
						
						<p>To sample the normals we have to add a normal map texture property to our shader, with <em translate="no">bump</em> as its default, representing a flat map. Also add a normal scale property so we can control the map's strength.</p>
						
						<pre translate="no">		<ins>[NoScaleOffset] _NormalMap("Normals", 2D) = "bump" {}</ins>
		<ins>_NormalScale("Normal Scale", Range(0, 1)) = 1</ins></pre>
						
						<figure>
							<img src="normal-maps/normals-inspector.png" width="304" height="110">
							<figcaption>Normal map and scale.</figcaption>
						</figure>
						
						<p>The most straightforward way to store the normal information is as described above&mdash;XYZ in the RGB channels&mdash;but this isn't the most efficient way. If we assume that the normal vectors always point up and never down we can omit the upward component and derive it from the other two. Those channels can then be stored in a compressed texture format in such a way that loss of precision is minimized. XY get stored in either RG or AG, depending on the texture format. This would change the appearance of the texture, but the Unity editor only shows previews and thumbnails of the original map.</p>
						
						<p>Whether normal maps are changed depends on the target platform. If the maps aren't changed then <em translate="no">UNITY_NO_DXT5nm</em> is defined. If so we can use the <code>UnpackNormalRGB</code> function to convert the sampled normal data, otherwise we can use <code>UnpackNormalmapRGorAG</code>. Both have a sample and a scale parameter and are defined in the <em translate="no">Packing</em> file from the <em translate="no">Core RP Library</em>. Add a function to <em translate="no">Common</em> that uses those functions to decode the normal data.</p>
						
						<pre translate="no">#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"
<ins>#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"</ins>

&hellip;

<ins>float3 DecodeNormal (float4 sample, float scale) {</ins>
	<ins>#if defined(UNITY_NO_DXT5nm)</ins>
	    <ins>return UnpackNormalRGB(sample, scale);</ins>
	<ins>#else</ins>
	    <ins>return UnpackNormalmapRGorAG(sample, scale);</ins>
	<ins>#endif</ins>
<ins>}</ins></pre>
						
						<aside>
							<h3>What does <em translate="no">DXT5nm</em> mean?</h3>
							<div>
								<p><em translate="no">DXT5</em>&mdash;also known as <em translate="no">BC3</em>&mdash;is a compression format that partitions the texture in blocks of 4&times;4 pixels. Each block is approximated with two colors that get interpolated per pixel. The amount of bits used for the colors varies per channel. R and B get five bits each, G gets six bits, and A gets eight bits. That's one reason why the X coordinate is moved to the A channel. The other reason is that the RGB channels get one lookup table, while the A channel gets its own lookup table. This keeps the X and Y components isolated.</p>
								
								<p>When <em translate="no">DXT5</em> is used to store normal vectors it's referred to as <em translate="no">DXT5nm</em>. However, when a high compression quality is used Unity prefers <em translate="no">BC7</em> compression instead. This mode works the same but the amount of bits per channel can vary. Thus X channel doesn't need to be moved. The final texture ends up larger because more bits are used for both channels, improving texture quality.</p>
								
								<p><code>UnpackNormalmapRGorAG</code> can deal with both approaches by multiplying the R and A channels. This requires that the unused channel is set to 1, which Unity automatically does.</p>
							</div>
						</aside>
						
						<p>Now add the normal map, normal scale, and a <code>GetNormalTS</code> function to <em translate="no">LitInput</em> and retrieve and decode the normal vector.</p>
						
						<pre translate="no"><ins>TEXTURE2D(_NormalMap);</ins>
&hellip;

UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
	&hellip;
	<ins>UNITY_DEFINE_INSTANCED_PROP(float, _NormalScale)</ins>
UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)

&hellip;

<ins>float3 GetNormalTS (float2 baseUV) {</ins>
	<ins>float4 map = SAMPLE_TEXTURE2D(_NormalMap, sampler_BaseMap, baseUV);</ins>
	<ins>float scale = INPUT_PROP(_NormalScale);</ins>
	<ins>float3 normal = DecodeNormal(map, scale);</ins>
	<ins>return normal;</ins>
<ins>}</ins></pre>
						
					</section>
					
					<section>
						<h3>Tangent Space</h3>
						
						<p>Because textures wrap around geometry their orientation in object and world space isn't uniform. Thus the space in which the normals are stored curves to match the geometry's surface. The only constant is that the space is tangential to the surface, which is why it is known as tangent space. The Y up axis of this space matches the surface normal. Besides that, it must have an X right axis that's tangential to the surface. If we have those two we can generate the Z forward axis from that.</p>
						
						<p>Because the X axis of tangent space isn't constant it has to be defined as part of the mesh vertex data. It's stored as a four-component tangent vector. Its XYZ components define the axis in object space. Its W component is either &minus;1 or 1, which is used to control in which direction the Z axis points. This is used to flip normal maps for meshes with bilateral symmetry&mdash;which most animals have&mdash;so the same map can be used for both sides of the mesh, halving the required texture size.</p>
						
						<p>So if we have world-space normal and tangent vectors we can construct a conversion matrix from tangent to world space. We can use the existing <code>CreateTangentToWorld</code> function for this, passing it the normal, tangent XYZ, and tangent W as arguments. Then we can invoke <code>TransformTangentToWorld</code> with the tangent-space normal and conversion matrix as arguments. Add a function that does all this to <em translate="no">Common</em>.</p>
						
						<pre translate="no"><ins>float3 NormalTangentToWorld (float3 normalTS, float3 normalWS, float4 tangentWS) {</ins>
	<ins>float3x3 tangentToWorld =</ins>
		<ins>CreateTangentToWorld(normalWS, tangentWS.xyz, tangentWS.w);</ins>
	<ins>return TransformTangentToWorld(normalTS, tangentToWorld);</ins>
<ins>}</ins></pre>
						
						<p>Next, add the object-space tangent vector with the <code>TANGENT</code> semantic to <code>Attributes</code> and a world-space tangent to <code>Varyings</code> in <em translate="no">LitPass</em>.</p>
						
						<pre translate="no">struct Attributes {
	float3 positionOS : POSITION;
	float3 normalOS : NORMAL;
	<ins>float4 tangentOS : TANGENT;</ins>
	&hellip;
};

struct Varyings {
	float4 positionCS : SV_POSITION;
	float3 positionWS : VAR_POSITION;
	float3 normalWS : VAR_NORMAL;
	<ins>float4 tangentWS : VAR_TANGENT;</ins>
	&hellip;
};</pre>
						
						<p>The XYZ portion of the tangent vector can be converted to world space in <code>LitPassVertex</code> by invoking <code>TransformObjectToWorldDir</code>.</p>
						
						<pre translate="no">	output.normalWS = TransformObjectToWorldNormal(input.normalOS);
	<ins>output.tangentWS =</ins>
		<ins>float4(TransformObjectToWorldDir(input.tangentOS.xyz), input.tangentOS.w);</ins></pre>
						
						<p>Finally, we get the final mapped normal by invoking <code>NormalTangentToWorld</code> in <code>LitPassFragment</code>.</p>
						
						<pre translate="no">	surface.normal = <ins>NormalTangentToWorld(</ins>
		<ins>GetNormalTS(input.baseUV), input.normalWS, input.tangentWS</ins>
	<ins>)</ins>;</pre>
						
						<figure>
							<img src="normal-maps/normal-mapped.png" width="260" height="260">
							<figcaption>Normal-mapped sphere.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>Interpolated Normal for Shadow Bias</h3>
						
						<p>Perturbing the normal vector is appropriate for lighting the surface, but we also use the fragment normal to bias shadow sampling. We should use the original surface normal for that. So add a field for it to <code>Surface</code>.</p>
						
						<pre translate="no">struct Surface {
	float3 position;
	float3 normal;
	<ins>float3 interpolatedNormal;</ins>
	&hellip;
};</pre>
						
						<p>Assign the normal vector in <code>LitPassFragment</code>. In this case we can usually get away with skipping normalizing the vector, as most meshes don't have vertex normals that curve so much per triangle that it would negatively affect shadow biasing.</p>
						
						<pre translate="no">	surface.normal = NormalTangentToWorld(
		GetNormalTS(input.baseUV), input.normalWS, input.tangentWS
	);
	<ins>surface.interpolatedNormal = input.normalWS;</ins></pre>
						
						<p>Then use this vector in <code>GetCascadedShadow</code>.</p>
						
						<pre translate="no">float GetCascadedShadow (
	DirectionalShadowData directional, ShadowData global, Surface surfaceWS
) {
	float3 normalBias = surfaceWS.<ins>interpolatedNormal</ins> *
		(directional.normalBias * _CascadeData[global.cascadeIndex].y);
	&hellip;
	if (global.cascadeBlend &lt; 1.0) {
		normalBias = surfaceWS.<ins>interpolatedNormal</ins> *
			(directional.normalBias * _CascadeData[global.cascadeIndex + 1].y);
		&hellip;
	}
	return shadow;
}</pre>
						
					</section>
					
					<section>
						<h3>Detailed Normals</h3>
						
						<p>We can include a normal map for details as well. Although the HDRP combines the detail normal with the albedo and smoothness in a single map, we'll use a <a href="normal-maps/circuitry-detail-normal.png">separate texture</a>. Turn the imported texture into a normal map and enable <em translate="no">Fadeout Mip Maps</em> so its fades out like the other details.</p>
						
						<figure>
							<img src="normal-maps/circuitry-detail-normal.png" width="256" height="256">
							<figcaption>Detail normal map.</figcaption>
						</figure>
						
						<aside>
							<h3>Why not combine both maps?</h3>
							<div>
								<p>While that's more efficient it's harder to generate such a map. Normal vectors should be treated differently than other data channels when generating mip maps, which Unity's texture importer cannot do. Also, Unity ignores the alpha channel when fading mip maps, so data in that channel won't get properly faded. Thus it would require use to generate mip maps ourselves, either outside Unity or with a script. Even then, we'd need to manually decode the normal data instead of relying on <code>UnpackNormalmapRGorAG</code>. I won't cover all that in this tutorial.</p>
							</div>
						</aside>
					
						<p>Add shader properties for the map and again for the normal scale.</p>
						
						<pre translate="no">		_DetailMap("Details", 2D) = "linearGrey" {}
		<ins>[NoScaleOffset] _DetailNormalMap("Detail Normals", 2D) = "bump" {}</ins>
		_DetailAlbedo("Detail Albedo", Range(0, 1)) = 1
		_DetailSmoothness("Detail Smoothness", Range(0, 1)) = 1
		<ins>_DetailNormalScale("Detail Normal Scale", Range(0, 1)) = 1</ins></pre>
						
						<figure>
							<img src="normal-maps/detail-normal-inspector.png" width="304" height="200">
							<figcaption>Detail normal properties; set to half strength.</figcaption>
						</figure>
						
						<p>Adjust <code>GetNormalTS</code> by adding a detail UV parameter and sample the detail map. In this case we can apply the mask by factoring it into the detail normal strength. After that we have to combine both normals, which we can do by invoking <code>BlendNormalRNM</code> with the original and detail normals. This function rotates the detail normal around the base normal.</p>
						
						<pre translate="no">float3 GetNormalTS (float2 baseUV<ins>, float2 detailUV = 0.0</ins>) {
	float4 map = SAMPLE_TEXTURE2D(_NormalMap, sampler_BaseMap, baseUV);
	float scale = INPUT_PROP(_NormalScale);
	float3 normal = DecodeNormal(map, scale);

	<ins>map = SAMPLE_TEXTURE2D(_DetailNormalMap, sampler_DetailMap, detailUV);</ins>
	<ins>scale = INPUT_PROP(_DetailNormalScale) * GetMask(baseUV).b;</ins>
	<ins>float3 detail = DecodeNormal(map, scale);</ins>
	<ins>normal = BlendNormalRNM(normal, detail);</ins>

	return normal;
}</pre>
						
						<p>Finally, pass the detail UV to <code>GetNormalTS</code>.</p>
						
						<pre translate="no">	surface.normal = NormalTangentToWorld(
		GetNormalTS(input.baseUV<ins>, input.detailUV</ins>), input.normalWS, input.tangentWS
	);</pre>
						
						<figure>
							<img src="normal-maps/detail-normal-mapped.png" width="260" height="260">
							<figcaption>Detailed normals.</figcaption>
						</figure>
					</section>
					
				</section>
				
				<section>
					<h2>Optional Maps</h2>
					
					<p>Not every material needs all maps that we currently support. Leaving a map unassigned means that the result doesn't get altered, but the shader still does all the work, using the default texture. We can avoid unneeded work by adding a few shader features to control which maps get used by the shader. Unity's shaders do this automatically based on which maps are assigned in the editor, but we'll control this with explicit toggles.</p>
					
					<section>
						<h3>Normal Maps</h3>
						
						<p>We start with normal maps, which are the most expensive features. Add a toggle shader property linked to an appropriate keyword.</p>
						
						<pre translate="no">		<ins>[Toggle(_NORMAL_MAP)] _NormalMapToggle ("Normal Map", Float) = 0</ins>
		[NoScaleOffset] _NormalMap("Normals", 2D) = "bump" {}
		_NormalScale("Normal Scale", Range(0, 1)) = 1</pre>
						
						<figure>
							<img src="optional-maps/optional-normal-maps.png" width="304" height="86">
							<figcaption>Optional normal maps enabled.</figcaption>
						</figure>
						
						<p>Add a matching shader feature pragma to the <em translate="no">CustomLit</em> pass only. None of the other passes need mapped normals so shouldn't get the feature.</p>
						
						<pre translate="no">			<ins>#pragma shader_feature _NORMAL_MAP</ins></pre>
						
						<p>In <code>LitPassFragment</code>, either use the tangent-space normal or just normalize the interpolated normal, based on the keyword. And in the latter case we might as well use the normalized version for the interpolated normal.</p>
						
						<pre translate="no">	<ins>#if defined(_NORMAL_MAP)</ins>
		surface.normal = NormalTangentToWorld(
			GetNormalTS(input.baseUV, input.detailUV),
			input.normalWS, input.tangentWS
		);
		surface.interpolatedNormal = input.normalWS;
	<ins>#else</ins>
		<ins>surface.normal = normalize(input.normalWS);</ins>
		<ins>surface.interpolatedNormal = surface.normal;</ins>
	<ins>#endif</ins></pre>
						
						<p>Also, omit the tangent vector from <code>Varyings</code> if possible. We don't need to omit it from <code>Attributes</code> because it'll get automatically ignored there if we don't use it.</p>
						
						<pre translate="no">struct Varyings {
	&hellip;
	<ins>#if defined(_NORMAL_MAP)</ins>
		float4 tangentWS : VAR_TANGENT;
	<ins>#endif</ins>
	&hellip;
};

Varyings LitPassVertex (Attributes input) {
	&hellip;
	<ins>#if defined(_NORMAL_MAP)</ins>
		output.tangentWS = float4(
			TransformObjectToWorldDir(input.tangentOS.xyz), input.tangentOS.w
		);
	<ins>#endif</ins>
	&hellip;
}</pre>
						
					</section>
					
					<section>
						<h3>Input Config</h3>
						
						<p>At this point we should reconsider how we pass data to the getter functions of <em translate="no">LitInput</em>. We can end up with any combination of using or not using multiple things, which we have to communicate somehow. Let's do this by introducing an <code>InputConfig</code> struct, initially bundling base and detail UV coordinates. Also create a convenient <code>GetInputConfig</code> function that returns a config given base UV and optional detail UV.</p>
						
						<pre translate="no"><ins>struct InputConfig {</ins>
	<ins>float2 baseUV;</ins>
	<ins>float2 detailUV;</ins>
<ins>};</ins>

<ins>InputConfig GetInputConfig (float2 baseUV, float2 detailUV = 0.0) {</ins>
	<ins>InputConfig c;</ins>
	<ins>c.baseUV = baseUV;</ins>
	<ins>c.detailUV = detailUV;</ins>
	<ins>return c;</ins>
<ins>}</ins></pre>
						
						<p>Now adjust all <code>LitInput</code> functions except <code>TransformBaseUV</code> and <code>TransformDetailUV</code> so they have a single config parameter. I only show the changes to <code>GetBase</code>.</p>
						
						<pre translate="no">float4 GetBase (<ins>InputConfig c</ins>) {
	float4 map = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, <ins>c.</ins>baseUV);
	float4 color = INPUT_PROP(_BaseColor);
	
	float detail = GetDetail(<ins>c</ins>).r * INPUT_PROP(_DetailAlbedo);
	float mask = GetMask(<ins>c</ins>).b;
	&hellip;
}</pre>
						
						<p>Then adjust <code>LitPassFragment</code> so it uses the new config approach.</p>
						
						<pre translate="no">	<ins>InputConfig config = GetInputConfig(input.baseUV, input.detailUV);</ins>
	float4 base = GetBase(<ins>config</ins>);
	#if defined(_CLIPPING)
		clip(base.a - GetCutoff(<ins>config</ins>));
	#endif
	
	Surface surface;
	surface.position = input.positionWS;
	#if defined(_NORMAL_MAP)
		surface.normal = NormalTangentToWorld(
			GetNormalTS(<ins>config</ins>), input.normalWS, input.tangentWS
		);
	#else
		surface.normal = normalize(input.normalWS);
	#endif
	&hellip;
	surface.metallic = GetMetallic(<ins>config</ins>);
	surface.occlusion = GetOcclusion(<ins>config</ins>);
	surface.smoothness = GetSmoothness(<ins>config</ins>);
	surface.fresnelStrength = GetFresnel(<ins>config</ins>);
	&hellip;
	color += GetEmission(<ins>config</ins>);</pre>
						
						<p>Adjust the other passes&mdash;<em translate="no">MetaPass</em>, <em translate="no">ShadowCasterPass</em>, and <em translate="no">UnlitPass</em>&mdash;to use the new approach as well. This means that we also have to make <em translate="no">UnlitPass</em> use the new approach.</p>
						
					</section>
					
					<section>
						<h3>Optional Mask Map</h3>
						
						<p>Next, let's make the mask map optional by adding a boolean for it to <code>InputConfig</code>, set to <code>false</code> by default.</p>
						
						<pre translate="no">struct InputConfig {
	float2 baseUV;
	float2 detailUV;
	<ins>bool useMask;</ins>
};

InputConfig GetInputConfig (float2 baseUV, float2 detailUV = 0.0) {
	InputConfig c;
	c.baseUV = baseUV;
	c.detailUV = detailUV;
	<ins>c.useMask = false;</ins>
	return c;
}</pre>
						
						<p>We can avoid sampling the mask by simply returning 1 in <code>GetMask</code>. This assumes that the mask toggle is constant, so it won't cause a branch in the shader.</p>
						
						<pre translate="no">float4 GetMask (InputConfig c) {
	<ins>if (c.useMask) {</ins>
		return SAMPLE_TEXTURE2D(_MaskMap, sampler_BaseMap, c.baseUV);
	<ins>}</ins>
	<ins>return 1.0;</ins>
}</pre>
						
						<p>Add a toggle for it to our shader.</p>
						
						<pre translate="no">		<ins>[Toggle(_MASK_MAP)] _MaskMapToggle ("Mask Map", Float) = 0</ins>
		[NoScaleOffset] _MaskMap("Mask (MODS)", 2D) = "white" {}</pre>
						
						<p>Along with the relevant pragma in the <em translate="no">CustomLit</em> pass.</p>
						
						<pre translate="no">			<ins>#pragma shader_feature _MASK_MAP</ins></pre>
						
						<figure>
							<img src="optional-maps/optional-mask-map.png" width="304" height="86">
							<figcaption>Optional mask map.</figcaption>
						</figure>
						
						<p>Now turn on the mask in <code>LitPassFragment</code> only when needed.</p>
						
						<pre translate="no">	InputConfig config = GetInputConfig(input.baseUV, input.detailUV);
	<ins>#if defined(_MASK_MAP)</ins>
		<ins>config.useMask = true;</ins>
	<ins>#endif</ins></pre>
						
					</section>
					
					<section>
						<h3>Optional Detail</h3>
						
						<p>Using the same approach, add a toggle for detail to <code>InputConfig</code>, again disabled by default.</p>
						
						<pre translate="no">struct InputConfig {
	&hellip;
	<ins>bool useDetail;</ins>
};

InputConfig GetInputConfig (float2 baseUV, float2 detailUV = 0.0) {
	&hellip;
	<ins>c.useDetail = false;</ins>
	return c;
}</pre>
						
						<p>Only sample the detail map in <code>GetDetail</code> when needed, otherwise return zero.</p>
						
						<pre translate="no">float4 GetDetail (InputConfig c) {
	<ins>if (c.useDetail) {</ins>
		float4 map = SAMPLE_TEXTURE2D(_DetailMap, sampler_DetailMap, c.detailUV);
		return map * 2.0 - 1.0;
	<ins>}</ins>
	<ins>return 0.0;</ins>
}</pre>
						
						<p>That avoids sampling the detail map, but incorporating the details still happens. To stop that also skip the relevant code in <code>GetBase</code>.</p>
						
						<pre translate="no">	<ins>if (c.useDetail) {</ins>
		float detail = GetDetail(c).r * INPUT_PROP(_DetailAlbedo);
		float mask = GetMask(c).b;
		map.rgb =
			lerp(sqrt(map.rgb), detail &lt; 0.0 ? 0.0 : 1.0, abs(detail) * mask);
		map.rgb *= map.rgb;
	<ins>}</ins></pre>
						
						<p>And in <code>GetSmoothness</code>.</p>
						
						<pre translate="no">	<ins>if (c.useDetail) {</ins>
		float detail = GetDetail(c).b * INPUT_PROP(_DetailSmoothness);
		float mask = GetMask(c).b;
		smoothness =
			lerp(smoothness, detail &lt; 0.0 ? 0.0 : 1.0, abs(detail) * mask);
	<ins>}</ins></pre>
						
						<p>And in <code>GetNormalTS</code>.</p>
						
						<pre translate="no">	<ins>if (c.useDetail) {</ins>
		map = SAMPLE_TEXTURE2D(_DetailNormalMap, sampler_DetailMap, c.detailUV);
		scale = INPUT_PROP(_DetailNormalScale) * GetMask(c).b;
		float3 detail = DecodeNormal(map, scale);
		normal = BlendNormalRNM(normal, detail);
	<ins>}</ins></pre>
						
						<p>Then add a toggle property for the details to the shader.</p>
						
						<pre translate="no">		<ins>[Toggle(_DETAIL_MAP)] _DetailMapToggle ("Detail Maps", Float) = 0</ins>
		_DetailMap("Details", 2D) = "linearGrey" {}</pre>
						
						<p>Once again with an accompanying shader feature in <em translate="no">CustomLit</em>.</p>
						
						<pre translate="no">			<ins>#pragma shader_feature _DETAIL_MAP</ins></pre>
						
						<figure>
							<img src="optional-maps/optional-detail-maps.png" width="304" height="86">
							<figcaption>Optional details.</figcaption>
						</figure>
						
						<p>Now we only need to include detail UV in <code>Varyings</code> when the relevant keyword is defined.</p>
						
						<pre translate="no">struct Varyings {
	&hellip;
	#if defined(_DETAIL_MAP)
		float2 detailUV : VAR_DETAIL_UV;
	#endif
	&hellip;
};

Varyings LitPassVertex (Attributes input) {
	&hellip;
	<ins>#if defined(_DETAIL_MAP)</ins>
		output.detailUV = TransformDetailUV(input.baseUV);
	<ins>#endif</ins>
	return output;
}</pre>
						
						<p>Finally, include details in <code>LitPassFragment</code> only when needed.</p>
						
						<pre translate="no">	InputConfig config = GetInputConfig(<ins>input.baseUV</ins>);
	#if defined(_MASK_MAP)
		config.useMask = true;
	#endif
	<ins>#if defined(_DETAIL_MAP)</ins>
		<ins>config.detailUV = input.detailUV;</ins>
		<ins>config.useDetail = true;</ins>
	<ins>#endif</ins></pre>
											
						<p>The next tutorial is <a href="../point-and-spot-lights/index.html">Point and Spot Lights</a>.</p>
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/custom-srp-08-complex-maps/" class="repository">repository</a>
					<a href="Complex-Maps.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>