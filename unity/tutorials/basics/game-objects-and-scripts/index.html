<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/tutorial-image.jpg">
		<meta property="og:title" content="Game Objects and Scripts">
		<meta property="og:description" content="A Unity Basics tutorial about creating game objects and your own script.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Game Objects and Scripts</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/#article",
				"headline": "Game Objects and Scripts",
				"alternativeHeadline": "Creating a Clock",
				"datePublished": "2017-09-08",
				"dateModified": "2021-05-18",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Basics tutorial about creating game objects and your own script.",
				"image": "https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/tutorial-image.jpg",
				"dependencies": "Unity 2020.3.6f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/basics/", "name": "Basics" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				Clock: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Basics</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Game Objects and Scripts</h1>
					<p>Creating a Clock</p>
					<ul>
						<li>Build a clock with simple objects.</li>
						<li>Write a C# script.</li>
						<li>Rotate the clock's arms to show the time.</li>
						<li>Animate the arms.</li>
					</ul>
				</header>

				<p>This is the first tutorial in a series about learning the <a href="../index.html">basics</a> of working with Unity. In it we will create a simple clock and program a component to have it display the current time. You don't need to have any experience with the Unity editor yet, but you're assumed to have some experience with multi-window editor applications in general.</p>
				
				<p>At the bottom of all my recent tutorials you'll find links to the tutorial license, a repository containing the finished tutorial project, and a PDF version of the tutorial page.</p>
				
				<p>This tutorial is made with Unity 2020.3.6f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>It is time to create a clock.</figcaption>
				</figure>
				
				<section>
					<h2>Creating a Project</h2>
					
					<p>Before we can start working with the Unity editor we must first create a project.</p>
					
					<section>
						<h3>New Project</h3>
						
						<p>When you open Unity you will be presented with the Unity Hub. This is a launcher and installer app from where you can create or open projects, install Unity versions, and do some other things. If you don't have Unity 2020.3 or higher installed add it now.</p>
						
						<aside>
							<h3>Which Unity versions are appropriate?</h3>
							<div>
								<p>Unity releases multiple new versions per year. There are two parallel release schedules. The most stable and safe are the LTS releases. LTS stands for long term support, which is two years in Unity's case. I stick to LTS versions for my tutorials, of which 2020.3 is the latest. This tutorial uses 2020.3.6 specifically. The third portion of the version number indicates the patch release. Patch releases contain bug fixes and only rarely new functionality. A further f1 suffix indicates an official final release. Any 2020.3 version will do for this tutorial.</p>
								
								<p>The highest Unity version&mdash;like 2021.1&mdash;is usually of the development branch, which introduces new features and possibly removes old functionality. These versions aren't as reliable as LTS versions and only remain supported for a few months each.</p>
							</div>
						</aside>
						
						<p>Occasionally my tutorials contain little questions and their answers, always in a gray box, like the one above. On a web page the answer is hidden by default. This can be toggled by clicking or tapping the question.</p>
						
						<p>When you create a new project you get to pick its Unity version and a template. We'll use the standard 3D template. Once it's created it gets added to the list of projects and gets opened in the appropriate version of the Unity editor.</p>
						
						<aside>
							<h3>Can I create a project with a different render pipeline?</h3>
							<div>
								<p>Yes, the only difference is that the project will have more things in its default scene and your materials will look different. Your project will also contain the appropriate packages.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Editor Layout</h3>
						
						<p>If you haven't customized the editor yet, you will end up with its default window layout.</p>
						
						<figure>
							<img src="creating-a-project/default-layout.png" width="600" height="356">
							<figcaption>Default editor layout.</figcaption>
						</figure>
						
						<p>The default layout contains all the windows that we need, but you can customize it as you like, by reordering and grouping windows. You can also open and close windows, like the one of the asset store. Each window also has its own configuration options, accessible via the triple-dot button in their top right corner. Besides that most also have a toolbar with more options. If your window doesn't look the same as in the tutorials&mdash;for example the scene window has a uniform background instead of a skybox&mdash;then one of its options is different.</p>
						
						<p>You can switch to a preconfigured layout via the dropdown menu at the top right of the Unity editor. You can also save your current layout there so you can revert to it later.</p>
					</section>
					
					<section>
						<h3>Packages</h3>
						
						<p>Unity's functionality is modular. Besides the core functionality there are extra packages that can be downloaded and included in your project. The default 3D project currently includes a few packages by default, which you can see in the project window under <em translate="no">Packages</em>.</p>
						
						<figure>
							<img src="creating-a-project/default-packages.png" width="200" height="162">
							<figcaption>Default packages.</figcaption>
						</figure>
						
						<p>These packages can be hidden, by toggling the button at the top right of the project window that looks like an eye with a dash through it. This is purely to reduce visual clutter in the editor, the packages are still part of the project. The button also displays how many such packages there are.</p>
						
						<p>You can control which packages are included in your project via the package manager, which can be opened via the <em translate="no">Window / Package Manager</em> menu item.</p>
						
						<figure>
							<img src="creating-a-project/package-manager.png" width="700" height="296">
							<figcaption>Package manager, only showing packages in project.</figcaption>
						</figure>
						
						<p>The packages add extra functionality to Unity. For example, <em>Visual Studio Editor</em> adds integration for the Visual Studio editor, used to write code. This tutorial doesn't use the functionality of the included packages, so I removed them all. The only exception is <em>Visual Studio Editor</em> because that's the editor that I use for writing code. If you use a different editor you'd want to include its integration package, if it exists.</p>
						
						<aside>
							<h3>Don't you also need the <em>Visual Studio Code Editor</em> package?</h3>
							<div>
								<p>Despite the similar names, <em>Visual Studio</em> and <em>Visual Studio Code</em> are two different editors. You only need one of the packages, depending on which editor you use.</p>
							</div>
						</aside>
						
						<p>The easiest way to remove packages is by first using the toolbar to limit the package list to <em translate="no">In Project</em> only. Then select the packages one at a time and use the <em translate="no">Remove</em> button at the bottom right of the window. Unity will recompile after each removal, so it takes a few seconds before the process is finished.</p>
						
						<p>After removing everything except <em>Visual Studio Editor</em> I an left with three packages visible in the project window: <em>Custom NUnit</em>, <em>Test Framework</em>, and <em>Visual Studio Editor</em>. The other two are still there because <em>Visual Studio Editor</em> depends on them.</p>
						
						<p>You can make dependencies and implicitly imported packages visible in the package manager via the project settings window, opened via <em>Edit / Project Settings...</em> Select its <em>Package Manager</em> category and then enable <em>Show Dependencies</em> under <em>Advanced Settings</em>.</p>
						
						<figure>
							<img src="creating-a-project/package-manager-settings.png" width="690" height="210">
							<figcaption>Package manager project settings; <em>Show Dependencies</em> enabled.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Color Space</h3>
						
						<p>Nowadays rendering is usually done in linear color space, but Unity still configured to use gamma color space by default. For best visual results select the <em translate="no">Player</em> category of the project settings window, open the <em translate="no">Other Settings</em> panel, and scroll down to its <em translate="no">Rendering</em> section. Make sure that <em translate="no">Color Space</em> is set to <em translate="no">Linear</em>. Unity will show warning that this might take a long time, but this won't be the case for a nearly-empty project. Confirm to switch.</p>
						
						<figure>
							<img src="creating-a-project/color-space.png" width="690" height="164">
							<figcaption>Color space set to linear.</figcaption>
						</figure>
						
						<aside>
							<h3>Is there a reason to ever use gamma color space?</h3>
							<div>
								<p>Only when you're targeting old hardware or old graphics APIs. OpenGL ES 2.0 and WebGL 1.0 don't support linear space, besides that gamma can be faster than linear on old mobile devices.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Sample Scene</h3>
						
						<p>The new project contains a sample scene named <em translate="no">SampleScene</em>, which is opened by default. You can find its asset under <em translate="no">Assets / Scenes</em> in the project window.</p>
						
						<figure>
							<img src="creating-a-project/two-column-layout.png" width="310" height="112">
							<figcaption>Sample scene in project window.</figcaption>
						</figure>
						
						<p>By default the project window uses a two-column layout. You can switch to a one-column layout via its triple-dot configuration menu option.</p>
						
						<figure>
							<img src="creating-a-project/one-column-layout.png" width="150" height="54">
							<figcaption>One-column layout.</figcaption>
						</figure>
						
						<p>The sample scene contains a main camera and a directional light. These are game objects. They are listed in the hierarchy window, under the scene.</p>
						
						<figure>
							<img src="creating-a-project/sample-scene-hierarchy.png" width="277" height="71">
							<figcaption>Object hierarchy within scene.</figcaption>
						</figure>
						
						<p>You can select a game object either via the hierarchy window or the scene window. The camera has a scene icon that looks like an oldfashioned film camera while the directional light's icon looks like a sun.</p>
						
						<figure>
							<img src="creating-a-project/scene-icons.png" width="210" height="120">
							<figcaption>Icons in scene window.</figcaption>
						</figure>
						
						<aside>
							<h3>How do I navigate the scene window?</h3>
							<div>
								<p>You can use the alt or option key in combination with the cursor to rotate the view. You can also use the arrow keys to move the point of view, and zoom by scrolling. Also, pressing the F key focuses the view on the game object that is currently selected. There are more possibilities, but these are enough to find your way around the scene.</p>
							</div>
						</aside>
						
						<p>When an object is selected details about it will be shown in the inspector window, but we'll cover those when we need them. We won't need to modify the camera nor the light, so we can hide them in the scene by clicking the eye icon to the left of them in the hierarchy window. This icon is invisible by default but will appear when we hover the cursor there. This is purely to reduce visual clutter in the scene window.</p>
						
						<figure>
							<img src="creating-a-project/hidden-objects.png" width="283" height="35">
							<figcaption>Hidden objects.</figcaption>
						</figure>
						
						<aside>
							<h3>What does the hand-like icon next to the eye do?</h3>
							<div>
								<p>Next to the column that contains the eye icons is another column that contains hand-like icons. These icons are also invisible by default. When a game object's hand icon is active it is impossible to select the object via the scene window. This way you can control which objects respond to selection via the scene window.</p>
							</div>
						</aside>
					</section>
					
				</section>
				
				<section>
					<h2>Building a Simple Clock</h2>
					
					<p>Now that our project is set up correctly we can start creating our clock.</p>
					
					<section>
						<h3>Creating a Game Object</h3>
						
						<p>We need a game object to represent the clock. We'll start with the simplest possible game object, which is an empty one. It can be created via the <em translate="no">GameObject / Create Empty</em> menu option. Alternatively, you can use the <em translate="no">Create Empty</em> option in the context menu of the hierarchy window, which you can open with an alternative click, usually a right-click or a two-finger tap. This will add the game object to the scene. It's visible and immediately selected in the hierarchy window under <em translate="no">SampleScene</em>, which is now marked with an asterisk to indicate that it has unsaved changes. You can also immediately change its name or leave that for later.</p>
						
						<figure>
							<img src="building-a-simple-clock/new-game-object.png" width="283" height="64">
							<figcaption>Hierarchy with new game object selected.</figcaption>
						</figure>
						
						<p>The inspector window shows the details of the game object as long as it is selected. At its top is a header with the object's name plus a few configuration options. By default, the object is enabled, is not static, is untagged, and sits on the default layer. These settings are fine, except its name. Rename it to <em translate="no">Clock</em>.</p>
						
						<figure>
							<img src="building-a-simple-clock/inspector.png" width="320" height="192">
							<figcaption>Inspector window with clock selected.</figcaption>
						</figure>
						
						<p> Below the header is a list of all the components of the game object. The list always has a <code>Transform</code> component at the top, which is all our clock currently has. It controls the position, rotation, and scale of the game object. Make sure that all the clock's position and rotation values are set to 0. Its scale should be uniformly 1.</p>
						
						<aside>
							<h3>What about 2D objects?</h3>
							<div>
								<p>When working in 2D instead of 3D, you can ignore one of the three dimensions. Objects specifically meant for 2D&mdash;like UI elements&mdash;typically have a <code>RectTransform</code> instead, which is a specialized <code>Transform</code> component.</p>
							</div>
						</aside>
						
						<p>Because the game object is empty it isn't visible in the scene window itself. However, a manipulation tool is visible at the game object's location, which is at the center of the world.</p>
						
						<figure>
							<img src="building-a-simple-clock/move-tool.png" width="170" height="160">
							<figcaption>Selected with move tool.</figcaption>
						</figure>
						
						<aside>
							<h3>Why don't I see a manipulation tool after selecting the clock?</h3>
							<div>
								<p>The manipulation tool exists in the scene window. Make sure that you're looking at the scene window, not the game window.</p>
							</div>
						</aside>
						
						<p>Which manipulation tool is active can be controlled via the buttons at the top left of the editor toolbar. The modes can also be activated via the Q, W, E, R, T, and Y keys. The rightmost button in the group is for enabling custom editor tools, which we don't have. The move tool is active by default. </p>
						
						<figure>
							<img src="building-a-simple-clock/manipulation-toolbar.png" width="410" height="28">
							<figcaption>Manipulation mode toolbar.</figcaption>
						</figure>
						
						<p>Next to the mode buttons are three more buttons to control the placement, orientation, and snapping of manipulation tools.</p>
					</section>
					
					<section>
						<h3>Creating the Face of the Clock</h3>
						
						<p>Although we have a clock object, we don't see anything yet. We'll have to add 3D models to it so something gets rendered. Unity contains a few primitive objects that we can use to build a simple clock. Let's begin by adding a cylinder to the scene via <em translate="no">GameObject / 3D Object / Cylinder</em>. Make sure that it has the same <code>Transform</code> values as our clock.</p>
						
						<figure>
							<img src="building-a-simple-clock/cylinder-scene.png" width="166" height="220" alt="scene">
							<img src="building-a-simple-clock/cylinder-inspector.png" width="320" height="320" alt="inspector">
							<figcaption>Game object representing a cylinder.</figcaption>
						</figure>
						
						<p>The new object has three more components than an empty game object. First, it has a <code>MeshFilter</code>, which contains a reference to the built-in cylinder mesh.</p>
						
						<figure>
							<img src="building-a-simple-clock/mesh-filter.png" width="320" height="52">
							<figcaption><code>MeshFilter</code> component, set to cylinder.</figcaption>
						</figure>
						
						<p>Second is a <code>MeshRenderer</code>. This component's purpose is to ensure that the object's mesh gets rendered. It also determines what material is used for rendering, which is the default material. This material is also shown in the inspector, below the component list.</p>
						
						<figure>
							<img src="building-a-simple-clock/mesh-renderer.png" width="320" height="161">
							<figcaption><code>MeshRenderer</code> component, set to default material.</figcaption>
						</figure>
						
						<p>Third is a <code>CapsuleCollider</code>, which is for 3D physics. The object represents a cylinder, but it has a capsule collider because Unity doesn't have a primitive cylinder collider. We don't need it, so we can remove this component. If you'd like to use physics with your clock, you're better off using a <code>MeshCollider</code> component. Components can be removed via the triple-dot dropdown menu in their top right corner.</p>
						
						<figure>
							<img src="building-a-simple-clock/cylinder-without-collider.png" width="320" height="178">
							<figcaption>Cylinder without collider.</figcaption>
						</figure>
						
						<p>We'll turn the cylinder into the clock's face, by flattening it. This is done by decreasing the Y component of its scale. Reduce it to 0.2. As the cylinder mesh is two units high, its effective height becomes 0.4 units. Let's also make a big clock, so increase the X and Z components of its scale to 10.</p>
						
						<figure>
							<img src="building-a-simple-clock/cylinder-scaled-scene.png" width="320" height="206" alt="scene"><br>
							<img src="building-a-simple-clock/cylinder-scaled-inspector.png" width="320" height="96" alt="inspector">
							<figcaption>Scaled cylinder.</figcaption>
						</figure>
						
						<p>Our clock is supposed to stand or hang on a wall, but its face is currently laying flat. We can fix this by rotating the cylinder a quarter turn. In Unity the X axis points right, the Y axis points up, and the Z axis points forward. So let's design our clock with the same orientation in mind, meaning that we see its front while we're looking at it along the Z axis. Set the cylinder's X rotation to 90 and adjust the scene view so the clock's front is visible, so the blue Z arrow of the move tool points away from you, into the screen.</p>
						
						<figure>
							<img src="building-a-simple-clock/cylinder-rotated-scene.png" width="320" height="290" alt="scene"><br>
							<img src="building-a-simple-clock/cylinder-rotated-inspector.png" width="320" height="96" alt="inspector">
							<figcaption>Rotated cylinder.</figcaption>
						</figure>
						
						<p>Change the name of the cylinder object to <em translate="no">Face</em>, as it represents the face of the clock. It is only one part of the clock, so we make it a child of the <em translate="no">Clock</em> object. We do this by dragging the face onto the clock in the hierarchy window.</p>
						
						<figure>
							<img src="building-a-simple-clock/child-object.png" width="200" height="36">
							<figcaption>Face child object.</figcaption>
						</figure>
						
						<p>Child objects are subject to the transformation of their parent object. This means that when <em translate="no">Clock</em> changes position, <em translate="no">Face</em> does as well. It's as if they are a single entity. The same goes for rotation and scale. You can use this to make complex object hierarchies.</p>
					</section>
					
					<section>
						<h3>Creating the Clock Periphery</h3>
						
						<p>The outer ring of a clock's face usually has markings that help indicate what time it is displaying. This is known as the clock periphery. Let's use blocks to indicate the hours of a 12-hour clock.</p>
						
						<p>Add a cube object to the scene via <em translate="no">GameObject / 3D Object / Cube</em>, name it <em translate="no">Hour Indicator 12</em>, and also make it a child of <em translate="no">Clock</em>. The order of the child objects in the hierarchy doesn't matter, you could place it either above or below the face.</p>
						
						<figure>
							<img src="building-a-simple-clock/hour-indicator-child.png" width="200" height="52">
							<figcaption>Hour indicator child object.</figcaption>
						</figure>
						
						<p>Set its X scale to 0.5, Y scale to 1, and Z scale to 0.1 so it becomes a narrow flat long block. Then set its X position to 0, Y position to 4, and Z position to &minus;0.25. That places it on top of the face to indicate hour 12. Also remove its <code>BoxCollider</code> component.</p>
						
						<figure>
							<img src="building-a-simple-clock/indicator-scene.png" width="190" height="266" alt="scene">
							<img src="building-a-simple-clock/indicator-inspector.png" width="320" height="266" alt="inspector">
							<figcaption>Indicator for hour 12.</figcaption>
						</figure>
						
						<p>The indicator is hard to see, because it has the same color as the face. Let's create a separate material for it, via <em translate="no">Assets / Create / Material</em>, or via the plus button or context menu of the project window. This gives us a material asset that is a duplicate of the default material. Change its name to <em translate="no">Hour Indicator</em>.</p>
						
						<figure>
							<img src="building-a-simple-clock/material-project-one-column.png" width="140" height="52" alt="one-column"><br>
							<img src="building-a-simple-clock/material-project-two-column.png" width="364" height="92" alt="two-column">
							<figcaption>Hour indicator in project window, one and two column layout.</figcaption>
						</figure>
						
						<p>Select the material and change its <em translate="no">Albedo</em> to something else, by clicking its color field. That opens a color popup window which offers various ways to pick a color. I chose dark gray, corresponding to hexadecimal 494949, which is the same as uniform 73 for RGB 0&ndash;255 mode. We don't use the alpha channel so its value is irrelevant. We can also leave all other material properties as they are.</p>
						
						<figure>
							<img alt="color popup" src="building-a-simple-clock/hour-indicator-material.png" width="320" height="120">
							<figcaption>Dark gray albedo.</figcaption>
						</figure>
						
						<aside>
							<h3>What is albedo?</h3>
							<div>
								<p>Albedo is a Latin word which means whiteness. It's the color of something when illuminated by white light.</p>
							</div>
						</aside>
						
						<p>Make the hour indicator use this material. You can do this by dragging the material onto the object in either the scene or hierarchy window. You can also drag it to the bottom of the inspector window when the indicator game object is selected, or change <em translate="no">Element 0</em> of the <em translate="no">Materials</em> array of its <code>MeshRenderer</code>.</p>
						
						<figure>
							<img src="building-a-simple-clock/dark-hour-indicator-scene.png" width="180" height="215" alt="scene">
							<img src="building-a-simple-clock/dark-hour-indicator-inspector.png" width="320" height="215" alt="inspector">
							<figcaption>Dark hour indicator.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Twelve Hour Indicators</h3>
						
						<p>We could make do with a single indicator for hour 12, but let's include one for every hour. Begin by orienting the scene view camera so we look straight down the Z axis. You can do this by clicking on the axis cones of the view camera gizmo at the top right of the scene view. You can also change the axis of the scene grid to Z via the grid toolbar button.</p>
						
						<figure>
							<img src="building-a-simple-clock/looking-along-z-axis.png" width="586" height="306">
							<figcaption>Looking straight at clock, along Z axis.</figcaption>
						</figure>
						
						<p>Duplicate the <em translate="no">Hour Indicator 12</em> game object. You can do this via <em translate="no">Edit / Duplicate</em>, via the indicated keyboard shortcut, or via the its context menu in the hierarchy window. The duplicate will appear underneath the original in the hierarchy window, also a child of <em translate="no">Clock</em>. Its name is set to <em translate="no">Hour Indicator 12 (1)</em>. Rename it to <em translate="no">Hour Indicator 6</em> and negate the Y component of its position so it indicates hour 6.</p>
						
						<figure>
							<img src="building-a-simple-clock/hour-indicator-6-hierarchy.png" width="200" height="68" alt="hierarchy"><br>
							<img src="building-a-simple-clock/hour-indicator-6-scene.png" width="224" height="224" alt="scene">
							<figcaption>Indicators for hours 6 and 12.</figcaption>
						</figure>
						
						<p>Create indicators for hours 3 and 9 in the same way. In this case their X positions should be 4 and &minus;4 while their Y positions should be zero. Also, set their Z rotation to 90 so they're turned a quarter circle.</p>
						
						<figure>
							<img src="building-a-simple-clock/four-hour-indicators.png" width="224" height="224">
							<figcaption>Four hour indicators.</figcaption>
						</figure>
						
						<p>Then create another duplicate of <em translate="no">Hour Indicator 12</em>, this time for hour 1. Set its X position to 2, its Y position to 3.464, and its Z rotation to &minus;30. Then duplicate that one for hour 2, swap its X and Y positions, and double its Z rotation to &minus;60.</p>
						
						<figure>
							<img src="building-a-simple-clock/hour-indicators-1-2.png" width="224" height="224">
							<figcaption>Indicators for hours 1 and 2.</figcaption>
						</figure>
						
						<aside>
							<h3>Where do those numbers come from?</h3>
							<div>
								<p>Each hour covers a 30&deg; clockwise rotation along the Z axis. In this case we use negative rotations because Unity's rotation is counterclockwise. We can find the position for hour 1 via trigonometry. The sine of 30&deg; is &frac12; and its cosine is `sqrt(3)/2`. We scale those by the distance at which we position the hours indicator from the center, which is 4. So we end up with X 2 and Y `2sqrt(3)~~3.464`. For hour 2 the rotation is 60&deg;, for which we can simply swap the sine and cosine.</p>
							</div>
						</aside>
						
						<p>Duplicate these two indicators and negate their Y positions and their rotations to create the indicators for hours 4 and 5. Then use the same trick on hours 1, 2, 4, and 5 to create the remaining indicators, this time negating their X positions and again their rotations.</p>
						
						<figure>
							<img src="building-a-simple-clock/all-hour-indicators.png" width="224" height="224">
							<figcaption>All hour indicators.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Creating the Arms</h3>
						
						<p>The next step is to create the arms of the clock. We start with the hour arm. Again duplicate <em translate="no">Hour Indicator 12</em> and name it <em translate="no">Hours Arm</em>. Then create a <em translate="no">Clock Arm</em> material and make the arm use it. In this case I made it solid black, hexadecimal 000000. Decrease the arm's X scale to 0.3 and increase its Y scale to 2.5. Then change its Y position to 0.75 so it points towards hour 12, but also a bit in the opposite direction. That makes it look as if the arm has a little counterweight when it rotates.</p>
						
						<figure>
							<img src="building-a-simple-clock/hours-arm-scene.png" width="224" height="224" alt="scene">
							<img alt="inspector" src="building-a-simple-clock/hours-arm-inspector.png" width="320" height="248">
							<figcaption>Hours arm.</figcaption>
						</figure>
						
						<p>The arm must rotate around the center of the clock, but changing its Z rotation makes it rotate around its own center.</p>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/candidcleanekaltadeta?controls=0'></iframe></div>
							<figcaption>Clock arm rotates around its center.</figcaption>
						</figure>
						
						<p>This happens because rotation is relative to the local position of the game object. To create the appropriate rotation we have to introduce a pivot object and rotate that one instead. So create a new empty game object and make it a child of <em translate="no">Clock</em>. You can do this directly by creating the object via the context menu of <em translate="no">Clock</em> in the hierarchy window. Name it <em translate="no">Hours Arm Pivot</em> and make sure that its position and rotation are zero and its scale is uniformly 1. Then make <em translate="no">Hours Arm</em> a child of the pivot.</p>
						
						<figure>
							<img src="building-a-simple-clock/hours-arm-hierarchy.png" width="200" height="65">
							<figcaption>Hours arm with pivot.</figcaption>
						</figure>
						
						<p>Now try rotating the pivot. If you do this via the scene view make sure that the tool handle position mode is set to <em translate="no">Pivot</em> instead of <em translate="no">Center</em>.</p>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/dismalunhealthyazurevase?controls=0'></iframe></div>
							<figcaption>Clock arm rotates around the pivot.</figcaption>
						</figure>
						
						
						<p>Duplicate <em translate="no">Hours Arm Pivot</em> twice to create a <em translate="no">Minutes Arm Pivot</em> and a <em translate="no">Seconds Arm Pivot</em>. Rename them accordingly, including the duplicated arm child objects.</p>
						
						<figure>
							<img src="building-a-simple-clock/all-arms-hierarchy.png" width="210" height="130">
							<figcaption>All arm hierarchies.</figcaption>
						</figure>
						
						<p><em translate="no">Minutes Arm</em> should be narrower and longer than <em translate="no">Hours Arm</em>, so set its X scale to 0.2 and Y scale to 4, then increase its Y position to 1. Also change its Z position to &minus;0.35 so it sits on top of the hours arm. Note that this applies to the arm, not its pivot.</p>
						
						<figure>
							<img src="building-a-simple-clock/minutes-arm-transform.png" width="320" height="70">
							<figcaption><code>Transform</code> of <em translate="no">Minutes Arm</em>.</figcaption>
						</figure>
						
						<p>Adjust <em translate="no">Seconds Arm</em> as well. This time use 0.1 and 5 for the XY scale and 1.25 and &minus;0.45 for the YZ position.</p>
						
						<figure>
							<img src="building-a-simple-clock/seconds-arm-transform.png" width="320" height="70">
							<figcaption><code>Transform</code> of <em translate="no">Seconds Arm</em>.</figcaption>
						</figure>
						
						<p>Let's make the seconds arm stand out by creating a separate material for it. I gave it a dark red color, hexadecimal B30000. Also, I turned off the grid in the scene window as we finished building our clock.</p>
						
						<figure>
							<img src="building-a-simple-clock/all-arms-scene.png" width="224" height="224">
							<figcaption>Clock with three arms.</figcaption>
						</figure>
						
						<p>If you haven't done so already, this is a good moment to save the scene, via <em translate="no">File / Save</em> or the indicated keyboard shortcut.</p>
						
						<p>It is also a good idea to keep the project's assets organized. As we have three materials let's put them in a <em translate="no">Materials</em> folder that we create via <em translate="no">Assets / Create / Folder</em> or via the project window. You can then drag the materials there.</p>
						
						<figure>
							<img src="building-a-simple-clock/material-folder-one-column.png" width="176" height="98" alt="one-column"><br>
							<img src="building-a-simple-clock/material-folder-two-column.png" width="444" height="86" alt="two-column">
							<figcaption>Material folder in project window, one and two column layout.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Animating the Clock</h2>
					
					<p>Our clock currently does not tell the time, it's always stuck at twelve o'clock. To animate it we have to add a custom behavior to it. We do this by creating a custom component type, which is defined via a script.</p>
					
					<section>
						<h3>C# Script Asset</h3>
						
						 <p>Add a new script asset to the project via <em translate="no">Assets / Create / C# Script</em> and name it <em translate="no">Clock</em>. C# is the programming language used for Unity scripts and is pronounced as <em translate="no">C-sharp</em>. Let's also immediately put it in a new <em translate="no">Scripts</em> folder to keep the project tidy.</p>
						 
						 <figure>
							<img src="animating-the-clock/script-asset-one-column.png" width="110" height="83" alt="one-column"><br>
							<img src="animating-the-clock/script-asset-two-column.png" width="288" height="88" alt="two-column">
							<figcaption>Scripts folder with <code>Clock</code> script, one and two column layout.</figcaption>
						</figure>
						
					<p>When the script is selected the inspector will show its contents. But to edit the code we'll have to use a code editor. You can open the script for editing by pressing the <em translate="no">Open...</em> button in its inspector or by double-clicking it in the hierarchy window. Which program gets opened can be configured via Unity's preferences.</p>
						
						<figure>
							<img src="animating-the-clock/clock-inspector.png" width="320" height="492">
							<figcaption>Inspector of C# <code>Clock</code> asset.</figcaption>
						</figure>
					</section>
						
					<section>
						<h3>Defining a Component Type</h3>
						
						<p>Once the script is loaded in your code editor begin by deleting the standard template code, as we'll create the component type from scratch.
						
						<p>An empty file defines nothing. It must contain the definition of our clock component. What we're going to define isn't a single instance of a component. Instead, we define the general class or type known as <code>Clock</code>. Once that's established, we could create multiple such components in Unity, even though we'll limit ourselves to a single clock in this tutorial.</p>
						
						<p>In C#, we define the <code>Clock</code> type by first stating that we're defining a class, followed by its name. In the code fragments below, changed code has a yellow background, or dark red if you're using the dark web page theme to view this tutorial. As we start with an empty file, the contents of it should literally become <code>class Clock</code> and nothing else, though you could add spaces and newlines between words as you like.</p>
						
						<pre translate="no"><ins>class Clock</ins></pre>
						
						<aside>
							<h3>What's a class, technically?</h3>
							<div>
								<p>You can think of a class as a blueprint that can be used to create objects that reside in a computer's memory. The blueprint defines what data these objects contain and what functionality they have.</p>
								
								<p>Classes can also define data and functionality that don't belong to object instances, but to the class itself. This is often used to provide globally-available functionality. We'll use some of that, but <code>Clock</code> won't have it.</p>
							</div>
						</aside>
						
						<p>Because we don't want to restrict which code has access to our <code>Clock</code> type, it is good form to prefix it with the <code>public</code> access modifier.</p>
						
						<pre translate="no"><ins>public</ins> class Clock</pre>
						
						<aside>
							<h3>What is the default access modifier for classes?</h3>
							<div>
								<p>Without the access modifier, it would be as if we had written <code>internal class Clock</code>. That would restrict access to code from the same assembly, which becomes relevant when you use code packaged in separate assemblies. To make sure it always works, make classes public by default.</p>
							</div>
						</aside>
						
						<p>At this point we don't have valid C# syntax yet. If you were to save the file and go back to the Unity editor then compilation errors will get logged in its console window.</p>
						
						<p>We indicated that we're defining a type, so we must actually define what it is like. That's done by a block of code that follows the declaration. The boundaries of a code block are indicated with curly brackets. We're leaving it empty for now, so just write <code>{}</code>.</p>
						
						<pre translate="no">public class Clock <ins>{}</ins></pre>
						
						<p>Our code is now valid. Save the file and switch back to Unity. The Unity editor will detect that the script asset has changed and triggers a recompilation. After that is done, select our script. The inspector will inform us that the asset does not contain a <code>MonoBehaviour</code> script.</p>
						
						<figure>
							<img src="animating-the-clock/non-component.png" width="320" height="272">
							<figcaption>Non-component script.</figcaption>
						</figure>
						
						<p>What this means is that we cannot use this script to create components in Unity. At this point, our <code>Clock</code> defines a basic C# object type. Our custom component type must extend Unity's <code>MonoBehaviour</code> type, inheriting its data and functionality.</p>
						
						<aside>
							<h3>What does mono-behavior mean?</h3>
							<div>
								<p>The idea is that we can program our own components to add custom behavior to game objects. That's what the behavior part refers to. It just happens to use the British spelling, which is an oddity. The mono part refers to the way in which support for custom code was added to Unity. It used the Mono project, which is a multi-platform implementation of the .NET framework. Hence, <code>MonoBehaviour</code>. It's an old name that we're stuck with due to backwards-compatibility.</p>
							</div>
						</aside>
						
						<p>To turn <code>Clock</code> into a subtype of <code>MonoBehaviour</code>, we have to change our type declaration so that it extends that type, which is done with a colon after our type name, followed by what it extends. This makes <code>Clock</code> inherit everything of the <code>MonoBehaviour</code> class type.</p>
						
						<pre translate="no">public class Clock <ins>: MonoBehaviour</ins> {}</pre>
						
						<p>However, this will result in an error after compilation. The compiler complains that it cannot find the <code>MonoBehaviour</code> type. This happens because the type is contained in a namespace, which is <code>UnityEngine</code>. To access it, we have to use its fully-qualified name, <code>UnityEngine.MonoBehaviour</code>.</p>
						
						<pre translate="no">public class Clock : <ins>UnityEngine.</ins>MonoBehaviour {}</pre>
						
						<aside>
							<h3>What's a namespace?</h3>
							<div>
								<p>A namespace is like a website domain, but for code. Just like domains can have subdomains, namespaces can have sub-namespaces. The big difference is that it's written the other way around. So instead of forum.unity.com it would be com.unity.forum. Namespaces are used to organize code and prevent name clashes.</p>
								
								<p>The assembly containing the <code>UnityEngine</code> code comes with Unity, you don't have to go online to fetch it separately. The project file used by the code editor should be set up automatically to recognize it, if you imported the appropriate editor integration package.</p>
							</div>
						</aside>
						
						<p>It is inconvenient to always have to include the <code>UnityEngine</code> prefix when accessing Unity types. Fortunately we can declare that the namespace should be searched automatically to complete type names in the C# file. This is done by adding <code>using UnityEngine;</code> at the top of the file. The semicolon is required to mark the end of the statement.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

public class Clock : <ins>MonoBehaviour</ins> {}</pre>
						
						<p>Now we can add our custom component to the <em translate="no">Clock</em> game object in Unity. This can be done either by dragging the script asset onto the object, or via the <em translate="no">Add Component</em> button at the bottom of the object's inspector.</p>
						
						<figure>
							<img src="animating-the-clock/clock-with-component.png" width="320" height="242">
							<figcaption>Clock game object with our <code>Clock</code> component.</figcaption>
						</figure>
						
						<p>Note that most code types in my tutorials are linked to online documentation. For example, <code>MonoBehaviour</code> is a link that takes you to Unity's online scripting API page for that type.</p>
					</section>
					
					<section>
						<h3>Getting Hold of an Arm</h3>
						
						<p>To rotate the arms, <code>Clock</code> objects need to know about them. Let's start with the hours arm. Like all game objects, it can be rotated by adjusting its <code>Transform</code> component. So we have to add knowledge of the arm pivot's <code>Transform</code> component to <code>Clock</code>. This can be done by adding a data field inside its code block, defined as a name followed by a semicolon.</p>
						
						<p>The name <code>hours pivot</code> would be appropriate for the field. However, names have to be single words. The convention is to make the first word of a field name lowercase and capitalize all other words, then stick them together. So we'll name it <code>hoursPivot</code>.</p>
						
						<pre translate="no">public class Clock : MonoBehaviour {

	<ins>hoursPivot;</ins>
}</pre>
						
						<aside>
							<h3>Where did the <code>using</code> statement go?</h3>
							<div>
								<p>It's still there, I just didn't show it. The code fragments will contain enough of the existing code so you know the context of the changes.</p>
							</div>
						</aside>
						
						<p>We also have to declare the type of the field, which in this case is <code>UnityEngine.Transform</code>. It has to be written in front of the field's name.</p>
						
						<pre translate="no">	<ins>Transform</ins> hoursPivot;</pre>
						
						<p>Our class now defines a field that can hold a reference to another object, whose type has to be <code>Transform</code>. We have to make sure that it holds a reference to the <code>Transform</code> component of the hours arm pivot.</p>
						
						<p>Fields are private by default, which means that they can only be accessed by the code belonging to <code>Clock</code>. But the class doesn't know about our Unity scene, so there's no direct way to associate the field with the correct object. We can change that by declaring the field as serializable. This means that it should be included in the scene's data when Unity saves the scene, which it does by putting all data in a sequence&mdash;serializing it&mdash;and writing it to a file.</p>
						
						<p>Marking a field as serializable is done by attaching an attribute to it, in this case <code>SerializeField</code>. It's written in front of the field declaration between square brackets, typically on the line above it but can also be placed on the same line.</p>
						
						<pre translate="no">	<ins>[SerializeField]</ins>
	Transform hoursPivot;</pre>
						
						<aside>
							<h3>Can't we just make it <code>public</code>?</h3>
							<div>
								<p>Yes, but it is generally bad form to make class fields publicly accessible. The rule of thumb is to only make class contents public if C# code from other types need access to it, and then prefer methods or properties over fields. The less accessible something is the easier it is to maintain, because there's less code that could directly depend on it. In this tutorial our only C# code is <code>Clock</code> so there's no reason to make its contents public.</p>
							</div>
						</aside>
						
						<p>Once the field is serializable Unity will detect this and display it in the inspector window of the <code>Clock</code> component of our <em translate="no">Clock</em> game object.</p>
						
						<figure>
							<img src="animating-the-clock/hours-pivot-field.png" width="320" height="153">
							<figcaption>Hours pivot field.</figcaption>
						</figure>
						
						<p>To make the proper connection, drag the <em translate="no">Hours Arm Pivot</em> from the hierarchy onto the <em translate="no">Hours Pivot</em> field. Alternatively, use the circular button at the right of the field and search for the pivot in the list that pops up. In both cases the Unity editor grabs the <code>Transform</code> component of <em translate="no">Hours Arm Pivot</em> and puts a reference to it in our field.</p>
						
						<figure>
							<img src="animating-the-clock/hours-pivot-connected.png" width="320" height="72">
							<figcaption>Hours pivot connected.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Knowing all Three Arms</h3>
						
						<p>We have to do the same for the minutes and seconds arm pivots. So add two more serializable <code>Transform</code> fields to <code>Clock</code> with appropriate names.</p>
						
						<pre translate="no">	[SerializeField]
	Transform hoursPivot;

	<ins>[SerializeField]</ins>
	<ins>Transform minutesPivot;</ins>

	<ins>[SerializeField]</ins>
	<ins>Transform secondsPivot;</ins></pre>
						
						<p>It is possible to make these field declarations more concise, because they share the same attribute, access modifier, and type. They can be consolidated into a comma-separated list of field names following the attribute and type declaration.</p>
						
						<pre translate="no">	[SerializeField]
	Transform hoursPivot<ins>, minutesPivot, secondsPivot</ins>;

	<del>//[SerializeField]</del>
	<del>//Transform minutesPivot;</del>

	<del>//[SerializeField]</del>
	<del>//Transform secondsPivot;</del></pre>
						
						<aside>
							<h3>What does <code>//</code> do?</h3>
							<div>
								<p>Double slashes indicate a comment. All text after them until the end of the line is ignored by the compiler. It is used to add text to clarify code, if needed. I also use it to indicate code that has been removed. Besides that, deleted code has a line through it.</p>
							</div>
						</aside>
						
						<p>Hook up the other two arms in the editor as well.</p>
						
						<figure>
							<img src="animating-the-clock/all-pivots-connected.png" width="320" height="72">
							<figcaption>All three pivots connected.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Waking Up</h3>
						
						<p>Now that we have access to the arm pivots the next step is to rotate them. To do this, we need to tell <code>Clock</code> to execute some code. This is done by adding a code block to the class, known as a method. The block has to be prefixed by a name, which is capitalized by convention. We'll name it <code>Awake</code>, suggesting that the code should be executed when the component awakens.</p>
						
						<pre translate="no">public class Clock : MonoBehaviour {

	[SerializeField]
	Transform hoursPivot, minutesPivot, secondsPivot;

	<ins>Awake {}</ins>
}</pre>
						
						<p>Methods are somewhat like mathematical functions, for example `f(x) = 2x + 3`. That function takes a number&mdash;represented by the variable parameter `x`&mdash;doubles it, then adds three. It operates on a single number, and its result is a single number as well. In the case of a method, it's more like `f(p) = c` where `p` represents input parameters and `c` represents whatever code it executes.</p>
						
						<p>Like a mathematical function a method can produce a result, but this isn't required. We have to declare the type of the result&mdash;as if it were a field&mdash;or write <code>void</code> to indicate that there is no result. In our case, we just want to execute some code without providing a resulting value, so we use <code>void</code>.</p>
						
						<pre translate="no">	<ins>void</ins> Awake {}</pre>
						
						<p>We also don't need any input data. However, we still have to define the method's parameters, as a comma-separated list between round brackets. It's just an empty list in our case.</p>
						
						<pre translate="no">	void Awake <ins>()</ins> {}</pre>
						
						<p>We now have a valid method, although it doesn't do anything yet. Just like Unity detected our fields, it also detects this <code>Awake</code> method. When a component has an <code>Awake</code> method, Unity will invoke that method on the component when it awakens. This happens after it's been created or loaded while in play mode. We're currently in edit mode, so this doesn't happen yet.</p>
						
						<aside>
							<h3>Doesn't <code>Awake</code> have to be <code>public</code>?</h3>
							<div>
								<p><code>Awake</code> and a collection of other methods are considered special Unity event methods. The Unity engine will find them and invoke them when appropriate, no matter how we declare them. This happens from outside the managed .NET environment.</p>
							</div>
						</aside>
						
						<p></p>
						
						<p>Note that <code>Awake</code> and other special Unity event methods have bold text in my tutorials and link to their online Unity scripting API page.</p>
					</section>
					
					<section>
						<h3>Rotating via Code</h3>
						
						<p>To rotate the arms we have to create a new rotation. We can change the rotation of a <code>Transform</code> by assigning a new one to its <code>localRotation</code> property.</p>
						
						<aside>
							<h3>What's a property?</h3>
							<div>
								<p>A property is a method that pretends to be a field. It might be read-only or write-only. The C# convention is to capitalize properties, but Unity's code doesn't do this.</p>
							</div>
						</aside>
						
						<p>Although the rotation of a <code>Transform</code> component is defined with Euler angles in degrees per axis in the inspector, in code we have to do it with a quaternion.</p>
						
						<aside>
							<h3>What's a quaternion?</h3>
							<div>
								<p>Quaternions are based on complex numbers and are used to represent 3D rotations. Although harder to understand than a combination of separate X, Y, and Z rotation angles, they have some useful characteristics. For example, they don't suffer from gimbal lock.</p>
							</div>
						</aside>
						
						<p>We can create a quaternion based on Euler angles by invoking the <code>Quaternion.Euler</code> method. Do this by writing it in <code>Awake</code>, followed by a semicolon to end the statement.</p>
						
						<pre translate="no">	void Awake () {
		<ins>Quaternion.Euler;</ins>
	}</pre>
						
						<p>The method has parameters used to describe the desired rotation. In this case we'll provide a comma-separated list of containing three arguments, all between round brackets, after the method name. We supply three numbers for the X, Y, and Z rotations. Use zero for the first two and &minus;30 for the Z rotation.</p>
						
						<pre translate="no">	Quaternion.Euler<ins>(0, 0, -30)</ins>;</pre>
						
						<p>The result of this invocation is a <code>Quaternion</code> struct value containing a 30&deg; clockwise rotation around the Z axis, matching hour 1 on our clock.</p>
						
						<aside>
							<h3>What's a struct?</h3>
							<div>
								<p>A struct&mdash;short for structure&mdash;is a blueprint, just like a class. The difference is that whatever it creates is treated as a simple value, like an integer or color, instead of an object. It has no sense of identity. Defining your own structure works the same as defining a class, except you write <code>struct</code> instead of <code>class</code>.</p>
							</div>
						</aside>
						
						<p>To apply this rotation to the hour arm assign the result of <code>Quaternion.Euler</code> to <code>hoursPivots.localRotation</code>, using the <code>=</code> assignment statement.</p>
						
						<pre translate="no">		<ins>hoursPivot.localRotation =</ins> Quaternion.Euler(0, 0, -30);</pre>
						
						<aside>
							<h3>What's the difference between <code>localRotation</code> and <code>rotation</code>?</h3>
							<div>
								<p>The <code>localRotation</code> property represents the rotation described by the <code>Transform</code> component in isolation, thus it is a rotation relative to its parent. It's the rotation that you see in its inspector. In contrast, the <code>rotation</code> property represents the final rotation in world space, taking the entire object hierarchy into account. Setting that property would produce weird results if we rotate the clock as a whole, because the arm would ignore that as the property compensates for the rotation of the clock.</p>
							</div>
						</aside>
						
						<aside>
							<h3>Shouldn't there be a warning that <code>hoursPivot</code> is never initialized?</h3>
							<div>
								<p>The compiler can detect that no code assigns anything to the field and could indeed issue such a warning, because it is unaware that we set it up via Unity's inspector. However, this warning is suppressed by default. The suppression can be controlled via the project settings. There's a <em>Suppress Common Warnings</em> toggle under <em>Player / Other Settings / Script Compilation</em>. It suppresses warnings about both uninitialized and unused private fields.</p>
							</div>
						</aside>
						
						<p>Now enter play mode in the editor. You can do this via <em translate="no">Edit / Play</em>, the indicated keyboard shortcut, or by pressing the play button at top center of the editor window. Unity will switch focus to the game window, which renders what the <em translate="no">Main Camera</em> in the scene sees. The clock component will awaken, and the clock will be set to one o'clock.</p>
						
						<figure>
							<img src="animating-the-clock/one-o-clock.png" width="224" height="224">
							<figcaption>Always one o'clock in play mode.</figcaption>
						</figure>
						
						<p>If the camera isn't focused on the clock you can move it so the clock becomes visible, but keep in mind that the scene is reset when exiting play mode, so any changes that you make to the scene while in play mode will not persist. This isn't true for assets though, changes to them always persist. You can also have the scene window&mdash;or even multiple scene and game windows&mdash;open while in play mode. Exit play mode before continuing.</p>
					</section>
					
					<section>
						<h3>Getting the Current Time</h3>
						
						<p>The next step is to figure out the current time when we awaken. We can use the <code>DateTime</code> struct to access the system time of the device we're running on. <code>DateTime</code> isn't a Unity type, it is found in the <code>System</code> namespace. It is part of the core functionality of the .NET framework, which is what Unity uses to support scripting.</p>
						
						<p><code>DateTime</code> has a <code>Now</code> property that produces a <code>DateTime</code> value containing the current system date and time. To check whether it's correct we'll log it to the console at the start of <code>Awake</code>. We can do that by passing it to the <code>Debug.Log</code> method.</p>
						
						<pre translate="no"><ins>using System;</ins>
using UnityEngine;

public class Clock : MonoBehaviour {

	[SerializeField]
	Transform hoursPivot, minutesPivot, secondsPivot;

	void Awake () {
		<ins>Debug.Log(DateTime.Now);</ins>
		hoursPivot.localRotation = Quaternion.Euler(0, 0, -30);
	}
}</pre>
						
						<p>Now we get a timestamp logged each time we enter play mode. You can see it both in the console window and in the status bar at the bottom of the editor window.</p>
					</section>
					
					<section>
						<h3>Rotating the Arms</h3>
						
						<p>We're getting close to a working clock. Let's again start with the hours. <code>DateTime</code> has an <code>Hour</code> property that gets us the hours portion of a <code>DateTime</code> value. Invoking it on the current timestamp will give us the hour of the day.</p>
						
						<pre translate="no">		Debug.Log(DateTime.Now<ins>.Hour</ins>);</pre>
						
						<p>So to have the hours arm show the current hour we have to multiply the &minus;30&deg; rotation by the current hour. Multiplication is done with the asterisk <code>*</code> character. We also no longer need to log the current time so can get rid of that statement.</p>
						
						<pre translate="no">		<del>//Debug.Log(DateTime.Now.Hour);</del>
		hoursPivot.localRotation = Quaternion.Euler(0, 0, -30 <ins>* DateTime.Now.Hour</ins>);</pre>
						
						<figure>
							<img src="animating-the-clock/four-o-clock.png" width="224" height="224">
							<figcaption>Currently four o'clock in play mode.</figcaption>
						</figure>
						
						
						<p>To make it clear that we're converting from hours to degrees, we can define an <code>hoursToDegrees</code> field containing the conversion factor. The angles of <code>Quaternion.Euler</code> are defined as floating-point values, so we'll use the <code>float</code> type. Because we already know the number, we can immediately assign it as part of the field declaration. Then multiply with the field instead of the literal <code>-30</code> in <code>Awake</code>.</p>
						
						<pre translate="no">	<ins>float hoursToDegrees = -30;</ins>

	[SerializeField]
	Transform hoursPivot, minutesPivot, secondsPivot;

	void Awake () {
		hoursPivot.localRotation =
			Quaternion.Euler(0, 0, <ins>hoursToDegrees</ins> * DateTime.Now.Hour);
	}</pre>
						
						<aside>
							<h3>What's a <code>float</code>?</h3>
							<div>
								<p>Computers cannot store all numbers, they have to be representable in their binary memory which consists of bits that are either 0 or 1. This makes it impossible to store many numbers exactly within a finite memory size, for example &frac13;, just like how we cannot exactly write that number in decimal notation. The best we can do is write 0.3333333 and stop at some point.</p>
								
								<p>Suppose that we decide to write at most three digits after the dot and only one in front of it. Then &frac13; is approximated by 0.333. If we were to divide &frac13; by 100 then we'd be forced to write 0.003, which means that we lost two digits of precision. To improve precision of small values let's add a separate exponent that indicates the order of magnitude of our number. Then `0.333xx10^-2` can represent &frac13; divided by 100, without losing meaningful digits.  And we can use `0.333xx10^2` to represent multiplication by 100 as well, while keeping only a single digit in front of the dot. Thus the dot can be considered to float, as it doesn't designate a fixed order of magnitude. This allows us to use only a few digits to represents a large amount of numbers.</p>
								
								<p>Floating-point numbers work the same way for computers, except that they use binary instead of decimal digits and also have to represent special values like infinities and not-a-number. A <code>float</code> is such a value stored in four bytes, which means that it has 32 bits.</p>
							</div>
						</aside>
						
						<p>If we declare a whole number without a suffix then it's assumed to be an integer, which is a different value type. Although the compiler converts them automatically, let's make explicit that all our numbers are of type <code>float</code>, by adding the f suffix to them.</p>
						
						<pre translate="no">	float hoursToDegrees = <ins>-30f</ins>;

	[SerializeField]
	Transform hoursPivot, minutesPivot, secondsPivot;

	void Awake () {
		hoursPivot.localRotation =
			Quaternion.Euler(<ins>0f</ins>, <ins>0f</ins>, hoursToDegrees * DateTime.Now.Hour);
	}</pre>
												
						<p>The amount of degrees per hour is always the same. We can enforce this by adding the <code>const</code> prefix to the declaration of <code>hoursToDegrees</code>. This turns it into a constant instead of a field.</p>
						
						<pre translate="no">	<ins>const</ins> float hoursToDegrees = -30f;</pre>
						
						<aside>
							<h3>What's special about <code>const</code> values?</h3>
							<div>
								<p>The <code>const</code> keyword indicates that a value will never change and doesn't need to be a field. Instead, its value will be computed during compilation and is substituted for all usage of the constant. This is only possible for primitive types like numbers.</p>
							</div>
						</aside>
												
						<p>Let's give the same treatment to the other two arms, using the appropriate properties of <code>DateTime</code>. Both a minute and a second are represented by a rotation of negative six degrees.</p>
						
						<pre translate="no">	const float hoursToDegrees = -30f<ins>, minutesToDegrees = -6f, secondsToDegrees = -6f</ins>;

	[SerializeField]
	Transform hoursPivot, minutesPivot, secondsPivot;

	void Awake () {
		hoursPivot.localRotation =
			Quaternion.Euler(0f, 0f, hoursToDegrees * DateTime.Now.Hour);
		<ins>minutesPivot.localRotation =</ins>
			<ins>Quaternion.Euler(0f, 0f, minutesToDegrees * DateTime.Now.Minute);</ins>
		<ins>secondsPivot.localRotation =</ins>
			<ins>Quaternion.Euler(0f, 0f, secondsToDegrees * DateTime.Now.Second);</ins>
	}</pre>
						
						<figure>
							<img src="animating-the-clock/time-5-16-31.png" width="224" height="224">
							<figcaption>Currently 5:16:31.</figcaption>
						</figure>
						
						<p>We're using <code>DateTime.Now</code> three times, to retrieve the hour, minute, and second. Each time we go through the property again, which requires some work, which could theoretically result in different time values. To make sure that this doesn't happen, we should retrieve the time only once. We can do this by declaring a variable inside the method and assign the time to it, then use this value afterwards. Let's name it <code>time</code>.</p>
						
						<aside>
							<h3>What's a variable?</h3>
							<div>
								<p>A variable acts like a field, except that it exists only while a method is being executed. It belongs to the method, not the class.</p>
							</div>
						</aside>
						
						<pre translate="no">	void Awake () {
		<ins>DateTime time = DateTime.Now;</ins>
		hoursPivot.localRotation =
			Quaternion.Euler(0f, 0f, hoursToDegrees * <ins>time</ins>.Hour);
		minutesPivot.localRotation =
			Quaternion.Euler(0f, 0f, minutesToDegrees * <ins>time</ins>.Minute);
		secondsPivot.localRotation =
			Quaternion.Euler(0f, 0f, secondsToDegrees * <ins>time</ins>.Second);
	}</pre>
						
						<p>In case of a variable it's possible to omit the type declaration, replacing it with the <code>var</code> keyword. This can shorten the code but is only possible when the variable's type can be inferred from what is assigned to it when it is declared. Also, I prefer to only do this when the type is explicitly mentioned in the statement, which is the case here.</p>
						
						<pre translate="no">		<ins>var</ins> time = DateTime.Now;</pre>
					</section>
					
					<section>
						<h3>Animating the Arms</h3>
						
						<p>We get the current time when entering play mode, but after that the clock remains motionless. To keep the clock synchronized with the current time, change the name of our <code>Awake</code> method to <code>Update</code>. This is another special event method that gets invoked by Unity every frame instead of just once, as long as we stay in play mode.</p>
						
						<pre translate="no">	void <ins>Update</ins> () {
		var time = DateTime.Now;
		hoursPivot.localRotation =
			Quaternion.Euler(0f, 0f, hoursToDegrees * time.Hour);
		minutesPivot.localRotation =
			Quaternion.Euler(0f, 0f, minutesToDegrees * time.Minute);
		secondsPivot.localRotation =
			Quaternion.Euler(0f, 0f, secondsToDegrees * time.Second);
	}</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/relievedfamiliarhamadryad?controls=0'></iframe></div>
							<figcaption>Updating clock.</figcaption>
						</figure>
						
						<aside>
							<h3>What's a frame?</h3>
							<div>
								<p>While in play mode Unity continually renders the scene from the point of view of the main camera. Once rendering is done the result is presented to the display. The display will then show that frame until it gets the next one. Before rendering a new frame everything gets updated. So Unity goes through a sequence of update, render, update, render, and so on. A single update step followed by rendering the scene once is typically considered a single frame, though in reality the timing is more complicated.</p>
							</div>
						</aside>
						
						
						<p>Note that our <code>Clock</code> component has gained a toggle in front of its name in the inspector. This allows us to disable it, which prevents Unity from invoking its <code>Update</code> method.</p>
						
						<figure>
							<img src="animating-the-clock/enabled-toggle.png" width="320" height="112">
							<figcaption><code>Clock</code> component that can be disabled.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Continuously Rotating</h3>
						
						<p>The arms of our clock indicate exactly the current hour, minute, or second. It behaves like a digital clock, discrete but with arms. Typically clocks have slowly-rotating arms that provide an analog representation of time. Let's change our approach so our clock becomes analog.</p>
						
						<p><code>DateTime</code> doesn't contain fractional data. Fortunately, it does have a <code>TimeOfDay</code> property. This gives us a <code>TimeSpan</code> value that contains the data in the format that we need, via its <code>TotalHours</code>, <code>TotalMinutes</code>, and <code>TotalSeconds</code> properties.</p>
						
						<p>Begin by getting the <code>TimeOfDay</code> struct value from <code>DateTime.Now</code> and store that in the variable instead. As the <code>TimeSpan</code> type isn't mentioned in this statement I'll make the variable's type explicit. Then adjust the properties that we use to rotate the arms.</p>
						
						<pre translate="no">	void Update () {
		<ins>TimeSpan</ins> time = DateTime.Now<ins>.TimeOfDay</ins>;
		hoursPivot.localRotation =
			Quaternion.Euler(0f, 0f, hoursToDegrees * time.<ins>TotalHours</ins>);
		minutesPivot.localRotation =
			Quaternion.Euler(0f, 0f, minutesToDegrees * time.<ins>TotalMinutes</ins>);
		secondsPivot.localRotation =
			Quaternion.Euler(0f, 0f, secondsToDegrees * time.<ins>TotalSeconds</ins>);
	}</pre>
						
						<p>This will result in compiler errors, complaining that we cannot convert from <code>double</code> to <code>float</code>. This happens because the <code>TimeSpan</code> properties produce values with the double-precision floating point type, known as <code>double</code>. These values provide higher precision than <code>float</code> values, but Unity's code only works with single-precision floating point values.</p>
						
						<aside>
							<h3>Is single precision enough?</h3>
							<div>
								<p>For most games, yes. It becomes a problem when working with very large distances or scale differences. Then you'll have to apply tricks like teleportation or camera-relative rendering to keep the active area near the world origin. While using double precision would solve this problem, it would also double the memory size of the numbers involved, which leads to other performance problems. Game engines typically use single-precision floating-point values, and so do GPUs.</p>
							</div>
						</aside>
						
						<p>We can solve this problem by explicitly converting from <code>double</code> to <code>float</code>. This process is known as casting and is done by writing the new type within round brackets in front of the value to be converted.</p>
						
						<pre translate="no">		hoursPivot.localRotation =
			Quaternion.Euler(0f, 0f, hoursToDegrees * <ins>(float)</ins>time.TotalHours);
		minutesPivot.localRotation =
			Quaternion.Euler(0f, 0f, minutesToDegrees * <ins>(float)</ins>time.TotalMinutes);
		secondsPivot.localRotation =
			Quaternion.Euler(0f, 0f, secondsToDegrees * <ins>(float)</ins>time.TotalSeconds);</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/majorsecondhammerheadbird?controls=0'></iframe></div>
 							<figcaption>Analog clock.</figcaption>
						</figure>
						
						<p>Now you know the fundamentals of object creation and writing code in Unity. The next tutorial is <a href="../../graphs/index.html">Building a Graph</a>.</p>
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/basics-01-game-objects-and-scripts/" class="repository">repository</a>
					<a href="Game-Objects-and-Scripts.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>