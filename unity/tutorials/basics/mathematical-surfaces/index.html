<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/basics/mathematical-surfaces/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/basics/mathematical-surfaces/tutorial-image.jpg">
		<meta property="og:title" content="Mathematical Surfaces">
		<meta property="og:description" content="A Unity C# Basics tutorial about describing surfaces with math and visualizing them with cubes.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Mathematical Surfaces</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/basics/mathematical-surfaces/#article",
				"headline": "Mathematical Surfaces",
				"alternativeHeadline": "Sculpting with Numbers",
				"datePublished": "2018-01-10",
				"dateModified": "2021-05-18",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity C# Basics tutorial about describing surfaces with math and visualizing them with cubes.",
				"image": "https://catlikecoding.com/unity/tutorials/basics/mathematical-surfaces/tutorial-image.jpg",
				"dependencies": "Unity 2020.3.6f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/basics/", "name": "Basics" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				'Function': 1,
				FunctionLibrary: 1,
				FunctionName: 1,
				Graph: 1,
				GraphFunction: 1,
				GraphFunctionName: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Basics</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Mathematical Surfaces</h1>
					<p>Sculpting with Numbers</p>
					<ul>
						<li>Create a function library.</li>
						<li>Use a delegate and an enumeration type.</li>
						<li>Display 2D functions with a grid.</li>
						<li>Define surfaces in 3D space.</li>
					</ul>
				</header>
				
				<p>This is the third tutorial in a series about learning the <a href="../index.html">basics</a> of working with Unity. It is a continuation of the <a href="../../graphs/index.html">Building a Graph</a> tutorial, so we won't start a new project. This time we'll make it possible to display multiple and more complex functions.</p>
				
				<p>This tutorial is made with Unity 2020.3.6f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Combining a few waves to create a complex surface.</figcaption>
				</figure>
				
				<section>
					<h2>Function Library</h2>
					
					<p>After finishing the <a href="../../graphs/index.html">previous tutorial</a> we have a point graph that shows an animated sine wave while in play mode. It is also possible to show other mathematical functions. You can change the code and the function will change along with it. You can even do this while the Unity editor is in play mode. Execution will be paused, the current game state saved, then the scripts are compiled again, and finally the game state is reloaded and play resumes. This is known as a hot reload. Not everything survives a hot reload, but our graph does. It will switch to animating the new function, without being aware that something changed.</p>
					
					<p>While changing code during play mode can be convenient, it is not a handy way to switch back and forth between multiple functions. It would be much better if we could change the function via a configuration option of the graph.</p>
					
					<section>
						<h3>Library Class</h3>
						
						<p>We could declare multiple mathematical functions inside <code>Graph</code>, but let's dedicate that class to displaying a function, leaving it unaware of the exact mathematical equations. This is an example of specialization and separation of concerns.</p>
						
						<p>Create a new <code>FunctionLibrary</code> C# script and put it in the <em translate="no">Scripts</em> folder, next to <code>Graph</code>. You could either use a menu option to create a new asset or duplicate and the rename <code>Graph</code>. In either case clear the file contents and start with using <code>UnityEngine</code> and declaring an empty <code>FunctionLibrary</code> class that doesn't extend anything.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public class FunctionLibrary {}</ins></pre>
						
						<p>This class isn't going to be a component type. We're also not going to create an object instance of it. Instead we'll use it to provide a collection of publicly-accessible methods that represent math functions, similar to Unity's <code>Mathf</code>.</p>
						
						<p>To signify that this class is not to be used as an object template mark it as static, by writing the <code>static</code> keyword before <code>class</code>.</p>
						
						<pre translate="no">public <ins>static</ins> class FunctionLibrary {}</pre>
					</section>
					
					<section>
						<h3>Function Method</h3>
						
						<p>Our first function is going to be the same sine wave that <code>Graph</code> is currently showing. We need to create a method for it. This works the same as creating an <code>Awake</code> or <code>Update</code> method, except that we will name it <code>Wave</code> instead.</p>
						
						<pre translate="no">public static class FunctionLibrary {

	<ins>void Wave () {}</ins>
}</pre>
						
						<p>By default methods are instance methods, which means that they have to be invoked on an object instance. To make them work directly at the class level we have to mark it as static, just like <code>FunctionLibrary</code> itself.</p>
						
						<pre translate="no">	<ins>static</ins> void Wave () {}</pre>
						
						<p>And to make it publicly accessible give it the <code>public</code> access modifier as well.</p>
						
						<pre translate="no">	<ins>public</ins> static void Wave () {}</pre>
						
						<p>This method is going to represent our mathematical function `f(x,t)=sin(pi(x+t))`. This means that it must produce a result, which has to be a floating-point number. So instead of <code>void</code> the return type of the function needs to be <code>float</code>.</p>
						
						<pre translate="no">	public static <ins>float</ins> Wave () {}</pre>
						
						<p>Next, we have to add the two parameters to the method's parameter list, just like for the mathematical function. The only difference is that we have to write the type in front of each parameter, which is <code>float</code>.</p>
						
						<pre translate="no">	public static float Wave (<ins>float x, float t</ins>) {}</pre>
						
						<p>Now we can put the code that computes the sine wave inside the method, using its <code>x</code> and <code>t</code> parameters.</p>
						
						<pre translate="no">	public static float Wave (float x, float t) {
		<ins>Mathf.Sin(Mathf.PI * (x + t));</ins>
	}</pre>
						
						<p>The last step is to explicitly indicate what the result of the method is. As this is a <code>float</code> method, it has to return a <code>float</code> value when it's done. We indicate this by writing <code>return</code> followed by what the result is supposed to be, which is our mathematical computation.</p>
						
						<pre translate="no">	public static float Wave (float x, float t) {
		<ins>return</ins> Mathf.Sin(Mathf.PI * (x + t));
	}</pre>
						
						<p>It is now possible to invoke this method inside <code>Graph.Update</code>, using <code>position.x</code> and <code>time</code> as arguments for its parameters. Its result can by used to set the point's Y coordinate, instead of an explicit math equation.</p>
						
						<pre translate="no">	void Update () {
		float time = Time.time;
		for (int i = 0; i &lt; points.Length; i++) {
			Transform point = points[i];
			Vector3 position = point.localPosition;
			position.y = <ins>FunctionLibrary.Wave(position.x, time)</ins>;
			point.localPosition = position;
		}
	}</pre>
					</section>
					
					<section>
						<h3>Implicitly using a Type</h3>
						
						<p>We'll be using <code>Mathf.PI</code>, <code>Mathf.Sin</code>, and other methods from <code>Mathf</code> at lot in <code>FunctionLibrary</code>. It would be nice if we could write those without having to explicitly mention the type all the time. We can make this possible by adding another <code>using</code> statement at the top of the <code>FunctionLibrary</code> file, with the extra <code>static</code> keyword followed by the explicit <code>UnityEngine.Mathf</code> type. That makes all constant and static members of the type usable without explicitly mentioning the type itself.</p>
						
						<pre translate="no">using UnityEngine;

<ins>using static UnityEngine.Mathf;</ins>

public static class FunctionLibrary { &hellip; }</pre>
						
						<p>Now we can shorten the code in <code>Wave</code> by omitting <code>Mathf</code>.</p>
						
						<pre translate="no">	public static float Wave (float x, float z, float t) {
		return <ins>Sin</ins>(<ins>PI</ins> * (x + t));
	}</pre>
						
					</section>
					
					<section>
						<h3>A Second Function</h3>
						
						<p>Let's add another function method. This time we'll make a slightly more complex function, using more than one sine wave. Begin by duplicating the <code>Wave</code> method and renaming it to <code>MultiWave</code>.</p>
						
						<pre translate="no">	public static float Wave (float x, float t) {
		return Sin(PI * (x + t));
	}

	<ins>public static float MultiWave (float x, float t) {</ins>
		<ins>return Sin(PI * (x + t));</ins>
	<ins>}</ins></pre>
						
						<p>We'll keep the sine function that we already have, but add something extra to it. To make that easy, assign the current result to an <code>y</code> variable before returning it.</p>
						
						<pre translate="no">	public static float MultiWave (float x, float t) {
		<ins>float y =</ins> Sin(PI * (x + t));
		<ins>return y;</ins>
	}</pre>
						
						<p>The simplest way to add more complexity to a sine wave is to add another one that has double the frequency. This means that it changes twice as fast, which is done by multiplying the argument of the sine function by 2. At the same time, we'll halve the result of this function. That keeps the shape of the new sine wave the same as the old one, but at half size.</p>
						
						<pre translate="no">		float y = Sin(PI * (x + t));
		<ins>y += Sin(2f * PI * (x + t)) / 2f;</ins>
		return y;</pre>
						
						<p>This gives us the mathematical function `f(x,t)=sin(pi(x+t))+sin(2pi(x+t))/2`. As both the positive and negative extremes of the sine function are 1 and &minus;1, the maximum and minimum values of this new function could be 1.5 and &minus;1.5. To guarantee that we stay in the &minus;1&ndash;1 range, we should divide the sum by 1.5.</p>
						
						<pre translate="no">		return y <ins>/ 1.5f</ins>;</pre>
						
						<p>Division requires a bit more work than multiplication, so it's a rule of thumb to prefer multiplication over division. However, constant expressions like <code>1f / 2f</code> and also <code>2f * Mathf.PI</code> are already reduced to a single number by the compiler. So we could rewrite our code to only use multiplication at runtime. We have to make sure that the constant portions are reduced first, using operation order and brackets.</p>
						
						<pre translate="no">		y += Sin(2f * PI * (x + t)) <ins>* (1f / 2f)</ins>;
		return y <ins>* (2f / 3f)</ins>;</pre>
						
						<p>We can also directly write <code>0.5f</code> instead of <code>1f / 2f</code>, but the inverse of 1.5 cannot be written exactly in decimal notation so we'll keep using <code>2f / 3f</code>, which the compiler reduces to a floating-point representation of it with maximum precision.</p>
						
						<pre translate="no">		y += <ins>0.5f *</ins> Sin(2f * PI * (x + t))<ins>;</ins></pre>
						
						<p>Now use this function instead of <code>Wave</code> in <code>Graph.Update</code> and see what it looks like.</p>
						
						<pre translate="no">			position.y = FunctionLibrary.<ins>MultiWave</ins>(position.x, time);</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/testycoldbasilisk?controls=0'></iframe></div>
							<figcaption>Sum of two sine waves.</figcaption>
						</figure>
						
						<p>You could say that a smaller sine wave is now following a larger sine wave. We can also make the smaller one slide along the larger, for example by halving the time for the larger wave. The result will be a function that doesn't just slide as time progresses, it changes its shape. It now takes four seconds for the pattern to repeat.</p>
						
						<pre translate="no">		float y = Sin(PI * (x + <ins>0.5f *</ins> t));
		y += 0.5f * Sin(2f * PI * (x + t));</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/jampackedevergreenbovine?controls=0'></iframe></div>
							<figcaption>Morphing wave.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Selecting Functions in the Editor</h3>
						
						<p>The next thing we can do is add some code that makes it possible to control which method is used by <code>Graph</code>. We could do this with a slider, just like for the graph's resolution. As we have two functions to choose from, we'll need a serializable integer field with a range of 0&ndash;1. Name it <code>function</code> so it's obvious what it controls.</p>
						
						<pre translate="no">	[SerializeField, Range(10, 100)]
	int resolution = 10;
	
	<ins>[SerializeField, Range(0, 1)]</ins>
	<ins>int function;</ins></pre>
						
						<figure>
							<img src="function-library/function-slider.png" width="320" height="112">
							<figcaption>Function slider.</figcaption>
						</figure>
						
						<p>Now we can check <code>function</code> inside the loop of <code>Update</code>. If it is zero then the graph should display <code>Wave</code>. To make that choice we'll use the <code>if</code> statement followed by an expression and a code block. This works like <code>while</code> except it doesn't loop back, so the block either gets executed or skipped. In this case the test is whether <code>function</code> equals zero, which can be done with the <code>==</code> equality operator.</p>
						
						<pre translate="no">	void Update () {
		float time = Time.time;
		for (int i = 0; i &lt; points.Length; i++) {
			Transform point = points[i];
			Vector3 position = point.localPosition;
			<ins>if (function == 0) {</ins>
				position.y = FunctionLibrary.<ins>Wave</ins>(position.x, time);
			<ins>}</ins>
			point.localPosition = position;
		}
	}</pre>
						
						<p>We can follow the if-block with <code>else</code> and another block, which gets executed if the test failed. In that case the graph should display <code>MultiWave</code> instead.</p>
						
						<pre translate="no">			if (function == 0) {
				position.y = FunctionLibrary.Wave(position.x, time);
			}
			<ins>else {</ins>
				<ins>position.y = FunctionLibrary.MultiWave(position.x, time);</ins>
			<ins>}</ins></pre>
						
						<p>This makes it possible to control the function via the graph's inspector, also while we're in play mode.</p>
						
						<aside>
							<h3>Does changing the resolution slider in play mode have any effect?</h3>
							<div>
								<p>That will cause the resolution value of the graph to change, but <code>Graph.Update</code> doesn't depend on it so there is no visible effect. Changing the amount of points while in play mode would require deletion and instantiation of points, but we're not going to support that in this tutorial.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Ripple Function</h3>
						
						<p>Let's add a third function to our library, one that produces a ripple-like effect. We create it by making a sine wave move away from the origin, instead of always traveling in the same direction. We can do this by basing it on the distance from the center, which is the absolute of X. Start with computing only that, with the help of <code>Mathf.Abs</code>, in a new <code>FunctionLibrary.Ripple</code> method. Store the distance in a <code>d</code> variable and then return it.</p>
						
						<pre translate="no">	<ins>public static float Ripple (float x, float t) {</ins>
		<ins>float d = Abs(x);</ins>
		<ins>return d;</ins>
	}</pre>
						
						<p>To show it, increase the range of <code>Graph.function</code> to 2 and add another block for the <code>Wave</code> method in <code>Update</code>. We can chain multiple conditional blocks by writing another <code>if</code> directly after <code>else</code>, so it becomes an else-if block which should be executed when <code>function</code> equals 1. Then add a new <code>else</code> block for the ripple.</p>
						
						<pre translate="no">	[SerializeField, Range(0, <ins>2</ins>)]
	&hellip;

	void Update () {
		float time = Time.time;
		for (int i = 0; i &lt; points.Length; i++) {
			Transform point = points[i];
			Vector3 position = point.localPosition;
			if (function == 0) {
				position.y = FunctionLibrary.Wave(position.x, time);
			}
			else <ins>if (function == 1)</ins> {
				position.y = FunctionLibrary.MultiWave(position.x, time);
			}
			<ins>else {</ins>
				<ins>position.y = FunctionLibrary.Ripple(position.x, time);</ins>
			<ins>}</ins>
			point.localPosition = position;
		}
	}</pre>
						
						<figure>
							<img src="function-library/absolute-x.png" width="230" height="230">
							<figcaption>Absolute X.</figcaption>
						</figure>
						
						<p>Back to <code>FunctionLibrary.Ripple</code>, we use the distance as input for the sine function and make that the result. Specifically, we'll use `y=sin(4pid)` with `d=|x|` so the ripple goes up and down multiple times in the graph's domain.</p>
						
						<pre translate="no">	public static float Ripple (float x, float t) {
		float d = Abs(x);
		<ins>float y = Sin(4f * PI * d);</ins>
		return <ins>y</ins>;
	}</pre>
						
						<figure>
							<img src="function-library/sin-d.png" width="230" height="230">
							<figcaption>Sine of distance.</figcaption>
						</figure>
						
						<p>The result is visually hard to interpret because Y varies too much. We can reduce that by decreasing the amplitude of the wave. But a ripple doesn't have a fixed amplitude, it decreases with distance. So let's turn our function into `y=sin(4pid)/(1+10d)`.</p>
						
						<pre translate="no">		float y = Sin(4f * PI * d);
		return y <ins>/ (1f + 10f * d)</ins>;</pre>
						
						<p>The finishing touch is animating the ripple. To make it flow outward we have to subtract the time from the value we pass to the sine function. Let's use `pit` so the final function becomes `y=sin(pi(4d-t))/(1+10d)`.</p>
						
						<pre translate="no">		float y = Sin(<ins>PI * (4f * d - t)</ins>);
		return y / (1f + 10f * d);</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/spottedevergreenicelandgull?controls=0'></iframe></div>
							<figcaption>Animated ripple.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Managing Methods</h2>
					
					<p>A sequence of conditional blocks works for two or three functions, but it gets unwieldy fast when trying to support more than that. It would be much more convenient if we could ask our library for a reference to a method based on some criteria and then invoke it repeatedly.</p>
					
					<section>
						<h3>Delegates</h3>
						
						<p>It is possible to get a reference to a method by using a delegate. A delegate is a special type that defines what kind of method something can reference. There isn't a standard delegate type for our mathematical function methods, but we can define it ourselves. Because it is a type we could create it in its own file, but as it's specifically for methods of our library we'll define it inside the <code>FunctionLibrary</code> class, making it an inner or nested type.</p>
						
						<p>To create the delegate type duplicate the <code>Wave</code> function, rename it to <code>Function</code> and replace its code block with a semicolon. This defines a method signature without an implementation. We then turn it into a delegate type by replacing the <code>static</code> keyword with <code>delegate</code>.</p>
						
						<pre translate="no">public static class FunctionLibrary {
	
	public <ins>delegate</ins> float Function (float x, float t);
	
	&hellip;
}</pre>
						
						<p>Now we can introduce a <code>GetFunction</code> method that returns a <code>Function</code> given an index parameter, using the same if-else logic that we used in the loop, except that in each block we return the appropriate method instead of invoking it.</p>
						
						<pre translate="no">	public delegate float Function (float x, float t);
	
	<ins>public static Function GetFunction (int index) {</ins>
		<ins>if (index == 0) {</ins>
			<ins>return Wave;</ins>
		<ins>}</ins>
		<ins>else if (index == 1) {</ins>
			<ins>return MultiWave;</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>return Ripple;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Next, we use this method to get a function delegate at the beginning of <code>Graph.Update</code>, based on <code>function</code>, and store it in a variable. Because this code isn't inside <code>FunctionLibrary</code> we have to refer to the nested delegate type as <code>FunctionLibrary.Function</code>.</p>
						
						<pre translate="no">	void Update () {
		<ins>FunctionLibrary.Function f = FunctionLibrary.GetFunction(function);</ins>
		&hellip;
	}</pre>
						
						<p>Then invoke the delegate variable instead of an explicit method in the loop.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; points.Length; i++) {
			Transform point = points[i];
			Vector3 position = point.localPosition;
			<del>//if (function == 0) {</del>
			<del>//	position.y = FunctionLibrary.Wave(position.x, time);</del>
			<del>//}</del>
			<del>//else if (function == 1) {</del>
			<del>//	position.y = FunctionLibrary.MultiWave(position.x, time);</del>
			<del>//}</del>
			<del>//else {</del>
			<del>//	position.y = FunctionLibrary.Ripple(position.x, time);</del>
			<del>//}</del>
			<ins>position.y = f(position.x, time);</ins>
			point.localPosition = position;
		}</pre>
					</section>
					
					<section>
						<h3>An Array of Delegates</h3>
						
						<div>We've simplified <code>Graph.Update</code> a lot, but we only moved the if-else code to <code>FunctionLibrary.GetFunction</code>. We can get rid of this code completely by replacing it with indexing an array. Begin by adding a static field for a <code>functions</code> array to <code>FunctionLibrary</code>. This array is for internal use only, so don't make it public.</p>
						
						<pre translate="no">	public delegate float Function (float x, float t);

	<ins>static Function[] functions;</ins>

	public static Function GetFunction (int index) { &hellip; }</pre>
						
						<p>We're always going to put the same elements in this array, so we can explicitly define its contents as part of its declaration. This is done by assigning a comma-separated array element sequence, between curly brackets. The simplest is an empty list.</p>
						
						<pre translate="no">	static Function[] functions <ins>= {}</ins>;</pre>
						
						<p>This means that we immediately get an array instance, but it is empty. Change this so it will contain delegates to our method, in the same order as before.</p>
						
						<pre translate="no">	static Function[] functions = { <ins>Wave, MultiWave, Ripple</ins> };</pre>
						
						<p>The <code>GetFunction</code> method can now simply index the array to return the appropriate delegate.</p>
						
						<pre translate="no">	public static Function GetFunction (int index) {
		<ins>return functions[index];</ins>
	}</pre>
						
						<aside>
							<h3>Why don't we just make the array public?</h3>
							<div>
								<p>That would make it possible for any code to change the array. By keeping it private to the library we guarantee that it never changes.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Enumerations</h3>
						
						<p>An integer slider works, but it is not obvious that 0 represents the wave function and so on. It would be clearer if we had a dropdown list containing the function names. We can use an enumeration to achieve this.</p>
						
						<p>Enumerations can be created by defining an <code>enum</code> type. Once again we'll do this inside <code>FunctionLibrary</code>, this time naming it <code>FunctionName</code>. In this case the type name is followed by a list of labels within curly brackets. We can use a copy of the array element list, but without the semicolon. Note that these are simple labels, they don't reference anything, although they follow the same rules as type names. It's our responsibility to keep the two lists identical.</p>
						
						<pre translate="no">	public delegate float Function (float x, float t);

	<ins>public enum FunctionName { Wave, MultiWave, Ripple }</ins>

	static Function[] functions = { Wave, MultiWave, Ripple };</pre>
						
						<p>Now replace the index parameter of <code>GetFunction</code> with a name parameter of type <code>FunctionName</code>. This indicates that the argument has to be a valid function name.</p>
						
						<pre translate="no">	public static Function GetFunction (<ins>FunctionName name</ins>) {
		return functions[<ins>name</ins>];
	}</pre>
						
						<p>Enumerations can be considered syntactical sugar. By default, each label of the enumeration represents an integer. The first label corresponds to 0, the second label to 1, and so on. So we can use the name to index the array. However, the compiler will complain that an enumeration cannot be implicitly cast to an integer. We have to explicitly perform this cast.</p>
						
						<pre translate="no">		return functions[<ins>(int)</ins>name];</pre>
						
						<p>The last step is to change the type of the <code>Graph.function</code> field to <code>FunctionLibrary.FunctionName</code> and remove its <code>Range</code> attribute.</p>
						
						<pre translate="no">	<del>//[SerializeField, Range(0, 2)]</del>
	<ins>[SerializeField]</ins>
	<ins>FunctionLibrary.FunctionName</ins> function;
</pre>
						
						<p>The inspector of <code>Graph</code> now shows a dropdown list containing the function names, with spaces added between capitalized words.</p>
						
						<figure>
							<img src="managing-methods/function-name.png" width="320" height="112">
							<figcaption>Function dropdown list.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Adding Another Dimension</h2>
					
					<p>So far our graph only contains a single line of points. We map 1-dimensional values to other 1D values, though if you take time into account it's actually mapping 2D values to 1D values. So we're already mapping higher-dimensional input to a 1D value. Like we added time, we can add additional spatial dimensions as well.</p>
					
					<p>Currently, we're using the X dimension as the spatial input for our functions. The Y dimension is used to display the output. That leaves Z as a second spatial dimension to use for input. Adding Z as an input upgrades our line to a square grid.</p>
					
					<section>
						<h3>3D Colors</h3>
						
						<p>With Z no longer constant, change our <em translate="no">Point Surface</em> shader so it also modifies the blue albedo component, by removing the <code class="shader">.rg</code> and <code class="shader">.xy</code> code from the assignment.</p>
					
						<pre class="shader" translate="no">			surface.<ins>Albedo</ins> = saturate(input.<ins>worldPos</ins> * 0.5 + 0.5);</pre>
						
						<p>And adjust our <em translate="no">Point URP</em> shader graph so that Z is treated the same as X and Y.</p>
						
						<figure>
							<img src="adding-another-dimension/shader-graph.png" width="410" height="154">
							<figcaption>Adjusted <em>Multiply</em> and <em>Add</em> node inputs.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Upgrading the Functions</h3>
						
						<p>To support a second non-time input for our functions, add a <code>z</code> parameter after the <code>x</code> parameter of the <code>FunctionLibrary.Function</code> delegate type.</p>
						
						<pre translate="no">	public delegate float Function (float x, <ins>float z,</ins> float t);</pre>
						
						<p>This requires us to also add the parameter to our three function methods.</p>
						
						<pre translate="no">	public static float Wave (float x, <ins>float z,</ins> float t) { &hellip; }
	
	public static float MultiWave (float x, <ins>float z,</ins> float t) { &hellip; }
	
	public static float Ripple (float x, <ins>float z,</ins> float t) { &hellip; }</pre>
						
						<p>And also add <code>position.z</code> as an argument when invoking the function in <code>Graph.Update</code>.</p>
						
						<pre translate="no">			position.y = f(position.x, <ins>position.z,</ins> time);</pre>
					</section>
					
					<section>
						<h3>Creating a Grid of Points</h3>
						
						<p>To show the Z dimension we have to turn our line of points into a grid of points. We can do this by creating multiple lines, each offset one step along Z. We'll use the same range for Z as we use for X, so we'll create as many lines as we currently have points. This means that we have to square the amount of points. Adjust the creation of the <code>points</code> array in <code>Awake</code> so it's big enough to contain all the points.</p>
						
						<pre translate="no">		points = new Transform[resolution <ins>* resolution</ins>];</pre>
						
						<p>As we increase the X coordinate each iteration of the loop in <code>Awake</code> based on the resolution, simply creating more points will result in a single long line. We have to adjust the initialization loop to take the second dimension into account.</p>
						
						<figure>
							<img src="adding-another-dimension/long-line.png" width="210" height="200">
							<figcaption>Long line of 2500 points.</figcaption>
						</figure>
						
						<p>First, let's keep track of the X coordinate explicitly. Do this by declaring and incrementing an <code>x</code> variable inside the <code>for</code> loop, along with the <code>i</code> iterator variable. The third section of the <code>for</code> statement can be turned into a comma-separated lists for this purpose.</p>
						
						<pre translate="no">		points = new Transform[resolution * resolution];
		for (int i = 0<ins>, x = 0</ins>; i &lt; points.Length; i++<ins>, x++</ins>) {
			&hellip;
		}</pre>
						
						<p>Each time we finish a row we have to reset <code>x</code> back to zero. A row is finished when <code>x</code> has become equal to <code>resolution</code>, so we can use an <code>if</code> block at the top of the loop to take care of this. Then use <code>x</code> instead of <code>i</code> to calculate the X coordinate.</p>
						
						<pre translate="no">		for (int i = 0, x = 0; i &lt; points.Length; i++, x++) {
			<ins>if (x == resolution) {</ins>
				<ins>x = 0;</ins>
			<ins>}</ins>
			Transform point = points[i] = Instantiate(pointPrefab);
			position.x = (<ins>x</ins> + 0.5f) * step - 1f;
			&hellip;
		}</pre>
						
						<p>Next, each row has to be offset along the Z dimension. This can be done by adding a <code>z</code> variable to the <code>for</code> loop as well. This variable must not be incremented each iteration. Instead, it only increments when we move on to the next row, for which we already have an <code>if</code> block. Then set the position's Z coordinate just like its X coordinate, using <code>z</code> instead of <code>x</code>.</p>
						
						<pre translate="no">		for (int i = 0, x = 0<ins>, z = 0</ins>; i &lt; points.Length; i++, x++) {
			if (x == resolution) {
				x = 0;
				<ins>z += 1;</ins>
			}
			Transform point = points[i] = Instantiate(pointPrefab);
			position.x = (x + 0.5f) * step - 1f;
			<ins>position.z = (z + 0.5f) * step - 1f;</ins>
			&hellip;
		}</pre>
						
						<p>We now create a square grid of points instead of a single line. Because our functions still only use the X dimension it will look like the original points have been extruded into lines.</p>
						
						<figure>
							<img src="adding-another-dimension/grid.png" width="200" height="160">
							<figcaption>Graph grid.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Better Visuals</h3>
						
						<p>Because our graph is now 3D I'll be looking at it from a perspective viewpoint from now on, using the game window. To quickly choose a good camera position you can find a nice viewpoint in the scene window while in play mode, exit play mode and then make the game's camera match the viewpoint. You can do that via <em translate="no">GameObject / Align With View</em> with <em translate="no">Main Camera</em> selected and the scene window visible. I made it look roughly down on the XZ diagonal. Then I changed the Y rotation of <em translate="no">Directional Light</em> from &minus;30 to 30, to improve the lighting for that view angle.</p>
						
						<p>Besides that, we can tweak the shadow quality a bit. Shadows probably already look acceptable when using the default render pipeline, but they're configured for looking far away while we're looking at our graph up close.</p>
						
						<p>You can select the visual quality level for the default render pipeline by going to the <em translate="no">Quality</em> project settings and selecting one of the preconfigured levels. The default dropdown controls which level gets used by default for standalone apps.</p>
						
						<figure>
							<img src="adding-another-dimension/quality-levels.png" width="130" height="144">
							<figcaption>Quality levels.</figcaption>
						</figure>
						
						<p>We can tweak performance and precision of the shadows further by going to the <em translate="no">Shadows</em> section below and reducing <em translate="no">Shadow Distance</em> to 10 and setting <em translate="no">Shadow Cascades</em> to <em translate="no">No Cascades</em>. The default settings render shadows four times, which is overkill for us.</p>
						
						<figure>
							<img src="adding-another-dimension/shadow-settings-default-quality.png" width="442" height="160" alt="quality"><br>
							<img src="adding-another-dimension/shadow-settings-default-game.png" width="200" height="160" alt="game">
							<figcaption>Shadow settings for default render pipeline.</figcaption>
						</figure>
						
						<aside>
							<h3>What do shadow cascades and distance control?</h3>
							<div>
								<p>Unity&mdash;and most game engines&mdash;render shadow casters into textures and later sample those to create shadows. These shadow maps have a fixed resolution. If they have to cover a large area the individual pixels will become large as well, resulting in blocky shadows.</p>
								
								<p>By reducing the maximum shadow distance we reduce the area the shadow maps have to cover, thus improving shadow quality, at the cost of losing shadows in the distance.</p>
								
								<p>Shadow cascades take this a step further for directional lights by using multiple maps, based on distance, so nearby shadows end up with an effective higher resolution than shadows that are far away. Both render pipeline support up to four cascades.</p>
							</div>
						</aside>
						
						<p>The URP doesn't use these settings, instead its shadows are configured via the inspector of our <em translate="no">URP</em> asset. It already renders directional shadows only once by default, but <em>Shadows / Max Distance</em> can be reduced to 10. Also, to match the standard <em translate="no">Ultra</em> quality of the default render pipeline enable <em translate="no">Shadows / Soft Shadows</em> and increase <em translate="no">Lighting / Main Light / Shadow Resolution</em> under <em translate="no">Lighting</em> to 4096.</p>
						
						<figure>
							<img src="adding-another-dimension/shadow-settings-urp-inspector.png" width="320" height="356" alt="inspector"><br>
							<img src="adding-another-dimension/shadow-settings-urp-game.png" width="200" height="160" alt="game">
							<figcaption>Shadows settings for URP.</figcaption>
						</figure>
						
						<p>Finally, you might notice visual tearing while in play mode. This can be prevented from happening in the game window by enabling <em translate="no">VSync (Game view only)</em> via the second dropdown menu from the left of the game window's toolbar. When enabled the presentation of new frames is synchronized with the display refresh rate. This only works reliably if no scene window is visible at the same time. VSync is configured for standalone apps via the <em translate="no">Other</em> section of the quality settings.</p>
						
						<figure>
							<img src="adding-another-dimension/game-window-vsync.png" width="300" height="98">
							<figcaption>VSnyc enabled for game window.</figcaption>
						</figure>
						
						<aside>
							<h3>Why has the frame rate dropped?</h3>
							<div>
								<p>Compared to the previous single line, a grid contains a lot more points. At resolution 50 it has 2,500 points. At resolution 100 it has 10,000 points. For best performance only have one scene or game window visible at all times. Also, make sure that the object hierarchy of <code>Graph</code> is collapsed in the hierarchy window so none of the points have to be listed.</p>
								
								<p>We'll take a closer look at performance in the next tutorial.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Incorporating Z</h3>
						
						<p>The simplest way to use Z in the <code>Wave</code> function is to use the sum of both X and Z instead of just X. That will create a diagonal wave.</p>
						
						<pre translate="no">	public static float Wave (float x, float z, float t) {
		return Sin(PI * (x <ins>+ z</ins> + t));
	}</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/fatalbrownjenny?controls=0'></iframe></div>
							<figcaption>Diagonal wave.</figcaption>
						</figure>
						
						<p>And the most straightforward change for <code>MultiWave</code> is to make each wave use a separate dimension. Let's make the smaller one use Z.</p>
						
						<pre translate="no">	public static float MultiWave (float x, float z, float t) {
		float y = Sin(PI * (x + 0.5f * t));
		y += 0.5f * Sin(2f * PI * (<ins>z</ins> + t));
		return y * (2f / 3f);
	}</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/brownlawfulhound?controls=0'></iframe></div>
							<figcaption>Two waves in different dimensions.</figcaption>
						</figure>
						
						<p>We can also add a third wave that travels along the XZ diagonal. Let's use the same wave as <code>Wave</code> does, except with the time slowed down to a quarter. Then scale the result by dividing by 2.5 to keep it inside the &minus;1&ndash;1 range.</p>
						
						<pre translate="no">		float y = Sin(PI * (x + 0.5f * t));
		y += 0.5f * Sin(2f * PI * (z + t));
		<ins>y += Sin(PI * (x + z + 0.25f * t));</ins>
		return y * (<ins>1f / 2.5f</ins>);</pre>
						
						<p>Note that the first and third waves will cancel each other out at regular intervals.</p>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/shadybabyishcricket?controls=0'></iframe></div>
							<figcaption>Triple wave.</figcaption>
						</figure>
						
						<p>Finally, to make the ripple spread in all directions on the XZ plane we have to calculate the distance in both dimensions. We can use the Pythagorean theorem for this, with help of the <code>Mathf.Sqrt</code> method.</p>
						
						<aside>
							<h3>What's the Pythagorean theorem?</h3>
							<div>
								
								<p>The Pythagorean theorem states that `a^2+b^2=c^2` where `c` is the length of the hypotenuse of a right triangle and `a` and `b` are the lengths of its other two sides.</p>
								
								<figure>
									<img src="adding-another-dimension/pythagorean-theorem.png" width="240" height="175">
									<figcaption>Using the Pythagorean theorem.</figcaption>
								</figure>
								
								<p>In the case of 2D points in the XZ plane the hypotenuse of such a triangle corresponds to the line between the origin and that point, with its X and Z coordinates as the lengths of the other two sides. Thus the distance between each of our points and the origin is `sqrt(x^2+z^2)`.</p>
							</div>
						</aside>
						
						<pre translate="no">	public static float Ripple (float x, float z, float t) {
		float d = <ins>Sqrt(x * x + z * z)</ins>;
		float y = Sin(PI * (4f * d - t));
		return y / (1f + 10f * d);
	}</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/kindheartedvariablebarnswallow?controls=0'></iframe></div>
							<figcaption>Ripple on XZ plane.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Leaving the Grid</h2>
					
					<p>By using X and Z to define Y we are able to create functions that describe a large variety of surfaces, but they're always linked to the XZ plane. No two points can have the same X and Z coordinates while having a different Y coordinate. This means that the curvature of our surfaces is limited. Their slopes cannot become vertical and they cannot fold backward. To make this possible, our functions would have to not only output Y, but also X and Z.</p>
					
					<section>
						<h3>Three-Dimensional Functions</h3>
						
						<p>If our functions were to output 3D positions instead of 1D values we could use them to create arbitrary surfaces. For example, the function `f(x,z)=[[x],[0],[z]]` describes the XZ plane, while the function `f(x,z)=[[x],[z],[0]]` describes the XY plane.</p>
						
						<p>Because the input parameters for these functions no longer have to correspond to the final X and Z coordinates, it's no longer appropriate to name them `x` and `z`. Instead, they're used to create a parametric surface and are often named `u` and `v`. So we'd get functions like `f(u,v)=[[u],[sin(pi(u+v))],[v]]`.</p>
						
						<p>Adjust our <code>Function</code> delegate type to support this new approach. The only required change is replacing its <code>float</code> return type with <code>Vector3</code>, but let's also rename its parameters.</p>
						
						<pre translate="no">	public delegate <ins>Vector3</ins> Function (float <ins>u</ins>, float <ins>v</ins>, float t);</pre>
						
						<p>We also have to adjust our function methods accordingly. We'll simply use U and V directly for X and Z. It isn't required to adjust the parameter names&mdash;only their types need to match the delegate&mdash;but let's do this to stay consistent. If your code editor supports it you can quickly refactor-rename parameters and other things so it gets renamed everywhere it's used in one go, via a menu or context menu option.</p>
						
						<p>Begin with <code>Wave</code>. Have it initially declare a <code>Vector3</code> variable, then set its components, and then return it. We don't have to give the vector an initial value because we set all its fields before returning it.</p>
						
						<pre translate="no">	public static <ins>Vector3</ins> Wave (float <ins>u</ins>, float <ins>v</ins>, float t) {
		<ins>Vector3 p;</ins>
		<ins>p.x = u;</ins>
		<ins>p.y =</ins> Sin(PI * (<ins>u</ins> + <ins>v</ins> + t));
		<ins>p.z = v;</ins>
		<ins>return p;</ins>
	}</pre>
						
						<p>Then give <code>MultiWave</code> and <code>Ripple</code> the same treatment.</p>
						
						<pre translate="no">	public static <ins>Vector3</ins> MultiWave (float <ins>u</ins>, float <ins>v</ins>, float t) {
		<ins>Vector3 p;</ins>
		<ins>p.x = u;</ins>
		<ins>p.y</ins> = Sin(PI * (<ins>u</ins> + 0.5f * t));
		<ins>p.y</ins> += 0.5f * Sin(2f * PI * (<ins>v</ins> + t));
		<ins>p.y</ins> += Sin(PI * (<ins>u</ins> + <ins>v</ins> + 0.25f * t));
		<ins>p.y *= 1f / 2.5f</ins>;
		<ins>p.z = v;</ins>
		<ins>return p;</ins>
	}

	public static <ins>Vector3</ins> Ripple (float <ins>u</ins>, float <ins>v</ins>, float t) {
		float d = Sqrt(u * u + v * v);
		<ins>Vector3 p;</ins>
		<ins>p.x = u;</ins>
		<ins>p.y</ins> = Sin(PI * (4f * d - t));
		<ins>p.y /= 1f + 10f * d</ins>;
		<ins>p.z = v;</ins>
		<ins>return p;</ins>
	}</pre>
						
						<p>Because the X and Z coordinates of points are no longer constant we can also no longer rely on their initial values in <code>Graph.Update</code>. We can solve this problem by replacing the loop in <code>Update</code> with the same one used in <code>Awake</code>, except that we can now directly assign the function result to the point's position.</p>
						
						<pre translate="no">	void Update () {
		FunctionLibrary.Function f = FunctionLibrary.GetFunction(function);
		float time = Time.time;
		<ins>float step = 2f / resolution;</ins>
		for (int i = 0<ins>, x = 0, z = 0</ins>; i &lt; points.Length; i++<ins>, x++</ins>) {
			<ins>if (x == resolution) {</ins>
				<ins>x = 0;</ins>
				<ins>z += 1;</ins>
			<ins>}</ins>
			<ins>float u = (x + 0.5f) * step - 1f;</ins>
			<ins>float v = (z + 0.5f) * step - 1f;</ins>
			<ins>points[i].localPosition = f(u, v, time);</ins>
		}
	}</pre>
						
						<p>Note that we only need to recalculate <code>v</code> when <code>z</code> changes. This does require us to set its initial value before the start of the loop.</p>
						
						<pre translate="no">		<ins>float v = 0.5f * step - 1f;</ins>
		for (int i = 0, x = 0, z = 0; i &lt; points.Length; i++, x++) {
			if (x == resolution) {
				x = 0;
				z += 1;
				<ins>v = (z + 0.5f) * step - 1f;</ins>
			}
			float u = (x + 0.5f) * step - 1f;
			<del>//float v = (z + 0.5f) * step - 1f;</del>
			points[i].localPosition = f(u, v, time);
		}</pre>
						
						<p>Also note that because <code>Update</code> now uses the resolution, changing it while in play mode will deform the graph, stretching or squashing the grid into a rectangle.</p>
						
						<aside>
							<h3>Why not use a nested double loop?</h3>
							<div>
								<p>That's also possible and is the usual approach when looping over two dimensions. However, this approach primarily loops over points instead of dimensions. It always updates all points even when the resolution gets changed while in play mode.</p>
							</div>
						</aside>
						
						<p>We no longer need to initialize the positions in <code>Awake</code>, so we can make that method a lot simpler. We can suffice with setting only the scale and parent of the points.</p>
						
						<pre translate="no">	void Awake () {
		float step = 2f / resolution;
		var scale = Vector3.one * step;
		<del>//var position = Vector3.zero;</del>
		points = new Transform[resolution * resolution];
		for (int <ins>i = 0</ins>; i &lt; points.Length; <ins>i++</ins>) {
			<del>//if (x == resolution) {</del>
			<del>//	x = 0;</del>
			<del>//	z += 1;</del>
			<del>//}</del>
			Transform point = points[i] = Instantiate(pointPrefab);
			<del>//position.x = (x + 0.5f) * step - 1f;</del>
			<del>//position.z = (z + 0.5f) * step - 1f;</del>
			<del>//point.localPosition = position;</del>
			point.localScale = scale;
			point.SetParent(transform, false);
		}
	}</pre>
					</section>
					
					<section>
						<h3>Creating a Sphere</h3>
						
						<p>To demonstrate that we indeed are no longer limited to one point per (X, Z) coordinate pair, let's create a function that defines a sphere. Add a <code>Sphere</code> method to <code>FunctionLibrary</code> for this purpose. Also add an entry for it to the <code>FunctionName</code> enum and the <code>functions</code> array. Start with always returning a point at the origin.</p>
						
						<pre translate="no">	public enum FunctionName { Wave, MultiWave, Ripple<ins>, Sphere</ins> }

	static Function[] functions = { Wave, MultiWave, Ripple<ins>, Sphere</ins> };

	&hellip;

	<ins>public static Vector3 Sphere (float u, float v, float t) {</ins>
		<ins>Vector3 p;</ins>
		<ins>p.x = 0f;</ins>
		<ins>p.y = 0f;</ins>
		<ins>p.z = 0f;</ins>
		<ins>return p;</ins>
	<ins>}</ins></pre>
						
						<p>The first step to creating a sphere is to describe a circle, laying flat in the XZ plane. We can use `[[sin(piu)],[0],[cos(piu)]]` for this, relying solely on `u`.</p>
						
						<pre translate="no">		p.x = <ins>Sin(PI * u)</ins>;
		p.y = 0f;
		p.z = <ins>Cos(PI * u)</ins>;</pre>
						
						<figure>
							<img src="leaving-the-grid/circle.png" width="200" height="120">
							<figcaption>A circle.</figcaption>
						</figure>
						
						<p>We now have multiple circles that overlap perfectly. We can extrude them along Y based on `v`, which gives us an uncapped cylinder.</p>
						
						<pre translate="no">		p.x = Sin(PI * u);
		p.y = <ins>v</ins>;
		p.z = Cos(PI * u);</pre>
						
						<figure>
							<img src="leaving-the-grid/cylinder.png" width="200" height="240">
							<figcaption>A cylinder.</figcaption>
						</figure>
						
						<p>We can adjust the radius of the cylinder by scaling X and Z by some value `r`. If we use `r=cos(pi/2v)` then the cylinder's top and bottom get collapsed to single points.</p>
						
						<pre translate="no">		<ins>float r = Cos(0.5f * PI * v);</ins>
		Vector3 p;
		p.x = <ins>r *</ins> Sin(PI * u);
		p.y = v;
		p.z = <ins>r *</ins> Cos(PI * u);</pre>
						
						<figure>
							<img src="leaving-the-grid/cylinder-collapsing.png" width="200" height="170">
							<figcaption>A cylinder with collapsing radius.</figcaption>
						</figure>
						
						<p>This gets us close to a sphere, but the reduction of the cylinder's radius isn't circular yet. That's because a circle is made with both a sine and a cosine, and we're only using the cosine for its radius at this point. The other part of the equation is Y, which is currently still equal to `v`. To complete the circle everywhere we have to use `y=sin(pi/2v)`.</p>
						
						<pre translate="no">		p.y = <ins>Sin(PI * 0.5f * v)</ins>;</pre>
						
						<figure>
							<img src="leaving-the-grid/sphere.png" width="200" height="200">
							<figcaption>A sphere.</figcaption>
						</figure>
						
						<p>The result is a sphere, created with a pattern that's usually known as a UV-sphere. While this approach creates a correct sphere, note that the distribution of points isn't uniform, because the sphere is created by stacking circles with different radii. Alternatively, we can consider it to consists of multiple half-circles that are rotated around the Y axis.</p>
					</section>
					
					<section>
						<h3>Perturbing the Sphere</h3>
					
						<p>Let's tweak the surface of the sphere to make it more interesting. To do this we have to adjust our formula somewhat. We'll use `f(u,v)=[[ssin(piu)],[rsin(pi/2v)],[scos(piu)]]`, where `s=rcos(pi/2v)`, and `r` is the radius. That makes it possible to animate the radius. For example, we could animate it by using `r=(1+sin(pit))/2` to scale it based on time.</p>
						
						<pre translate="no">		float r = <ins>0.5f + 0.5f * Sin(PI * t);</ins>
		<ins>float s = r *</ins> Cos(0.5f * PI * v);
		Vector3 p;
		p.x = <ins>s</ins> * Sin(PI * u);
		p.y = <ins>r *</ins> Sin(0.5f * PI * v);
		p.z = <ins>s</ins> * Cos(PI * u);</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/spiffyvaluablebaleenwhale?controls=0'></iframe></div>
							<figcaption>Scaling sphere.</figcaption>
						</figure>
						
						<p>We don't have to use a uniform radius. We could vary it based on `u`, like `r=(9+sin(8piu))/10`.</p>
						
						<pre translate="no">		float r = <ins>0.9f + 0.1f * Sin(8f * PI * u)</ins>;</pre>
						
						<figure>
							<img src="leaving-the-grid/sphere-vertical-bands.png" width="200" height="200">
							<figcaption>Sphere with vertical bands; resolution 100.</figcaption>
						</figure>
						
						<p>This gives the sphere the appearance of having vertical bands. We can switch to horizontal bands by using `v` instead of `u`.</p>
						
						<pre translate="no">		float r = 0.9f + 0.1f * Sin(8f * PI * <ins>v</ins>);</pre>
						
						<figure>
							<img src="leaving-the-grid/sphere-horizontal-bands.png" width="200" height="200">
							<figcaption>Sphere with horizontal bands.</figcaption>
						</figure>
						
						<p>And by using both we get twisting bands. Let's add time as well to make them rotate, finishing with `r=(9+sin(pi(6u+4v+t)))/10`.</p>
						
						<pre translate="no">		float r = 0.9f + 0.1f * Sin(<ins>PI * (6f * u + 4f * v + t)</ins>);
</pre>
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/unsightlyselfreliantamericanindianhorse?controls=0'></iframe></div>
							<figcaption>Rotating twisted sphere.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Creating a Torus</h3>
						
						<p>Let's wrap up by adding a torus surface to <code>FunctionLibrary</code>. Duplicate <code>Sphere</code>, rename it to <code>Torus</code> and set its radius to 1. Also update the names and function array.</p>
						
						<pre translate="no">	public enum FunctionName { Wave, MultiWave, Ripple, Sphere<ins>, Torus</ins> }

	static Function[] functions = { Wave, MultiWave, Ripple, Sphere<ins>, Torus</ins> };

	&hellip;

	<ins>public static Vector3 Torus (float u, float v, float t) {</ins>
		<ins>float r = 1f;</ins>
		<ins>float s = r * Cos(0.5f * PI * v);</ins>
		<ins>Vector3 p;</ins>
		<ins>p.x = s * Sin(PI * u);</ins>
		<ins>p.y = r * Sin(0.5f * PI * v);</ins>
		<ins>p.z = s * Cos(PI * u);</ins>
		<ins>return p;</ins>
	<ins>}</ins></pre>
						
						<p>We can morph our sphere into a torus by pulling its vertical half-circles away from each other and turning them into full circles. Let's begin with by switching to `s=1/2+rcos(pi/2v)`.</p>
						
						<pre translate="no">		float s = <ins>0.5f +</ins> r * Cos(0.5f * PI * v);
</pre>
						
						<figure>
							<img src="leaving-the-grid/sphere-pulled-apart.png" width="280" height="230">
							<figcaption>Sphere pulled apart.</figcaption>
						</figure>
						
						<p>This gives us half a torus, with only the outer portion of its ring accounted for. To complete the torus we have to use `v` to describe an entire circle instead of half a circle. That can be done by using `piv` instead of `pi/2v` in `s` and `y`.</p>
						
						<pre translate="no">		float s = 0.5f + r * Cos(<ins>PI</ins> * v);
		Vector3 p;
		p.x = s * Sin(PI * u);
		p.y = r * Sin(<ins>PI</ins> * v);
		p.z = s * Cos(PI * u);
</pre>
						
						<figure>
							<img src="leaving-the-grid/torus-spindle.png" width="280" height="230">
							<figcaption>A self-intersecting spindle torus.</figcaption>
						</figure>
						
						<p>Because we've pulled the sphere apart by half a unit this produces a self-intersecting shape, known as a spindle torus. Had we pulled it apart by one unit instead, we would've gotten a torus that doesn't self-intersect, but doesn't have a hole either, which is known as a horn torus. So how far we pull the sphere apart influences the shape of the torus. Specifically, it defines the major radius of the torus. The other radius is the minor radius and determines the thickness of the ring. Let's define the major radius as `r_1` and rename the other to `r_2` so `s=r_2cos(piv)+r_1`. Then use 0.75 for the major and 0.25 for the minor radius to keep the points inside the &minus;1&ndash;1 range.</p>
						
						<pre translate="no">		<del>//float r = 1f;</del>
		<ins>float r1 = 0.75f;</ins>
		<ins>float r2 = 0.25f;</ins>
		float s = <ins>r1</ins> + <ins>r2</ins> * Cos(PI * v);
		Vector3 p;
		p.x = s * Sin(PI * u);
		p.y = <ins>r2</ins> * Sin(PI * v);
		p.z = s * Cos(PI * u);
</pre>
						
						<figure>
							<img src="leaving-the-grid/torus-ring.png" width="200" height="140">
							<figcaption>A ring torus.</figcaption>
						</figure>
						
						<p>Now we have two radii to play with to make a more interesting torus. For example, we can turn it into a rotating star pattern by using `r_1=(7+sin(pi(6u+t/2)))/10`, while also twisting the ring by using `r_2=(3+sin(pi(8u+4v+2t)))/20`.</p>
						
						<pre translate="no">		float r1 = <ins>0.7f + 0.1f * Sin(PI * (6f * u + 0.5f * t))</ins>;
		float r2 = <ins>0.15f + 0.05f * Sin(PI * (8f * u + 4f * v + 2f * t))</ins>;</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:216px;"><iframe src='https://gfycat.com/ifr/mediocrespottedcuscus?controls=0'></iframe></div>
							<figcaption>Twisting torus.</figcaption>
						</figure>
						
						<p>You now have some experience working with nontrivial functions that describe surfaces, plus how to visualize them. You can experiment with your own functions to get a better grasp of how it works. There are many seemingly complex parametric surfaces that can be created with a few sine waves.</p>
						
						<p>The next tutorial is <a href="../measuring-performance/index.html">Measuring Performance</a>.</p>
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/basics-03-mathematical-surfaces/" class="repository">repository</a>
					<a href="Mathematical-Surfaces.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>