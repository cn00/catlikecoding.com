<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/procedural-meshes/icosphere/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/procedural-meshes/icosphere/tutorial-image.jpg">
		<meta property="og:title" content="Icosphere">
		<meta property="og:description" content="A Unity C# Procedural Meshes tutorial about creating an icosphere.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Icosphere</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/procedural-meshes/icosphere/#article",
				"headline": "Icosphere",
				"alternativeHeadline": "From Octahedron to Icosahedron",
				"datePublished": "2022-06-29",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity C# Procedural Meshes tutorial about creating an icosphere.",
				"image": "https://catlikecoding.com/unity/tutorials/procedural-meshes/icosphere/tutorial-image.jpg",
				"dependencies": "Unity 2020.3.35f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/procedural-meshes/", "name": "Procedural Meshes" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				CubeSphere: 1,
				FlatHexagonGrid: 1,
				IMeshGenerator: 1,
				IMeshStreams: 1,
				G: 1,
				GeoIcosphere: 1,
				GeoOctasphere: 1,
				GizmoMode: 1,
				Icosphere: 1,
				MaterialMode: 1,
				MeshJob: 1,
				MeshJobScheduleDelegate: 1,
				MeshOptimizationMode: 1,
				MeshType: 1,
				MultiStream: 1,
				Octasphere: 1,
				PointyHexagonGrid: 1,
				PositionStream: 1,
				ProceduralMesh: 1,
				Rhombus: 1,
				S: 1,
				SharedCubeSphere: 1,
				SharedSquareGrid: 1,
				SharedTriangleGrid: 1,
				Side: 1,
				SingleStream: 1,
				SquareGrid: 1,
				Stream0: 1,
				Strip: 1,
				TriangleUInt16: 1,
				UVSphere: 1,
				Vertex: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Procedural Meshes</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Icosphere</h1>
					<p>From Octahedron to Icosahedron</p>
					<ul>
						<li>Create a seamless octasphere.</li>
						<li>Convert from octahedron to icosahedron.</li>
						<li>Make a geodesic icosphere variant.</li>
					</ul>
				</header>
				
				<p>This is the tenth tutorial in a series about <a href="../index.html">procedural meshes</a>. This time we take our octasphere as a starting point and transform it into an icosphere.</p>
				
				<p>This tutorial is made with Unity 2020.3.35f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>A geodesic icosphere.</figcaption>
				</figure>
				
				<aside>
					<h3>Why doesn't Burst compile my code?</h3>
					<div>
						<p><a href="https://forum.unity.com/threads/burst-fails-to-recompile-changed-code.1286153/">There is a bug</a> introduced after Burst version 1.5.6 that causes Unity to fail to detect changes in code that is used in Burst jobs via generics. Everything works fine for the first compilation when the editor starts&mdash;and for builds&mdash;but later changes aren't picked up by the editor.</p>
						
						<p>Until this bug is fixed you can work around it by either sticking to Burst 1.5.6 at most, by disabling Bust compilation in the editor, or by making a change&mdash;like adding a space somewhere&mdash; in <code>MeshJob</code> every time you want to recompile.</p>
					</div>
				</aside>
				
				<section>
					<h2>Seamless Octasphere</h2>
					
					<p>The final shape that we'll use to generate a sphere is the icosahedron. It has twenty sides so should provide the most even vertex distribution of all the options. The resulting shape is typically known as an icosphere. Like the cube sphere it doesn't have a straight vertical seam going from pole to pole, so it will not support lat/lon texturing and thus only needs to have vertex position data.</p>
					
					<section>
						<h3>Icosphere Type</h3>
						
						<p>An icosahedron consists of equilateral triangles, just like an octahedron. Their construction is also similar, so we'll construct the icosphere by adjusting the octasphere, duplicating <code>Octasphere</code> and renaming it to <code>Icosphere</code>.</p>
						
						<pre translate="no">	public struct <ins>Icosphere</ins> : IMeshGenerator { &hellip; }</pre>
						
						<p>Add an option for it to <code>ProceduralMesh</code>, with <code>PositionStream</code> so it only generates positions.</p>
						
						<pre translate="no">	static MeshJobScheduleDelegate[] jobs = {
		&hellip;
		MeshJob&lt;SharedCubeSphere, PositionStream>.ScheduleParallel,
		<ins>MeshJob&lt;Icosphere, PositionStream>.ScheduleParallel,</ins>
		&hellip;
	};

	public enum MeshType {
		SquareGrid€, SharedSquareGrid€, SharedTriangleGrid€,
		FlatHexagonGrid€, PointyHexagonGrid€, CubeSphere€, SharedCubeSphere€,
		<ins>Icosphere€</ins>, Octasphere€, GeoOctasphere€, UVSphere€
	};</pre>
					</section>
					
					<section>
						<h3>No More Seam</h3>
						
						<p>Because the icosphere will not contain texture coordinates it doesn't not need a vertex seam. So let's begin by adjusting <code>Icosphere</code> so it generates a seamless octasphere. The resulting approach will be like a hybrid of the shared cube sphere and the octasphere.</p>
						
						<p>Getting rid of the seam means that the vertex line along the seam disappears as well as the duplicate vertices at the poles. The extra job index for the seam is also no longer needed. Adjust the vertex count and job length accordingly.</p>
						
						<pre translate="no">		public int VertexCount => 4 * Resolution * Resolution + 2<ins>;</ins> <del>// * Resolution + 7;</del>

		public int IndexCount => 6 * 4 * Resolution * Resolution;

		public int JobLength => 4 * Resolution<ins>;</ins> <del>// + 1;</del></pre>
							
							<p>Then get rid of <code>ExecutePolesAndSeams</code> and turn <code>ExecuteRegular</code> into the only <code>Execute</code> method.</p>
							
							<pre translate="no">		<del>//public void Execute&lt;S> (int i, S streams) where S : struct, IMeshStreams {</del>
			<del>//&hellip;</del>
		<del>//}</del>
		
		public void <ins>Execute</ins>&lt;S> (int i, S streams) where S : struct, IMeshStreams {
			int u = i / 4;
			&hellip;
		}

		<del>//public void ExecutePolesAndSeam&lt;S> (S streams) where S : struct, IMeshStreams {</del>
			<del>//&hellip;</del>
		<del>//}</del></pre>
					</section>
					
					<section>
						<h3>Positions Only</h3>
						
						<p>The <code>GetTangentXZ</code> and <code>GetTexCoord</code> methods are no longer needed, so remove them.</p>
						
						<pre translate="no">		<del>//static float2 GetTangentXZ (float3 p) => normalize(float2(-p.z, p.x));</del>

		<del>//static float2 GetTextCoord (float3 p) { &hellip; }</del></pre>
						
						<p>Along with all the code in <code>Execute</code> that deals with normals, tangents, and texture coordinates.</p>
						
						<pre translate="no">		public void Execute&lt;S> (int i, S streams) where S : struct, IMeshStreams {
			&hellip;

			var vertex = new Vertex();
			<del>//vertex.normal =</del>
			vertex.position = normalize(columnBottomStart);
			<del>//vertex.tangent.xz = GetTangentXZ(vertex.position);</del>
			<del>//vertex.tangent.w = -1f;</del>
			<del>//vertex.texCoord0 = GetTextCoord(vertex.position);</del>
			streams.SetVertex(vi, vertex);
			vi += 1;

			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				&hellip;
				<del>//vertex.normal =</del>
				vertex.position = normalize(vertex.position);
				<del>//vertex.tangent.xz = GetTangentXZ(vertex.position);</del>
				<del>//vertex.texCoord0 = GetTextCoord(vertex.position);</del>
				&hellip;
			}

			&hellip;
		}</pre>
					</section>
					
					<section>
						<h3>Fixing the Mesh</h3>
						
						<p>At this point the mesh doesn't work because <code>Execute</code> uses incorrect indices. The initial vertex index should be `r(ri+u)+2` instead of `r(ri+u+2)+7`, where `i` is the rhombus index.</p>
						
						<pre translate="no">			int vi = Resolution * (Resolution * rhombus.id + u) <ins>+ 2</ins>; <del>// + 2) + 7</del>;</pre>
						
						<p>The quad indices must also be changed. The initial Y index for the first column is now always zero, because there is only a single south pole vertex. Besides that the initial Z index for the first column of the first rhombus now needs to wrap around to the last rhombus, so it becomes `3r^2+2` instead of 8.</p>
						
						<pre translate="no">			int4 quad = int4(
				vi,
				firstColumn ? <ins>0</ins> : vi - Resolution,
				firstColumn ?
					rhombus.id == 0 ?
						<ins>3 * Resolution * Resolution + 2</ins> :
						vi - Resolution * (Resolution + u) :
					vi - Resolution + 1,
				vi + 1
			);</pre>
						
						<p>After that, we'll have to generate the south and north pole vertices separately, for which we'll copy the approach from <code>SharedCubeSphere</code>.</p>
						
						<pre translate="no">			var vertex = new Vertex();
			<ins>if (i == 0) {</ins>
				<ins>vertex.position = down();</ins>
				<ins>streams.SetVertex(0, vertex);</ins>
				<ins>vertex.position = up();</ins>
				<ins>streams.SetVertex(1, vertex);</ins>
			<ins>}</ins></pre>
						
						<p>Moving on to the loop, the quad Z index now always needs to be incremented by `r` for the first column. The first rhombus is no longer an exception because the seam is gone.</p>
						
						<pre translate="no">			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				&hellip;
				quad += int4(1, 0, <ins>firstColumn</ins> ? Resolution : 1, 1);
			}</pre>
						
						<p>After the loop, the final Z index is now already correct, except for the first column. In that case it should be set to `r^2i-r+u+1`, except that `i` should wrap to 4 for the first rhombus.</p>
						
						<pre translate="no">			<del>//quad.z = Resolution * Resolution * rhombus.id + Resolution + u + 6;</del>
			<ins>if (!firstColumn) {</ins>
				<ins>quad.z = Resolution * Resolution * (rhombus.id == 0 ? 4 : rhombus.id) -</ins>
					<ins>Resolution + u + 1;</ins>
			<ins>}</ins></pre>
						
						<p>Finally, the final W index for the north pole is always 1.</p>
						
						<pre translate="no">			quad.w = u &lt; Resolution ? quad.z + 1 : <ins>1</ins>;</pre>
						
						<figure>
							<img src="seamless-octasphere/seamless-octasphere.png" width="300" height="300">
							<figcaption>Seamless octasphere; resolution 6; <em translate="no">Cube Map</em> material.</figcaption>
						</figure>
					</section>
						
						<aside>
							<h3>Can't we keep the seamless octasphere?</h3>
							<div>
								<p>You can, but if you do not need a seam for lon/lat texture mapping the icosphere is superior to the octasphere.</p>
							</div>
						</aside>
				</section>
				
				<section>
					<h2>From Octasphere to Icosphere</h2>
					
					<p>An icosahedron has twelve corners: a south and north pole, plus two rings of five vertices each in between. At the poles five triangle faces meet, forming the polar caps. In between those fits a ring of ten triangles, for a total of twenty faces.</p>
					
					<p>We can morph an octahedron layout into an icosahedron layout by adding a fifth rhombus, then doubling the V dimension of these rhombuses so they become parallelograms, forming strips of four triangles going from pole to pole.
					
					<figure>
						<img src="from-octasphere-to-icosphere/icosahedron-layout.png" width="390" height="390">
						<figcaption>Icosahedron layout.</figcaption>
					</figure>
					
					<aside>
						<h3>Could we double the U dimension instead?</h3>
						<div>
							<p>Yes. That would flip the direction of the parallelograms and the logic for U and V.</p>
						</div>
					</aside>
					
					<section>
						<h3>Octahedron</h3>
						
						<p>To make the transformation easier to see, turn the octasphere back into an octahedron by removing the normalization of the vertex positions.</p>
						
						<pre translate="no">			vertex.position = <ins>columnBottomStart</ins>;
			streams.SetVertex(vi, vertex);
			vi += 1;

			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				&hellip;
				<del>//vertex.position = normalize(vertex.position);</del>
				&hellip;
			}</pre>
						
						<figure>
							<img src="from-octasphere-to-icosphere/octahedron.png" width="300" height="300">
							<figcaption>Octahedron.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Five Rhombuses</h3>
						
						<p>To fit five rhombuses in a circle we have to work with 72&deg; rotation increments instead of 90&deg;, which complicates things. Let's create a convenient static method that creates a point with X and Z coordinates rotated based on the rhombus identifier, starting with the back vector: `[[sin((2pi)/5i)],[0],[-cos((2pi)/5i)]]`</p>
						
						<pre translate="no">		<ins>static float3 GetCorner (int id) => float3(</ins>
			<ins>sin(0.4f * PI * id),</ins>
			<ins>0f,</ins>
			<ins>-cos(0.4f * PI * id)</ins>
		<ins>);</ins></pre>
						
						<p>Use it to create the five rhombuses in <code>GetRhombus</code>.</p>
						
						<pre translate="no">		static Rhombus GetRhombus (int id) => id switch {
			0 => new Rhombus {
				id = id,
				leftCorner = <ins>GetCorner(0)</ins>,
				rightCorner = <ins>GetCorner(1)</ins>
			},
			1 => new Rhombus {
				id = id,
				leftCorner = <ins>GetCorner(1)</ins>,
				rightCorner = <ins>GetCorner(2)</ins>
			},
			2 => new Rhombus {
				id = id,
				leftCorner = <ins>GetCorner(2)</ins>,
				rightCorner = <ins>GetCorner(3)</ins>
			},
			<ins>3 => new Rhombus {</ins>
				<ins>id = id,</ins>
				<ins>leftCorner = GetCorner(3),</ins>
				<ins>rightCorner = GetCorner(4)</ins>
			<ins>},</ins>
			_ => new Rhombus {
				id = id,
				leftCorner = <ins>GetCorner(4)</ins>,
				rightCorner = <ins>GetCorner(0)</ins>
			}
		};</pre>
						
						<figure>
							<img src="from-octasphere-to-icosphere/four-out-of-five.png" width="300" height="300">
							<figcaption>Four out of five rhombuses; bottom view.</figcaption>
						</figure>
						
						<p>At this point we get a misshapen octahedron. The next step is to add vertices and triangles for a fifth rhombus. Increase the vertex count, index count, and job length accordingly.</p>
						
						<pre translate="no">		public int VertexCount => <ins>5</ins> * Resolution * Resolution + 2;

		public int IndexCount => 6 * <ins>5</ins> * Resolution * Resolution;

		public int JobLength => <ins>5</ins> * Resolution;</pre>
						
						<p>Adjust the U coordinate and rhombus identifier in <code>Execute</code> as well.</p>
						
						<pre translate="no">			int u = i / <ins>5</ins>;
			Rhombus rhombus = GetRhombus(i - <ins>5</ins> * u);</pre>
						
						<p>We also have to adjust the Z index of the first rhombus before the loop.</p>
						
						<pre translate="no">			int4 quad = int4(
				vi,
				firstColumn ? 0 : vi - Resolution,
				firstColumn ?
					rhombus.id == 0 ?
						<ins>4</ins> * Resolution * Resolution + 2 :
						vi - Resolution * (Resolution + u) :
					vi - Resolution + 1,
				vi + 1
			);</pre>
						
						<p>And also afterwards.</p>
						
						<pre translate="no">			if (!firstColumn) {
				quad.z = Resolution * Resolution * (rhombus.id == 0 ? <ins>5</ins> : rhombus.id) -
					Resolution + u + 1;
			}</pre>
						
						<figure>
							<img src="from-octasphere-to-icosphere/five-rhombuses.png" width="300" height="300">
							<figcaption>Five rhombuses.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Five Strips</h3>
						
						<p>To make the full transition to icosahedron we have to elongate our rhombuses, which means that the <code>Rhombus</code> type name is no longer appropriate. They will become parallelograms, but to keep the name short we'll refactor rename the type to <code>Strip</code>.</p>
						
						<pre translate="no">		struct <ins>Strip</ins> {
			public int id;
			public float3 leftCorner, rightCorner;
		}</pre>
						
						<p>Rename <code>GetRhombus</code> to <code>GetStrip</code> to match.</p>
						
						<pre translate="no">		static Strip <ins>GetStrip</ins> (int id) => id switch { &hellip; };</pre>
						
						<p>And also rename the variable in <code>Execute</code>. As usual for a refactor rename, I don't show all the required code changes.</p>
						
						<pre translate="no">		public void Execute&lt;S> (int i, S streams) where S : struct, IMeshStreams {
			int u = i / 5;
			Strip <ins>strip</ins> = GetStrip(i - 5 * u);
			&hellip;
		}</pre>
					</section>
					
					<section>
						<h3>Low Corner Ring</h3>
						
						<p>To make sure that we end up with equilateral triangles the corner rings must have the appropriate radius and vertical position. We can do this for the low ring by setting its Y coordinate to &minus;&frac12; and then scaling everything by `2/5sqrt(5)`.</p>
						
						<pre translate="no">		static float3 GetCorner (int id) => float3(
			<ins>0.4f * sqrt(5f) *</ins> sin(0.4f * PI * id),
			<ins>-0.2f * sqrt(5f)</ins>,
			-<ins>0.4f * sqrt(5f) *</ins> cos(0.4f * PI * id)
		);</pre>
						
						<figure>
							<img src="from-octasphere-to-icosphere/low-corner-ring.png" width="300" height="300">
							<figcaption>Low corner ring.</figcaption>
						</figure>
						
						<aside>
							<h3>How did you find those values?</h3>
							<div>
								<p>Those are the vertices on the bottom ring of a <a href="https://mathworld.wolfram.com/RegularIcosahedron.html">regular icosahedron</a> when using two polar vertices, with all its vertices on the unit sphere.</p>
							</div>
						</aside>
						
						<p>To make clear that those corners are for the low ring, let's refactor rename the fields to <code>lowLeftCorner</code> and <code>LowRightCorner</code>.</p>
						
						<pre translate="no">		struct Strip {
			public int id;
			public float3 <ins>lowLeftCorner</ins>, <ins>lowRightCorner</ins>;
		}</pre>
					</section>
					
					<section>
						<h3>Both Rings</h3>
						
						<p>To also support the high ring, add two more corners to <code>Strip</code>.
						
						<pre translate="no">			public float3 lowLeftCorner, lowRightCorner<ins>, highLeftCorner, highRightCorner</ins>;</pre>
						
						<p>Compared to the low ring, the high ring is rotated `pi/5` radians clockwise and its Y coordinates are positive instead of negative. To make <code>GetCorner</code> support both rings halve its radian scalar and add an integer parameter to control the sign of the Y coordinate via multiplication.</p>
						
						<pre translate="no">		static float3 GetCorner (int id<ins>, int ySign</ins>) => float3(
			0.4f * sqrt(5f) * sin(<ins>0.2f</ins> * PI * id),
			<ins>ySign * 0.2f</ins> * sqrt(5f),
			-0.4f * sqrt(5f) * cos(<ins>0.2f</ins> * PI * id)
		);</pre>
						
						<p>To keep the results of <code>GetStrip</code> the same we now have to double the first argument passed to <code>GetCorner</code> and use &minus;1 for its new second argument.</p>
						
						<pre translate="no">		static Strip GetStrip (int id) => id switch {
			0 => new Strip {
				id = id,
				lowLeftCorner = GetCorner(0<ins>, -1</ins>),
				lowRightCorner = GetCorner(<ins>2, -1</ins>)
			},
			1 => new Strip {
				id = id,
				lowLeftCorner = GetCorner(<ins>2, -1</ins>),
				lowRightCorner = GetCorner(<ins>4, -1</ins>)
			},
			2 => new Strip {
				id = id,
				lowLeftCorner = GetCorner(<ins>4, -1</ins>),
				lowRightCorner = GetCorner(<ins>6, -1</ins>)
			},
			3 => new Strip {
				id = id,
				lowLeftCorner = GetCorner(<ins>6, -1</ins>),
				lowRightCorner = GetCorner(<ins>8, -1</ins>)
			},
			_ => new Strip {
				id = id,
				lowLeftCorner = GetCorner(<ins>8, -1</ins>),
				lowRightCorner = GetCorner(<ins>0, -1</ins>)
			}
		};</pre>
						
						<p>This is repetitive code, which we can reduce to just a few lines by directly using the strip identifier to calculate the correct arguments for <code>GetCorner</code>.</p>
						
						<pre translate="no">		static Strip GetStrip (int id) => <ins>new Strip {</ins>
			<ins>id = id,</ins>
			<ins>lowLeftCorner = GetCorner(2 * id, -1),</ins>
			<ins>lowRightCorner = GetCorner(id == 4 ? 0 : 2 * id + 2, -1)</ins>
		<ins>};</ins></pre>
						
						<p>Unfortunately the Burst compiler now considers all code variable, which makes our Burst code perform trigonometry instead of copying a few constant values. We can force the compiler to again treat the corner data as constant by reintroducing the switch and moving the strip-creating code to a new <code>CreateStrip</code> method.</p>
						
						<pre translate="no">		static Strip GetStrip (int id) => <ins>id switch {</ins>
			<ins>0 => CreateStrip(0),</ins>
			<ins>1 => CreateStrip(1),</ins>
			<ins>2 => CreateStrip(2),</ins>
			<ins>3 => CreateStrip(3),</ins>
			<ins>_ => CreateStrip(4)</ins>
		<ins>};</ins>

		<ins>static Strip CreateStrip (int id) =></ins> new Strip {
			id = id,
			lowLeftCorner = GetCorner(2 * id, -1),
			lowRightCorner = GetCorner(id == 4 ? 0 : 2 * id + 2, -1)
		};</pre>
						
						<p>Now add the high corners to <code>CreateStip</code>. Their identifier arguments are one less than the respective low corners, with correct wrapping for the first strip. Their Y sign is positive.</p>
						
						<pre translate="no">		static Strip CreateStrip (int id) => new Strip {
			id = id,
			lowLeftCorner = GetCorner(2 * id, -1),
			lowRightCorner = GetCorner(id == 4 ? 0 : 2 * id + 2, -1)<ins>,</ins>
			<ins>highLeftCorner = GetCorner(id == 0 ? 9 : 2 * id - 1, 1),</ins>
			<ins>highRightCorner = GetCorner(2 * id + 1, 1)</ins>
		};</pre>
					</section>
					
					<section>
						<h3>Entire Strips</h3>
						
						<p>To fill the entire strips we have to double the effective resolution in the V dimension. Add a convenient private property to reference it.</p>
						
						<pre translate="no">		<ins>int ResolutionV => 2 * Resolution;</ins></pre>
						
						<p>Adjust the vertex count and index count to use this increased resolution, still using the regular one for the U dimension.</p>
						
						<pre translate="no">		public int VertexCount => 5 * <ins>ResolutionV</ins> * Resolution + 2;

		public int IndexCount => 6 * 5 * <ins>ResolutionV</ins> * Resolution;</pre>
						
						<p>Also adjust the vertex and triangle index offsets at the start of <code>Execute</code> to match.</p>
						
						<pre translate="no">			int vi = <ins>ResolutionV</ins> * (Resolution * strip.id + u) + 2;
			int ti = 2 * <ins>ResolutionV</ins> * (Resolution * strip.id + u);</pre>
						
						<p>And incorporate it into the initial quad indices.</p>
						
						<pre translate="no">			int4 quad = int4(
				vi,
				firstColumn ? 0 : vi - <ins>ResolutionV</ins>,
				firstColumn ?
					strip.id == 0 ?
						4 * <ins>ResolutionV</ins> * Resolution + 2 :
						vi - <ins>ResolutionV</ins> * (Resolution + u) :
					vi - <ins>ResolutionV</ins> + 1,
				vi + 1
			);</pre>
						
						<p>The loop along the V dimension also becomes longer, as well as the quad Z index increase for the first column.</p>
						
						<pre translate="no">			for (int v = 1; v &lt; <ins>ResolutionV</ins>; v++, vi++, ti += 2) {
				&hellip;
				quad += int4(1, 0, firstColumn ? <ins>ResolutionV</ins> : 1, 1);
			}</pre>	
						
						<p>And update the quad Z index for the first column after the loop as well.</p>
						
						<pre translate="no">			if (!firstColumn) {
				quad.z = <ins>ResolutionV</ins> * Resolution * (strip.id == 0 ? 5 : strip.id) -
					Resolution + u + 1;
			}</pre>
						
						<p>We need to make one additional change to make sure that all triangle indices are correct. Because the strips are longer they now connect to three icosahedron edges of their neighbor instead of two octahedron edges. This new edge affects the first column. Only the first edge requires incrementing the quad Z index inside the loop by an entire column. This is the case when `v&lt;=r_u-u`, where `r_u` is the U resolution. In all other cases we only have to add 1.</p>
						
						<pre translate="no">				quad +=
					int4(1, 0, firstColumn <ins>&amp;&amp; v &lt;= Resolution - u</ins> ? ResolutionV : 1, 1);</pre>
						
						<p>The loop can now also go through four different faces instead of just two. The first face is still `v&lt;=r_u-u`. The second face comes after that, as long as `v&lt;r_u`. The third face comes after that, as long as `v&lt;=r_v-u`, so based on the V dimension this time, and the last one comes after that. Let's initially set the positions for the two new faces to zero, keeping the top and bottom faces as they were. Also, the last face's interpolator should be reduced by one.</p>
						
						<pre translate="no">				if (v &lt;= Resolution - u) {
					vertex.position =
						lerp(columnBottomStart, columnBottomEnd, (float)v / Resolution);
				}
				<ins>else if (v &lt; Resolution) {</ins>
					<ins>vertex.position = 0f;</ins>
				<ins>}</ins>
				<ins>else if (v &lt;= ResolutionV - u) {</ins>
					<ins>vertex.position = 0f;</ins>
				<ins>}</ins>
				else {
					vertex.position =
						lerp(columnTopStart, columnTopEnd, (float)v / Resolution <ins>- 1f</ins>);
				}</pre>
						
						<figure>
							<img src="from-octasphere-to-icosphere/incorrect-shape.png" width="300" height="300">
							<figcaption>Incorrect shape.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Completing the Icosahedron</h3>
						
						<p>To fix the top of the icosahedron we have to adjust the data for the top face. It must be relative to the high corners instead of relative to the low corners.</p>
						
						<pre translate="no">			float3 columnTopDir = up() - strip.<ins>highLeftCorner</ins>;
			float3 columnTopStart =
				strip.<ins>highRightCorner</ins> + columnTopDir * ((float)u / Resolution - 1f);
			float3 columnTopEnd = strip.<ins>highLeftCorner</ins> + columnTopDir * u / Resolution;</pre>
						
						<figure>
							<img src="from-octasphere-to-icosphere/top-and-bottom.png" width="300" height="300">
							<figcaption>Top and bottom.</figcaption>
						</figure>
						
						<p>The data for the second face&mdash;the low triangle of the ring&mdash;is calculated the same way as the top face, as both triangles are pointing up, but it's relative to different corners. It goes from the low corners to the high right corner.</p>
						
						<pre translate="no">			<ins>float3 columnLowDir = strip.highRightCorner - strip.lowLeftCorner;</ins>
			<ins>float3 columnLowStart =</ins>
				<ins>strip.lowRightCorner + columnLowDir * ((float)u / Resolution - 1f);</ins>
			<ins>float3 columnLowEnd = strip.lowLeftCorner + columnLowDir * u / Resolution;</ins>

			float3 columnTopDir = up() - strip.highLeftCorner;
			float3 columnTopStart =
				strip.highRightCorner + columnTopDir * ((float)u / Resolution - 1f);
			float3 columnTopEnd = strip.highLeftCorner + columnTopDir * u / Resolution;</pre>
						
						<p>Add the interpolation for it to the loop, with `v/r_u` as the interpolator.</p>
						
						<pre translate="no">				else if (v &lt; Resolution) {
					vertex.position =
						<ins>lerp(columnLowStart, columnLowEnd, (float)v / Resolution);</ins>
				}</pre>
						
						<figure>
							<img src="from-octasphere-to-icosphere/lower-ring.png" width="300" height="300">
							<figcaption>Lower ring faces.</figcaption>
						</figure>
						
						<p>The third face&mdash;the high triangle of the ring&mdash;is calculated the same way as the bottom face, as both triangles are pointing down, but once again relative to different corners. It goes from the low left corner to the high corners.</p>
						
						<pre translate="no">			float3 columnBottomDir = strip.lowRightCorner - down();
			float3 columnBottomStart = down() + columnBottomDir * u / Resolution;
			float3 columnBottomEnd =
				strip.lowLeftCorner + columnBottomDir * u / Resolution;

			float3 columnLowDir = strip.highRightCorner - strip.lowLeftCorner;
			float3 columnLowStart =
				strip.lowRightCorner + columnLowDir * ((float)u / Resolution - 1f);
			float3 columnLowEnd = strip.lowLeftCorner + columnLowDir * u / Resolution;

			<ins>float3 columnHighDir = strip.highRightCorner - strip.lowLeftCorner;</ins>
			<ins>float3 columnHighStart = strip.lowLeftCorner + columnHighDir * u / Resolution;</ins>
			<ins>float3 columnHighEnd = strip.highLeftCorner + columnHighDir * u / Resolution;</ins></pre>
						
						<p>Add the interpolation for it to the loop as well, with `v/r_u-1` as the interpolator, completing the icosahedron.</p>
						
						<pre translate="no">				else if (v &lt;= ResolutionV - u) {
					vertex.position =
						<ins>lerp(columnHighStart, columnHighEnd, (float)v / Resolution - 1f);</ins>
				}</pre>
						
						<figure>
							<img src="from-octasphere-to-icosphere/entire-icosahedron.png" width="300" height="300" alt="back">
							<figcaption>Entire icosahedron.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Sphere</h3>
						
						<p>To produce the icosphere we have to reintroduce normalization of the vertex position vectors.</p>
						
						<pre translate="no">			vertex.position = <ins>normalize(</ins>columnBottomStart<ins>)</ins>;
			streams.SetVertex(vi, vertex);
			vi += 1;

			for (int v = 1; v &lt; ResolutionV; v++, vi++, ti += 2) {
				&hellip;
				<ins>vertex.position = normalize(vertex.position);</ins>
				streams.SetVertex(vi, vertex);
				&hellip;
			}</pre>
						
						<figure>
							<img src="from-octasphere-to-icosphere/icosphere.png" width="300" height="300">
							<figcaption>Icosphere.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Geodesic Icosphere</h2>
					
					<p>Just like with the octasphere, the vertices of the icosphere bunch up near the corners of the underlying shape. Because the icosahedron has more corners than the octahedron&mdash;twelve instead of eight&mdash;and at each corner five face meet instead of four, the bunching up is less severe, but it still happens. We can again use geodesic lines to alleviate this phenomenon.</p>
					
					<section>
						<h3>Alternative Icosphere</h3>
						
						<p>Duplicate <code>Icosphere</code> and rename it to <code>GeoIcosphere</code>.
						
						<pre translate="no">	public struct <ins>GeoIcosphere</ins> : IMeshGenerator { &hellip; }</pre>
						
						<p>And add an option for it to <code>ProceduralMesh</code>.</p>
						
						<pre translate="no">	static MeshJobScheduleDelegate[] jobs = {
		&hellip;
		MeshJob&lt;Icosphere, PositionStream>.ScheduleParallel,
		<ins>MeshJob&lt;GeoIcosphere, PositionStream>.ScheduleParallel,</ins>
		&hellip;
	};

	public enum MeshType {
		SquareGrid€, SharedSquareGrid€, SharedTriangleGrid€,
		FlatHexagonGrid€, PointyHexagonGrid€, CubeSphere€, SharedCubeSphere€,
		Icosphere€, <ins>GeoIcosphere€,</ins> Octasphere€, GeoOctasphere€, UVSphere€
	};</pre>
					</section>
					
					<section>
						<h3>Edge Rotation Axes</h3>
						
						<p>The conversion from a normalization approach to a geodesic approach is the same as for the octasphere, except that the vertical icosahedron edges are not on the XY and YZ planes. So we need to also generate a rotation axis for each of those edges.</p>
						
						<p>Each triangle face has two edges, so we need an axis for each. However, the two middle faces of the strip&mdash;those forming the ring&mdash;share the same middle edge, so we only need seven different axes. Add fields for them to <code>Strip</code>.</p>
						
						<pre translate="no">		struct Strip {
			public int id;
			public float3 lowLeftCorner, lowRightCorner, highLeftCorner, highRightCorner;
			<ins>public float3</ins>
				<ins>bottomLeftAxis, bottomRightAxis,</ins>
				<ins>midLeftAxis, midCenterAxis, midRightAxis,</ins>
				<ins>topLeftAxis, topRightAxis;</ins>
		}</pre>
						
						<p>The bottom left axis can be found by taking the normalized cross product of the south pole and the low left corner position vectors. Likewise for the bottom right axis. Adjust <code>CreateStip</code> so it calculates these axes based on the previously-defined corners.</p>
						
						<pre translate="no">		static Strip CreateStrip (int id) <ins>{</ins>
			<ins>var s =</ins> new Strip {
				id = id,
				lowLeftCorner = GetCorner(2 * id, -1),
				lowRightCorner = GetCorner(id == 4 ? 0 : 2 * id + 2, -1),
				highLeftCorner = GetCorner(id == 0 ? 9 : 2 * id - 1, 1),
				highRightCorner = GetCorner(2 * id + 1, 1)
			};
			<ins>s.bottomLeftAxis = normalize(cross(down(), s.lowLeftCorner));</ins>
			<ins>s.bottomRightAxis = normalize(cross(down(), s.lowRightCorner));</ins>
			<ins>return s;</ins>
		<ins>}</ins></pre>
						
						<p>The top axes are found the same way, using the appropriate high corner and the north pole.</p>
						
						<pre translate="no">			s.bottomLeftAxis = normalize(cross(down(), s.lowLeftCorner));
			s.bottomRightAxis = normalize(cross(down(), s.lowRightCorner));
			<ins>s.topLeftAxis = normalize(cross(s.highLeftCorner, up()));</ins>
			<ins>s.topRightAxis = normalize(cross(s.highRightCorner, up()));</ins></pre>
						
						<p>And the middle axes fit in between, stiching them together.</p>
						
						<pre translate="no">			s.bottomLeftAxis = normalize(cross(down(), s.lowLeftCorner));
			s.bottomRightAxis = normalize(cross(down(), s.lowRightCorner));
			<ins>s.midLeftAxis = normalize(cross(s.lowLeftCorner, s.highLeftCorner));</ins>
			<ins>s.midCenterAxis = normalize(cross(s.lowLeftCorner, s.highRightCorner));</ins>
			<ins>s.midRightAxis = normalize(cross(s.lowRightCorner, s.highRightCorner));</ins>
			s.topLeftAxis = normalize(cross(s.highLeftCorner, up()));
			s.topRightAxis = normalize(cross(s.highRightCorner, up()));</pre>
					</section>
					
					<section>
						<h3>Geodesic Column Start</h3>
						
						<p>We begin by adjusting the first position of each column. We need to use <code>quaternion</code> for that, which we again have to explicitly use to avoid a type name clash.</p>
						
						<pre translate="no"><ins>using quaternion = Unity.Mathematics.quaternion;</ins></pre>
						
						<p>To know by how much to rotate we need to know the angle between icosahedron corners that share an edge. This angle is always the same, so we'll introduce a private <code>EdgeRotationAngle</code> property for it. We can use any two corners with the correct relationship to calculate it.</p>
						
						<pre translate="no">		<ins>static float EdgeRotationAngle => acos(dot(up(), GetCorner(0, 1)));</ins></pre>
						
						<p>Now we can put the first position of each column in <code>Execute</code> on a geodesic line, by rotating the south pole around the bottom right axis and scaling the rotation angle by `u/r_u`.</p>
						
						<pre translate="no">			vertex.position = <ins>mul(</ins>
				<ins>quaternion.AxisAngle(</ins>
					<ins>strip.bottomRightAxis, EdgeRotationAngle * u / Resolution</ins>
				<ins>),</ins>
				<ins>down()</ins>
			<ins>)</ins>;
			streams.SetVertex(vi, vertex);
			vi += 1;</pre>
						
						<p>At this point there isn't much of a visual difference yet.</p>
					</section>
					
					<section>
						<h3>Geodesic Edges</h3>
						
						<p>The next step is to use the edge rotation axes to find the appropriate points on the vertical edges that will be used to calculate the final rotation across the face. For this we again need to calculate `h=u+v` inside the loop. We also need to determine which two axes and start positions to use for the left and right side, so add variables for those.</p>
						
						<pre translate="no">			for (int v = 1; v &lt; ResolutionV; v++, vi++, ti += 2) {
				<ins>float h = u + v;</ins>
				<ins>float3 leftAxis, rightAxis, leftStart, rightStart;</ins>
				&hellip;
			}</pre>
						
						<p>We replace the code that does the linear interpolation with new code that sets those axes and positions. The first face uses the bottom left and right axes and the start position is the south pole for both sides.</p>
						
						<pre translate="no">				if (v &lt;= Resolution - u) {
					<ins>leftAxis = strip.bottomLeftAxis;</ins>
					<ins>rightAxis = strip.bottomRightAxis;</ins>
					<ins>leftStart = rightStart = down();</ins>
				}</pre>
						
						<p>The second face uses the mid center and mid right axes for the left and right edges, and the low left and low right corners as starting positions.</p>
						
						<pre translate="no">				else if (v &lt; Resolution) {
					<ins>leftAxis = strip.midCenterAxis;</ins>
					<ins>rightAxis = strip.midRightAxis;</ins>
					<ins>leftStart = strip.lowLeftCorner;</ins>
					<ins>rightStart = strip.lowRightCorner;</ins>
				}</pre>
						
						<p>The third face uses the mid left and mid center axes, along with the low left corner.</p>
						
						<pre translate="no">				else if (v &lt;= ResolutionV - u) {
					<ins>leftAxis = strip.midLeftAxis;</ins>
					<ins>rightAxis = strip.midCenterAxis;</ins>
					<ins>leftStart = rightStart = strip.lowLeftCorner;</ins>
				}</pre>
						
						<p>The fourth face uses the top axes and high corners.</p>
						
						<pre translate="no">				else {
					<ins>leftAxis = strip.topLeftAxis;</ins>
					<ins>rightAxis = strip.topRightAxis;</ins>
					<ins>leftStart = strip.highLeftCorner;</ins>
					<ins>rightStart = strip.highRightCorner;</ins>
				}</pre>
						
						<p>We also need to know by how much to scale the edge angle. This factor is `h/r_u` for the first face, `h/r_u-1` for the middle two faces, and `h/r_u-2` for the fourth face.</p>
						
						<pre translate="no">				<ins>float edgeAngleScale;</ins>
				if (v &lt;= Resolution - u) {
					&hellip;
					<ins>edgeAngleScale = h / Resolution;</ins>
				}
				else if (v &lt; Resolution) {
					&hellip;
					<ins>edgeAngleScale = h / Resolution - 1f;</ins>
				}
				else if (v &lt;= ResolutionV - u) {
					&hellip;
					<ins>edgeAngleScale = h / Resolution - 1f;</ins>
				}
				else {
					&hellip;
					<ins>edgeAngleScale = h / Resolution - 2f;</ins>
				}</pre>
						
						<p>After we have determined these values we can perform the rotations to create <code>pLeft</code> and <code>pRight</code> and then use those to find the final position like we did for the geodesic octasphere. But let's initially leave the final rotation angle unscaled so we end up with only the vertical geodesic edge lines.</p>
						
						<pre translate="no">				<ins>float3 pLeft = mul(</ins>
					<ins>quaternion.AxisAngle(leftAxis, EdgeRotationAngle * edgeAngleScale),</ins>
					<ins>leftStart</ins>
				<ins>);</ins>
				<ins>float3 pRight = mul(</ins>
					<ins>quaternion.AxisAngle(rightAxis, EdgeRotationAngle * edgeAngleScale),</ins>
					<ins>rightStart</ins>
				<ins>);</ins>
				<ins>float3 axis = normalize(cross(pRight, pLeft));</ins>
				<ins>float angle = acos(dot(pRight, pLeft));</ins>
				vertex.position = <ins>mul(</ins>
					<ins>quaternion.AxisAngle(axis, angle), pRight</ins>
				<ins>)</ins>;</pre>
						
						<figure>
							<img src="geodesic-icosphere/south-north-edges.png" width="300" height="300">
							<figcaption>Geodesic edges from south pole to north pole.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>All Geodesic Lines</h3>
						
						<p>In the case of the geodesic octasphere the scale of the final rotation angle is `v/h` for the first face and `(r-u)/(2r-h)` for the second face of the rhombus. To make it work for the four faces of the icosahedron strip we need to use `v/h` for the first face, `(r_u-u)/(r_v-h)` for the second, `(v-r_u)/(h-r_u)` for the third, and `(r_u-u)/(3r_u-h)` for the fourth. Use that to scale the final rotation angle.</p>
						
						<pre translate="no">				float edgeAngleScale<ins>, faceAngleScale</ins>;
				if (v &lt;= Resolution - u) {
					&hellip;
					<ins>faceAngleScale = v / h;</ins>
				}
				else if (v &lt; Resolution) {
					&hellip;
					<ins>faceAngleScale = (Resolution - u) / (ResolutionV - h);</ins>
				}
				else if (v &lt;= ResolutionV - u) {
					&hellip;
					<ins>faceAngleScale = (v - Resolution) / (h - Resolution);</ins>
				}
				else {
					&hellip;
					<ins>faceAngleScale = (Resolution - u) / (3f * Resolution - h);</ins>
				}

				&hellip;
				float angle = acos(dot(pRight, pLeft)) <ins>* faceAngleScale</ins>;</pre>
						
						<figure>
							<img src="geodesic-icosphere/geodesic-icosphere.png" width="300" height="300">
							<figcaption>Geodesic icosphere.</figcaption>
						</figure>
						
						<p>With our geodesic icosphere finished we can remove all old code that calculate the values used for the linear interpolation.</p>
						
						<pre translate="no">			<del>//float3 columnBottomDir = strip.lowRightCorner - down();</del>
			<del>//&hellip;</del>
			<del>//float3 columnTopEnd = strip.highLeftCorner + columnTopDir * u / Resolution;</del></pre>
					</section>
					
					<section>
						<h3>Comparison</h3>
						
						<p>When comparing both approaches it becomes clear that the geodesic variant indeed gets rid of some bunching up near the poles, although the difference isn't as stark as for the octasphere. So the geodesic icosphere can be considered better in that regard, but just like for the octasphere its vertex distribution is less symmetrical than the normalized variant.</p>
						
						<figure>
							<img src="geodesic-icosphere/geodesic-top.png" width="300" height="300" alt="geodesic top">
							<img src="geodesic-icosphere/normalized-top.png" width="300" height="300" alt="normalized top">
							<img src="geodesic-icosphere/geodesic-back.png" width="300" height="300" alt="geodesic back">
							<img src="geodesic-icosphere/normalized-back.png" width="300" height="300" alt="normalized back">
							<img src="geodesic-icosphere/geodesic-right.png" width="300" height="300" alt="geodesic right">
							<img src="geodesic-icosphere/normalized-right.png" width="300" height="300" alt="normalized right">
							<figcaption>Geodesic vs. normalized; top, back, and right views; solid black; resolution 12.</figcaption>
						</figure>
						
						<p>Want to know when the next tutorial gets released? Keep tabs on my <a href="https://www.patreon.com/catlikecoding">Patreon</a> page!</p>
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/procedural-meshes-10-icosphere/" class="repository">repository</a>
					<a href="Icosphere.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>7" height="51"></a></p>
			<p><b><a href="https://catlikecoding.com/unity/tutorials/donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="https://catlikecoding.com/jasper-flick/" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>