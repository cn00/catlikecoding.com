<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/procedural-meshes/octasphere/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/procedural-meshes/octasphere/tutorial-image.jpg">
		<meta property="og:title" content="Octasphere">
		<meta property="og:description" content="A Unity C# Procedural Meshes tutorial about creating an octasphere.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Octasphere</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/procedural-meshes/octasphere/#article",
				"headline": "Octasphere",
				"alternativeHeadline": "Superior Lat/Lon Sphere",
				"datePublished": "2022-04-30",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity C# Procedural Meshes tutorial about creating an octasphere.",
				"image": "https://catlikecoding.com/unity/tutorials/procedural-meshes/octasphere/tutorial-image.jpg",
				"dependencies": "Unity 2020.3.23f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/procedural-meshes/", "name": "Procedural Meshes" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				CubeSphere: 1,
				FlatHexagonGrid: 1,
				IMeshGenerator: 1,
				IMeshStreams: 1,
				G: 1,
				GizmoMode: 1,
				MaterialMode: 1,
				MeshJob: 1,
				MeshJobScheduleDelegate: 1,
				MeshOptimizationMode: 1,
				MeshType: 1,
				MultiStream: 1,
				Octasphere: 1,
				PointyHexagonGrid: 1,
				PositionStream: 1,
				ProceduralMesh: 1,
				Rhombus: 1,
				S: 1,
				SharedCubeSphere: 1,
				SharedSquareGrid: 1,
				SharedTriangleGrid: 1,
				Side: 1,
				SingleStream: 1,
				SquareGrid: 1,
				Stream0: 1,
				TriangleUInt16: 1,
				UVSphere: 1,
				Vertex: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Procedural Meshes</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Octasphere</h1>
					<p>Superior Lat/Lon Sphere</p>
					<ul>
						<li>Combine cube sphere and UV sphere algorithms.</li>
						<li>Fold rhombuses to create an octahedron.</li>
						<li>Derive texture coordinates from vertex position.</li>
					</ul>
				</header>
				
				<p>This is the eighth tutorial in a series about <a href="../index.html">procedural meshes</a>. This time we create an octahedron sphere as an alternative to the UV sphere.</p>
				
				<p>This tutorial is made with Unity 2020.3.23f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>An octasphere with a lat/lon texture applied to it.</figcaption>
				</figure>
				
				<section>
					<h2>Octahedron</h2>
					
					<p>The cube sphere has much better vertex distribution than a UV sphere, but it is not a good candidate when you want to apply a lat/lon texture to a sphere. An alternative is to use what's commonly known as an octasphere, which is a sphere based on an octahedron. We can be sure that this will work because a resolution 1 UV sphere is an octahedron.</p>
					
					<section>
						<h3>Hybrid Approach</h3>
						
						<p>One way to construct an octasphere is to use an approach that is a hybrid of the cube sphere and the UV sphere: create four folded rhombus grids similar to the sides of a cube sphere, positioned and anchored to the poles like the columns of a UV sphere.</p>
						
						<figure>
							<img src="octahedron/layout-octahedron.png" width="285" height="285">
							<figcaption>Octahedron layout.</figcaption>
						</figure>
						
						<p>We'll use <code>SharedCubeSphere</code> as the basis of the new approach. Duplicate its asset file and rename it to <code>Octasphere</code>.</p>
						
						<pre translate="no">	public struct <ins>Octasphere</ins> : IMeshGenerator { &hellip; }</pre>
						
						<p>Also add an option for it to <code>ProceduralMesh</code>.</p>
						
						<pre translate="no">	static MeshJobScheduleDelegate[] jobs = {
		&hellip;
		MeshJob&lt;SharedCubeSphere, PositionStream>.ScheduleParallel,
		<ins>MeshJob&lt;Octasphere, SingleStream>.ScheduleParallel,</ins>
		MeshJob&lt;UVSphere, SingleStream>.ScheduleParallel
	};

	public enum MeshType {
		SquareGrid€, SharedSquareGrid€, SharedTriangleGrid€,
		FlatHexagonGrid€, PointyHexagonGrid€, CubeSphere€, SharedCubeSphere€,
		<ins>Octasphere€,</ins> UVSphere€
	};</pre>
					</section>
					
					<section>
						<h3>Four Sides</h3>
						
						<p>Instead of having six square sides an octahedron has eight equilateral triangle sides. We'll generate these in pairs, by creating four folded rhombuses. Let's rename the <code>Side</code> struct, method, and variable to make this clear. Note that I don't show the replacement of all variable references in <code>Execute</code>.</p>
						
						<pre translate="no">		struct <ins>Rhombus</ins> {
			public int id;
			&hellip;
		}
		
		public void Execute&lt;S> (int i, S streams) where S : struct, IMeshStreams {
			int u = i / 6;
			<ins>Rhombus</ins> <ins>rhombus</ins> = <ins>GetRhombus</ins>(i - 6 * u);
			<ins>&hellip;</ins>
		}
		
		static Rhombus <ins>GetRhombus</ins> (int id) => id switch { &hellip; };</pre>
						
						<p>As we go from six down to four sides the vertex count reduces accordingly. So that's `4r^2` instead of `6r^2` vertices for the rhombuses, where `r` is the resolution. However, as we'll support lat/lon maps we also need a seam like the UV sphere has, which requires an additional `2r-1` vertices. Finally, the cube sphere has two polar vertices, but because of the lat/lon map these cannot be shared, so we need eight vertices for the poles, two per rhombus. Thus the final vertex count is `4r^2+2r+7`.</p>
						
						<pre translate="no">		public int VertexCount => <ins>4</ins> * Resolution * Resolution + 2 <ins>* Resolution + 7</ins>;</pre>
						
						<p>The index count reduces from six to four sides.</p>
						
						<pre translate="no">		public int IndexCount => 6 * <ins>4</ins> * Resolution * Resolution;</pre>
						
						<p>The job length is reduced likewise, but we also add one special case for the seam, like we did for the UV sphere.</p>
						
						<pre translate="no">		public int JobLength => <ins>4</ins> * Resolution <ins>+ 1</ins>;</pre>
						
						<p>Next, update the U coordinate, rhombus identifier, and vertex index at the start of <code>Execute</code> to match the new vertex count and job length. The polar and seam vertices come first, so we have to skip those.</p>
						
						<pre translate="no">			int u = i / <ins>4</ins>;
			Rhombus rhombus = GetRhombus(i - <ins>4</ins> * u);
			int vi = Resolution * (Resolution * rhombus.id + u <ins>+ 2</ins>) + <ins>7</ins>;</pre>
						
						<p>Finally, remove all the vertex and triangle calculations specific to the cube, while keeping the code that fills the streams. This will produce a degenerate mesh. Because the polar vertices aren't shared we don't need to split the quad that we add outside the loop, so we'll set both its triangles at the end.</p>
						
						<pre translate="no">		public void Execute&lt;S> (int i, S streams) where S : struct, IMeshStreams {
			int u = i / 4;
			Rhombus rhombus = GetRhombus(i - 4 * u);
			int vi = Resolution * (Resolution * rhombus.id + u + 2) + 7;
			int ti = 2 * Resolution * (Resolution * rhombus.id + u);
			bool firstColumn = u == 0;
			u += 1;

			<del>//float3 pStart = rhombus.uvOrigin + rhombus.uVector * u / Resolution;</del>
			
			var vertex = new Vertex();
			<del>//&hellip;</del>
			streams.SetVertex(vi, vertex);
			<del>//&hellip;</del>
			vi += 1;
			<del>//ti += 1;</del>

			<del>//&hellip;</del>

			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				<del>//vertex.position = CubeToSphere(pStart + side.vVector * v / Resolution);</del>
				streams.SetVertex(vi, vertex);
				
				<del>//&hellip;</del>
				streams.SetTriangle(ti + 0, <ins>0</ins>);
				streams.SetTriangle(ti + 1, <ins>0</ins>);
			}

			streams.SetTriangle(ti <ins>+ 0</ins>, 0);
			<ins>streams.SetTriangle(ti + 1, 0);</ins>
		}
		
		<del>//static float3 CubeToSphere (float3 p) => &hellip;;</del></pre>
					</section>
					
					<section>
						<h3>Poles and Seam</h3>
						
						<p>We'll first take care of the vertices for the poles and the seam. We reuse the approach of the UV sphere, introducing a dedicated method for job index zero, this time naming it <code>ExecutePolesAndSeams</code>. To keep the logic for <code>ExecuteRegular</code> the same, subtract one from the job index before passing it to the method.</p>
						
						<pre translate="no">		<ins>public void Execute&lt;S> (int i, S streams) where S : struct, IMeshStreams {</ins>
			<ins>if (i == 0) {</ins>
				<ins>ExecutePolesAndSeam(streams);</ins>
			<ins>}</ins>
			<ins>else {</ins>
				<ins>ExecuteRegular(i - 1, streams);</ins>
			<ins>}</ins>
		<ins>}</ins>

		public void <ins>ExecuteRegular</ins>&lt;S> (int i, S streams) where S : struct, IMeshStreams {
			int u = i / 4;
			&hellip;
		}

		<ins>public void ExecutePolesAndSeam&lt;S> (S streams) where S : struct, IMeshStreams {}</ins></pre>
						
						<p>The polar vertices for the UV sphere were special, because we have to set their tangent and texture coordinates halfway between their adjacent vertex columns to keep the texture correct. We have to do the same thing here as well, exactly like for a resolution 1 UV sphere. Begin by configuring the tangent and texture X coordinate for the first rhombus, the one going from the back corner to the right corner. Don't set the vertex yet.</p>
						
						<pre translate="no">		public void ExecutePolesAndSeam&lt;S> (S streams) where S : struct, IMeshStreams {
			<ins>var vertex = new Vertex();</ins>
			<ins>vertex.tangent = float4(sqrt(0.5f), 0f, sqrt(0.5f), -1f);</ins>
			<ins>vertex.texCoord0.x = 0.125f;</ins>
		}</pre>
						
						<p>Follow this with a loop over all four south pole vertices, setting the position, normal, and texture Y coordinate. Then set the vertex, rotate the tangent 90&deg; and increment the texture X coordinate by &frac14; for the next iteration. We'll assign them to the first four vertices.</p>
						
						<pre translate="no">			var vertex = new Vertex();
			vertex.tangent = float4(sqrt(0.5f), 0f, sqrt(0.5f), -1f);
			vertex.texCoord0.x = 0.125f;

			<ins>for (int i = 0; i &lt; 4; i++) {</ins>
				<ins>vertex.position = vertex.normal = down();</ins>
				<ins>vertex.texCoord0.y = 0f;</ins>
				<ins>streams.SetVertex(i, vertex);</ins>
				<ins>vertex.tangent.xz = float2(-vertex.tangent.z, vertex.tangent.x);</ins>
				<ins>vertex.texCoord0.x += 0.25f;</ins>
			<ins>}</ins></pre>
						
						<p>The north pole vertices are the same, but at the top of the sphere. We can set them in the same loop, using the next four vertices.</p>
						
						<pre translate="no">			for (int i = 0; i < 4; i++) {
				vertex.position = vertex.normal = down();
				vertex.texCoord0.y = 0f;
				streams.SetVertex(i, vertex);
				<ins>vertex.position = vertex.normal = up();</ins>
				<ins>vertex.texCoord0.y = 1f;</ins>
				<ins>streams.SetVertex(i + 4, vertex);</ins>
				vertex.tangent.xz = float2(-vertex.tangent.z, vertex.tangent.x);
				vertex.texCoord0.x += 0.25f;
			}</pre>
						
						<p>After that come the vertices of the seam. Begin by creating a line from the south pole to the back corner of the octahedron, via linear interpolation.</p>
						
						<pre translate="no">			for (int i = 0; i &lt; 4; i++) { &hellip; }

			<ins>vertex.tangent.xz = float2(1f, 0f);</ins>
			<ins>vertex.texCoord0.x = 0f;</ins>

			<ins>for (int v = 1; v &lt; 2 * Resolution; v++) {</ins>
				<ins>vertex.position = lerp(down(), back(), (float)v / (2 * Resolution));</ins>
				<ins>vertex.normal = normalize(vertex.position);</ins>
				<ins>streams.SetVertex(v + 7, vertex);</ins>
			<ins>}</ins></pre>
						
						<figure>
							<img src="octahedron/partial-seam.png" width="110" height="200">
							<figcaption>Partial seam; resolution 6.</figcaption>
						</figure>
						
						<p>This puts all seam vertices on the bottom half of the octahedron. To make them go all the way to the top we can double the interpolator, so it extrapolates past the end point.</p>
						
						<pre translate="no">				vertex.position = lerp(down(), back(), (float)v / <ins>Resolution</ins>);</pre>
						
						<figure>
							<img src="octahedron/open-seam.png" width="230" height="200">
							<figcaption>Open seam.</figcaption>
						</figure>
						
						<p>This gives us a seams as if our octahedron were pulled open at the top. To close it we have to switch to a different interpolation for the second half of the loop, going from the back corner to the north pole, and also resetting the interpolator.</p>
						
						
						<pre translate="no">				<ins>if (v < Resolution) {</ins>
					vertex.position = lerp(down(), back(), (float)v / Resolution);
				<ins>}</ins>
				<ins>else {</ins>
					<ins>vertex.position =</ins>
						<ins>lerp(back(), up(), (float)(v - Resolution) / Resolution);</ins>
				<ins>}</ins></pre>
						
						<figure>
							<img src="octahedron/closed-seam.png" width="110" height="200">
							<figcaption>Closed seam.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Rhombuses</h3>
						
						<p>Moving on to the four rhombuses, we need to know their orientation. We can define this by adding positions for their middle left and right corners to <code>Rhombus</code>. We don't need anything else besides the identifier, so remove all those fields.</p>
						
						<pre translate="no">		struct Rhombus {
			public int id;
			<ins>public float3 leftCorner, rightCorner;</ins>

			<del>//public float3 uvOrigin, uVector, vVector;</del>
			<del>//public int seamStep;</del>

			<del>//public bool TouchesMinimumPole => (id & 1) == 0;</del>
		}</pre>
						
						<p>Going counterclockwise around the sphere, the four corner pairs are back-right, right-forward, forward-left, and left-back. Adjust <code>GetRhombus</code> accordingly.</p>
						
						<pre translate="no">		static Rhombus GetRhombus (int id) => id switch {
			0 => new Rhombus {
				id = id,
				<ins>leftCorner = back(),</ins>
				<ins>rightCorner = right()</ins>
			},
			1 => new Rhombus {
				id = id,
				<ins>leftCorner = right(),</ins>
				<ins>rightCorner = forward()</ins>
			},
			2 => new Rhombus {
				id = id,
				<ins>leftCorner = forward(),</ins>
				<ins>rightCorner = left()</ins>
			},
			<del>//3 => new Rhombus {  },</del>
			<del>//4 => new Rhombus {  },</del>
			_ => new Rhombus {
				id = id,
				<ins>leftCorner = left(),</ins>
				<ins>rightCorner = back()</ins>
			}
		};</pre>
						
						<p>Now we can set the position of the first vertex inside <code>ExecuteRegular</code>, which defines the bottom vertex of each column. We set this position by interpolating from the south pole to the right corner based on U. We'll focus on the positions only for now, leaving the other vertex attributes for later.</p>
						
						<pre translate="no">			var vertex = new Vertex();
			<ins>vertex.position = lerp(down(), rhombus.rightCorner, (float)u / Resolution);</ins>
			streams.SetVertex(vi, vertex);</pre>
						
						<figure>
							<img src="octahedron/bottom-rows.png" width="190" height="200">
							<figcaption>Bottom rows.</figcaption>
						</figure>
						
						<p>To create a complete rhombus we also need to interpolate based on V inside the loop. Let's first build a flat rhombus. We can do this by also determining the end of the column before the loop begins. In the case of a flat rhombus the column end has to interpolate in the same direction as the column start, so let's replace the usage of <code>lerp</code> with the application of a column direction vector.</p>
						
						<pre translate="no">			<ins>float3 columnDir = rhombus.rightCorner - down();</ins>

			var vertex = new Vertex();
			vertex.position = <ins>down() + columnDir * u / Resolution</ins>;</pre>
						
						<p>Now we can determine both start and end by adding to the appropriate positions and store them in variables. To find the column end we have to begin at the left corner instead of at the south pole.</p>
						
						<pre translate="no">			float3 columnDir = rhombus.rightCorner - down();
			<ins>float3 columnStart = down() + columnDir * u / Resolution;</ins>
			<ins>float3 columnEnd = rhombus.leftCorner + columnDir * u / Resolution;</ins>

			var vertex = new Vertex();
			vertex.position = <ins>columnStart</ins>;</pre>
						
						<p>This makes it possible to interpolate through the column inside the loop.</p>
						
						<pre translate="no">			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				<ins>vertex.position = lerp(columnStart, columnEnd, (float)v / Resolution);</ins>
				streams.SetVertex(vi, vertex);
				streams.SetTriangle(ti + 0, 0);
				streams.SetTriangle(ti + 1, 0);
			}</pre>
						
						<figure>
							<img src="octahedron/open-octahedron.png" width="280" height="200">
							<figcaption>Four rhombuses form an open octahedron.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Closing the Octahedron</h3>
						
						<p>At this point we have an open octahedron. We can close it like we closed the seam. First, let's make explicit that what we currently have works for the bottom half of the rhombus, by renaming our variables.</p>
						
						<pre translate="no">			float3 <ins>columnBottomDir</ins> = rhombus.rightCorner - down();
			float3 <ins>columnBottomStart</ins> = down() + columnBottomDir * u / Resolution;
			float3 <ins>columnBottomEnd</ins> =
				rhombus.leftCorner + <ins>columnBottomDir</ins> * u / Resolution;

			var vertex = new Vertex();
			vertex.position = <ins>columnBottomStart</ins>;
			streams.SetVertex(vi, vertex);
			vi += 1;

			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				vertex.position =
					lerp(<ins>columnBottomStart</ins>, <ins>columnBottomEnd</ins>, (float)v / Resolution);
				&hellip;
			}</pre>
						
						<p>Then introduce alternatives for the top half of the rhombus, based on going from the left corner to the north pole instead of from the south pole to the right corner. In this case the starting points are the right corner and the left corner.</p>
						
						<pre translate="no">			float3 columnBottomDir = rhombus.rightCorner - down();
			float3 columnBottomStart = down() + columnBottomDir * u / Resolution;
			float3 columnBottomEnd =
				rhombus.leftCorner + columnBottomDir * u / Resolution;

			<ins>float3 columnTopDir = up() - rhombus.leftCorner;</ins>
			<ins>float3 columnTopStart = rhombus.rightCorner + columnTopDir * u / Resolution;</ins>
			<ins>float3 columnTopEnd = rhombus.leftCorner + columnTopDir * u / Resolution;</ins></pre>
						
						<p>Adjust the loop so it generated the top portion.</p>
						
						<pre translate="no">				vertex.position =
					lerp(<ins>columnTopStart</ins>, <ins>columnTopEnd</ins>, (float)v / Resolution);</pre>
						
						<figure>
							<img src="octahedron/closed-top-incorrect.png" width="260" height="210">
							<figcaption>Closed top, incorrect.</figcaption>
						</figure>
						
						<p>This should give us a closed top and open bottom, but it went wrong. That happened because our top start should begin outside of the octahedron, because we're going in the opposite direction compared to the bottom scenario. We can achieve that via extrapolation, by subtracting 1 from the factor by which we multiply the direction vector for the top.</p>
						
						<pre translate="no">			float3 columnTopStart =
				rhombus.rightCorner + columnTopDir * <ins>((float)</ins>u / Resolution <ins>- 1f)</ins>;</pre>
						
						<figure>
							<img src="octahedron/closed-top-correct.png" width="220" height="230">
							<figcaption>Closed top, correct.</figcaption>
						</figure>
						
						<p>With both sides correct all that's left is to pick the correct one for each iteration. In this case the halfway point is reached when V equals the resolution minus U.</p>
						
						<pre translate="no">				<ins>if (v <= Resolution - u) {</ins>
					<ins>vertex.position =</ins>
						<ins>lerp(columnBottomStart, columnBottomEnd, (float)v / Resolution);</ins>
				<ins>}</ins>
				<ins>else {</ins>
					vertex.position =
						lerp(columnTopStart, columnTopEnd, (float)v / Resolution);
				<ins>}</ins></pre>
						
						<figure>
							<img src="octahedron/closed-octahedron.png" width="220" height="230">
							<figcaption>Closed octahedron.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Triangles</h2>
					
					<p>With all the vertices of the octahedron in place we can generate its triangles. The complexity of this work lies somewhere in between the cube sphere and the UV sphere.</p>
					
					<section>
						<h3>Rhombus Quads</h3>
						
						<p>Although an octasphere is made with triangles and not squares, we can also say that it's made with folded rhombuses, as long as we orient their triangles correctly.</p>
						
						<figure>
							<img src="triangles/rhombus-quads.png" width="315" height="535">
							<figcaption>Rhombus quads.</figcaption>
						</figure>
						
						<p> So we can create quads again and this time we'll use an <code>int4</code> variable to hold all four indices at once. We'll use the following vertex order: right, bottom, left, top. The first triangle of each quad uses the XYZ components and the second triangle uses the XZW components. Adjust <code>ExecuteRegular</code> to use this approach, initially generating degenerate triangles with all indices set to zero.</p>
						
						<figure>
							<img src="triangles/quad-layout.png" width="105" height="160">
							<figcaption>Quad layout.</figcaption>
						</figure>
						
						<pre translate="no">			<ins>int4 quad = 0;</ins>
			
			u += 1;
			
			&hellip;

			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				&hellip;
				streams.SetTriangle(ti + 0, <ins>quad.xyz</ins>);
				streams.SetTriangle(ti + 1, <ins>quad.xzw</ins>);
			}
			
			streams.SetTriangle(ti + 0, <ins>quad.xyz</ins>);
			streams.SetTriangle(ti + 1, <ins>quad.xzw</ins>);</pre>
					</section>
					
					<section>
						<h3>Seam Column</h3>
						
						<p>We begin with the first quad of the first column of the first rhombus, the one touching the south pole. Its first vertex X is the current one. Its second vertex Y is the first south pole vertex, which is the first of the mesh. Its third vertex Z is the first seam vertex after the poles, so index 8. The final vertex W is the one after X. Set these if we're in the first column of the first rhombus, keeping all other quads degenerate for now.</p>
						
						<pre translate="no">			int4 quad = 0;
			<ins>if (firstColumn &amp;&amp; rhombus.id == 0) {</ins>
				<ins>quad.x = vi;</ins>
				<ins>quad.y = 0;</ins>
				<ins>quad.z = 8;</ins>
				<ins>quad.w = vi + 1;</ins>
			<ins>}</ins></pre>
						
						<figure>
							<img src="triangles/first-quad.png" width="250" height="180">
							<figcaption>First quad; <em translate="no">Cube Map</em> material.</figcaption>
						</figure>
						
						<p>This column runs along the bottom part of the seam, so we can simply increment all the quad's indices inside the loop, except for Y, which has to become equal to Z first.</p>
						
						<pre translate="no">			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				&hellip;
				streams.SetTriangle(ti + 0, quad.xyz);
				streams.SetTriangle(ti + 1, quad.xzw);

				<ins>quad.y = quad.z;</ins>
				<ins>quad += int4(1, 0, 1, 1);</ins>
			}</pre>
						
						<figure>
							<img src="triangles/seam-column-incomplete.png" width="250" height="180">
							<figcaption>Seam column, without last triangle.</figcaption>
						</figure>
						
						<p>The only thing that's missing is the top part of the last rhombus, because it lies inside the top half of the rhombus. We can set its W correctly by making it equal to Z plus 1 after the loop.</p>
						
						<pre translate="no">			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) { &hellip; }

			<ins>if (firstColumn &amp;&amp; rhombus.id == 0) {</ins>
				<ins>quad.w = quad.z + 1;</ins>
			<ins>}</ins>

			streams.SetTriangle(ti + 0, quad.xyz);
			streams.SetTriangle(ti + 1, quad.xzw);</pre>
						
						<figure>
							<img src="triangles/seam-column-complete.png" width="250" height="200">
							<figcaption>Seam column, complete.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>First Rhombus</h3>
						
						<p>Next, always initialize the quad if we're working on the first rhombus. If we're not in the first column then Y should be one column below X and Z is simply one step after that.</p>
						
						<pre translate="no">			int4 quad = 0;
			if (<ins>rhombus.id == 0</ins>) {
				quad.x = vi;
				quad.y = <ins>firstColumn ?</ins> 0 <ins>: vi - Resolution</ins>;
				quad.z = <ins>firstColumn ?</ins> 8 <ins>: vi - Resolution + 1</ins>;
				quad.w = vi + 1;
			}</pre>
						
						<figure>
							<img src="triangles/first-rhombus-missing-last-row.png" width="250" height="240">
							<figcaption>First rhombus, missing the last row.</figcaption>
						</figure>
						
						<p>This works for everything except the last row, which touches the top half of the seam. To fix this always adjust W for the first rhombus and set Z to the correct seam vertex, which is the resolution plus U plus 6.</p>
						
						<pre translate="no">			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) { &hellip; }

			if (<ins>rhombus.id == 0</ins>) {
				<ins>quad.z = Resolution + u + 6;</ins>
				quad.w = quad.z + 1;
			}</pre>
						
						<figure>
							<img src="triangles/first-rhombus-missing-top.png" width="250" height="240">
							<figcaption>First rhombus, missing top triangle.</figcaption>
						</figure>
						
						<p>And to fix the top triangle set W to 4 for the last column, which is the first north pole vertex.</p>
						
						<pre translate="no">			if (rhombus.id == 0) {
				quad.z = Resolution + u + 6;
				quad.w = <ins>u &lt; Resolution ?</ins> quad.z + 1 <ins>: 4</ins>;
			}</pre>
						
						<figure>
							<img src="triangles/first-rhombus-complete.png" width="250" height="240">
							<figcaption>First rhombus, complete.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>All First Columns</h3>
						
						<p>Moving on to the other rhombuses, we again begin with their first columns. If we're not working on the first rhombus but are in the first column, then initialize the first quad. In this case X and W are the same as for the first rhombus, while Y is equal to the rhombus identifier. Z wraps to the previous rhombus and thus requires an offset of `-r^2+ru`.</p>
						
						<pre translate="no">			int4 quad = 0;
			if (rhombus.id == 0) {
				quad.x = vi;
				quad.y = firstColumn ? 0 : vi - Resolution;
				quad.z = firstColumn ? 8 : vi - Resolution + 1;
				quad.w = vi + 1;
			}
			<ins>else if (firstColumn) {</ins>
				<ins>quad.x = vi;</ins>
				<ins>quad.y = rhombus.id;</ins>
				<ins>quad.z = vi - Resolution * (Resolution + u);</ins>
				<ins>quad.w = vi + 1;</ins>
			<ins>}</ins></pre>
						
						<p>Also, when incrementing, if we're working on the first column that isn't of the first rhombus we have to add the resolution instead of 1 to Z, because we're moving along the edge of the previous rhombus.</p>
						
						<pre translate="no">				quad.y = quad.z;
				quad += int4(1, 0, <ins>firstColumn &amp;&amp; rhombus.id != 0 ? Resolution :</ins> 1, 1);</pre>
						
						<p>After the loop, we now also have to also add the rhombus offset to Z, while W is again equal to Z plus 1. Again, we only focus on the first columns of the other rhombuses for now.</p>
						
						<pre translate="no">			if (rhombus.id == 0) {
				quad.z = Resolution + u + 6;
				quad.w = u < Resolution ? quad.z + 1 : 4;
			}
			<ins>else if (firstColumn) {</ins>
				<ins>quad.z = Resolution + u + 6 + Resolution * Resolution * rhombus.id;</ins>
				<ins>quad.w = quad.z + 1;</ins>
			<ins>}</ins>
			<ins>else {</ins>
				<ins>quad = 0;</ins>
			<ins>}</ins></pre>
						
						<figure>
							<img src="triangles/first-columns.png" width="280" height="280">
							<figcaption>First columns of the 2<sup>nd</sup> and 3<sup>rd</sup> rhombuses.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Entire Octahedron</h3>
						
						<p>To fill all these rhombuses, again apply the initialization for them to all columns. The logic for all other columns is the same as for the first rhombus.</p>
						
						<pre translate="no">			int4 quad = 0;
			if (rhombus.id == 0) {
				quad.x = vi;
				quad.y = firstColumn ? 0 : vi - Resolution;
				quad.z = firstColumn ? 8 : vi - Resolution + 1;
				quad.w = vi + 1;
			}
			else <ins>{</ins> <del>//if (firstColumn) {</del>
				quad.x = vi;
				quad.y = <ins>firstColumn ?</ins> rhombus.id <ins>: vi - Resolution</ins>;
				quad.z = <ins>firstColumn ?</ins>
					vi - Resolution * (Resolution + u) <ins>: vi - Resolution + 1</ins>;
				quad.w = vi + 1;
			}</pre>
						
						<p>Likewise for the final quad, we just need to add the rhombus identifier to get the correct north pole vertex.</p>
						
						<pre translate="no">			if (rhombus.id == 0) {
				quad.z = Resolution + u + 6;
				quad.w = u < Resolution ? quad.z + 1 : 4;
			}
			else <ins>{</ins> <ins>//if (firstColumn) {</ins>
				quad.z = Resolution + u + 6 + Resolution * Resolution * rhombus.id;
				quad.w = <ins>u &lt; Resolution ?</ins> quad.z + 1 <ins>: rhombus.id + 4</ins>;
			}
			<del>//else {</del>
			<del>//	quad = 0;</del>
			<del>//}</del></pre>
						
						<figure>
							<img src="triangles/entire-octahedron.png" width="280" height="280">
							<figcaption>Entire octahedron.</figcaption>
						</figure>
						
						<p>Now that we have a complete octahedron let's consolidate the quad initialization code.</p>
						
						<pre translate="no">			int4 quad = <ins>int4(</ins>
				<ins>vi,</ins>
				<ins>firstColumn ? rhombus.id : vi - Resolution,</ins>
				<ins>firstColumn ?</ins>
					<ins>rhombus.id == 0 ? 8 : vi - Resolution * (Resolution + u) :</ins>
					<ins>vi - Resolution + 1,</ins>
				<ins>vi + 1</ins>
			<ins>);</ins>
			<del>//if (rhombus.id == 0) { &hellip; }</del>
			<del>//else { &hellip; }</del></pre>						
						
						<p>And also the adjustment for the final quad.</p>
						
						<pre translate="no">			<ins>quad.z = Resolution * Resolution * rhombus.id + Resolution + u + 6;</ins>
			<ins>quad.w = u < Resolution ? quad.z + 1 : rhombus.id + 4;</ins>
			<del>//if (rhombus.id == 0) { &hellip; }</del>
			<del>//else { &hellip; }</del></pre>
					</section>
				</section>
				
				<section>
					<h2>Sphere</h2>
					
					<p>With the octahedron complete what's left is to turn it into a sphere and make sure that all its vertex data is set correctly.</p>
					
					<section>
						<h3>Positions and Normals</h3>
						
						<p>The correct positions and normal vectors are both found by normalizing the octahedron position. This needs to be done inside the loop in <code>ExecutePolesAndSeam</code>.</p>
						
						<pre translate="no">				vertex.normal = <ins>vertex.position = normalize(</ins>vertex.position<ins>)</ins>;</pre>
						
						<p>And for the first vertex in <code>ExecuteRegular</code>.</p>
						
						<pre translate="no">			var vertex = new Vertex();
			<ins>vertex.normal =</ins> vertex.position = <ins>normalize(</ins>columnBottomStart<ins>)</ins>;</pre>
						
						<p>And also inside its column loop.</p>
						
						<pre translate="no">				if (v <= Resolution - u) { &hellip; }
				else { &hellip; }
				<ins>vertex.normal = vertex.position = normalize(vertex.position);</ins>
				streams.SetVertex(vi, vertex);</pre>
						
						<figure>
							<img src="sphere/octasphere.png" width="280" height="280">
							<figcaption>Octasphere.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Tangents</h3>
						
						<p>The seam already has tangent vectors. All XZ components of all other tangent vectors can be found by rotating the XZ position of the sphere vertex 90&deg; counterclockwise and normalizing it. Introduce a convenient method for that.</p>
						
						<pre translate="no">		<ins>static float2 GetTangentXZ (float3 p) => normalize(float2(-p.z, p.x));</ins></pre>
						
						<p>Use it inside <code>ExecuteRegular</code>, also initializing the tangent W component to &minus;1.</p>
						
						<pre translate="no">			var vertex = new Vertex();
			vertex.position = normalize(columnBottomStart);
			<ins>vertex.tangent.xz = GetTangentXZ(vertex.position);</ins>
			<ins>vertex.tangent.w = -1f;</ins>
			streams.SetVertex(vi, vertex);
			vi += 1;

			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				&hellip;
				vertex.position = normalize(vertex.position);
				<ins>vertex.tangent.xz = GetTangentXZ(vertex.position);</ins>
				streams.SetVertex(vi, vertex);
				&hellip;
			}</pre>
						<figure>
							<img src="sphere/normals-tangents.png" width="280" height="280">
							<figcaption>Normal and tangent vectors.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Texture Coordinates</h3>
						
						<p>Generating the correct texture coordinates is not as straightforward, as we have to determine the correct mapping for effectively arbitrary points on the unit sphere. When generating the UV sphere we converted from UV coordinates to unit sphere positions. Now we have to do the opposite, which can be done by applying inverse trigonometric functions. Also introduce a convenient method for this.</p>
						
						<pre translate="no">		<ins>static float2 GetTexCoord (float3 p) => float2(</ins>
			<ins>0f,</ins>
			<ins>0f,</ins>
		<ins>);</ins></pre>
						
						<p>Use this method to set the texture coordinates in <code>ExecuteRegular</code>.</p>
						
						<pre translate="no">			<ins>vertex.texCoord0 = GetTexCoord(vertex.position);</ins>
			streams.SetVertex(vi, vertex);
			vi += 1;

			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				&hellip;
				<ins>vertex.texCoord0 = GetTexCoord(vertex.position);</ins>
				streams.SetVertex(vi, vertex);
				&hellip;
			}</pre>
						
						<p>And also for the seam in <code>ExecutePolesAndSeam</code>, but in this case only set the V coordinate, as the seam's U coordinates are all zero.</p>
						
						<pre translate="no">				vertex.normal = vertex.position = normalize(vertex.position);
				<ins>vertex.texCoord0.y = vertex.texCoord0 = GetTexCoord(vertex.position).y;</ins>
				streams.SetVertex(v + 7, vertex);</pre>
						
						<p>The V coordinate can be found by calculating the arc sine of the Y coordinate. This gives us an angle in radians with a range of &pi; centered on zero, which we have to convert to the 0&ndash;1 range to get the texture coordinate.</p>
						
						<pre translate="no">		static float2 GetTexCoord (float3 p) => float2(
			0f,
			<ins>asin(p.y) / PI + 0.5f</ins>
		);</pre>
						
						<figure>
							<img src="sphere/v-coordinates.png" width="280" height="280">
							<figcaption>V texture coordinates; <em translate="no">Lat Lon Map</em> material.</figcaption>
						</figure>
						
						<p>To find the U coordinate we need to apply the arc tangent. We'll use the <code>atan2</code> method for this, passing it X and Z as arguments. This gives us the arc tangent in radians of X divided by Z, with the result in the correct quadrant. The resulting angle has a range of 2&pi; centered on zero, which we have to convert to the 0&ndash;1 range.</p>
						
						<pre translate="no">		static float2 GetTexCoord (float3 p) => float2(
			<ins>atan2(p.x, p.z) / (2f * PI) + 0.5f</ins>,
			asin(p.y) / PI + 0.5f
		);</pre>
						
						<figure>
							<img src="sphere/u-coordinates-reversed.png" width="280" height="280">
							<figcaption>U texture coordinates reversed; <em translate="no">Flat</em> material.</figcaption>
						</figure>
						
						<p>The result goes in the wrong direction, which is fixed by negating the result of the arc tangent. We can do this by flippin the sign of the constant denominator.</p>
						
						<pre translate="no">		static float2 GetTexCoord (float3 p) => float2(
			atan2(p.x, p.z) / (<ins>-</ins>2f * PI) + 0.5f,
			asin(p.y) / PI + 0.5f
		);</pre>
						
						<figure>
							<img src="sphere/u-coordinates-incorrect-wrapping.png" width="280" height="280">
							<figcaption>Correct direction but incorrect wrapping.</figcaption>
						</figure>
						
						<p>This works except for the right side of the fourth quadrant. The U coordinate wraps back to zero while it should go to 1. We can fix this by checking whether the U coordinate that we calculated is very close to zero&mdash;but not too close due to precision limitations&mdash;like less than 0.000001. If so, set it to 1. This works because the seam's U coordinates are always zero.</p>
						
						<pre translate="no">		static float2 GetTexCoord (float3 p) <ins>{</ins>
			<ins>var texCoord =</ins> float2(
				atan2(p.x, p.z) / (-2f * PI) + 0.5f,
				asin(p.y) / PI + 0.5f
			);
			<ins>if (texCoord.x < 1e-6f) {</ins>
				<ins>texCoord.x = 1f;</ins>
			<ins>}</ins>
			<ins>return texCoord;</ins>
		<ins>}</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/octasphere/sphere/texture-coordinates-correct.png" width="280" height="280">
							<figcaption>Correct texture coordinates.</figcaption>
						</figure>
						
						<aside>
							<h3>What does <code>1e-6f</code> mean?</h3>
							<div>
								<p>It's scientific notation for `0.000001=10^-6`.</p>
							</div>
						</aside>
						
						<p>The next tutorial is <a href="../geodesic-octasphere/index.html">Geodesic Octasphere</a>.</p>
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/procedural-meshes-08-octasphere/" class="repository">repository</a>
					<a href="https://catlikecoding.com/unity/tutorials/procedural-meshes/octasphere/Octasphere.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>ml">Or make a direct donation</a>!</b></p>
			<p>made by <a href="https://catlikecoding.com/jasper-flick/" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>