<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/tutorial-image.jpg">
		<meta property="og:title" content="Seamless Cube Sphere">
		<meta property="og:description" content="A Unity C# Procedural Meshes tutorial about creating a cube sphere without seams.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Seamless Cube Sphere</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/#article",
				"headline": "Seamless Cube Sphere",
				"alternativeHeadline": "Stiching Sides Together",
				"datePublished": "2022-03-31",
				"dateModified": "2022-05-29",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity C# Procedural Meshes tutorial about creating a cube sphere without seams.",
				"image": "https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/tutorial-image.jpg",
				"dependencies": "Unity 2020.3.23f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/procedural-meshes/", "name": "Procedural Meshes" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				CubeSphere: 1,
				FlatHexagonGrid: 1,
				IMeshGenerator: 1,
				IMeshStreams: 1,
				G: 1,
				GizmoMode: 1,
				MaterialMode: 1,
				MeshJob: 1,
				MeshJobScheduleDelegate: 1,
				MeshOptimizationMode: 1,
				MeshType: 1,
				MultiStream: 1,
				PointyHexagonGrid: 1,
				PositionStream: 1,
				ProceduralMesh: 1,
				S: 1,
				SharedCubeSphere: 1,
				SharedSquareGrid: 1,
				SharedTriangleGrid: 1,
				Side: 1,
				SingleStream: 1,
				SquareGrid: 1,
				Stream0: 1,
				TriangleUInt16: 1,
				UVSphere: 1,
				Vertex: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Procedural Meshes</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Seamless Cube Sphere</h1>
					<p>Stitching Sides Together</p>
					<ul>
						<li>Support meshes with only position data.</li>
						<li>Make all cube sphere vertices shared.</li>
						<li>Stitch cube sides together with triangles.</li>
						<li>Visualize triangle draw order.</li>
						<li>Add mesh optimization options.</li>
					</ul>
				</header>
				
				<p>This is the seventh tutorial in a series about <a href="../index.html">procedural meshes</a>. This time we create a cube sphere with shared vertices, without any seams.</p>
				
				<p>This tutorial is made with Unity 2020.3.23f1.</p>
				
				<figure>
					<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/tutorial-image.jpg" width="512" height="256">
					<figcaption>A seamless cube sphere showing triangle draw order.</figcaption>
				</figure>
				
				<section>
					<h2>Minimal Vertex Data</h2>
					
					<p>It is impossible to apply a 2D texture to a sphere without introducing seams, so when we create a cube sphere that lacks seams we cannot rely on per-vertex texture coordinates. So we'll have to use our <em translate="no">Cube Map</em> material, other materials won't work. This means that we only have to generate vertex positions and can omit normals, tangents, and texture coordinates.</p>
					
					<section>
						<h3>Position-Only Stream</h3>
						
						<p>As we're only going to generate vertex positions, let's begin by creating an alternative <code>IMeshStreams</code> implementation for that. This significantly reduces the size of the generated mesh. Duplicate <code>MultiStream</code>, rename it to <code>PositionStream</code>, and remove all but its first stream field, keeping only <code>steam0</code>.</p>
						
						<pre translate="no">	public struct <ins>PositionStream</ins> : IMeshStreams {

		[NativeDisableContainerSafetyRestriction]
		NativeArray&lt;float3> stream0<ins>;</ins> <del>//, stream1;</del>

		<del>//[NativeDisableContainerSafetyRestriction]</del>
		<del>//NativeArray&lt;float4> stream2;</del>

		<del>//[NativeDisableContainerSafetyRestriction]</del>
		<del>//NativeArray&lt;float2> stream3;</del>

		&hellip;
	}</pre>
						
						<p>Also remove the unneeded streams from <code>Setup</code>, reducing the descriptor array's length to 1.</p>
						
						<pre translate="no">		public void Setup (
			Mesh.MeshData meshData, Bounds bounds, int vertexCount, int indexCount
		) {
			var descriptor = new NativeArray&lt;VertexAttributeDescriptor>(
				<ins>1</ins>, Allocator.Temp, NativeArrayOptions.UninitializedMemory
			);
			descriptor[0] = new VertexAttributeDescriptor(dimension: 3);
			<del>//descriptor[1] = &hellip;;</del>
			<del>//descriptor[2] = &hellip;;</del>
			<del>//descriptor[3] = &hellip;;</del>
			meshData.SetVertexBufferParams(vertexCount, descriptor);
			descriptor.Dispose();

			&hellip;

			stream0 = meshData.GetVertexData&lt;float3>();
			<del>//stream1 = meshData.GetVertexData&lt;float3>(1);</del>
			<del>//stream2 = meshData.GetVertexData&lt;float4>(2);</del>
			<del>//stream3 = meshData.GetVertexData&lt;float2>(3);</del>
			triangles = meshData.GetIndexData&lt;ushort>().Reinterpret&lt;TriangleUInt16>(2);
		}</pre>
						
						<p>Its <code>SetVertex</code> method only has to copy the vertex position, ignoring all other <code>Vertex</code> data.</p>
						
						<pre translate="no">		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void SetVertex (int index, Vertex vertex) {
			stream0[index] = vertex.position;
			<del>//stream1[index] = vertex.normal;</del>
			<del>//stream2[index] = vertex.tangent;</del>
			<del>//stream3[index] = vertex.texCoord0;</del>
		}</pre>
					</section>
					
					<section>
						<h3>Missing Gizmos</h3>
						
						<p>Before we continue we have to make sure that <code>ProceduralMesh.OnDrawGizmos</code> can deal with missing vertex data. If the mesh doesn't have normals or tangents then those properties will return an array with a length of zero, which would lead to an error because we assume that they have the same length as the vertex position array.</p>
						
						<p>If normals are missing then it makes most sense to not draw them either, even when configured to do so. We can do this by checking whether normals exist directly before we would retrieve the normals array, by invoking <code>HasVertexAttribute</code> on the mesh with <code>VertexAttribute.Normal</code> as an argument. Then we set whether we should draw normals to the result of that, and if we still should draw them, only then do we retrieve the array.</p>
						
						<pre translate="no">		if (drawNormals && normals == null) {
			<ins>drawNormals = mesh.HasVertexAttribute(VertexAttribute.Normal);</ins>
			<ins>if (drawNormals) {</ins>
				normals = mesh.normals;
			<ins>}</ins>
		}</pre>
						
						<p>Use the same approach for the tangents.</p>
						
						<pre translate="no">		if (drawTangents && tangents == null) {
			<ins>drawTangents = mesh.HasVertexAttribute(VertexAttribute.Tangent);</ins>
			<ins>if (drawTangents) {</ins>
				tangents = mesh.tangents;
			<ins>}</ins>
		}</pre>
						
						<p>This will work in all but one case. It goes wrong after a hot reload while play mode is paused, in which case <code>Update</code> isn't invoked immediately. Array fields that are <code>null</code> are serialized and deserialized by the editor as arrays with length zero, which will lead to the trouble we tried to avoid. We can prevent this serialization side-effect by instructing the editor to never store our arrays, by attaching the <code>System.NonSerialized</code> attribute to them. This makes sure that the fields are always reset to their default value, which is <code>null</code>.</p>
						
						<pre translate="no">	<ins>[System.NonSerialized]</ins>
	Vector3[] vertices, normals;

	<ins>[System.NonSerialized]</ins>
	Vector4[] tangents;</pre>
					</section>
					
					<section>
						<h3>Position-Only Cube Sphere</h3>
						
						<p>Duplicate <code>CubeSphere</code> and rename to <code>SharedCubeSphere</code>.</p>
						
						<pre translate="no">	public struct <ins>SharedCubeSphere</ins> : IMeshGenerator { &hellip; }</pre>
						
						<p>Add it to the options of <code>ProceduralMesh</code>, using the <code>PositionStream</code>.</p>
						
						<pre translate="no">	static MeshJobScheduleDelegate[] jobs = {
		&hellip;
		MeshJob&lt;CubeSphere, SingleStream>.ScheduleParallel,
		<ins>MeshJob&lt;SharedCubeSphere, PositionStream>.ScheduleParallel,</ins>
		MeshJob&lt;UVSphere, SingleStream>.ScheduleParallel
	};

	public enum MeshType {
		SquareGrid€, SharedSquareGrid€, SharedTriangleGrid€,
		FlatHexagonGrid€, PointyHexagonGrid€, CubeSphere€, <ins>SharedCubeSphere€,</ins> UVSphere€
	};</pre>
						
						<p>Without any other changes this creates a variant cube sphere mesh that only contains position data. You can verify this by inspecting the generated mesh in the editor and also by noticing that only the <em translate="no">Cube Map</em> material works with it. Also, if you inspect the code generated by <em translate="no">Burst</em> you'll see that all code exclusively used for normals, tangents, and texture coordinates has been stripped. But let's also remove this code manually from <code>SharedCubeSphere.Execute</code>.</p>
						
						<pre translate="no">			var vertex = new Vertex();
			<del>//vertex.tangent = float4(normalize(pB - pA), -1f);</del>

			for (int v = 1; v &lt;= Resolution; v++, vi += 4, ti += 2) {
				float3 pC = CubeToSphere(uA + side.vVector * v / Resolution);
				float3 pD = CubeToSphere(uB + side.vVector * v / Resolution);

				vertex.position = pA;
				<del>//vertex.normal = normalize(cross(pC - pA, vertex.tangent.xyz));</del>
				<del>//vertex.texCoord0 = 0f;</del>
				streams.SetVertex(vi + 0, vertex);

				vertex.position = pB;
				<del>//vertex.normal = normalize(cross(pD - pB, vertex.tangent.xyz));</del>
				<del>//vertex.texCoord0 = float2(1f, 0f);</del>
				streams.SetVertex(vi + 1, vertex);

				vertex.position = pC;
				<del>//vertex.tangent.xyz = normalize(pD - pC);</del>
				<del>//vertex.normal = normalize(cross(pC - pA, vertex.tangent.xyz));</del>
				<del>//vertex.texCoord0 = float2(0f, 1f);</del>
				streams.SetVertex(vi + 2, vertex);

				vertex.position = pD;
				<del>//vertex.normal = pD;</del>
				<del>//vertex.normal = normalize(cross(pD - pB, vertex.tangent.xyz));</del>
				<del>//vertex.texCoord0 = 1f;</del>
				streams.SetVertex(vi + 3, vertex);

				streams.SetTriangle(ti + 0, vi + int3(0, 2, 1));
				streams.SetTriangle(ti + 1, vi + int3(1, 2, 3));

				pA = pC;
				pB = pD;
			}</pre>
					</section>
				</section>
				
				<section>
					<h2>Vertices</h2>
					
					<p>Currently <code>SharedCubeSphere</code> still generates four separate vertices per quad. To share all vertices we have to get rid of a lot of them.</p>
					
					<section>
						<h3>Eliminating Triangles</h3>
						
						<p>We'll initially exclusively focus on the vertices, leaving the triangles for later. But we still have to generate triangles, so we'll simply make them degenerate for now.</p>
						
						<pre translate="no">				streams.SetTriangle(ti + 0, <ins>0</ins>);
				streams.SetTriangle(ti + 1, <ins>0</ins>);</pre>
						
						<figure>
							<img src="vertices/vertices-resolution-6.png" width="280" height="280">
							<figcaption>Only vertices of resolution 6 cube sphere.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Looping over Vertex Columns</h3>
						
						<p>When we consider a side of the cube sphere in isolation, what we need to do is similar to converting from <code>SquareGrid</code> to <code>SharedSquareGrid</code>. So instead of looping over a column of quads we'll change it so we loop over a column of vertices instead.</p>
						
						<p>Change the loop so the position that is calculated first&mdash;quad vertex position C&mdash;is used for the single vertex position that we set. Then remove all other code that deals with positions and vertices A, B, and D.</p>
						
						<pre translate="no">
			for (int v = 1; v &lt;= Resolution; v++, vi += 4, ti += 2) {
				<ins>vertex.position</ins> = CubeToSphere(uA + side.vVector * v / Resolution);
				<ins>streams.SetVertex(vi, vertex);</ins>

				<del>//float3 pD = CubeToSphere(uB + side.vVector * v / Resolution);</del>

				<del>//vertex.position = pA;</del>
				<del>//streams.SetVertex(vi + 0, vertex);</del>

				<del>//&hellip;</del>

				streams.SetTriangle(ti + 0, 0);
				streams.SetTriangle(ti + 1, 0);

				<del>//pA = pC;</del>
				<del>//pB = pD;</del>
			}</pre>
						
						<p>Also remove the code that initializes <code>uB</code>, <code>pA</code>, and <code>pB</code> before the loop.</p>
						
						<pre translate="no">			float3 uA = side.uvOrigin + side.uVector * u / Resolution;
			<del>//float3 uB = side.uvOrigin + side.uVector * (u + 1) / Resolution;</del>
			<del>//float3 pA = CubeToSphere(uA), pB = CubeToSphere(uB);</del></pre>
						
						<p>We need to keep <code>uA</code> because our vertex column is based on it, but let's rename it to <code>pStart</code> because it now represents the single starting position at the bottom of the vertex column.</p>
						
						<pre translate="no">			float3 <ins>pStart</ins> = side.uvOrigin + side.uVector * u / Resolution;

			var vertex = new Vertex();

			for (int v = 1; v &lt;= Resolution; v++, vi += 4, ti += 2) {
				vertex.position = CubeToSphere(<ins>pStart</ins> + side.vVector * v / Resolution);
				streams.SetVertex(vi, vertex);

				streams.SetTriangle(ti + 0, 0);
				streams.SetTriangle(ti + 1, 0);
			}</pre>
						
						<p>At this point we already appear to generate an almost-complete cube sphere. Only the two minimum and maximum polar vertices are missing, leaving two small gaps. Besides that there could also be random vertices visible because we haven't set their positions.</p>
					</section>
					
					<section>
						<h3>Reducing the Vertex Count</h3>
						
						<p>Our current approach works because we're generating six grids of `rxxr` vertices, with `r` being the resolution. These fit together such that the result is a cube with only two missing vertices: the polar vertices on the XYZ line.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/vertices/back-face-vertices.png" width="165" height="165">
							<figcaption>First side, showing back (black), right (red), and bottom (blue) vertices.</figcaption>
						</figure>
						
						<p>This means that we can reduce the vertex count from `24r^2` down to `6r^2+2`.</p>
						
						<pre translate="no">		public int VertexCount => <ins>6 *</ins> Resolution * Resolution <ins>+ 2</ins>;</pre>
						
						<p>Adjust the vertex offset at the start of <code>Execute</code> to match. We'll put the polar vertices at the beginning, so offset accordingly.</p>
						
						<pre translate="no">			int vi = <ins>Resolution *</ins> (Resolution * side.id + u) <ins>+ 2</ins>;</pre>
						
						<p>Also, we should increment the vertex index only once per iteration, as we no longer generate separate quads.</p>
						
						<pre translate="no">			for (int v = 1; v &lt;= Resolution; v++, <ins>vi++</ins>, ti += 2) { &hellip; }</pre>
					</section>
					
					<section>
						<h3>Adding the Polar Vertices</h3>
						
						<p>The two polar vertices are simple: their positions are `+-sqrt(1/3)`. Rather than put the code for that in a separate method we'll add the vertices directly after creating the <code>Vertex</code> value, first the minimum and then the maximum pole. This must be done only once, so we'll do it when the job index is zero.</p>
						
						<pre translate="no">			var vertex = new Vertex();
			<ins>if (i == 0) {</ins>
				<ins>vertex.position = -sqrt(1f / 3f);</ins>
				<ins>streams.SetVertex(0, vertex);</ins>
				<ins>vertex.position = sqrt(1f / 3f);</ins>
				<ins>streams.SetVertex(1, vertex);</ins>
			<ins>}</ins></pre>
						
						<aside>
							<h3>How do you find the position of the poles?</h3>
							<div>
								<p>The poles lie on the XYZ line, meaning that their coordinates are all the same. They also lie on the surface of the unit sphere, so `x^2+y^2+z^2=1`. As `x=y=z` we have `3x^2=1->x^2=1/3->x=+-sqrt(1/3)`.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Extracting First Vertex of Column</h3>
						
						<p>The approach that we used for <code>SharedSquareGrid</code> extracted the first vertex from the loop, because otherwise we couldn't generate the quads correctly. We'll have to do the same this time as well. So add the first vertex before the loop, directly using <code>pStart</code>. To compensate we have to reduce the loop length by one.</p>
						
						<pre translate="no">			<ins>vertex.position = CubeToSphere(pStart);</ins>
			<ins>streams.SetVertex(vi, vertex);</ins>
			<ins>vi += 1;</ins>

			for (int v = 1; v <ins>&lt;</ins> Resolution; v++, vi++, ti += 2) { &hellip; }</pre>
						
						<p>In this case this will result in missing quads, because the cube mesh vertex columns are one shorter than those of the flat grid. For now we'll simply compensate for this by adding an extra quad before the loop starts.</p>
						
						<pre translate="no">			vertex.position = CubeToSphere(pStart);
			streams.SetVertex(vi, vertex);

			<ins>streams.SetTriangle(ti + 0, 0);</ins>
			<ins>streams.SetTriangle(ti + 1, 0);</ins>
			vi += 1;
			<ins>ti += 2;</ins>
			
			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) { &hellip; }</pre>
						
						<p>These changes have shifted the V range of the vertex columns, as they now start at 0 instead of 1. This is easier to work with when stitching sides together later, but to keep the sides aligned properly we'll have to start U at 1 instead of 0. This is done by simply incrementing U after calculating the vertex and triangle indices and before calculating <code>pStart</code>.</p>
						
						<pre translate="no">			int u = i / 6;
			Side side = GetSide(i - 6 * u);
			int vi = Resolution * (Resolution * side.id + u) + 2;
			int ti = 2 * Resolution * (Resolution * side.id + u);

			<ins>u += 1;</ins>

			float3 pStart = side.uvOrigin + side.uVector * u / Resolution;</pre>
						
						<p>This changes the position of the vertex grid from the top left corner to the bottom right corner of each side.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/vertices/back-face-vertices-adjusted.png" width="165" height="165">
							<figcaption>First side, showing back (black), left (red), and top (blue) vertices.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Triangles</h2>
					
					<p>Our cube face has twelve edges where two sides meet and eight corners where three sides meet. When adding triangles we have to somehow stitch all these seams together. Thus we'll have to take care of multiple special cases, which we'll do one at a time.</p>
					
					<section>
						<h3>First Triangle per Column</h3>
						
						<p>Let's begin with only showing the first triangle of each column, so only the first triangle of the bottoms quads of each side. As our vertex columns are aligned with the bottom of each side this is a simple case, except for the first quad.</p>
						
						<p>When generating the first column of a side its first vertex is either borrowed from a different side or it is the minimum pole. So let's initially skip that first triangle, by checking whether we're working on the first column of a side, which is the case when U equals zero, before we increment it. Keep track of this fact via a boolean variable so we can easily check it later.</p>
						
						<pre translate="no">			int vi = Resolution * (Resolution * side.id + u) + 2;
			int ti = 2 * Resolution * (Resolution * side.id + u);
			<ins>bool firstColumn = u == 0;</ins>
			u += 1;</pre>
						
						<p>When it's the first column we keep the first triangle&mdash;the one added before the loop&mdash;degenerate. Otherwise we add the first triangle of the first quad, using the initial vertex index with offset `[[0],[-r],[-r+1]]`.</p>
						
						<pre translate="no">			<ins>if (firstColumn) {</ins>
				<ins>streams.SetTriangle(ti, 0);</ins>
			<ins>}</ins>
			<ins>else {</ins>
				<ins>streams.SetTriangle(ti, vi + int3(0, -Resolution, -Resolution + 1));</ins>
			<ins>}</ins>
			<del>//streams.SetTriangle(ti + 0, 0);</del>
			streams.SetTriangle(ti + 1, 0);
			vi += 1;
			ti += 2;</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/triangles/first-triangles.png" width="280" height="280">
							<figcaption>First triangles, with gaps.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Touching the Minimum Pole</h3>
						
						<p>To also include the first triangle of these rows we have to find the first two vertex indices of the side's column when U is zero. As we skip that column these vertices are found somewhere else in the mesh.</p>
						
						<p>The easiest vertices to find are the minimum corner vertices of the sides that touch the minimum pole, as that's always the minimum pole vertex, so index zero. Those sides have identifiers 0, 2, and 4, so we can find out whether a sides touches the minimum pole by checking whether its identifier is even. Add a property for this to <code>Side</code>.</p>
						
						<pre translate="no">		struct Side {
			public int id;
			public float3 uvOrigin, uVector, vVector;

			<ins>public bool TouchesMinimumPole => (id &amp; 1) == 0;</ins>
		}</pre>
						
						<p>Back in <code>Execute</code>, if we're in the first column and the side touches the minimum pole, then we know the first two indices of the first triangle: the vertex index and zero, with the third yet unknown. Otherwise we keep using a degenerate triangle for the first column.</p>
						
						<pre translate="no">			if (firstColumn) {
				<ins>if (side.TouchesMinimumPole) {</ins>
					<ins>streams.SetTriangle(ti, int3(vi, 0, 0));</ins>
				<ins>}</ins>
				<ins>else {</ins>
					streams.SetTriangle(ti, 0);
				<ins>}</ins>
			}
			else {
				streams.SetTriangle(ti, vi + int3(0, -Resolution, -Resolution + 1));
			}</pre>
						
						<p>To find the final vertex we have to go one step counterclockwise through the polar cube sphere side layout.</p>
						
						<figure>
							<img src="triangles/layout-polar.png" width="320" height="320">
							<figcaption>Cube sphere side layout.</figcaption>
						</figure>
						
						<p>Analyzing the layout tells use that for sides 2 and 4 we find the vertex with a relative offset of `-2r^2` while for side 0 we need to wrap around and use `4r^2` instead.</p>
						
						<aside>
							<h3>How are those offsets determined?</h3>
							<div>
								<p>The required vertex for side 2 is the first vertex of side 0, so a negative offset of two sides. Each side has `r^2` vertices. So the offset for side 2 is `-2r^2` and likewise for side 4. In the case of side 0 we have to offset in the other direct to reach side 4, hence `4r^2`.</p>
							</div>
						</aside>
						
						<pre translate="no">				if (side.TouchesMinimumPole) {
					streams.SetTriangle(ti, int3(
						vi,
						0,
						<ins>vi + (side.id == 0 ? 4 : -2) * Resolution * Resolution</ins>
					));
				}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/triangles/minimium-pole-triangles.png" width="280" height="280">
							<figcaption>With triangles touching the minimum pole.</figcaption>
						</figure>
						
						<p>We can also see that for the other sides we can simple jump back a single column as that wraps to the previous side.</p>
						
						<pre translate="no">				if (side.TouchesMinimumPole) {
					streams.SetTriangle(ti, int3(
						vi,
						0,
						vi + (side.id == 0 ? 4 : -2) * Resolution * Resolution
					));
				}
				else {
					streams.SetTriangle(ti, <ins>vi + int3(0, -Resolution, -Resolution + 1)</ins>);
				}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/triangles/all-first-triangles.png" width="280" height="280">
							<figcaption>All first triangles.</figcaption>
						</figure>
						
						<p>However, this goes wrong for the special case of using a resolution 1 cube sphere. In that case the third index offset has to be 4 for side 1 and &minus;2 for sides 3 and 5.</p>
						
						<pre translate="no">				if (side.TouchesMinimumPole) {
					streams.SetTriangle(ti, int3(
						vi,
						0,
						vi + (side.id == 0 ? 4 : -2) * Resolution * Resolution
					));
				}
				else {
					streams.SetTriangle(ti, vi + int3(
						0,
						-Resolution,
						<ins>Resolution == 1 ? (side.id == 1 ? 4 : -2) :</ins> -Resolution + 1
					));
				}</pre>
					</section>
					
					<section>
						<h3>Seam Step</h3>
						
						<p>Note that we're using the value 4 for sides 0 and 1 and the value &minus;2 for all other sides when stepping across an edge seam. Let's define this as the seam-step value and add it to <code>Side</code>.</p>
						
						<pre translate="no">		struct Side {
			public int id;
			public float3 uvOrigin, uVector, vVector;
			<ins>public int seamStep;</ins>

			public bool TouchesMinimumPole => (id & 1) == 0;
		}</pre>
						
						<p>Initialize it in <code>GetSide</code>.</p>
						
						<pre translate="no">		static Side GetSide (int id) => id switch {
			0 => new Side {
				&hellip;<ins>,</ins>
				<ins>seamStep = 4</ins>
			},
			1 => new Side {
				&hellip;<ins>,</ins>
				<ins>seamStep = 4</ins>
			},
			2 => new Side {
				&hellip;<ins>,</ins>
				<ins>seamStep = -2</ins>
			},
			3 => new Side {
				&hellip;<ins>,</ins>
				<ins>seamStep = -2</ins>
			},
			4 => new Side {
				&hellip;<ins>,</ins>
				<ins>seamStep = -2</ins>
			},
			_ => new Side {
				&hellip;<ins>,</ins>
				<ins>seamStep = -2</ins>
			}
		};</pre>
						
						<p>Then use it in <code>Execute</code>.</p>
						
						<pre translate="no">				if (side.TouchesMinimumPole) {
					streams.SetTriangle(ti, int3(
						vi,
						0,
						vi + <ins>side.seamStep</ins> * Resolution * Resolution
					));
				}
				else {
					streams.SetTriangle(ti, vi + int3(
						0,
						-Resolution,
						Resolution == 1 ? <ins>side.seamStep</ins> : -Resolution + 1
					));
				}</pre>
						
						<p>Let's also rewrite the triangle index code entirely, reducing it to a single expression that creates an <code>int3</code> triangle, using conditional operators instead of nested conditional blocks. Then we need to invoke <code>SetTriangle</code> only in one place.</p>
						
						<pre translate="no">			<ins>var triangle = int3(</ins>
				<ins>vi,</ins>
				<ins>firstColumn &amp;&amp; side.TouchesMinimumPole ? 0 : vi - Resolution,</ins>
				<ins>vi + (firstColumn ?</ins>
					<ins>side.TouchesMinimumPole ?</ins>
						<ins>side.seamStep * Resolution * Resolution :</ins>
						<ins>Resolution == 1 ? side.seamStep : -Resolution + 1 :</ins>
					<ins>-Resolution + 1</ins>
				<ins>)</ins>
			<ins>);</ins>

			<del>//if (firstColumn) { &hellip; }</del>
			<del>//else {</del>
			<del>//	streams.SetTriangle(ti, vi + int3(0, -Resolution, -Resolution + 1));</del>
			<del>//}</del>
			<ins>streams.SetTriangle(ti, triangle);</ins>
			streams.SetTriangle(ti + 1, 0);</pre>
					</section>
					
					<section>
						<h3>Closing the Seams</h3>
						
						<p>Now that we have the first triangle of each column, let's fill the entire column by simply incrementing that triangle each iteration and using that for the first part of the quad.</p>
						
						<pre translate="no">			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				vertex.position = CubeToSphere(pStart + side.vVector * v / Resolution);
				streams.SetVertex(vi, vertex);

				<ins>triangle += 1;</ins>
				streams.SetTriangle(ti + 0, <ins>triangle</ins>);
				streams.SetTriangle(ti + 1, 0);
			}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/triangles/incrementing-triangles-partially-correct.png" width="280" height="280">
							<figcaption>Incrementing triangles, partially correct.</figcaption>
						</figure>
						
						<p>This works for most of the sphere but fails for multiple seams in between sides, so let's take care of those one by one.</p>
						
						<p>Let's begin by looking at the first column of each side. It is always correct to increment the triangle's X index, because it corresponds to the vertex column that we're working through. But incrementing the Y index won't work when we start at the minimum pole. However, Y should always become equal to Z in the next iteration, so we can just assign Z to Y and it will always work.</p>
						
						<pre translate="no">				<del>//triangle += 1;</del>
				<ins>triangle.x += 1;</ins>
				<ins>triangle.y = triangle.z;</ins></pre>
						
						<p>That leaves the Z index. Incrementing it works fine for the sides that don't touch the minimum pole. Those that do end up connected to sides with a different orientation. This means that for the first column when touching the minimum pole, Z should be incremented by `r` instead.</p>
						
						<pre translate="no">				triangle.x += 1;
				triangle.y = triangle.z;
				<ins>triangle.z += firstColumn && side.TouchesMinimumPole ? Resolution : 1;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/triangles/first-column-correct.png" width="280" height="280">
							<figcaption>First columns correct.</figcaption>
						</figure>
						
						<p>Let's now look at the last rows&mdash;the last iteration of each column&mdash;when V equals `r-1`. We'll again start by using conditional blocks, condensing it later. It already appears to work correctly for the first columns touching the minimum pole, so we begin with copying the current logic.</p>
						
						<pre translate="no">				<ins>if (v == Resolution - 1) {</ins>
					<ins>if (firstColumn &amp;&amp; side.TouchesMinimumPole) {</ins>
						<ins>triangle.z += Resolution;</ins>
					<ins>}</ins>
					<ins>else {</ins>
						<ins>triangle.z += 1;</ins>
					<ins>}</ins>
				<ins>}</ins>
				<ins>else {</ins>
					triangle.z += firstColumn && side.TouchesMinimumPole ? Resolution : 1;
				<ins>}</ins></pre>
						
						<p>Looking at the sides not touching the minimum pole and analyzing the layout of their relevant adjacent sides, it becomes clear that the correct vertex is found by adding `(s+1)r^2-ur+u` to Z, where `s` is the seam step.</p>
						
						<pre translate="no">					if (firstColumn && side.TouchesMinimumPole) {
						triangle.z += Resolution;
					}
					else {
						triangle.z +=
							<ins>Resolution * ((side.seamStep + 1) * Resolution - u) + u</ins>;
					}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/triangles/half-last-rows-correct.png" width="280" height="280">
							<figcaption>Half of the last rows correct.</figcaption>
						</figure>
						
						<p>But this is only correct when working neither on the first column nor on a side touching the minimum pole. In all remaining cases U isn't factored into the equation so we add `(s+1)r^2-r+1` instead.</p>
						
						<pre translate="no">					if (firstColumn &amp;&amp; side.TouchesMinimumPole) {
						triangle.z += Resolution;
					}
					else <ins>if (!firstColumn &amp;&amp; !side.TouchesMinimumPole)</ins> {
						triangle.z +=
							Resolution * ((side.seamStep + 1) * Resolution - u) + u;
					}
					<ins>else {</ins>
						<ins>triangle.z +=</ins>
							<ins>(side.seamStep + 1) * Resolution * Resolution -</ins>
							<ins>Resolution + 1;</ins>
					<ins>}</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/triangles/all-last-rows-correct.png" width="280" height="280">
							<figcaption>All last rows correct.</figcaption>
						</figure>
						
						<p>At this point we have closed all seams and covered the entire sphere with half-quads. Let's now also condense the logic for incrementing Z, only keeping the last-iteration check a conditional block as it's the only portion that isn't constant for the entire loop.</p>
						
						<pre translate="no">				if (v == Resolution - 1) {
					<ins>triangle.z += firstColumn &amp;&amp; side.TouchesMinimumPole ?</ins>
						<ins>Resolution :</ins>
						<ins>!firstColumn &amp;&amp; !side.TouchesMinimumPole ?</ins>
							<ins>Resolution * ((side.seamStep + 1) * Resolution - u) + u :</ins>
							<ins>(side.seamStep + 1) * Resolution * Resolution -</ins>
							<ins>Resolution + 1;</ins>
				}
				else {
					triangle.z += firstColumn && side.TouchesMinimumPole ? Resolution : 1;
				}</pre>
						
						<p>Although a big portion of this code is invariant and can be hoisted out of the loop, inspecting the compiled code shows that <em translate="no">Burst</em> has some trouble with this, due to the complexity and the combination of invariant and variable evaluation. We can help <em translate="no">Burst</em> by pulling the logic out of the loop ourselves.</p>
						
						<pre translate="no">			<ins>int zAdd = firstColumn &amp;&amp; side.TouchesMinimumPole ? Resolution : 1;</ins>
			<ins>int zAddLast = firstColumn &amp;&amp; side.TouchesMinimumPole ?</ins>
				<ins>Resolution :</ins>
				<ins>!firstColumn &amp;&amp; !side.TouchesMinimumPole ?</ins>
					<ins>Resolution * ((side.seamStep + 1) * Resolution - u) + u :</ins>
					<ins>(side.seamStep + 1) * Resolution * Resolution - Resolution + 1;</ins>

			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) {
				vertex.position = CubeToSphere(pStart + side.vVector * v / Resolution);
				streams.SetVertex(vi, vertex);

				triangle.x += 1;
				triangle.y = triangle.z;
				<ins>triangle.z += v == Resolution - 1 ? zAddLast : zAdd;</ins>
				<del>//if (v == Resolution - 1) { &hellip; }</del>
				<del>//else { &hellip; }</del>
				streams.SetTriangle(ti + 0, triangle);
				streams.SetTriangle(ti + 1, 0);
			}</pre>
					</section>
					
					<section>
						<h3>Filling the Gaps</h3>
						
						<p>All that's left at this point is to complete the quads, filling the gaps in the mesh. However, because of the nature of the seams we cannot simply create square quads. This is easiest to see for a resolution 1 cube sphere, as in that case all we have is seams.</p>
						
						<p>The solution is to keep the fist and the last triangle of each column outside the loop, instead of the entire fist quad. The quads in between are then vertically sheared.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/triangles/sheared-quad-layout.png" width="270" height="270">
							<figcaption>Sheared quad layout.</figcaption>
						</figure>
						
						<p>Begin by removing the second triangle that is added before the loop and instead adding one after it. Thus the triangle index is only incremented by 1 before the loop starts.</p>
						
						<pre translate="no">			streams.SetTriangle(ti, triangle);
			<del>//streams.SetTriangle(ti + 1, 0);</del>
			vi += 1;
			ti += <ins>1</ins>;

			int zAdd = &hellip;;
			int &hellip;;

			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) { &hellip; }

			<ins>streams.SetTriangle(ti, 0);</ins></pre>
						
						<p>Second, inside the loop it now makes sense to swap the order of the triangles, as what we're currently generating are the top triangles of each sheared quad.</p>
						
						<pre translate="no">				triangle.z += v == Resolution - 1 ? zAddLast : zAdd;
				streams.SetTriangle(ti + 0, <ins>0</ins>);
				streams.SetTriangle(ti + 1, <ins>triangle</ins>);</pre>
						
						<p>The bottom triangle of each quad can then be found relative to its top triangle.</p>
						
						<pre translate="no">				streams.SetTriangle(ti + 0, <ins>int3(triangle.x - 1, triangle.y, triangle.x)</ins>);
				streams.SetTriangle(ti + 1, triangle);</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/triangles/filled-all-but-last-rows.png" width="280" height="280">
							<figcaption>Filled all but the last rows.</figcaption>
						</figure>
						
						<p>The final step is to fill in the last triangle of each column. The first two triangle indices come from the previous triangle. The last index again depends on the side we're working on. If the side touches the minimum pole then it's the triangle Z index plus `r`, otherwise we'll initially use zero.</p>
						
						<pre translate="no">			for (int v = 1; v &lt; Resolution; v++, vi++, ti += 2) { &hellip; }

			streams.SetTriangle(ti, <ins>int3(</ins>
				<ins>triangle.x,</ins>
				<ins>triangle.z,</ins>
				<ins>side.TouchesMinimumPole ? triangle.z + Resolution : 0</ins>
			<ins>)</ins>);</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/triangles/sides-touching-minimum-complete.png" width="280" height="280">
							<figcaption>Sides touching minimum pole are complete.</figcaption>
						</figure>
						
						<p>And for the remaining sides we have to add 1 instead of `r`, except when the resolution is 1, when we have to use the index of the maximum pole, which is 1.</p>
						
						<pre translate="no">			streams.SetTriangle(ti, int3(
				triangle.x,
				triangle.z,
				side.TouchesMinimumPole ?
					triangle.z + Resolution :
					<ins>u == Resolution ? 1 : triangle.z + 1</ins>
			));</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/triangles/complete-sphere.png" width="280" height="280">
							<figcaption>Complete sphere.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Mesh Optimization</h2>
					
					<p>With our seamless cube sphere complete, let's take a short look at the way the mesh is constructed and whether it's possible to optimize this.</p>
					
					<section>
						<h3>Showing Triangles</h3>
						
						<p>An interesting question related to performance is how the triangles of our mesh are organized, because that determines the order in which they are drawn. If meshes that share the same vertices are drawn quickly after each other the GPU can reuse cached vertices, which might improve performance. So let's use gizmos to visualize our triangles. Add an option for this to <code>ProceduralMesh.GizmoMode</code>.</p>
						
						<pre translate="no">	public enum GizmoMode {
		Nothing = 0, Vertices = 1, Normals = 0b10, Tangents = 0b100<ins>, Triangles = 0b1000</ins>
	}</pre>
						
						<p>Add a field for the triangles and code to set and clear it, just like drawing vertices, except it requires an integer array.</p>
						
						<pre translate="no">	<ins>[System.NonSerialized]</ins>
	<ins>int[] triangles;</ins>

	&hellip;

	void OnDrawGizmos () {
		&hellip;
		bool drawTangents = (gizmos & GizmoMode.Tangents) != 0;
		<ins>bool drawTriangles = (gizmos & GizmoMode.Triangles) != 0;</ins>

		&hellip;
		if (drawTangents && tangents == null) {
			drawTangents = mesh.HasVertexAttribute(VertexAttribute.Tangent);
			if (drawTangents) {
				tangents = mesh.tangents;
			}
		}
		<ins>if (drawTriangles && triangles == null) {</ins>
			<ins>triangles = mesh.triangles;</ins>
		<ins>}</ins>

		&hellip;
	}
	
	&hellip;
	
	void Update () {
		&hellip;
		tangents = null;
		<ins>triangles = null;</ins>

		GetComponent&lt;MeshRenderer>().material = materials[(int)material];
	}</pre>
						
						<p>The drawing of triangles is a little different because they are defined by three vertex indices. The triangles array contains these indices sequentially, so we'll work through these triplets in a separate loop. For visualization we use a magenta sphere placed at the average of the triangle's vertex positions.</p>
						
						<pre translate="no">	void OnDrawGizmos () {
		&hellip;

		<ins>if (drawTriangles) {</ins>
			<ins>Gizmos.color = Color.magenta;</ins>
			<ins>for (int i = 0; i &lt; triangles.Length; i += 3) {</ins>
				<ins>Gizmos.DrawSphere(</ins>
					<ins>t.TransformPoint((</ins>
						<ins>vertices[triangles[i]] +</ins>
						<ins>vertices[triangles[i + 1]] +</ins>
						<ins>vertices[triangles[i + 2]]</ins>
					<ins>) * (1f / 3f)),</ins>
					<ins>0.02f</ins>
				<ins>);</ins>
			<ins>}</ins>
		<ins>}</ins>
	}</pre>
						
						<figure>
							<img src="mesh-optimization/average-triangle-vertices.png" width="280" height="280">
							<figcaption>Showing average position of triangle vertices.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Triangle Draw Order</h3>
						
						<p>To visualize the draw order of the triangles we'll use a gradient going from black to magenta as we progress through the array.</p>
						
						<pre translate="no">		if (drawTriangles) {
			<del>//Gizmos.color = Color.magenta;</del>
			<ins>float colorStep = 1f / (triangles.Length - 3);</ins>
			for (int i = 0; i &lt; triangles.Length; i += 3) {
				<ins>float c = i * colorStep;</ins>
				<ins>Gizmos.color = new Color(c, 0f, c);</ins>
				Gizmos.DrawSphere(&hellip;);
			}
		}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/mesh-optimization/colored-based-on-draw-order.png" width="280" height="280">
							<figcaption>Colored base on draw order.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Optimizing Draw Order</h3>
						
						<p>It is now possible to get a visual impression of the triangle draw order, which is easiest to see when only showing triangles with a fairly high resolution. In the case of our cube sphere it reveals how we generated the triangles in columns per side. Clear seams are visible especially near the minimum pole.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/mesh-optimization/triangle-order-minimum-pole.png" width="280" height="280">
							<figcaption>Triangle order around minimum pole.</figcaption>
						</figure>
						
						<p>Unity offers a way to automatically optimize a mesh, by invoking <code>Optimize</code> on it. Let's do so after generating it.</p>
						
						<pre translate="no">	void GenerateMesh () {
		Mesh.MeshDataArray meshDataArray = Mesh.AllocateWritableMeshData(1);
		Mesh.MeshData meshData = meshDataArray[0];

		jobs[(int)meshType](mesh, meshData, resolution, default).Complete();

		Mesh.ApplyAndDisposeWritableMeshData(meshDataArray, mesh);

		<ins>mesh.Optimize();</ins>
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/mesh-optimization/triangle-order-optimized.png" width="280" height="280">
							<figcaption>Optimized triangle order.</figcaption>
						</figure>
						
						<p>This makes a big difference for our seamless cube sphere, at least visually. Unity's optimization algorithm decides to smooth out the region near the minimum pole a lot. Whether this has a significant impact on rendering performance is something that has to be tested though. As our seamless cube sphere has very little vertex data and the <em translate="no">Cube Map</em> material has a simple vertex shader stage the impact of optimization will likely be small, but it's a potentially useful option to have available.</p>
						
						<p>If you also analyze the other meshes you'll find that optimization won't make a difference, because we already generate triangles in an efficient order.</p>
					</section>
					
					<section>
						<h3>Configurable Optimization</h3>
						
						<p>Invoking <code>Optimize</code> doesn't guarantee better performance and it cannot be done as part of a job, so it's not something that should always be done by default. Also, there are a few different ways in which Unity can optimize a mesh. Invoking <code>Optimize</code> allows Unity to both reorder vertex data and triangle indices, but it's also possible to do only one of those. Let's make this configurable by adding a new <code>MeshOptimizationMode</code> enum type and configuration field that allows enabling reordering of indices and vertices independently.</p>
						
						<pre translate="no">	<ins>[System.Flags]</ins>
	<ins>public enum MeshOptimizationMode {</ins>
		<ins>Nothing = 0, ReorderIndices = 1, ReorderVertices = 0b10</ins>
	<ins>}</ins>

	<ins>[SerializeField]</ins>
	<ins>MeshOptimizationMode meshOptimization;</ins></pre>
						
						<figure>
							<img src="mesh-optimization/mesh-optimization-option.png" width="320" height="42">
							<figcaption>Optimization set to reorder indices only.</figcaption>
						</figure>
						
						<p>In <code>GenerateMesh</code>, if only indices should be reordered invoke <code>OptimizeIndexBuffers</code>. Otherwise, if only vertices should be reordered invoke <code>OptimizeReorderVertexBuffer</code>. Otherwise, unless optimization is disabled invoke <code>Optimize</code> as before to do both.</p>
						
						<pre translate="no">		<ins>if (meshOptimization == MeshOptimizationMode.ReorderIndices) {</ins>
			<ins>mesh.OptimizeIndexBuffers();</ins>
		<ins>}</ins>
		<ins>else if (meshOptimization == MeshOptimizationMode.ReorderVertices) {</ins>
			<ins>mesh.OptimizeReorderVertexBuffer();</ins>
		<ins>}</ins>
		<ins>else if (meshOptimization != MeshOptimizationMode.Nothing) {</ins>
			mesh.Optimize();
		<ins>}</ins></pre>
						
						<p>The next tutorial is <a href="../octasphere/index.html">Octasphere</a>.</p>
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/procedural-meshes-07-seamless-cube-sphere/" class="repository">repository</a>
					<a href="https://catlikecoding.com/unity/tutorials/procedural-meshes/seamless-cube-sphere/Seamless-Cube-Sphere.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>