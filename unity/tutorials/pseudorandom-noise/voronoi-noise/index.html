<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/voronoi-noise/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/voronoi-noise/tutorial-image.jpg">
		<meta property="og:title" content="Voronoi Noise">
		<meta property="og:description" content="A Unity C# Pseudorandom Noise tutorial about generating various flavors of Voronoi noise.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Voronoi Noise</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/pseudorandom-noise/voronoi-noise/#article",
				"headline": "Voronoi Noise",
				"alternativeHeadline": "Worley and Chebyshev",
				"datePublished": "2021-08-02",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity C# Pseudorandom Noise tutorial about generating various flavors of Voronoi noise.",
				"image": "https://catlikecoding.com/unity/tutorials/pseudorandom-noise/voronoi-noise/tutorial-image.jpg",
				"dependencies": "Unity 2020.3.12f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/pseudorandom-noise/", "name": "Pseudorandom Noise" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				Chebyshev: 1,
				D: 1,
				G: 1,
				HashJob: 1,
				HashVisualization: 1,
				F: 1,
				F1: 1,
				F2: 1,
				F2MinusF1: 1,
				IGradient: 1,
				ILattice: 1,
				INoise: 1,
				IShape: 1,
				IVoronoiDistance: 1,
				IVoronoiFunction: 1,
				Job: 1,
				L: 1,
				Lattice1D: 1,
				Lattice2D: 1,
				Lattice3D: 1,
				LatticeNormal : 1,
				LatticeSpan4 : 1,
				LatticeTiling : 1,
				MathExtensions: 1,
				N: 1,
				Noise: 1,
				NoiseType: 1,
				NoiseVisualization: 1,
				Perlin: 1,
				Plane : 1,
				Point4: 1,
				S: 1,
				ScheduleDelegate: 1,
				Settings: 1,
				Shape: 1,
				Shapes: 1,
				SmallXXHash: 1,
				SmallXXHash4: 1,
				SpaceTRS: 1,
				Sphere: 1,
				Torus: 1,
				Turbulence: 1,
				Value: 1,
				Visualization: 1,
				Voronoi1D : 1,
				Voronoi2D : 1,
				Voronoi3D : 1,
				Worley: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Pseudorandom Noise</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Voronoi Noise</h1>
					<p>Worley and Chebyshev</p>
					<ul>
						<li>Place cell points inside the lattice grid.</li>
						<li>Find the distance to the nearest point.</li>
						<li>Also find the distance to the second-nearest point.</li>
						<li>Support different functions and distance metrics.</li>
					</ul>
				</header>
				
				<p>This is the sixth tutorial in a series about <a href="../index.html">pseudorandom noise</a>. It introduces various flavors of Voronoi noise.</p>
				
				<p>This tutorial is made with Unity 2020.3.12f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>A sphere showing 3D Voronoi Worley F2 &minus; F1 noise.</figcaption>
				</figure>
				
				<section>
					<h2>Distance to Nearest Point</h2>
					
					<p>Besides value and gradient noise there is a third common type of noise. It is based on populating space with arbitrary points and finding the distance to the nearest point. The resulting pattern looks like a Voronoi diagram&mdash;space filled with convex polygonal cells&mdash;hence it is known as Voronoi or cell noise. This type of noise was first introduced by Steven Worley, hence it is also known as Worley noise.</p>
					
					<section>
						<h3>Voronoi Noise Type</h3>
						
						<p>To support Voronoi noise we'll create a new partial <code>Noise</code> class in a separate <em>Noise.Voronoi</em> asset, containing 1D, 2D, and 3D implementations of <code>INoise</code>. Although it isn't technically lattice noise we'll use the lattice grid to generate the arbitrary points, so make all implementations use a generic <code>ILattice</code> to get lattice spans for all their dimensions. Besides that they'll all initially return zero.</p>
						
						<pre><ins>using Unity.Mathematics;</ins>

<ins>using static Unity.Mathematics.math;</ins>

<ins>public static partial class Noise {</ins>

	<ins>public struct Voronoi1D&lt;L> : INoise where L : struct, ILattice {</ins>

		<ins>public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {</ins>
			<ins>LatticeSpan4 x = default(L).GetLatticeSpan4(positions.c0, frequency);</ins>

			<ins>return 0f;</ins>
		<ins>}</ins>
	<ins>}</ins>

	<ins>public struct Voronoi2D&lt;L> : INoise where L : struct, ILattice {</ins>

		<ins>public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {</ins>
			<ins>var l = default(L);</ins>
			<ins>LatticeSpan4</ins>
				<ins>x = l.GetLatticeSpan4(positions.c0, frequency),</ins>
				<ins>z = l.GetLatticeSpan4(positions.c2, frequency);</ins>

			<ins>return 0f;</ins>
		<ins>}</ins>
	<ins>}</ins>

	<ins>public struct Voronoi3D&lt;L> : INoise where L : struct, ILattice {</ins>

		<ins>public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {</ins>
			<ins>var l = default(L);</ins>
			<ins>LatticeSpan4</ins>
				<ins>x = l.GetLatticeSpan4(positions.c0, frequency),</ins>
				<ins>y = l.GetLatticeSpan4(positions.c1, frequency),</ins>
				<ins>z = l.GetLatticeSpan4(positions.c2, frequency);</ins>

			<ins>return 0f;</ins>
		<ins>}</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>To support visualizing the noise, add both regular and tiling versions of all Voronoi versions to the noise jobs array in <code>NoiseVisualization</code>.</p>
						
						<pre>	static ScheduleDelegate[,] noiseJobs = {
		{ &hellip; },
		{ &hellip; },
		{ &hellip; },
		{ &hellip; }<ins>,</ins>
		<ins>{</ins>
			<ins>Job&lt;Voronoi1D&lt;LatticeNormal>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi1D&lt;LatticeTiling>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi2D&lt;LatticeNormal>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi2D&lt;LatticeTiling>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi3D&lt;LatticeNormal>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi3D&lt;LatticeTiling>>.ScheduleParallel</ins>
		<ins>}</ins>
	};</pre>
						
						<p>And include an entry for it in the <code>NoiseType</code> enum.</p>
						
						<pre>	public enum NoiseType { Perlin€, PerlinTurbulence, Value€, ValueTurbulence<ins>, Voronoi</ins> }</pre>
						
					</section>
					
					<section>
						<h3>1D Distances</h3>
						
						<p>We'll begin with the simplest case, which is 1D Voronoi noise. Like the other 1D noise types it isn't very useful, but it is easiest to understand so makes a good starting point.</p>
						
						<p>The idea of Voronoi noise is that space is somehow filled with an arbitrary amount of points. The noise function is equal to the distance to the nearest point anywhere. Technically the amount of points to check is infinite, but we only need to know the nearest one. To make it possible to compute the noise we'll limit ourselves to a single arbitrary point per span.</p>
						
						<p>Each span covers a single unit of space. We can put a point somewhere inside it by using <code>Floats01A</code> from the hash of that span. The distance from the sample position to that point is then equal to the absolute difference of their offsets inside the span. The sample offset inside the span is equal to <code>g0</code>, so subtract it from <code>Floats01A</code> and pass that through the <code>abs</code> method.</p>
						
						<pre>	public struct Voronoi1D<L> : INoise where L : struct, ILattice {
		
		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			LatticeSpan4 x = default(L).GetLatticeSpan4(positions.c0, frequency);

			<ins>SmallXXHash4 h = hash.Eat(x.p0);</ins>
			return <ins>abs(h.Floats01A - x.g0)</ins>;
		}
	}</pre>
						
						<figure>
							<img src="distance-to-nearest-point/1d-distances-inside-span.png" width="410" height="60">
							<figcaption>Distances inside spans; 1 octave; frequency 4.</figcaption>
						</figure>
						
						<p>The result is a sequence of wedges or linear ramps, one per span, based on where inside each span the Voronoi point lies. The minimum of each ramp or wedge is always zero, which indicates the location of the Voronoi point. The maximum possible distance is 1, which is only reached if the Voronoi point lies on an edge of a span. So like the turbulence noise variants the amplitude range of the noise is 0&ndash;1.</p>
						
					</section>
					
					<section>
						<h3>Incorporating Adjacent Spans</h3>
						
						<p>The noise is currently discontinuous because we only consider the single point inside each span. But often a Voronoi point of an adjacent span lies closer to the sample position than the point inside the current span. So to get the correct distance we have to calculate the distances to the Voronoi points in the adjacent spans as well and pick the minimum.</p>
						
						<p>To get the correct vectorized minima we have to invoke the <code>select</code> method. To make this convenient introduce a static vectorized <code>UpdateVoronoiMinima</code> method directly inside <em>Noise.Voronoi</em>. It takes the current minima and a new set of distances as input and returns the updated minima.</p>
						
						<pre>	<ins>static float4 UpdateVoronoiMinima (float4 minima, float4 distances) {</ins>
		<ins>return select(minima, distances, distances < minima);</ins>
	<ins>}</ins></pre>
						
						<p>Now change <code>Voronoi1D.GetNoise4</code> so it loops through three spans with an offset of &minus;1, 0, and 1, calculates the distance to the point in each span, and updates the minima each time. The initial minima before the loop must be invalid for this to work. As the theoretical maximum distance to the nearest point is 1 any greater initial value will do. Let's use 2.</p>
						
						<pre>		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			LatticeSpan4 x = default(L).GetLatticeSpan4(positions.c0, frequency);

			<ins>float4 minima = 2f;</ins>
			<ins>for (int u = -1; u &lt;= 1; u++) {</ins>
				SmallXXHash4 h = hash.Eat(x.p0 + u);
				<ins>minima = UpdateVoronoiMinima(minima,</ins> abs(h.Floats01A <ins>+ u</ins> - x.g0)<ins>);</ins>
			<ins>}</ins>
			return <ins>minima</ins>;
		}</pre>
						
						<figure>
							<img src="distance-to-nearest-point/1d-voronoi.png" width="410" height="60">
							<figcaption>Minima across spans.</figcaption>
						</figure>
						
						<p>Now we have correct 1D Voronoi noise.</p>
						
						<aside>
							<h3>Do we always have to evaluate all three spans?</h3>
							<div>
								<p>It is possible to sometimes avoid evaluating one or even both adjacent spans. If the distance to the relevant span's nearest edge exceeds the current distance then that span can never contain a nearer point so it can be skipped. However, this has to be determined on a per-sample basis so doesn't work well with vectorization. Only if the criteria are met for all four sample positions can a span be skipped. So we'd have to add code to check this and add logic to conditionally evaluate spans, which is a lot more complex and also slower than a simple loop. So we rely on straightforward brute-force vectorization to make it fast and always get the same performance, instead of trying to avoid work some of the time.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Tiling</h3>
						
						<p>A consequence of having to include adjacent spans in our calculations is that tiling no longer works, because the adjacent spans can extend beyond the tiling region.</p>
						
						<figure>
							<img src="distance-to-nearest-point/tiling-incorrect.png" width="410" height="60">
							<figcaption>Incorrect tiling; frequency 2; domain scale 4.</figcaption>
						</figure>
						
						<p>To fix this we also have to apply tiling to the offset spans. Because we're either subtracting or adding 1 to the already tiled lattice coordinate, we only have to check two edge cases. We'll do both via a new <code>ValidateSingleStep</code> method signature that we add to the <code>ILattice</code> interface. It has the already-offset points and the frequency as parameters and returns the validated points. Note that the assumption of this method is that the input points are already correctly tiled and then had either &minus;1, 0, or 1 added to them.</p>
						
						<pre>	public interface ILattice {
		LatticeSpan4 GetLatticeSpan4 (float4 coordinates, int frequency);

		<ins>int4 ValidateSingleStep (int4 points, int frequency);</ins>
	}</pre>
						
						<p>If we aren't tiling then the implementation of this method simply returns the same points.</p>
						
						<pre>	public struct LatticeNormal : ILattice {

		&hellip;

		<ins>public int4 ValidateSingleStep (int4 points, int frequency) => points;</ins>
	}</pre>
						
						<p>If tiling is used then there are two possible cases that need adjustment. First, if an offset point is equal to the frequency then it is now one step too far and has to loop back to zero.</p>
						
						<pre>	public struct LatticeTiling : ILattice {

		&hellip;

		<ins>public int4 ValidateSingleStep (int4 points, int frequency) =></ins>
			<ins>select(points, 0, points == frequency);</ins>
	}</pre>
						
						<p>Second, if an offset point is equal to &minus;1 it has to loop to the maximum side, becoming equal to the frequency minus 1.</p>
						
						<pre>		public int4 ValidateSingleStep (int4 points, int frequency) =>
			<ins>select(</ins>select(points, 0, points == frequency)<ins>, frequency - 1, points == -1)</ins>;</pre>
						
						<p>Now we can make <code>Voronoi1D.GetNoise4</code> tile correctly by passing the offset lattice point through <code>ValidateSingleStep</code> before feeding it to the hash inside the loop.</p>
						
						<pre>		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			<ins>var l = default(L);</ins>
			LatticeSpan4 x = <ins>l</ins>.GetLatticeSpan4(positions.c0, frequency);

			float4 minima = 2f;
			for (int u = -1; u &lt;= 1; u++) {
				SmallXXHash4 h = hash.Eat(<ins>l.ValidateSingleStep(</ins>x.p0 + u<ins>, frequency)</ins>);
				minima = UpdateVoronoiMinima(minima, abs(h.Floats01A + u - x.g0));
			}
			return minima;
		}</pre>
						
						<figure>
							<img src="distance-to-nearest-point/tiling-correct.png" width="410" height="60">
							<figcaption>Correct tiling.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>2D Distances</h3>
						
						<p>To find the shortest distance in two dimensions we need to apply the Pythagorean theorem. Let's put a convenient static <code>GetDistance</code> method inside <em>Noise.Voronoi</em> to do this for two vectorized X and Y relative coordinate offsets.</p>
						
						<pre>	<ins>static float4 GetDistance (float4 x, float4 y) => sqrt(x * x + y * y);</ins></pre>
						
						<aside>
							<h3>Can't we delay the square root calculation until later?</h3>
							<div>
								<p>Yes, we'll use that optimization later in this tutorial.</p>
							</div>
						</aside>
						
						<p>We begin the creation of 2D Voronoi noise by copying the loop for 1D noise and putting it inside <code>Voronoi2D.GetNoise4</code>.</p>
						
						<pre>	public struct Voronoi2D&lt;L> : INoise where L : struct, ILattice {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			var l = default(L);
			LatticeSpan4
				x = l.GetLatticeSpan4(positions.c0, frequency),
				z = l.GetLatticeSpan4(positions.c2, frequency);

			<ins>float4 minima = 2f;</ins>
			<ins>for (int u = -1; u &lt;= 1; u++) {</ins>
				<ins>SmallXXHash4 h = hash.Eat(l.ValidateSingleStep(x.p0 + u, frequency));</ins>
				<ins>minima = UpdateVoronoiMinima(minima, abs(h.Floats01A + u - x.g0));</ins>
			<ins>}</ins>
			<ins>return minima;</ins>
		}
	}</pre>
						
						<p>To incorporate the Z dimension we have to loop through it as well, once per X offset, so we end up with a nested loop, evaluating a total of nine lattice squares. Feed the offset Z lattice point to the hash and find the distance by applying both a X offset and a Z offset.</p>
						
						<pre>			float4 minima = 2f;
			for (int u = -1; u <= 1; u++) {
				SmallXXHash4 <ins>hx</ins> = hash.Eat(l.ValidateSingleStep(x.p0 + u, frequency));
				<ins>float4 xOffset = u - x.g0;</ins>
				<ins>for (int v = -1; v &lt;= 1; v++) {</ins>
					<ins>SmallXXHash4 h = hx.Eat(l.ValidateSingleStep(z.p0 + v, frequency));</ins>
					<ins>float4 zOffset = v - z.g0;</ins>
					minima = UpdateVoronoiMinima(minima, <ins>GetDistance(</ins>
						<ins>h.Floats01A + xOffset, h.Floats01D + zOffset</ins>
					<ins>)</ins>);
				<ins>}</ins>
			}
			return minima;</pre>
						
						<figure>
							<img src="distance-to-nearest-point/2d-voronoi.png" width="220" height="220" alt="1 octave">
							<img src="distance-to-nearest-point/2d-voronoi-2-octaves.png" width="220" height="220" alt="2 octaves">
							<figcaption>One and two octaves 2D Voronoi noise.</figcaption>
						</figure>
						
						<p>2D Voronoi noise looks like a Voronoi diagram, with each cell containing a circular gradient increasing from zero at the cell's point to its maximum at the cell's edge. The edges are always equidistant from at least two cell points.</p>
						
						<p>The maximum value of the noise is equal to the maximum distance that any sample point could be from a cell point. At its most extreme this is a sample point at the corner of a lattice square, with the nearest cell point in the diagonally opposite corner of the four cells surrounding the sample point. Hence the maximum amplitude of the noise is &radic;2.</p>
						
						<figure>
							<img src="distance-to-nearest-point/maximum-distance-visualization.png" width="170" height="170">
							<figcaption>Maximum distance visualization; big circle indicates distances up to 1.</figcaption>
						</figure>
						
						<p>Although &radic;2 is the theoretical maximum encountering it would be extremely rare. Most distances end up less than 1, but it is fairly common that they exceed 1. We can visualize this by returning the 1 threshold of the minima.</p>
						
						<pre>			return <ins>select(0f, 1f,</ins> minima <ins>> 1f)</ins>;</pre>
						
						<figure>
							<img src="distance-to-nearest-point/2d-f32-normal.png" width="220" height="220" alt="normal">
							<img src="distance-to-nearest-point/2d-f32-exceeding-1.png" width="220" height="220" alt="exceeding 1">
							<figcaption>Frequency 32, normal visualization and exceeding 1.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Two points per Lattice Square</h3>
						
						<p>A problem of allowing distances that exceed 1 is that it would mean that the nearest cell point could end up in a cell with an offset greater than one. We currently do not take this into consideration, which means that we have potential discontinuities in the noise, where adjacent lattice squares disagree about the nearest point.</p>
						
						<figure>
							<img src="distance-to-nearest-point/potential-nearest-point.png" width="380" height="380">
							<figcaption>Potential locations for nearest cell point in dark square; red for corners; blue for edge midpoints.</figcaption>
						</figure>
						
						<p>So the only way to guarantee artifact-free noise would be to evaluate up to 21 cells, which is not practical. However, this is only required when distances exceed one, which is uncommon. But we don't want the noise to exceed one, its range should be 0&ndash;1. So the practical solution is to clamp the noise so it never exceeds one.</p>
						
						<figure>
							<img src="distance-to-nearest-point/potential-nearest-point-clamped.png" width="240" height="240">
							<figcaption>Potential locations for nearest cell point up to distance 1.</figcaption>
						</figure>
						
						<p>The downside of limiting the amplitude to 1 is that our noise will contain small regions where it becomes flat uniform 1. Although we cannot completely eliminate these regions we can make them extremely rare by increasing the amount of cell points per lattice square from one to two. We can do this by updating the minima twice per lattice square instead of just once, taking advantage of the fact that we can extract four values from the hash.</p>
						
						<pre>			for (int u = -1; u &lt;= 1; u++) {
				SmallXXHash4 hx = hash.Eat(l.ValidateSingleStep(x.p0 + u, frequency));
				float4 xOffset = u - x.g0;
				for (int v = -1; v &lt;= 1; v++) {
					SmallXXHash4 h = hx.Eat(l.ValidateSingleStep(z.p0 + v, frequency));
					float4 zOffset = v - z.g0;
					minima = UpdateVoronoiMinima(minima, GetDistance(
						h.Floats01A + xOffset, h.<ins>Floats01B</ins> + zOffset
					));
					<ins>minima = UpdateVoronoiMinima(minima, GetDistance(</ins>
						<ins>h.Floats01C + xOffset, h.Floats01D + zOffset</ins>
					<ins>));</ins>
				}
			}
			return <ins>minima</ins>;</pre>
						
						<figure>
							<img src="distance-to-nearest-point/2d-two-points.png" width="220" height="220" alt="1 octave">
							<img src="distance-to-nearest-point/2d-two-points-2-octaves.png" width="220" height="220" alt="2 octaves">
							<figcaption>Two points per square; one and two octaves.</figcaption>
						</figure>
						
						<p>This makes the noise more compact and practically eliminates the flat regions. The final step is to guarantee that the final result never exceeds 1, in case we do encounter a flat region.</p>
						
						<pre>			return <ins>min(</ins>minima<ins>, 1f)</ins>;</pre>
					</section>
					
					<section>
						<h3>3D Distances</h3>
						
						<p>The same approach to expand 1D noise to 2D noise can be used to create to 3D noise. Begin by introducing a 3D variant of the <code>GetDistance</code> method.</p>
						
						<pre>	<ins>static float4 GetDistance (float4 x, float4 y, float4 z) =></ins>
		<ins>sqrt(x * x + y * y + z * z);</ins></pre>
						
						<aside>
							<h3>Does the Pythagorean theorem work for three dimensions?</h3>
							<div>
								<p>Yes. To see this, first reduce the distance calculation to a single dimension: `d_1=|x|=sqrt(x^2)`.</p>
								
								<p>If we go from a single to two dimensions, the 2D distance can be found by forming a triangle by adding the second dimension: `d_2=sqrt(d_1^2+y^2)=sqrt(sqrt(x^2)^2+y^2)=sqrt(x^2+y^2)`.</p>
								
								<p>Going from two to three dimensions adds a third dimension on top of that, forming a triangle on top of the 2D hypotenuse: `d_3=sqrt(d_2^2+z^2)=sqrt(sqrt(x^2+y^2)^2+z^2)=sqrt(x^2+y^2+z^2)`.</p>
								
								<p>This is also true for still higher dimensions. In general, `d_n=sqrt(c_1^2+...+c_n^2)=sqrt(sum_(i=1)^nc_i^2)`.</p>
							</div>
						</aside>
						
						<p>Then fill <code>Voronoi3D.GetNoise4</code> with a triple loop, initially updating the minima once per lattice cube, thus 27 times.</p>
						
						<pre>	public struct Voronoi3D&lt;L> : INoise where L : struct, ILattice {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			var l = default(L);
			LatticeSpan4
				x = l.GetLatticeSpan4(positions.c0, frequency),
				y = l.GetLatticeSpan4(positions.c1, frequency),
				z = l.GetLatticeSpan4(positions.c2, frequency);

			<ins>float4 minima = 2f;</ins>
			<ins>for (int u = -1; u &lt;= 1; u++) {</ins>
				<ins>SmallXXHash4 hx = hash.Eat(l.ValidateSingleStep(x.p0 + u, frequency));</ins>
				<ins>float4 xOffset = u - x.g0;</ins>
				<ins>for (int v = -1; v &lt;= 1; v++) {</ins>
					<ins>SmallXXHash4 hy = hx.Eat(l.ValidateSingleStep(y.p0 + v, frequency));</ins>
					<ins>float4 yOffset = v - y.g0;</ins>
					<ins>for (int w = -1; w &lt;= 1; w++) {</ins>
						<ins>SmallXXHash4 h =</ins>
							<ins>hy.Eat(l.ValidateSingleStep(z.p0 + w, frequency));</ins>
						<ins>float4 zOffset = w - z.g0;</ins>
						<ins>minima = UpdateVoronoiMinima(minima, GetDistance(</ins>
							<ins>h.Floats01A + xOffset,</ins>
							<ins>h.Floats01B + yOffset,</ins>
							<ins>h.Floats01C + zOffset</ins>
						<ins>));</ins>
					<ins>}</ins>
				<ins>}</ins>
			<ins>}</ins>
			<ins>return min(minima, 1f);</ins>
		}
	}</pre>
						
						<figure>
							<img src="distance-to-nearest-point/3d-f32-normal.png" width="220" height="220" alt="normal">
							<img src="distance-to-nearest-point/3d-f32-exceeding-1.png" width="220" height="220" alt="exceeding 1">
							<figcaption>Frequency 32 3D noise on a plane, normal and exceeding 1.</figcaption>
						</figure>
						
						<p>This gets us 3D Voronoi noise, which has the same problems as the 2D versions, but with a theoretical maximum amplitude of &radic;3. We'll again drastically reduce the likelihood of the minima exceeding 1 by using two points per lattice cube. However, because we require three values to generate a cell point in 3D we need to extract six values from the hash in total. So the currently available A, B, C, and D values do not suffice.</p>
						
					</section>
					
					<section>
						<h3>Six Values Per Hash</h3>
						
						<p>We could add more explicit methods to <code>SmallXXHash4</code> to support extracting six values from it, but that would clutter the class. So we'll instead give it general-purpose value extraction methods. The first is a <code>GetBits</code> method that returns a configurable amount of bits, shifted by a configurable amount of steps. The result is found by first right-shifting by the desired amount and then masking the result to limit it to the desired bit count. The mask is found by left-shifting 1 by the count and then subtracting one.</p>
						
						<pre>	<ins>public uint4 GetBits (int count, int shift) =></ins>
		<ins>((uint4)this >> shift) &amp; (uint)((1 &lt;&lt; count) - 1);</ins></pre>
						
						<aside>
							<h3>How does the generation of the bit mask work?</h3>
							<div>
								<p>Left-shifting 1 by `s` steps is equivalent to `2^s`. For example, shifting <code>1b</code> by three yields <code>1000b</code> which is `2^3=8`. Subtracting one reduces it to seven, which is <code>111b</code> which when used as a bit mask eliminates everything but the three least-significant bits.</p>
							</div>
						</aside>
						
						<p>Also add an accompanying <code>GetBitsAsFloats01</code> method that converts the bits to 0&ndash;1 values via a cast and appropriate scaling.</p>
						
						<pre>	<ins>public float4 GetBitsAsFloats01 (int count, int shift) =></ins>
		<ins>(float4)GetBits(count, shift) * (1f / ((1 &lt;&lt; count) - 1));</ins></pre>
						
					</section>
					
					<section>
						<h3>Two Points Per Lattice Cube</h3>
						
						<p>Now we can extract six values from the hash in <code>Voronoi3D.GetNoise4</code>. 32 divided by 6 rounded down equals 5, so we'll use five bits per coordinate, leaving 2 bits unused. This means that each coordinate has only `2^5=32` possible values instead of `2^8=256`, but that's still enough to create acceptable noise.</p>
						
						<pre>						SmallXXHash4 h =
							hv.Eat(l.ValidateSingleStep(z.p0 + w, frequency));
						float4 wOffset = w - z.g0;
						minima = UpdateVoronoiMinima(minima, GetDistance(
							h.<ins>GetBitsAsFloats01(5, 0)</ins> + xOffset,
							h.<ins>GetBitsAsFloats01(5, 5)</ins> + yOffset,
							h.<ins>GetBitsAsFloats01(5, 10)</ins> + zOffset
						));
						<ins>minima = UpdateVoronoiMinima(minima, GetDistance(</ins>
							<ins>h.GetBitsAsFloats01(5, 15) + xOffset,</ins>
							<ins>h.GetBitsAsFloats01(5, 20) + yOffset,</ins>
							<ins>h.GetBitsAsFloats01(5, 25) + zOffset</ins>
						<ins>));</ins></pre>
						
						<figure>
							<img src="distance-to-nearest-point/3d-sphere-1o-positive.png" width="280" height="280" alt="1 octave positive">
							<img src="distance-to-nearest-point/3d-sphere-2o-positive.png" width="280" height="280" alt="2 octaves positive">
							<img src="distance-to-nearest-point/3d-sphere-1o-negative.png" width="280" height="280" alt="1 octave negative">
							<img src="distance-to-nearest-point/3d-sphere-2o-negative.png" width="280" height="280" alt="2 octaves negative">
							<figcaption>One and two octaves frequency 6 3D Voronoi noise; positive and negative displacement.</figcaption>
						</figure>
						
						<p>Note that when 3D Voronoi noise is projected on an axis-aligned plane it looks quite different than 2D Voronoi noise. The cell points from the 3D version most likely don't lie exactly on the plane, so the gradients inside most visible cells doesn't reach zero.</p>
						
						<figure>
							<img src="distance-to-nearest-point/3d-voronoi.png" width="220" height="220" alt="1 octave">
							<img src="distance-to-nearest-point/3d-voronoi-2-octaves.png" width="220" height="220" alt="2 octaves">
							<figcaption>One and two octaves 3D Voronoi noise.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Distance to Second-Nearest Point</h2>
					
					<p>We don't need to limit ourselves to only considering the distance to the nearest cell point. There is also a second-nearest point, a third-nearest, and so on. Using those distances would produce different patterns. Of course distances to points further away are longer, so the average noise value will be higher and clamped flat regions will be more common. So we'll include the second-nearest distance only.</p>
					
					<section>
						<h3>Tracking Two Minima</h3>
						
						<p>To find the second-nearest distance we also need to know the nearest distance, so we'll have to keep track of two minima per sample point instead  of just one. Adjust <code>UpdateVoronoiMinima</code> so it accepts and return a <code>float4x2</code> minima value. Its first vector contains the closest and its second vector contains the second-closest distances. This requires us to rewrite the code of this method, initially returning the minima unchanged.</p>
						
						<pre>	static <ins>float4x2</ins> UpdateVoronoiMinima (<ins>float4x2</ins> minima, float4 distances) {
		return <ins>minima</ins>;
	}</pre>
						
						<p>The first step is to update the true minima as before, now contained in <code>c0</code>. Store the distance check for new minima in a boolean vector variable for convenience, as we'll have to check it twice for each minima vector.</p>
						
						<pre>	static float4x2 UpdateVoronoiMinima (float4x2 minima, float4 distances) {
		<ins>bool4 newMinimum = distances &lt; minima.c0;</ins>
		<ins>minima.c0 = select(minima.c0, distances, newMinimum);</ins>
		return minima;
	}</pre>
						
						<p>If there is a new minimum then the old minimum becomes the secondary minimum. So <code>c1</code> has to be updated before <code>c0</code>.</p>
						
						<pre>		bool4 newMinimum = distances < minima.c0;
		<ins>minima.c1 = select(minima.c1, minima.c0, newMinimum);</ins>
		minima.c0 = select(minima.c0, distances, newMinimum);</pre>
						
						<p>Besides that, it is also possible that a new distance doesn't provide a new primary minima but does provide a new secondary minima, so check for that as well.</p>
						
						<pre>		minima.c1 = select(
			<ins>select(</ins>minima.c1<ins>, distances, distances < minima.c1)</ins>,
			minima.c0,
			newMinimum
		);</pre>
						
						<p>We have to adjust <code>Voronoi1D.GetNoise4</code> so it uses the new double-minima type. To keep the noise the same use <code>c0</code> as the final result. This will produce the same code as before, as the unused secondary minima will be optimized away by <em>Burst</em>.</p>
						
						<pre>			<ins>float4x2</ins> minima = 2f;
			for (int u = -1; u &lt;= 1; u++) {
				SmallXXHash4 h = hash.Eat(l.ValidateSingleStep(x.p0 + u, frequency));
				minima = UpdateVoronoiMinima(minima, abs(h.Floats01A + u - x.g0));
			}
			return minima<ins>.c0</ins>;</pre>
						
						<p>Do the same for <code>Voronoi2D</code> and <code>Voronoi3D</code>.</p>
						
						<pre>			<ins>float4x2</ins> minima = 2f;
			&hellip;
			return min(minima<ins>.c0</ins>, 1f);
						
					</section>
					
					<section>
						<h3>Voronoi Functions</h3>
						
						<p>The specific result that we use for Voronoi noise is usually known as its function. The function that shows the distance to the nearest cell point is named F1. The distance to the second-nearest point is named F2, and so on. To support easy application of these functions we'll introduce an <code>IVoronoiFunction</code> interface with a single <code>Evaluate</code> method that takes a double-minima vector and produces a single-vector result. Put it in a new <em>Noise.Voronoi.Function</em> partial <code>Noise</code> class asset.</p>
						
						<pre><ins>using Unity.Mathematics;</ins>

<ins>public static partial class Noise {</ins>

	<ins>public interface IVoronoiFunction {</ins>
		<ins>float4 Evaluate (float4x2 minima);</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>Then add <code>F1</code> and <code>F2</code> structs that implement the interface, simply returning either <code>c0</code> or <code>c1</code>.</p>
						
						<pre>	<ins>public struct F1 : IVoronoiFunction {</ins>

		<ins>public float4 Evaluate (float4x2 distances) => distances.c0;</ins>
	<ins>}</ins>

	<ins>public struct F2 : IVoronoiFunction {</ins>

		<ins>public float4 Evaluate (float4x2 distances) => distances.c1;</ins>
	<ins>}</ins></pre>
						
						<p>The next step is to make the Voronoi structs use these functions. Add a generic type parameter for <code>IVoronoiFunction</code> to <code>Voronoi1D</code> and use it to evaluate the minima.</p>
						
						<pre>	public struct Voronoi1D&lt;L<ins>, F</ins>> : INoise
		where L : struct, ILattice <ins>where F : struct, IVoronoiFunction</ins> {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			&hellip;
			return <ins>default(F).Evaluate(minima)</ins>;
		}
	}</pre>
						
						<p>Do the same for <code>Voronoi2D</code>, also clamping the minima vectors before evaluating the final result.
						
						<pre>	public struct Voronoi2D&lt;L<ins>, F</ins>> : INoise
		where L : struct, ILattice <ins>where F : struct, IVoronoiFunction</ins> {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			&hellip;
			<ins>minima.c0 = min(minima.c0, 1f);</ins>
			<ins>minima.c1 = min(minima.c1, 1f);</ins>
			return <ins>default(F).Evaluate(minima)</ins>;
		}
	}</pre>
						
						<p>Adjust <code>Voronoi3D</code> in the same way. Then adjust the job array in <code>NoiseVisualization</code> so it contains Voronoi versions for both F1 and F2.</p>
						
						<pre>		{
			Job&lt;Voronoi1D&lt;LatticeNormal<ins>, F1</ins>>>.ScheduleParallel,
			Job&lt;Voronoi1D&lt;LatticeTiling<ins>, F1</ins>>>.ScheduleParallel,
			Job&lt;Voronoi2D&lt;LatticeNormal<ins>, F1</ins>>>.ScheduleParallel,
			Job&lt;Voronoi2D&lt;LatticeTiling<ins>, F1</ins>>>.ScheduleParallel,
			Job&lt;Voronoi3D&lt;LatticeNormal<ins>, F1</ins>>>.ScheduleParallel,
			Job&lt;Voronoi3D&lt;LatticeTiling<ins>, F1</ins>>>.ScheduleParallel
		}<ins>,</ins>
		<ins>{</ins>
			<ins>Job&lt;Voronoi1D&lt;LatticeNormal, F2>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi1D&lt;LatticeTiling, F2>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi2D&lt;LatticeNormal, F2>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi2D&lt;LatticeTiling, F2>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi3D&lt;LatticeNormal, F2>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi3D&lt;LatticeTiling, F2>>.ScheduleParallel</ins>
		<ins>}</ins></pre>
						
						<p>Finally, replace the single Voronoi element of <code>NoiseType</code> with two elements, for F1 and F2.</p>
						
						<pre>	public enum NoiseType {
		Perlin€, PerlinTurbulence, Value€, ValueTurbulence, <ins>VoronoiF1, VoronoiF2</ins>
	}</pre>
						
						<figure>
							<img src="distance-to-nearest-point/1d-voronoi.png" width="410" height="60" alt="F1">
							<img src="distance-to-second-nearest-point/1d-f2.png" width="410" height="70" alt="F2">
							<figcaption>1D Voronoi F1 and F2.</figcaption>
						</figure>
						
						<figure>
							<img src="distance-to-nearest-point/2d-two-points.png" width="220" height="220" alt="F1">
							<img src="distance-to-second-nearest-point/2d-f2.png" width="220" height="220" alt="F2">
							<figcaption>2D Voronoi F1 and F2.</figcaption>
						</figure>
						
						<figure>
							<img src="distance-to-nearest-point/3d-sphere-1o-positive.png" width="280" height="280" alt="F1 positive">
							<img src="distance-to-second-nearest-point/3d-f2.png" width="280" height="280" alt="F2 positive">
							<figcaption>3D Voronoi F1 and F2.</figcaption>
						</figure>
						
						<p>The results of F2 show the same Voronoi cells as F1, but the directions of the gradients are reversed. Also, the cells are partitioned into gradients with different orientations, because different regions of a cell have different nearest cell neighbors.</p>
						
					</section>
					
					<section>
						<h3>F2 Minus F1</h3>
						
						<p>We don't have to limit ourselves to using either F1 or F2 exclusively, we can also use a function that combines them in some way. The most interesting variant is F2 &minus; F1. Create an <code>IVoronoiFunction</code> for it in <em>Noise.Voronoi.Function</em>.</p>
						
						<pre>	<ins>public struct F2MinusF1 : IVoronoiFunction {</ins>

		<ins>public float4 Evaluate (float4x2 distances) => distances.c1 - distances.c0;</ins>
	<ins>}</ins></pre>
						
						<p>Add it to the job array in <code>NoiseVisualization</code>.</p>
						
						<pre>		{
			&hellip;
			Job&lt;Voronoi3D&lt;LatticeTiling, F2>>.ScheduleParallel
		}<ins>,</ins>
		<ins>{</ins>
			<ins>Job&lt;Voronoi1D&lt;LatticeNormal, F2MinusF1>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi1D&lt;LatticeTiling, F2MinusF1>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi2D&lt;LatticeNormal, F2MinusF1>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi2D&lt;LatticeTiling, F2MinusF1>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi3D&lt;LatticeNormal, F2MinusF1>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi3D&lt;LatticeTiling, F2MinusF1>>.ScheduleParallel</ins>
		<ins>}</ins></pre>
						
						<p>And include it in <em>NoiseType</em>.</p>
						
						<pre>	public enum NoiseType {
		Perlin€, PerlinTurbulence, Value€, ValueTurbulence,
		VoronoiF1, VoronoiF2<ins>, VoronoiF2MinusF1</ins>
	}</pre>
						
						<figure>
							<img src="distance-to-second-nearest-point/1d-f2-f1.png" width="410" height="70" alt="1D"><br>
							<img src="distance-to-second-nearest-point/2d-f2-f1.png" width="220" height="220" alt="2D"><br>
							<img src="distance-to-second-nearest-point/3d-f2-f1.png" width="280" height="280" alt="3D">
							<figcaption>1D, 2D, and 3D Voronoi F2 &minus; F1.</figcaption>
						</figure>
						
						<p>F2 &minus; F1 produces a strongly segmented pattern, which looks somewhat like angular cobblestones. This happens because F1 and F2 are equal along cell edges, while F2 always exceeds F1 inside cells. Thus the result is guaranteed to lie in the 0&ndash;1 range.</p>
						
						<p>Note that this function doesn't produce perfect outlines. The strength of the gradient inside a cell depends on how close to a cell edge its point lies.</p>
						
						<aside>
							<h3>Is it possible to create perfectly uniform cell outlines?</h3>
							<div>
								<p>Yes, but it requires a secondary search for distances and cannot be solved with a variant Voronoi function. This works for 2D noise but not for 3D noise, because cell faces can end up significantly aligned with the sample surface, resulting in a region that consists mostly of the outline.</p>
							</div>
						</aside>
					</section>
				</section>
				
				<section>
					<h2>Distance Metrics</h2>
					
					<p>Besides changing the function of the Voronoi noise it is also possible to determine distances in different ways, because standard Euclidean distance isn't the only option.</p>
					
					<section>
						<h3>Voronoi Distance Interface</h3>
						
						<p>To support multiple distance metrics we'll introduce the <code>IVoronoiDistance</code> interface, in a new <em>Noise.Voronoi.Distance</em> partial <code>Noise</code> class asset. Give it three <code>GetDistance</code> methods, for 1D, 2D, and 3D.</p>
						
						<pre><ins>using Unity.Mathematics;</ins>

<ins>using static Unity.Mathematics.math;</ins>

<ins>public static partial class Noise {</ins>

	<ins>public interface IVoronoiDistance {</ins>
		<ins>float4 GetDistance (float4 x);</ins>

		<ins>float4 GetDistance (float4 x, float4 y);</ins>

		<ins>float4 GetDistance (float4 x, float4 y, float4 z);</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>Besides that, also include three finalization methods for the minima vectors, one per dimension. These will be invoked on the final minima and is where final clamping and other adjustments belong.</p>
						
						<pre>	public interface IVoronoiDistance {
		&hellip;

		<ins>float4x2 Finalize1D (float4x2 minima);</ins>

		<ins>float4x2 Finalize2D (float4x2 minima);</ins>

		<ins>float4x2 Finalize3D (float4x2 minima);</ins>
	}</pre>
						
						<p>Adjust <code>Voronoi1D</code> so it relies on a generic <code>IVoronoiDistance</code> type parameter. Use it to get the distance per span and to finalize the minima before evaluating them.</p>
						
						<pre>	public struct Voronoi1D&lt;L, <ins>D,</ins> F> : INoise
		where L : struct, ILattice
		<ins>where D : struct, IVoronoiDistance</ins>
		where F : struct, IVoronoiFunction {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			var l = default(L);
			<ins>var d = default(D);</ins>
			LatticeSpan4 x = l.GetLatticeSpan4(positions.c0, frequency);

			float4x2 minima = 2f;
			for (int u = -1; u <= 1; u++) {
				SmallXXHash4 h = hash.Eat(l.ValidateSingleStep(x.p0 + u, frequency));
				minima =
					UpdateVoronoiMinima(minima, <ins>d.GetDistance</ins>(h.Floats01A + u - x.g0));
			}
			return default(F).Evaluate(<ins>d.Finalize1D(</ins>minima<ins>)</ins>);
		}
	}</pre>
						
						<p>Do this for <code>Voronoi2D</code> as well, also removing the clamping code from its <code>GetNoise4</code> method.</p>
						
						<pre>	public struct Voronoi2D&lt;L, <ins>D,</ins> F> : INoise
		where L : struct, ILattice
		<ins>where D : struct, IVoronoiDistance</ins>
		where F : struct, IVoronoiFunction {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			var l = default(L);
			<ins>var d = default(D);</ins>
			&hellip;
					minima = UpdateVoronoiMinima(minima, <ins>d.</ins>GetDistance(
						h.Floats01A + xOffset, h.Floats01B + zOffset
					));
					minima = UpdateVoronoiMinima(minima, <ins>d.</ins>GetDistance(
						h.Floats01C + xOffset, h.Floats01D + zOffset
					));
			&hellip;
			<del>//minima.c0 = min(minima.c0, 1f);</del>
			<del>//minima.c1 = min(minima.c1, 1f);</del>
			return default(F).Evaluate(<ins>d.Finalize2D(</ins>minima<ins>)</ins>);
		}
	}</pre>
						
						<p>And do the same for <code>Voronoi3D</code>. Make sure that each noise version invokes the appropriate <code>Finalize</code> method.</p>
						
						<pre>	public struct Voronoi3D&lt;L, <ins>D,</ins> F> : INoise
		where L : struct, ILattice
		<ins>where D : struct, IVoronoiDistance</ins>
		where F : struct, IVoronoiFunction {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			var l = default(L);
			<ins>var d = default(D);</ins>
			&hellip;
						minima = UpdateVoronoiMinima(minima, <ins>d.</ins>GetDistance(
							&hellip;
						));
						minima = UpdateVoronoiMinima(minima, <ins>d.</ins>GetDistance(
							&hellip;
						));
			&hellip;
			<del>//minima.c0 = min(minima.c0, 1f);</del>
			<del>//minima.c1 = min(minima.c1, 1f);</del>
			return default(F).Evaluate(<ins>d.Finalize3D(</ins>minima<ins>)</ins>);
		}
	}</pre>
						
						<p>The static <code>GetDistance</code> methods are no longer needed after these changes, so remove them.</p>
						
						<pre>	<del>//static float4 GetDistance (float4 x, float4 y) => sqrt(x * x + y * y);</del>

	<del>//static float4 GetDistance (float4 x, float4 y, float4 z) =></del>
	<del>//	sqrt(x * x + y * y + z * z);</del></pre>
						
					</section>
					
					<section>
						<h3>Voronoi Worley Noise</h3>
						
						<p>To make Voronoi noise work again we have to introduce a struct type that implements <code>IVoronoiDistance</code> in <em>Noise.Voronoi.Distance</em>, using the same Euclidean distance metrics and clamping that we have used up to this point. Because this is the default Voronoi noise implementation and it was introduced by Steven Worley let's name it <code>Worley</code>.</p>
						
						<p>Because 2D and 3D finalization is the same <code>Finalize3D</code> can forward to <code>Finalize2D</code>, avoiding duplicate code.</p>
						
						<pre>	<ins>public struct Worley : IVoronoiDistance {</ins>

		<ins>public float4 GetDistance (float4 x) => abs(x);</ins>

		<ins>public float4 GetDistance (float4 x, float4 y) => sqrt(x * x + y * y);</ins>

		<ins>public float4 GetDistance (float4 x, float4 y, float4 z) =></ins>
			<ins>sqrt(x * x + y * y + z * z);</ins>

		<ins>public float4x2 Finalize1D (float4x2 minima) => minima;</ins>

		<ins>public float4x2 Finalize2D (float4x2 minima) {</ins>
			<ins>minima.c0 = min(minima.c0, 1f);</ins>
			<ins>minima.c1 = min(minima.c1, 1f);</ins>
			<ins>return minima;</ins>
		<ins>}</ins>

		<ins>public float4x2 Finalize3D (float4x2 minima) => Finalize2D(minima);</ins>
	<ins>}</ins></pre>
						
						<p>Let's also introduce an optimization at this point. Because if `a<=b` then also `a^2<=b^2`&mdash;as long as `a` and `b` aren't negative&mdash;we can delay calculating the square root until finalization. This means that we only have to calculate square roots once instead of every iteration.</p>
						
						<pre>		public float4 GetDistance (float4 x, float4 y) => <ins>x * x + y * y</ins>;

		public float4 GetDistance (float4 x, float4 y, float4 z) => <ins>x * x + y * y + z * z</ins>;

		public float4x2 Finalize2D (float4x2 minima) {
			minima.c0 = <ins>sqrt(</ins>min(minima.c0, 1f)<ins>)</ins>;
			minima.c1 = <ins>sqrt(</ins>min(minima.c1, 1f)<ins>)</ins>;
			return minima;
		}</pre>
						
						<p>Provide the new generic type argument in the job array of <code>NoiseVisualization</code>.</p>
						
						<pre>		{
			Job&lt;Voronoi1D&lt;LatticeNormal, <ins>Worley,</ins> F1>>.ScheduleParallel,
			Job&lt;Voronoi1D&lt;LatticeTiling, <ins>Worley,</ins> F1>>.ScheduleParallel,
			Job&lt;Voronoi2D&lt;LatticeNormal, <ins>Worley,</ins> F1>>.ScheduleParallel,
			Job&lt;Voronoi2D&lt;LatticeTiling, <ins>Worley,</ins> F1>>.ScheduleParallel,
			Job&lt;Voronoi3D&lt;LatticeNormal, <ins>Worley,</ins> F1>>.ScheduleParallel,
			Job&lt;Voronoi3D&lt;LatticeTiling, <ins>Worley,</ins> F1>>.ScheduleParallel
		},</pre>
						
						<p>And adjust the Voronoi labels to indicate that they represent the Worley variant.</p>
						
						<pre>	public enum NoiseType {
		Perlin€, PerlinTurbulence, Value€, ValueTurbulence,
		<ins>VoronoiWorleyF1</ins>, <ins>VoronoiWorleyF2</ins>, <ins>VoronoiWorleyF2MinusF1</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Voronoi Chebyshev Noise</h3>
						
						<p>We'll use chessboard distance as an alternative metric. It describes how many steps a king requires to reach a destination on a chess board. For a king diagonal movement is the same as axis-aligned movement. In general this means that the distance is equal to the maximum distance in any one dimension. This type of distance is commonly named after Pafnuty Chebyshev, so we'll name it <code>Chebyshev</code>.</p>
						
						<p>Because of its nature the maximum possible distance is the same in all dimensions, so we do not need to limit the minima.</p>
						
						<pre>	<ins>public struct Chebyshev : IVoronoiDistance {</ins>

		<ins>public float4 GetDistance (float4 x) => abs(x);</ins>

		<ins>public float4 GetDistance (float4 x, float4 y) => max(abs(x), abs(y));</ins>

		<ins>public float4 GetDistance (float4 x, float4 y, float4 z) =></ins>
			<ins>max(max(abs(x), abs(y)), abs(z));</ins>

		<ins>public float4x2 Finalize1D (float4x2 minima) => minima;</ins>

		<ins>public float4x2 Finalize2D (float4x2 minima) => minima;</ins>

		<ins>public float4x2 Finalize3D (float4x2 minima) => minima;</ins>
	<ins>}</ins></pre>
						
						<p>Add Chebyshev versions of Voronoi noise to the job array in <code>NoiseVisualization</code>.</p>
						
						<pre>		{
			&hellip;
			Job&lt;Voronoi3D&lt;LatticeTiling, Worley, F2MinusF1>>.ScheduleParallel
		}<ins>,</ins>
		<ins>{</ins>
			<ins>Job&lt;Voronoi1D&lt;LatticeNormal, Chebyshev, F1>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi1D&lt;LatticeTiling, Chebyshev, F1>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi2D&lt;LatticeNormal, Chebyshev, F1>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi2D&lt;LatticeTiling, Chebyshev, F1>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi3D&lt;LatticeNormal, Chebyshev, F1>>.ScheduleParallel,</ins>
			<ins>Job&lt;Voronoi3D&lt;LatticeTiling, Chebyshev, F1>>.ScheduleParallel</ins>
		<ins>},</ins>
		<ins>{</ins>
			<ins>Job&lt;Voronoi1D&lt;LatticeNormal, Chebyshev, F2>>.ScheduleParallel,</ins>
			<ins>&hellip;</ins>
		<ins>},</ins>
		<ins>{</ins>
			<ins>Job&lt;Voronoi1D&lt;LatticeNormal, Chebyshev, F2MinusF1>>.ScheduleParallel,</ins>
			<ins>&hellip;</ins>
		<ins>}</ins></pre>
						
						<p>Before we continue, note that 1D Worley and Chebyshev noise are identical. So we can replace the entries for 1D Chebyshev noise with their Worley equivalents. The advantage of this is that Unity doesn't have to generate the 1D Chebyshev jobs.</p>
						
						<pre>		{
			Job&lt;Voronoi1D&lt;LatticeNormal, <ins>Worley</ins>, F1>>.ScheduleParallel,
			Job&lt;Voronoi1D&lt;LatticeTiling, <ins>Worley</ins>, F1>>.ScheduleParallel,
			Job&lt;Voronoi2D&lt;LatticeNormal, Chebyshev, F1>>.ScheduleParallel,
			Job&lt;Voronoi2D&lt;LatticeTiling, Chebyshev, F1>>.ScheduleParallel,
			Job&lt;Voronoi3D&lt;LatticeNormal, Chebyshev, F1>>.ScheduleParallel,
			Job&lt;Voronoi3D&lt;LatticeTiling, Chebyshev, F1>>.ScheduleParallel
		},
		{
			Job&lt;Voronoi1D&lt;LatticeNormal, <ins>Worley</ins>, F2>>.ScheduleParallel,
			Job&lt;Voronoi1D&lt;LatticeTiling, <ins>Worley</ins>, F2>>.ScheduleParallel,
			Job&lt;Voronoi2D&lt;LatticeNormal, Chebyshev, F2>>.ScheduleParallel,
			&hellip;
		},
		{
			Job&lt;Voronoi1D&lt;LatticeNormal, <ins>Worley</ins>, F2MinusF1>>.ScheduleParallel,
			Job&lt;Voronoi1D&lt;LatticeTiling, <ins>Worley</ins>, F2MinusF1>>.ScheduleParallel,
			Job&lt;Voronoi2D&lt;LatticeNormal, Chebyshev, F2MinusF1>>.ScheduleParallel,
			&hellip;
		}</pre>
						
						<p>Finally, add the Chebyshev variants to <code>NoiseType</code> as well.</p>
						
						<pre>	public enum NoiseType {
		Perlin€, PerlinTurbulence, Value€, ValueTurbulence,
		VoronoiWorleyF1, VoronoiWorleyF2, VoronoiWorleyF2MinusF1<ins>,</ins>
		<ins>VoronoiChebyshevF1, VoronoiChebyshevF2, VoronoiChebyshevF2MinusF1</ins>
	}</pre>
						
						<figure>
							<img src="distance-metrics/chebyshev-2d-f1.png" width="220" height="220" alt="2D F1">
							<img src="distance-metrics/chebyshev-2d-f2.png" width="220" height="220" alt="2D F2">
							<img src="distance-metrics/chebyshev-2d-f2-f1.png" width="220" height="220" alt="2D F2 minus F1">
							<img src="distance-metrics/chebyshev-3d-f1.png" width="220" height="220" alt="3D F1">
							<img src="distance-metrics/chebyshev-3d-f2.png" width="220" height="220" alt="3D F2">
							<img src="distance-metrics/chebyshev-3d-f2-f1.png" width="220" height="220" alt="3D F2 - F1">
							<figcaption>2D and 3D Chebyshev noise on a plane; F1, F2, and F2 &minus; F1.</figcaption>
						</figure>
						
						<figure>
							<img src="distance-metrics/chebyshev-sphere-f1.png" width="280" height="280" alt="F1">
							<img src="distance-metrics/chebyshev-sphere-f2.png" width="280" height="280" alt="F2">
							<img src="distance-metrics/chebyshev-sphere-f2-f1.png" width="280" height="280" alt="F2 - F1">
							<figcaption>3D Chebyshev noise on a sphere; F1, F2, and F2 &minus; F1.</figcaption>
						</figure>
						
						<p>The cells of Chebyshev Voronoi noise have either diagonal or axis-aligned edges and their inner gradients form square patterns. This gives it an artificial look, compared to the more organic appearance of Worley noise. Also, an axis-aligned plane sampling 3D noise produces square regions of uniform color, wherever the closest point lies offset in the third dimension.</p>
					</section>
					
					<section>
						<h3>Other Metrics</h3>
						
						<p>There are other distance metrics that you could use. I'll mention three, but I won't include them in this tutorial.</p>
						
						<p>The simplest variant is squared Euclidean distance, created by omitting the square root of the minima. This produces a similar pattern as Worley noise, but with a smaller average amplitude and weaker cell interiors. The advantage of this variant is that it's cheaper to calculate.</p>
						
						<figure>
							<img src="distance-metrics/worley-squared-2d.png" width="220" height="220" alt="2D">
							<img src="distance-metrics/worley-squared-3d.png" width="220" height="220" alt="3D">
							<figcaption>2D and 3D Worley squared.</figcaption>
						</figure>
						
						<p>Another common variant is Manhattan distance, which disallows diagonal measurements. It corresponds to the movement of a rook on a chessboard. Thus the distance is the sum of the absolute distance in all dimensions. Its 2D version looks somewhat like Chebyshev rotated 45&deg;. The downside of Manhattan is that the maximum 2D distance is 2 and the maximum 3D distance is 3, which means that there are many regions clamped to 1, especially for F2.</p>
						
						<figure>
							<img src="distance-metrics/manhattan-2d.png" width="220" height="220" alt="2D">
							<img src="distance-metrics/manhattan-3d.png" width="220" height="220" alt="3D">
							<figcaption>2D and 3D Manhattan.</figcaption>
						</figure>
						
						<p>Finally, instead of producing distances it is also possible to visualize cell hashes. This works like our hash visualization, but based on Voronoi cells instead of the lattice grid. This requires adjusting our noise implementation to also generate an identifier value per cell point and keep track of the closest one. The cell identifier has to be extracted from the hash, cannibalizing bits from the values used to offset the point. For example, for 2D noise reduce the bits per coordinate offset to 6, so the remaining bits can be used for two 4-bit identifiers. For 3D noise the offsets have to be reduced to four bits each. Note that these identifiers can produce discontinuity artifacts in extremely rare cases when the true nearest cell lies outside the single-step offset region that we evaluate.</p>
						
						<figure>
							<img src="distance-metrics/cell-hash-2d.png" width="220" height="220" alt="ID">
							<img src="distance-metrics/cell-hash-f2-f1-2d.png" width="220" height="220" alt="ID * (F2 - F1)">
							<figcaption>2D cell hashes, and multiplied with F2 &minus; F1.</figcaption>
						</figure>
					
						<p>The next tutorial is <a href="../simplex-noise/index.html">Simplex Noise</a>.</p>
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/pseudorandom-noise-06-voronoi-noise/" class="repository">repository</a>
					<a href="Voronoi-Noise.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>