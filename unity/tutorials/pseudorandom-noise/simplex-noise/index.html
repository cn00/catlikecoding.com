<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/tutorial-image.jpg">
		<meta property="og:title" content="Simplex Noise">
		<meta property="og:description" content="A Unity C# Pseudorandom Noise tutorial about creating simplex noise.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Simplex Noise</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/#article",
				"headline": "Simplex Noise",
				"alternativeHeadline": "Simplexes and Radial Kernels",
				"datePublished": "2021-09-23",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity C# Pseudorandom Noise tutorial about creating simplex noise.",
				"image": "https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/tutorial-image.jpg",
				"dependencies": "Unity 2020.3.17f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/pseudorandom-noise/", "name": "Pseudorandom Noise" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				BaseGradients: 1,
				Chebyshev: 1,
				D: 1,
				G: 1,
				HashJob: 1,
				HashVisualization: 1,
				F: 1,
				F1: 1,
				F2: 1,
				F2MinusF1: 1,
				IGradient: 1,
				ILattice: 1,
				INoise: 1,
				IShape: 1,
				IVoronoiDistance: 1,
				IVoronoiFunction: 1,
				Job: 1,
				L: 1,
				Lattice1D: 1,
				Lattice2D: 1,
				Lattice3D: 1,
				LatticeNormal : 1,
				LatticeSpan4 : 1,
				LatticeTiling : 1,
				MathExtensions: 1,
				N: 1,
				Noise: 1,
				NoiseType: 1,
				NoiseVisualization: 1,
				Perlin: 1,
				Plane : 1,
				Point4: 1,
				S: 1,
				ScheduleDelegate: 1,
				Settings: 1,
				Shape: 1,
				Shapes: 1,
				Simplex: 1,
				Simplex1D: 1,
				Simplex2D: 1,
				Simplex3D: 1,
				SmallXXHash: 1,
				SmallXXHash4: 1,
				SpaceTRS: 1,
				Sphere: 1,
				Torus: 1,
				Turbulence: 1,
				Value: 1,
				Visualization: 1,
				Voronoi1D : 1,
				Voronoi2D : 1,
				Voronoi3D : 1,
				Worley: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Pseudorandom Noise</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Simplex Noise</h1>
					<p>Simplexes and Radial Kernels</p>
					<ul>
						<li>Apply radially-symmetrical falloff kernels.</li>
						<li>Use simplexes to partition space.</li>
						<li>Transform squares into triangles and cubes into tetrahedra.</li>
						<li>Introduce circle- and sphere-based gradients.</li>
					</ul>
				</header>
				
				<p>This is the seventh tutorial in a series about <a href="../index.html">pseudorandom noise</a>. It adds support for a vectorized version of the simplex noise algorithm.</p>
				
				<p>This tutorial is made with Unity 2020.3.17f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>A sphere showing 3D simplex noise.</figcaption>
				</figure>
				
				<section>
					<h2>Simplex Value Noise</h2>
					
					<p>After Ken Perlin created Perlin noise he later invented another noise pattern that he named simplex noise. This type of noise uses kernel summation instead of interpolation and is based on a simplex grid instead of a hypercube grid.</p>
					
						<p>In this context, a kernel can be thought of as a stamp or a mask that limits the influence of a pattern. A result is generated by adding multiple kernel samples centered at different locations together.</p>
					
					<p>A simplex is the simplest possible polytope&mdash;an object with flat sides&mdash;that takes up space in all available dimensions. A straight line segment is a 1D simplex. A triangle is a 2D simplex. A square is not a 2D simplex, because it has one more corner and side than a triangle and thus isn't the simplest possible shape. A straight line segment is also not a 2D simplex, because it has only a single dimension, no matter how it is oriented in 2D space. Finally, a tetrahedron is a 3D simplex.</p>
					
					<p>Simplex noise is a type of gradient noise, but we can also create value noise variants of it. We start with those because they are simpler and easier to analyze than the gradient variants.</p>
					
					<aside>
						<h3>Isn't simplex noise patented?</h3>
						<div>
							<p>U.S. Patent 6,867,776 B2 only covers 3D simplex gradient noise, not 2D nor 1D noise and none of the value noise variants in this tutorial. The implementation in this tutorial isn't exactly the same as described in the patent, because it is a vectorized algorithm and it generates gradients in a different way. Regardless, the parent expired 2022-01-08 and is no longer relevant.</p>
							
							<p>Note that the patent refers to Perlin's flawed initial noise implementation. Simplex noise was supposed to be an improvement of that version. After finishing simplex noise he later returned to his original Perlin noise and improved it. There is no compelling reason to use simplex noise instead of Perlin noise, besides aesthetic choice. Both have their advantages and disadvantages.</p>
						</div>
					</aside>
					
					<section>
						<h3>Simplex Jobs</h3>
						
						<p>We cannot rely on our existing lattice structs to generate simplex noise, because they use a hypercube lattice to partition space while we need simplex lattices. So we'll create a new partial <code>Noise</code> class asset named <em translate="no">Noise.Simplex</em> and declare new simplex noise types in there, for 1D, 2D, and 3D. </p>
						
						<p>Although we could create tiling simplex noise variants they won't be very useful, because the tiling would be based on the simplex lattice and thus not align with a hypercube grid. Thus 2D tiling won't match a square region and 3D tiling won't match a cube. 1D tiling would fit straight line segments so is possible, but we'll be consistent and won't support tiling for all simplex noise variants. So these noise types only need an <code>IGradient</code> generic type parameter. We begin by only using the gradient for the evaluation after interpolation, but pass zero to it for now.</p>
						
						<pre translate="no"><ins>using Unity.Mathematics;</ins>

<ins>using static Unity.Mathematics.math;</ins>

<ins>public static partial class Noise {</ins>

	<ins>public struct Simplex1D&lt;G> : INoise where G : struct, IGradient {</ins>

		<ins>public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {</ins>
			<ins>return default(G).EvaluateAfterInterpolation(0f);</ins>
		<ins>}</ins>
	<ins>}</ins>

	<ins>public struct Simplex2D&lt;G> : INoise where G : struct, IGradient {</ins>

		<ins>public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {</ins>
			<ins>return default(G).EvaluateAfterInterpolation(0f);</ins>
		<ins>}</ins>
	<ins>}</ins>

	<ins>public struct Simplex3D&lt;G> : INoise where G : struct, IGradient {</ins>

		<ins>public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {</ins>
			<ins>return default(G).EvaluateAfterInterpolation(0f);</ins>
		<ins>}</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>Add entries for simplex value noise and simplex value turbulence noise to the enum in <code>NoiseVisualization</code>.</p>
						
						<pre translate="no">	public enum NoiseType {
		Perlin€, PerlinTurbulence, Value€, ValueTurbulence,
		<ins>SimplexValue, SimplexValueTurbulence,</ins>
		VoronoiWorleyF1, VoronoiWorleyF2, VoronoiWorleyF2MinusF1,
		VoronoiChebyshevF1, VoronoiChebyshevF2, VoronoiChebyshevF2MinusF1
	}</pre>
						
						<p>And insert them into the job array at the appropriate location. The simplest way to not support tiling variants is to use the non-tiling variants for those elements, so each variant gets included twice.</p>
						
						<pre translate="no">		<ins>{</ins>
			<ins>Job&lt;Simplex1D&lt;Value>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex1D&lt;Value>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex2D&lt;Value>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex2D&lt;Value>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex3D&lt;Value>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex3D&lt;Value>>.ScheduleParallel</ins>
		<ins>},</ins>
		<ins>{</ins>
			<ins>Job&lt;Simplex1D&lt;Turbulence&lt;Value>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex1D&lt;Turbulence&lt;Value>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex2D&lt;Turbulence&lt;Value>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex2D&lt;Turbulence&lt;Value>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex3D&lt;Turbulence&lt;Value>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex3D&lt;Turbulence&lt;Value>>>.ScheduleParallel</ins>
		<ins>},</ins></pre>
					</section>
					
					<section>
						<h3>1D Simplexes and Kernels</h3>
						
						<p>We begin with 1D Simplex noise. It uses the same line-segment space partition as regular value noise, but we don't have an <code>ILattice</code> type to generate the required data. Instead, we find the first lattice point <code>x0</code> inside <code>Simplex1D.GetNoise4</code> directly, first by applying the frequency to the positions and then flooring the X coordinates.</p>
						
						<pre translate="no">	public struct Simplex1D&lt;G> : INoise where G : struct, IGradient {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			<ins>positions *= frequency;</ins>
			<ins>int4 x0 = (int4)floor(positions.c0);</ins>

			return default(G).EvaluateAfterInterpolation(0f);
		}
	}</pre>
						
						<p>To generate the noise value we need a kernel. For 1D noise the kernel requires evaluation of a hash and 1D gradient input. We add a static <code>Kernel</code> method to <code>Simplex1D</code> to do this, based on a hash, a lattice point, and the sample position, all vectorized. Just like for <code>Lattice1D</code>, the gradient input is found by subtracting the lattice points from their X coordinates.</p>
						
						<pre translate="no">	public struct Simplex1D&lt;G> : INoise where G : struct, IGradient {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			&hellip;
		}
		
		<ins>static float4 Kernel (SmallXXHash4 hash, float4 lx, float4x3 positions) {</ins>
			<ins>float4 x = positions.c0 - lx;</ins>
			<ins>return default(G).Evaluate(hash, x);</ins>
		<ins>}</ins>
	}</pre>
						
						<p>To apply the kernel for the first lattice point, invoke it inside <code>GetNoise4</code>, passing it the hash fed with the point, the point itself, and the positions. Pass its result to the final evaluation.</p>
						
						<pre translate="no">		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			positions *= frequency;
			int4 x0 = (int4)floor(positions.c0);

			return default(G).EvaluateAfterInterpolation(
				<ins>Kernel(hash.Eat(x0), x0, positions)</ins>
			);
		}</pre>
						
						<p>To complete the 1D noise we have to include the second point <code>x1</code> of the lattice span as well, one step further along the X axis. And because Simplex noise sums kernels, add its kernel to the first one, instead of interpolating them.</p> 
						
						<pre translate="no">		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			positions *= frequency;
			int4 x0 = (int4)floor(positions.c0)<ins>, x1 = x0 + 1</ins>;

			return default(G).EvaluateAfterInterpolation(
				Kernel(hash.Eat(x0), x0, positions) <ins>+ Kernel(hash.Eat(x1), x1, positions)</ins>
			);
		}</pre>
					</section>
					
					<section>
						<h3>Radially-symmetrical Falloff</h3>
						
						<p>At this point we're simply adding the uniform lattice values of value noise and using those constant values for the entire span. To turn this into a continuous pattern we have to introduce a smooth transition from one lattice point to the next. While regular lattice noise blends between lattice points via interpolation, simplex noise does this by limiting the influence of each lattice point. This is the job of the kernel. It defines a falloff function that starts at 1 at the lattice point and drops to zero when it reaches the adjacent lattice points, in both directions. Hence it is a symmetrical kernel, which in a single dimension also makes it radially-symmetrical.</p>
						
						<p>The simplest falloff function `f` that works is one minus the absolute distance along the single dimension: `f(x)=1-|x|`. This function starts at 1 and drops to zero at the adjacent lattice points. Use it to scale the gradient evaluation.</p>
						
						<pre translate="no">		static float4 Kernel (SmallXXHash4 hash, float4 lx, float4x3 positions) {
			float4 x = positions.c0 - lx;
			<ins>float4 f = 1f - abs(x);</ins>
			return <ins>f *</ins> default(G).Evaluate(hash, x);
		}</pre>
						
						<figure>
							<img src="simplex-value-noise/1d-linear-falloff.png" width="420" height="90">
							<figcaption>1D Value simplex noise, linear falloff.</figcaption>
						</figure>
						
						<p>The result is continuous noise, but it is equivalent to simple linear interpolation and thus isn't smooth. To make regular value noise smooth we needed to use a C2-continuous interpolation. Likewise, we need to find a C2-continuous falloff function to make simplex value noise meet the same standards.</p>
						
						<p>Let's start with the observation that `|x|=sqrt(x^2)` and thus that the simplest way to adjust our falloff function is to eliminate the square root. This leads to `f(x)=1-x^2`.</p>
						
						<pre translate="no">			float4 f = 1f - <ins>x * x</ins>;</pre>
						
						<figure>
							<img src="simplex-value-noise/1d-squared-falloff.png" width="420" height="100">
							<figcaption>Squared falloff.</figcaption>
						</figure>
						
						<p>This squared falloff introduces curvature but is obviously not C2-continuous yet. This makes sense because the first derivative is `f'(x)=-2x` and the second derivative is `f''(x)=-2`. Neither of these are zero at the end points, where `x` equals 1 or &minus;1.</p>
						
						<p>Another observation that we can make is that in the middle of a span the noise can end up with an amplitude that exceeds 1. This happens because at the halfway point `f(1/2)=1-(1/2)^2=1-1/4=3/4`. That is the maximum for a single kernel, but we add two, so the total maximum amplitude is `2f(1/2)=3/2=1.5`.</p>
						
						<figure>
							<img src="simplex-value-noise/falloff-graph-linear-squared.png" width="160" height="160">
							<figcaption>Linear and square falloff.</figcaption>
						</figure>
						
						<p>Let's make this more obvious by only using the falloff factor for the kernel result, thus always visualizing the maximum possible amplitude of the noise.</p>
						
						<pre translate="no">			return f<ins>;</ins> <del>// * default(G).Evaluate(hash, x);</del></pre>
						
						<figure>
							<img src="simplex-value-noise/1d-squared-max-amplitude.png" width="420" height="100">
							<figcaption>Maximum amplitude.</figcaption>
						</figure>
						
						<p>We can modify the falloff function that we currently have by squaring it, which leads to `f(x)=(1-x^2)^2 ` with derivatives `f'(x)=4x^3-4x` and `f''(x)=12x^2-4`. This function is C1- but not C2-continuous.</p>
						
						<figure>
							<img src="simplex-value-noise/c1-graph.png" width="400" height="400">
							<figcaption>C1 falloff and its derivatives.</figcaption>
						</figure>
						
						<aside>
							<h3>How is that first derivative found?</h3>
							<div>
								<p>The simplest approach is to first rewrite the function: `f(x)=(1-x^2)^2=(1-x^2)(1-x^2)`.</p>
								
								<p>Then use the polynomial multiplication rule `(a+b)(c+d)=ac+ad+bc+bd`:</p>
								
								<p>`f(x)=(1-x^2)(1-x^2)=1-x^2-x^2+x^4=x^4-2x^2+1`.</p>
								
								<p>Then the derivates can be found by applying the single rule mentioned in the <a href="../value-noise/index.html">Value Noise</a> tutorial.</p>
							</div>
						</aside>
						
						<p>To reach C2-continuity we have to raise the power of the function one step higher, cubing instead of squaring it: `f(x)=(1-x^2)^3` with derivatives `f'(x)=-6x^5+12x^3-6x` and `f''(x)=-30x^4+36x^2-6`.</p>
						
						<figure>
							<img src="simplex-value-noise/c2-graph.png" width="400" height="400">
							<figcaption>C2 falloff and its derivatives.</figcaption>
						</figure>
						
						<aside>
							<h3>And how is that first derivative found?</h3>
							<div>
								<p>First rewrite `f(x)=(1-x^2)^3=(1-x^2)(x^4-2x^2+1)`.</p>
								
								<p>Then again apply polynomial multiplication, in this case of the slightly more complex form `(a+b)(c+d+e)=ac+ad+ae+bc+bd+be`:</p>
								
								<p>`f(x)=(1-x^2)(x^4-2x^2+1)=-x^6+3x^4-3x^2+1`.</p>
							</div>
						</aside>
						
						<p>The second derivative of this function isn't zero at the lattice point itself, because that's where the kernel falloff switches direction. As the kernel influences both sides this isn't a problem, it only has to reach zero at its edges.</p>
						
						<p>Apply this falloff to our kernel.</p>
						
						<pre translate="no">			float4 f = 1f - x * x;
			<ins>f = f * f * f;</ins>
			return f;// * default(G).Evaluate(hash, x);</pre>
						
						<figure>
							<img src="simplex-value-noise/1d-final-max-amplitude.png" width="420" height="100">
							<figcaption>Final maximum amplitude.</figcaption>
						</figure>
						
						<p>Note that&mdash;unlike 1D regular value noise&mdash;the maximum amplitude of 1D simplex value noise isn't constant. It wobbles a bit, reaching 1 at lattice points and dropping to its minimum of 0.84375 in the middle of each span.</p>
						
						<aside>
							<h3>How do you find that minimum?</h3>
							<div>
								<p>At the midpoint `2f(1/2)=2(3/4)^3=2(27/64)=27/32=0.84375`.</p>
							</div>
						</aside>
						
						<p>Finally, complete 1D simplex value noise by reintroducing the gradient evaluation.</p>
						
						<pre translate="no">			return f <ins>* default(G).Evaluate(hash, x)</ins>;</pre>
						
						<figure>
							<img src="simplex-value-noise/1d-simplex-value-noise.png" width="420" height="100" alt="simplex">
							<img src="simplex-value-noise/1d-regular-value-noise.png" width="420" height="100" alt="regular">
							<figcaption>1D simplex and regular value noise.</figcaption>
						</figure>
						
						<p>Compared to regular value noise, the simplex variant is a bit more wobbly due to its variable maximum amplitude. Besides that both show the same pattern as they're based on the same line-segment lattice.</p>
					</section>
					
					<section>
						<h3>Renaming</h3>
						
						<p>At this point we're using the <code>IGradient.EvaluateAfterInterpolation</code> method to adjust the final combined noise value both after interpolation of lattice noise and after kernel summation of simplex noise. Its current name is thus too specific. Let's refactor rename all relevant code so it becomes <code>IGradient.EvaluateCombined</code>. I only show the change for the <code>IGradient</code> interface.</p>
						
						<pre translate="no">	public interface IGradient {
		&hellip;
		
		float4 <ins>EvaluateCombined</ins> (float4 value);
	}</pre>
					</section>
					
					<section>
						<h3>2D Kernels</h3>
						
						<p>Moving on to 2D noise, the falloff function of a radially-symmetrical kernel works the same as for 1D. We again subtract the square distance from 1 and cube that. In general the falloff function is `f(d)=(1-d)^3` where `d` is the square distance. For 1D `d=x^2` and for 2D `d=x^2+z^2`, because we base our 2D noise on the XZ plane. Thus for 2D the falloff function can be defined as `f(x,z)=(1-x^2-z^2)^3` Add a <code>Kernel</code> method to <code>Simplex2D</code> with this falloff as its result.</p>
						
						<pre translate="no">	public struct Simplex2D&lt;G> : INoise where G : struct, IGradient {

		&hellip;

		<ins>static float4 Kernel (</ins>
			<ins>SmallXXHash4 hash, float4 lx, float4 lz, float4x3 positions</ins>
		<ins>) {</ins>
			<ins>float4 x = positions.c0 - lx, z = positions.c2 - lz;</ins>
			<ins>float4 f = 1f - x * x - z * z;</ins>
			<ins>f = f * f * f;</ins>
			<ins>return f;</ins>
		<ins>}</ins>
	}</pre>
						
						<p>Follow that with an implementation of <code>GetNoise4</code> with the same logic as for 1D, initially using the same square-based lattice as <code>Lattice2D</code>, but this time summing four kernels.</p>
						
						<pre translate="no">		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			<ins>positions *= frequency;</ins>
			<ins>int4</ins>
				<ins>x0 = (int4)floor(positions.c0), x1 = x0 + 1,</ins>
				<ins>z0 = (int4)floor(positions.c2), z1 = z0 + 1;</ins>

			<ins>SmallXXHash4 h0 = hash.Eat(x0), h1 = hash.Eat(x1);</ins>

			<ins>return default(G).EvaluateCombined(</ins>
				<ins>Kernel(h0.Eat(z0), x0, z0, positions) +</ins>
				<ins>Kernel(h0.Eat(z1), x0, z1, positions) +</ins>
				<ins>Kernel(h1.Eat(z0), x1, z0, positions) +</ins>
				<ins>Kernel(h1.Eat(z1), x1, z1, positions)</ins>
			<ins>);</ins>
		}</pre>
						
						<figure>
							<img src="simplex-value-noise/2d-square-falloff-unclamped.png" width="220" height="220">
							<figcaption>Radial falloff with square lattice; frequency 4.</figcaption>
						</figure>
						
						<p>The result is a square grid filled with circular gradients that indicate the maximum amplitude of the noise. Although the maximum amplitude should be 1 at the lattice points this is currently not the case, because the kernel centered on the diagonally opposite corner has become negative as its distance has exceeded 1: `f(1,1)=(1-1-1)^3=-1^3=-1`. We fix this by eliminating negative falloff results.</p>
						
						<pre translate="no">		static float4 Kernel (
			SmallXXHash4 hash, float4 lx, float4 lz, float4x3 positions
		) {
			&hellip;
			return <ins>max(0f,</ins> f<ins>)</ins>;
		}</pre>
						
						<figure>
							<img src="simplex-value-noise/2d-square-falloff-clamped.png" width="220" height="220">
							<figcaption>Clamped kernels.</figcaption>
						</figure>
						
						<p>With our kernel influence clamped we see the result of kernel summation while using a square lattice. The next step is to switch to a triangular lattice.</p>
						
						<aside>
							<h3>What would radial 2D value noise look like?</h3>
							<div>
								<p>Using radial kernel summation with a square lattice would produce a result that is weaker and more wobbly than interpolation-based value noise, similar to the difference between 1D simplex and regular value noise, but more pronounced.</p>
								
								<figure>
									<img src="simplex-value-noise/2d-radial-value-noise.png" width="220" height="220" alt="radial">
									<img src="simplex-value-noise/2d-regular-value-noise.png" width="220" height="220" alt="interpolated">
									<figcaption>Radial and interpolated 2D value noise.</figcaption>
								</figure>
								
								<p>The maximum amplitude at the midpoint of each lattice edge is the same as for 1D noise, so 0.84375. At the center of each square it drops to `4f(1/2,1/2)=4(1-2(1/2)^2)^3=4(1-2/4)^3=4(1/2)^3=4/8=1/2`.</p>
								
								<p>And for 3D noise it would drop to `8(1-3(1/2)^2)^3=8(1/4)^3=8/64=1/8` at the center of each lattice cube.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>2D Simplexes</h3>
						
						<p>A 2D simplex is a triangle. It is possible to tile 2D space with a grid of equilateral triangles. We can start with our existing square-based approach and convert it into a triangular lattice using a two-step process. We take a square and scale it down along the XZ diagonal. This distorting operation is known as a skew. The result is a rhombus, which when split along its XZ diagonal becomes two triangles with opposite orientations. If we apply the correct skew the end result is a grid of equilateral triangles.</p>
						
						<figure>
							<img src="simplex-value-noise/2d-skew-square-rhombus.png" width="270" height="270">
							<figcaption>Skewing from square to rhombus.</figcaption>
						</figure>
						
						<p>The skew is performed by moving all points along the XZ diagonal line. We do this by applying the same adjustment to both coordinates of each point. To convert from square to rhombus we have to scale down, so we have to subtract some skew value `s`. So for every point we have to apply the transformation `[[x],[z]]->[[x-s],[z-s]]`.</p>
						
						<p>To create a rhombus `s` cannot be the same for all points, so it depends on their coordinates, which means that it has to be a function: `s(x,z)`. We have to determine what it is.</p>
						
						<p>Let's consider the case of a degenerate rhombus: we skew so all points end up on a single line. Let's also consider the square with corner points `[[0],[0]]`, `[[1],[0]]`, `[[1],[1]]`, and `[[0],[1]]`.</p>
						
						<figure>
							<img src="simplex-value-noise/2d-skew-degenerate.png" width="330" height="330">
							<figcaption>Skewing into a degenerate rhombus, which is a line.</figcaption>
						</figure>
						
						<p>From this we can see that `s(0,0)=0`, because the point at the origin doesn't move. The other point on the XZ line also ends up at the origin, so `s(1,1)=1`. And `s(0,1)=s(1,0)=1/2`. Thus in this case `s(x,z)=(x+z)/2`. In general we have `s(x,z)=v(x+z)` where the constant value `v` determines the shape of the rhombus. We have to determine which value to use for `v` so we end up with equilateral triangles.</p>
						
						<p>Let's look at the bottom right triangle of the original square, with corners `a=[[0],[0]]`, `b=[[1],[0]]` and `c=[[1],[1]]`.</p>
						
						<figure>
							<img src="simplex-value-noise/2d-skew-triangles.png" width="510" height="250">
							<figcaption>Right and equilateral versions of the same triangle.</figcaption>
						</figure>
						
						<p>After skewing `a` is still the same, but the other two corner points have changed. We have `b=[[1-v(1+0)],[-v(1+0)]]=[[1-v],[-v]]` and `c=[[1-v(1+1)],[1-v(1+1)]]=[[1-2v],[1-2v]]`.</p>
						
						<p>We do not yet know what `v` is, but we do know that the three sides of the triangle have the same length, so we can equate them. As `a` sits at the origin the distance from it to `b` and to `c` is equal to the length of the vectors that they define. So the length of those two vectors are equal: `||b||=||c||`, and thus their square lengths are also equal: `||b||^2=||c||^2`.</p>
						
						<p>The square length of a 2D vector is `x^2+z^2`. Thus `||b||^2=(1-v)^2+(-v)^2=2v^2-2v+1` and `||c||^2=2(1-2v)^2=8v^2-8v+2`. Now we can solve the equation and find `v=(3-sqrt(3))/6`.</p>
						
						<aside>
							<h3>How do you solve the equation?</h3>
							<div>
								<p>Rewrite `||b||^2=||c||^2->2v^2-2v+1=8v^2-8v+2->6v^2-6v+1=0`.</p>
								
								<p>Apply the quadratic formula: if `ax^2+bx+c=0` then `x=(-b+-sqrt(b^2-4ac))/(2a)`, so potentially two solutions. In our case `a=6`, `b=-6`, and `c=1`.</p>
								
								<p>Solve `v=(6+-sqrt(12))/12=(6+-2sqrt(3))/12=(3+-sqrt(3))/6`.</p>
								
								<p>`(3+sqrt(3))/6~~0.789` and `(3-sqrt(3))/6~~0.211`. Both solutions are valid, but a skew factor greater than 0.5 will cause the grid to flip, crossing the degenerate line, so we'll use the smaller value.</p>
							</div>
						</aside>
						
						<p>At this point we know how to convert from squares to triangles, but we have already declared that we are using a triangular lattice, that is our starting point. To find the lattice points we have to convert the other way, from triangles to squares. This requires moving all points along the same XZ diagonal, but now in the opposite direction&mdash;adding instead of subtracting the skew&mdash;so we have `[[x],[z]]->[[x+v(x+z)],[z+v(x+z)]]` where `v` is a different skew value that we have to find.</p>
						
						<p>Let's consider the transformation for point `c`. We know that it has to end up at `[[1],[1]]` and `x=z` thus `x+2vx=1`. We also know that `x=1-2(3-sqrt(3))/6=1-(3-sqrt(3))/3=sqrt(3)/3=1/sqrt(3)`. This leads to `1/sqrt(3)+(2v)/sqrt(3)=1` and we find `v=(sqrt(3)-1)/2`.</p>
						
						<aside>
							<h3>How do you find that skew value?</h3>
							<div>
								<p>Rewrite `1/sqrt(3)+(2v)/sqrt(3)=1->1+2v=sqrt(3)->2v=sqrt(3)-1->v=(sqrt(3)-1)/2`.</p>
							</div>
						</aside>
						
						<p>Now we have two skew values: `(3-sqrt(3))/6` to convert from squares to triangles and `(sqrt(3)-1)/2` to convert from triangles to squares. To find the lattice points we have to apply the latter in <code>GetNoise4</code>, and then use the skewed coordinates to determine the lattice points.</p>
						
						<pre translate="no">			positions *= frequency;
			<ins>float4 skew = (positions.c0 + positions.c2) * ((sqrt(3f) - 1f) / 2f);</ins>
			<ins>float4 sx = positions.c0 + skew, sz = positions.c2 + skew;</ins>
			int4
				x0 = (int4)floor(<ins>sx</ins>), x1 = x0 + 1,
				z0 = (int4)floor(<ins>sz</ins>), z1 = z0 + 1;</pre>
						
						<figure>
							<img src="simplex-value-noise/2d-skewed.png" width="220" height="220">
							<figcaption>Skewed coordinates; frequency 4.</figcaption>
						</figure>
						
						<p>This creates the correct lattice but messes up the kernels, because they are now calculated based on the skewed coordinates. We have to un-skew the square lattice points back to the triangles in <code>Kernel</code> to calculate them in the original space. For this we use the other skew value and subtract the skew from the lattice coordinates before subtracting them from the original coordinates. This is equivalent to adding the skew after the existing subtraction.</p>
						
						<pre translate="no">			<ins>float4 unskew = (lx + lz) * ((3f - sqrt(3f)) / 6f);</ins>
			float4 x = positions.c0 - lx <ins>+ unskew</ins>, z = positions.c2 - lz <ins>+ unskew</ins>;
			float4 f = 1f - x * x - z * z;</pre>
						
						<p>This fixes the kernel shapes but the result is blown-out white. The problem is that our kernel influence extends too far, because the triangles are smaller than the squares. The falloff should reach zero at the midpoint of the edge opposite to the corner it is centered on. We can do this by reducing the starting strength of the kernel to 0.5.</p>
						
						<pre translate="no">			float4 f = <ins>0.5f</ins> - x * x - z * z;</pre>
						
						<aside>
							<h3>Why start at half strength?</h3>
							<div>
								<p>The height of an equilateral triangle is `h=(lsqrt(3))/2` where `l` is its edge length. Let's use `l=||b||`.</p>
								
								<p>We already know `||b||^2=2v^2-2v+1` with `v=(3-sqrt(3))/6`.</p>
								
								<p>Calculate `v^2=(9-6sqrt(3)+3)/36=(2-sqrt(3))/6`.</p>
								
								<p>Find `||b||^2=(2-sqrt(3))/3-(3-sqrt(3))/3+1=1-1/3=2/3` and `||b||=sqrt(2/3)=sqrt(2)/sqrt(3)`.</p>
								
								<p>Thus `h=(||b||sqrt(3))/2=sqrt(2)/2=sqrt(1/2)`, which means that the falloff must reach zero at a squared distance of 0.5, which is achieved by simply using `f(x,z)=1/2-x^2-z^2`.</p>
							</div>
						</aside>
						
						<figure>
							<img src="simplex-value-noise/2d-unskewed.png" width="220" height="220">
							<figcaption>Un-skewed kernels, but weak.</figcaption>
						</figure>
						
						<p>The kernels now have the correct shape and size but they are very weak, because at their center `f(0,0)=(1/2)^3=1/8`. This is fixed by scaling up the falloff to compensate: `f(x,z)=8(1/2-x^2-z^2)^3`.</p>
						
						<pre translate="no">			f = f * f * f <ins>* 8f</ins>;</pre>
						
						<figure>
							<img src="simplex-value-noise/2d-max-amplitude.png" width="220" height="220">
							<figcaption>Maximum amplitude; still frequency 4</figcaption>
						</figure>
						
						<p>In this case we can find two different amplitude minima: those at the midpoints along the edges and the one at the center of each triangle. The edge minimum is `m_e=16/27~~0.593` and the center minimum is `m_c=1000/1944~~0.514`.</p>
						
						<aside>
							<h3>How do you find those minima?</h3>
							<div>
								<p>The falloff function based on distance is `f(d)=8(1/2-d^2)^3`. We know the edge length `l=sqrt(2/3)=sqrt(2)/sqrt(3)`.</p>
								
								<p>The minimum along edges is `m_e=2f(l/2)=16(1/2-2/12)^3=16/27`.</p>
								
								<p>The distance from corners to the equilateral triangle center &mdash;which is also its circumcenter&mdash;is equal to the radius of the circumscribed circle `r=l/sqrt(3)=sqrt(2)/3`.</p>
								
								<p>So the center minimum is `m_c=3f(r)=24(1/2-2/9)^3=1000/1944`.</p>
							</div>
						</aside>
						
						<p>Although our lattice and kernels are now finished, due to the skewing the simplex noise variant appears to have a higher frequency compared to the square-based version. Although this isn't a problem on its own, it makes comparing the different noise variants harder. So let's scale down the frequency, dividing it by &radic;3 at the start of <code>GetNoise4</code>.</p>
						
						<pre translate="no">			positions *= frequency <ins>* (1f / sqrt(3f)</ins>;</pre>
						
						<figure>
							<img src="simplex-value-noise/2d-scaled-frequency.png" width="220" height="220">
							<figcaption>Frequency 4, scaled.</figcaption>
						</figure>
						
						<aside>
							<h3>Where does that scale factor come from?</h3>
							<div>
								<p>The diagonal XZ axis line going though the origin is the only place where we can exactly match the lattice points of both squares and triangles. The distance between square lattice points along that line is &radic;2. To make the triangle lattice points match we need to scale them by &radic;2 divided by the triangle edge length `l=sqrt(2/3)=sqrt(2)/sqrt(3)`. Thus the scale factor is `sqrt(2)/l=sqrt(3)`, which means we have to divide the frequency by that.</p>
							</div>
						</aside>
						
						<p>We finish 2D simplex value noise by including the gradient evaluation.</p>
						
						<pre translate="no">			return max(0f, f) <ins>* default(G).Evaluate(hash, x, z)</ins>;</pre>
						
						<figure>
							<img src="simplex-value-noise/2d-simplex-value-1o.png" width="220" height="220" alt="simplex 1 octave">
							<img src="simplex-value-noise/2d-regular-value-noise.png" width="220" height="220" alt="regular 1 octave"><br>
							<img src="simplex-value-noise/2d-simplex-value-3o.png" width="220" height="220" alt="simplex 3 octaves">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/2d-regular-value-3o.png" width="220" height="220" alt="regular 3 octaves">
							<figcaption>2D simplex and regular value noise; frequency 8; 1 and 3 octaves.</figcaption>
						</figure>
						
						<p>Compared to regular value noise, the simplex variant distorts the noise pattern to fit what appears like a honeycomb lattice. It is also weaker. The pattern difference is most obvious when comparing the turbulence variants.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/2d-simplex-value-turbulence.png" width="220" height="220" alt="simplex">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/2d-regular-value-turbulence.png" width="220" height="220" alt="regular">
							<figcaption>2D simplex and regular value turbulence; frequency 4 and 3 octaves.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Only Three Kernels</h3>
						
						<p>Although our 2D simplex value noise is visually finished, we are currently still ignoring that each triangle requires only three kernels. We can verify this by looking at the four kernels that we currently use in isolation.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/2d-kernel-00.png" width="220" height="220" alt="kernel 00">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/2d-kernel-01.png" width="220" height="220" alt="kernel 01"><br>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/2d-kernel-10.png" width="220" height="220" alt="kernel 10">
							<img src="simplex-value-noise/2d-kernel-11.png" width="220" height="220" alt="kernel 11">
							<figcaption>Kernels 00, 01, 10, and 11 in isolation.</figcaption>
						</figure>
						
						<p>Kernels 00 and 11&mdash;those along the XZ diagonal&mdash;contribute to every triangle, while the other kernels only influence half of the triangles. So we can always skip either the 01 or the 10 kernel. Let's begin by removing both from <code>GetNoise4</code>.</p>
						
						<pre translate="no">			return default(G).EvaluateCombined(
				Kernel(h0.Eat(z0), x0, z0, positions) +
				<del>//Kernel(h0.Eat(z1), x0, z1, positions) +</del>
				<del>//Kernel(h1.Eat(z0), x1, z0, positions) +</del>
				Kernel(h1.Eat(z1), x1, z1, positions)
			);</pre>
						
						<figure>
							<img src="simplex-value-noise/2d-kernels-00-11.png" width="220" height="220">
							<figcaption>Only kernels 00 and 11.</figcaption>
						</figure>
						
						<p>Which third kernel is needed depends on which side of the XZ diagonal the sample point lies, in the skewed square lattice space. If we're on the side where the relative X coordinate is greater than the Z coordinate then we need the 10 kernel and otherwise the 01 kernel.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/2d-kernel-choice.png" width="300" height="300">
							<figcaption>Choosing either the 01 or 10 kernel.</figcaption>
						</figure>
						
						<p>This is a vectorized decision that applies to the selection of the appropriate X and Z lattice points. Store whether the relative skewed X exceed Z in a <code>bool4</code> variable directly after finding the lattice points.</p>
						
						<pre translate="no">			float4 sx = positions.c0 + skew, sz = positions.c2 + skew;
			int4
				x0 = (int4)floor(sx), x1 = x0 + 1,
				z0 = (int4)floor(sz), z1 = z0 + 1;

			<ins>bool4 xGz = sx - x0 > sz - z0;</ins>

			SmallXXHash4 h0 = hash.Eat(x0), h1 = hash.Eat(x1);</pre>
						
						<p>If X is greater than Z then select <code>x1</code> and <code>z0</code>, otherwise select <code>x0</code> and <code>z1</code>. Let's keep track of our choices via <code>xC</code> and <code>zC</code>.</p>
						
						<pre translate="no">			bool4 xGz = sx - x0 > sz - z0;
			<ins>int4 xC = select(x0, x1, xGz), zC = select(z1, z0, xGz);</ins></pre>
						
						<p>This allows us to add the variable third kernel to our sum.</p>
						
						<pre translate="no">			return default(G).EvaluateCombined(
				Kernel(h0.Eat(z0), x0, z0, positions) +
				Kernel(h1.Eat(z1), x1, z1, positions) <ins>+</ins>
				<ins>Kernel(hash.Eat(xC).Eat(zC), xC, zC, positions)</ins>
			);</pre>
						
						<p>While this works it requires us to feed an X lattice point to the hash, which we have already done for both options. Ideally we could select either <code>h0</code> or <code>h1</code>, but we cannot use the existing <code>select</code> methods because that would result in a premature hash avalanche. So let's add a public static <code>SmallXXHash4.Select</code> method that selects the appropriate accumulator without change.</p>
						
						<pre translate="no">	<ins>public static SmallXXHash4 Select (SmallXXHash4 a, SmallXXHash4 b, bool4 c) =></ins>
		<ins>math.select(a.accumulator, b.accumulator, c);</ins></pre>
						
						<p>Now we can reuse a partially-fed hash for the third kernel in <code>Simplex2D.GetNoise4</code>.</p>
						
						<pre translate="no">			SmallXXHash4
				h0 = hash.Eat(x0), h1 = hash.Eat(x1)<ins>,</ins>
				<ins>hC = SmallXXHash4.Select(h0, h1, xGz)</ins>;

			return default(G).EvaluateCombined(
				Kernel(h0.Eat(z0), x0, z0, positions) +
				Kernel(h1.Eat(z1), x1, z1, positions) +
				Kernel(<ins>hC.Eat(zC)</ins>, xC, zC, positions)
			);</pre>
					</section>
					
					<section>
						<h3>3D Simplices</h3>
						
						<p>Generating the 3D simplex lattice works the same as for 2D, but with an extra dimension. So instead of turning a square into a rhombus we turn a cube into a rhombohedron. The transformation is `[[x],[y],[z]]->[[x-v(x+y+z)],[y-v(x+y+z)],[z-v(x+y+z)]]` with `v` yet unknown.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-skew-cube-rhombohedron.png" width="380" height="320">
							<figcaption>Skewing from cube to rhombohedron.</figcaption>
						</figure>
						
						<p>And instead of splitting a square into two triangles we split a cube into six tetrahedra by selecting their corners in the following way: start with the 000 corner, then pick one of the three adjacent corners with a single 1, then pick one of the two adjacent corners with two 1s, and finish with 111. This can be done in six unique ways, resulting in six tetrahedra of the same shape that fill the cube.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-six-tetrahedra.png" width="390" height="490">
							<figcaption>Six tetrahedra in a cube.</figcaption>
						</figure>
						
						<p>We begin by copying the <code>Simplex2D.Kernel</code> method to <code>Simplex3D</code> and adjusting it to work for three dimensions. As we don't know the un-skew factor yet we'll set it to zero and use the same falloff start and scale as for 2D. Again we initially only show the falloff function, leaving the gradient evaluation for later.</p>
						
						<pre translate="no">	public struct Simplex3D&lt;G> : INoise where G : struct, IGradient {

		&hellip;

		<ins>static float4 Kernel (</ins>
			<ins>SmallXXHash4 hash, float4 lx, float4 ly, float4 lz, float4x3 positions</ins>
		<ins>) {</ins>
			<ins>float4 unskew = (lx + ly + lz) * 0f;</ins>
			<ins>float4</ins>
				<ins>x = positions.c0 - lx + unskew,</ins>
				<ins>y = positions.c1 - ly + unskew,</ins>
				<ins>z = positions.c2 - lz + unskew;</ins>
			<ins>float4 f = 0.5f - x * x - y * y - z * z;</ins>
			<ins>f = f * f * f * 8f;</ins>
			<ins>return max(0f, f);</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>The 3D version of <code>GetNoise</code> uses the same approach as the 2D version. This time we begin with the original frequency, leave the skew factor at zero, and only include the 000 and 111 kernels. As they lie on the XYZ diagonal they'll be part of every tetrahedron, while the other two kernels are variable.</p>
						
						<pre translate="no">		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			<ins>positions *= frequency;</ins>
			<ins>float4 skew = (positions.c0 + positions.c1 + positions.c2) * 0f;</ins>
			<ins>float4</ins>
				<ins>sx = positions.c0 + skew,</ins>
				<ins>sy = positions.c1 + skew,</ins>
				<ins>sz = positions.c2 + skew;</ins>
			<ins>int4</ins>
				<ins>x0 = (int4)floor(sx), x1 = x0 + 1,</ins>
				<ins>y0 = (int4)floor(sy), y1 = y0 + 1,</ins>
				<ins>z0 = (int4)floor(sz), z1 = z0 + 1;</ins>

			<ins>SmallXXHash4</ins>
				<ins>h0 = hash.Eat(x0), h1 = hash.Eat(x1);</ins>

			<ins>return default(G).EvaluateCombined(</ins>
				<ins>Kernel(h0.Eat(y0).Eat(z0), x0, y0, z0, positions) +</ins>
				<ins>Kernel(h1.Eat(y1).Eat(z1), x1, y1, z1, positions)</ins>
			<ins>);</ins>
		}</pre>
						
						<p>To find the skew factor `v` we'll look at the tetrahedron with corners `a=[[0],[0],[0]]`, `b=[[1],[0],[0]]`,`c=[[1],[0],[1]]`, and `d=[[1],[1],[1]]`.</p>
						
						<p>Just like for the triangle we'll find `v` by equating the square lengths of of the edges of the skewed `b`, `c`, and `d` vectors.This leads to a skew factor of &frac13;.</p>
						
						<pre translate="no">			float4 skew = (positions.c0 + positions.c1 + positions.c2) * <ins>(1f / 3f)</ins>;</pre>
						
						<p>And an un-skew factor of &frac16;.</p>
						
						<pre translate="no">		static float4 Kernel (
			SmallXXHash4 hash, float4 lx, float4 ly, float4 lz, float4x3 positions
		) {
			float4 unskew = (lx + ly + lz) * <ins>(1f / 6f)</ins>;
			&hellip;
		}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-kernels-000-111.png" width="220" height="220">
							<figcaption>3D kernels 000 and 111; frequency 4.</figcaption>
						</figure>
						
						<aside>
							<h3>How do you find the skew and un-skew values?</h3>
							<div>
								<p>Begin with calculating the conversion from cube to rhombohedron.</p>
								
								<p>`||b||^2=(1-v)^2+2(-v)^2=3v^2-2v+1`.</p>
								
								<p>`||c||^2=2(1-2v)^2+(-2v)^2=12v^2-8v+2`.</p>
								
								<p>`||d||^2=3(1-3v)^2=27v^2-18v+3`.</p>
								
								<p>First try `||b||^2=||c||^2->9v^2-6v+1=0->v=6/18=1/3`. If we use that then `||d||^2=0` so this is the degenerate case where the cube gets flattened and becomes a plane. This proves that we cannot create an equilateral tetrahedron via our skew operation. It is indeed impossible to tile 3D space with equilateral tetrahedra.</p>
								
								<p>Second, try `||b||^2=||d||^2=24v^2-16v+2=0->v=(2+-1)/6` of which we pick the one smaller than the degenerate case, so `v=1/6`. This leads to `||b||^2=||d||^2=3/4` and `||c||^2=1`. So we have two different square lengths, with difference `1/4`.</p>
								
								<p>Third, try `||c||^2=||d||^2=15v^2-10v+1=0->v=(5+-sqrt(10))/15` of which we again pick the smaller one, so `v=1/3-sqrt(2/5)/3`and `v^2=(7/5)/9-(2sqrt(2/5))/9` for ease of calculation.</p>
								
								<p>This leads to `||c||^2=||d||^2=6/5` and `||b||^2=4/5` with difference `2/5`.</p>
								
								<p>We pick the option with the smallest edge difference, so `v=1/6`.</p>
								
								<p>For skewing in the other direction we consider the transformation for point `d`. Using the same logic as for triangles but in 3D, we know `x+3vx=1` and `x=1-3/6=1/2`. Thus `1/2+(3v)/2=1->v=1/3`.</p>
							</div>
						</aside>
						
						<p>What we get is a lattice based on groups of six tetrahedra that have the same shape but different orientations. Each tetrahedron has four edges with length &radic;&frac34; and two edges with length 1.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-tetrahedron-skewed-unskewed.png" width="660" height="340">
							<figcaption>Tetrahedron both skewed and un-skewed.</figcaption>
						</figure>
						
						<p>We again scale the frequency to make it easier to compare noise variants. In this case the scale factor is 0.6.</p>
						
						<pre translate="no">		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			positions *= frequency <ins>* 0.6f</ins>;
			&hellip;
		}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-scaled-frequency.png" width="220" height="220">
							<figcaption>Scaled frequency, still 4.</figcaption>
						</figure>
						
						<aside>
							<h3>Where does that scale factor come from?</h3>
							<div>
								<p>We again match lattice points along the XZ axis line. We have to first find a 3D lattice point&mdash;other than the one at the origin&mdash;that exactly falls on that line. So we know that `x=z` and need to find some `y` that skews to zero.</p>
								
								<p>`y-(2x+y)/6=0->(5y)/6=x/3->y=(2x)/5`. This means that every five steps a lattice point lies exactly on the XZ line.</p>
								
								<p>Let's pick `x=5`: `[[5-12/6],[2-12/6],[5-12/6]]=[[3],[0],[3]]` at distance `sqrt(2(3^2))=3sqrt(2)` from the origin.</p>
								
								<p>For the square lattice the point after five steps along the XZ line is `[[5],[0],[5]]`, with distance `5sqrt(2)`.</p>
								
								<p>So to make the lattice frequencies match we have to divide the simplex distance by the square distance to find the scale factor `(3sqrt(2))/(5sqrt(2))=3/5=0.6`.</p>
							</div>
						</aside>
						
						<p>In order for the falloff function to be correct it should reach zero when it reaches the tetrahedron face opposite to the corner it is centered on. This distance is &radic;&frac12;, so our current falloff function is already correct.</p>
						
						<aside>
							<h3>Why is the falloff the same?</h3>
							<div>
								<p>We need to find the height of our tetrahedron. All its faces are isosceles triangles that have two short edges with length `l_s=sqrt(3/4)` and one long edge with length `l_l=1`.</p>
								
								<p>The height of our isosceles triangles is `h=sqrt(4l_s^2-l_l^2)/2=sqrt(2)/2=sqrt(1/2)`. Due to the shape of our tetrahedrons this is also the height of the tetrahedron itself. Thus the height of our 3D lattice tetrahedra is the same as the height of our 2D lattice triangles.</p>
								
								<figure>
									<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-tetrahedron-topology.png" width="560" height="340">
									<figcaption>Tetrahedron topology, with side views.</figcaption>
								</figure>
							</div>
						</aside>
						
					</section>
					
					<section>
						<h3>Four Kernels</h3>
						
						<p>A tetrahedron has four corners, so we need to select two more kernels. Which kernels are needed can be decided in a similar way that we found the variable kernel in 2D, but now in three dimensions. We do this by walking along the edges of the cubes depending on which relative coordinates are greatest. If X is greater than both Y and Z then we go from corner 000 to 100. After that we go to 110 if Y is greater than Z, otherwise to 101. Each tetrahedron has a similar pattern.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-choosing-kernels.png" width="400" height="350">
							<figcaption>Choosing kernels in two steps; the greater-than signs match walk direction.</figcaption>
						</figure>
						
						<p>To do this we can suffice with checking three comparisons: whether X is greater than Y, whether X is greater than Z, and whether Y is greater than Z.</p>
						
						<pre translate="no">			int4
				x0 = (int4)floor(sx), x1 = x0 + 1,
				y0 = (int4)floor(sy), y1 = y0 + 1,
				z0 = (int4)floor(sz), z1 = z0 + 1;

			<ins>bool4</ins>
				<ins>xGy = sx - x0 > sy - y0,</ins>
				<ins>xGz = sx - x0 > sz - z0,</ins>
				<ins>yGz = sy - y0 > sz - z0;</ins></pre>
						
						<p>With these three boolean checks we can construct a truth table that contains a row for all eight possible combinations. For each row we can also write down the first and second kernel offset per dimension, either zero or one.</p>
						
						<table>
							<th>
								<tr>
									<th>x>y</th><th>x>z</th><th>y>z</th>
									<th>X</th><th>Y</th><th>Z</th>
								</tr>
							</th>
							<tbody>
								<tr><td>T</td><td>T</td><td>T</td><td>1 1</td><td>0 1</td><td>0 0</td></tr>
								<tr><td>T</td><td>T</td><td>F</td><td>1 1</td><td>0 0</td><td>0 1</td></tr>
								<tr><td>T</td><td>F</td><td>T</td><td>0 1</td><td>0 0</td><td>1 1</td></tr>
								<tr><td>T</td><td>F</td><td>F</td><td>0 1</td><td>0 0</td><td>1 1</td></tr>
								<tr><td>F</td><td>T</td><td>T</td><td>0 1</td><td>1 1</td><td>0 0</td></tr>
								<tr><td>F</td><td>T</td><td>F</td><td>0 0</td><td>0 1</td><td>1 1</td></tr>
								<tr><td>F</td><td>F</td><td>T</td><td>0 0</td><td>1 1</td><td>0 1</td></tr>
								<tr><td>F</td><td>F</td><td>F</td><td>0 0</td><td>0 1</td><td>1 1</td></tr>
							</tbody>
						</table>
						
						<p>Because we cannot branch in our vectorized code we have to convert this to independent selection criteria for the first and second offsets per dimension. We'll keep track of whether the first X offset is 1 with an <code>xA</code> boolean variable and use <code>xB</code> for the second X offset. We'll use similar variables for Y and Z. Then we convert the truth table to boolean expressions and use those to set the variables. Note that we have to use the <code>&amp;</code> operator for vectorized boolean AND, rather than the usual <code>&amp;&amp;</code> operator.</p>
						
						<pre translate="no">			bool4
				xGy = sx - x0 > sy - y0,
				xGz = sx - x0 > sz - z0,
				yGz = sy - y0 > sz - z0;

			<ins>bool4</ins>
				<ins>xA = xGy &amp; xGz,</ins>
				<ins>xB = xGy | (xGz & yGz),</ins>
				<ins>yA = !xGy &amp; yGz,</ins>
				<ins>yB = !xGy | (xGz &amp; yGz),</ins>
				<ins>zA = (xGy &amp; !xGz) | (!xGy &amp; !yGz),</ins>
				<ins>zB = !(xGz &amp; yGz);</ins></pre>
						
						<p>Use these to find the lattice point choices for the variable kernels.</p>
						
						<pre translate="no">			bool4
				xA = xGy & xGz,
				xB = xGy | (xGz & yGz),
				yA = !xGy & yGz,
				yB = !xGy | (xGz & yGz),
				zA = (xGy & !xGz) | (!xGy & !yGz),
				zB = !(xGz & yGz);

			<ins>int4</ins>
				<ins>xCA = select(x0, x1, xA),</ins>
				<ins>xCB = select(x0, x1, xB),</ins>
				<ins>yCA = select(y0, y1, yA),</ins>
				<ins>yCB = select(y0, y1, yB),</ins>
				<ins>zCA = select(z0, z1, zA),</ins>
				<ins>zCB = select(z0, z1, zB);</ins></pre>
						
						<p>Then add the missing kernels to the sum. In this case we can reuse the fed kernels for both choices of X.</p>
						
						<pre translate="no">			SmallXXHash4
				h0 = hash.Eat(x0), h1 = hash.Eat(x1)<ins>,</ins>
				<ins>hA = SmallXXHash4.Select(h0, h1, xA),</ins>
				<ins>hB = SmallXXHash4.Select(h0, h1, xB)</ins>;

			return default(G).EvaluateCombined(
				Kernel(h0.Eat(y0).Eat(z0), x0, y0, z0, positions) +
				Kernel(h1.Eat(y1).Eat(z1), x1, y1, z1, positions) <ins>+</ins>
				<ins>Kernel(hA.Eat(yCA).Eat(zCA), xCA, yCA, zCA, positions) +</ins>
				<ins>Kernel(hB.Eat(yCB).Eat(zCB), xCB, yCB, zCB, positions)</ins>
			);</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-all-kernels.png" width="220" height="220">
							<img src="simplex-value-noise/2d-scaled-frequency.png" width="220" height="220">
							<figcaption>All kernels, without displacement; 3D and 2D.</figcaption>
						</figure>
						
						<p>The resulting kernel pattern looks similar to the 2D simplex lattice, but it has some variability due to its 3D nature and it not being aligned with the XZ plane. In this case we can find multiple different amplitude minima: at the midpoint of the short edges `m_s=125/256~~0.488`, at the midpoint of the long edges `m_l=1/4=0.25`, at the circumcenter of triangles `m_c=1029/4026~~0.256`, and at the circumcenter of the tetrahedron `m_t=27/128~~0.211`.</p>
						
						<aside>
							<h3>How do you find those minima?</h3>
							<div>
								<p>The falloff function based on distance is again `f(d)=8(1/2-d^2)^3`.</p>
								
								<p>The minimum along short edges is `m_s=2f(l_s/2)=16(1/2-3/16)^3=16(5/16)^3=125/256`.</p>
								
								<p>The minimum along long edges is `m_l=2f(1/2)=16(1/4)^3=1/4`.</p>
								
								<p>The distance from corners to the isosceles triangle center is equal to the radius of the circumscribed circle `r=l_s^2/(2h)=(3sqrt(2))/8`.</p>
								
								<p>So the triangle circumcenter minimum is `m_c=3f(r)=24(1/2-9/32)^3=24(7/32)^3=1029/4026`</p>
								
								<p>The circumsphere radius of the tetrahedron made with isosceles triangles is `r=sqrt((2l_s^2+l_l^2)/8)=sqrt(5/16)=sqrt(5)/4`.</p>
								
								<p>So the tetrahedron circumcenter minimum is `m_t=4f(r)=32(1/2-5/16)^3=32(3/16)^3=27/128`.</p>
							</div>
						</aside>
						
						<p>The variability is easier to see at higher frequencies.</p>
						
						<figure>
							<img src="simplex-value-noise/3d-frequency-16.png" width="220" height="220">
							<figcaption>Frequency 16.</figcaption>
						</figure>
						
						<p>There is a noticeable diagonal pattern. This is a consequence of the 3D skew, as the distance in the Z dimension of lattice points to the sample plane varies. The pattern depends on the orientation of the 2D slice. For example, compare no rotation with a 45&deg; domain rotation in a single dimension.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-rotation-x.png" width="220" height="220" alt="X">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-rotation-y.png" width="220" height="220" alt="Y">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-rotation-z.png" width="220" height="220" alt="Z">
							<figcaption>45&deg; domain rotation around X, Y, and Z.</figcaption>
						</figure>
						
						<p>Another interesting domain rotation is 45&deg; around both X and Y, which aligns the slice such that we look straight down the XYZ line.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-rotation-xy.png" width="220" height="220">
							<figcaption>45&deg; rotation around both X and Y.</figcaption>
						</figure>
						
						<p>Finally, we complete 3D simplex value noise by inserting the gradient evaluation.</p>
						
						<pre translate="no">			return max(0f, f) <ins>* default(G).Evaluate(hash, x, y, z)</ins>;</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-simplex-value.png" width="220" height="220" alt="no rotation">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-simplex-value-rotated-x.png" width="220" height="220" alt="X rotation"><br>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-simplex-value-rotated-y.png" width="220" height="220" alt="Y rotation">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-simplex-value-rotated-z.png" width="220" height="220" alt="Z rotation">
							<figcaption>3D simplex value noise, without rotation and with 45&deg; rotation around X, Y, and Z.</figcaption>
						</figure>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-simplex-value-rotated-xy.png" width="220" height="220" alt="simplex">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-value-rotated-xy.png" width="220" height="220" alt="interpolated">
							<figcaption>45&deg; rotation around both X and Y, simplex and regular 3D value noise.</figcaption>
						</figure>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-simplex-value-turbulence-rotated-xy.png" width="220" height="220" alt="simplex">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-value-turbulence-rotated-xy.png" width="220" height="220" alt="interpolated">
							<figcaption>45&deg; rotation around both X and Y, simplex and regular 3D value turbulence.</figcaption>
						</figure>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-simplex-value-turbulence.png" width="220" height="220" alt="3D">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/2d-simplex-value-turbulence.png" width="220" height="220" alt="2D">
							<figcaption>3D and 2D simplex value turbulence.</figcaption>
						</figure>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-value-noise/3d-sphere-simplex-value.png" width="270" height="290" alt="simplex">
							<img src="simplex-value-noise/3d-sphere-value.png" width="270" height="290" alt="interpolated">
							<figcaption>3D simplex and regular value noise on a sphere.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Simplex Gradient Noise</h2>
					
					<p>To generate simplex gradient noise we need appropriate gradient vectors. We already have the <code>Perlin</code> struct type, but we based it on square and octahedron shapes. We did this because it worked well with the square and cube lattices and avoided vector normalization. However, the simplex lattices aren't axis-aligned and thus we'll need to use circle- and sphere-based gradients for simplex noise.</p>
					
					<section>
						<h3>Base Gradients</h3>
						
						<p>The only difference between the square and circle and also between octahedron and sphere is whether their vectors are normalized. So rather than duplicate the vector-generating code we'll put it in a nested static <code>Noise.BaseGradients</code> class. Let's also do this for the line gradient and start with that, introducing a <code>BaseGradients.Line</code> method and use it in <code>Perlin</code>.</p>
						
						<pre translate="no">	public struct Perlin : IGradient {

		public float4 Evaluate (SmallXXHash4 hash, float4 x) =>
			<del>//(1f + hash.Floats01A) * select(-x, x, ((uint4)hash & 1 << 8) == 0);</del>
			<ins>BaseGradients.Line(hash, x);</ins>

		&hellip;
	}

	<ins>public static class BaseGradients {</ins>

		<ins>public static float4 Line (SmallXXHash4 hash, float4 x) =></ins>
			<ins>(1f + hash.Floats01A) * select(-x, x, ((uint4)hash & 1 << 8) == 0);</ins>
	<ins>}</ins></pre>
						
						<p>Then give <code>BaseGradients</code> private methods that generate and return the square- or octahedron-based vectors, given a hash.</p>
						
						<pre translate="no">		<ins>static float4x2 SquareVectors (SmallXXHash4 hash) {</ins>
			<ins>float4x2 v;</ins>
			<ins>v.c0 = hash.Floats01A * 2f - 1f;</ins>
			<ins>v.c1 = 0.5f - abs(v.c0);</ins>
			<ins>v.c0 -= floor(v.c0 + 0.5f);</ins>
			<ins>return v;</ins>
		<ins>}</ins>
		
		<ins>static float4x3 OctahedronVectors (SmallXXHash4 hash) {</ins>
			<ins>float4x3 g;</ins>
			<ins>g.c0 = hash.Floats01A * 2f - 1f;</ins>
			<ins>g.c1 = hash.Floats01D * 2f - 1f;</ins>
			<ins>g.c2 = 1f - abs(g.c0) - abs(g.c1);</ins>
			<ins>float4 offset = max(-g.c2, 0f);</ins>
			<ins>g.c0 += select(-offset, offset, g.c0 < 0f);</ins>
			<ins>g.c1 += select(-offset, offset, g.c1 < 0f);</ins>
			<ins>return g;</ins>
		<ins>}</ins></pre>
						
						<p>Use these methods to implement <code>Square</code>, <code>Circle</code>, <code>Octahedron</code>, and <code>Sphere€</code> gradient methods, without any scaling.</p>
						
						<pre translate="no">		<ins>public static float4 Square (SmallXXHash4 hash, float4 x, float4 y) {</ins>
			<ins>float4x2 v = SquareVectors(hash);</ins>
			<ins>return v.c0 * x + v.c1 * y;</ins>
		<ins>}</ins>
	
		<ins>public static float4 Circle (SmallXXHash4 hash, float4 x, float4 y) {</ins>
			<ins>float4x2 v = SquareVectors(hash);</ins>
			<ins>return (v.c0 * x + v.c1 * y) * rsqrt(v.c0 * v.c0 + v.c1 * v.c1);</ins>
		<ins>}</ins>
	
		<ins>public static float4 Octahedron (</ins>
			<ins>SmallXXHash4 hash, float4 x, float4 y, float4 z</ins>
		<ins>) {</ins>
			<ins>float4x3 v = OctahedronVectors(hash);</ins>
			<ins>return v.c0 * x + v.c1 * y + v.c2 * z;</ins>
		<ins>}</ins>

		<ins>public static float4 Sphere€ (SmallXXHash4 hash, float4 x, float4 y, float4 z) {</ins>
			<ins>float4x3 v = OctahedronVectors(hash);</ins>
			<ins>return</ins>
				<ins>(v.c0 * x + v.c1 * y + v.c2 * z) *</ins>
				<ins>rsqrt(v.c0 * v.c0 + v.c1 * v.c1 + v.c2 * v.c2);</ins>
		<ins>}</ins></pre>
						
						<p>Then use the <code>Square</code> and <code>Octahedron</code> methods in <code>Perlin</code>, applying the appropriate scaling there.</p>
						
						<pre translate="no">		public float4 Evaluate (SmallXXHash4 hash, float4 x, float4 y) <ins>=></ins>
			<ins>BaseGradients.Square(hash, x, y) * (2f / 0.53528f);</ins>
		
		public float4 Evaluate (SmallXXHash4 hash, float4 x, float4 y, float4 z) <ins>=></ins>
			<ins>BaseGradients.Octahedron(hash, x, y, z) * (1f / 0.56290f);</ins></pre>
					</section>
					
					<section>
						<h3>Simplex Gradients</h3>
						
						<p>Now we can create a <code>Simplex</code> gradient type that uses the line, circle, and sphere base gradients. We leave them unscaled for now.</p>
						
						<pre translate="no">	<ins>public struct Simplex : IGradient {</ins>

		<ins>public float4 Evaluate (SmallXXHash4 hash, float4 x) =></ins>
			<ins>BaseGradients.Line(hash, x);</ins>

		<ins>public float4 Evaluate (SmallXXHash4 hash, float4 x, float4 y) =></ins>
			<ins>BaseGradients.Circle(hash, x, y);</ins>

		<ins>public float4 Evaluate (SmallXXHash4 hash, float4 x, float4 y, float4 z) =></ins>
			<ins>BaseGradients.Sphere€(hash, x, y, z);</ins>

		<ins>public float4 EvaluateCombined (float4 value) => value;</ins>
	<ins>}</ins></pre>
						
						<p>To be able to visualize the simplex gradient noise variants, add entries for them to <code>NoiseVisualization.NoiseType</code>.</p>
						
						<pre translate="no">	public enum NoiseType {
		Perlin€, PerlinTurbulence, Value€, ValueTurbulence,
		<ins>Simplex€, SimplexTurbulence,</ins> SimplexValue, SimplexValueTurbulence,
		VoronoiWorleyF1, VoronoiWorleyF2, VoronoiWorleyF2MinusF1,
		VoronoiChebyshevF1, VoronoiChebyshevF2, VoronoiChebyshevF2MinusF1
	}</pre>
						
						<p>Also add them to the job array, at the appropriate location.</p>
						
						<pre translate="no">		<ins>{</ins>
			<ins>Job&lt;Simplex1D&lt;Simplex>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex1D&lt;Simplex>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex2D&lt;Simplex>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex2D&lt;Simplex>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex3D&lt;Simplex>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex3D&lt;Simplex>>.ScheduleParallel</ins>
		<ins>},</ins>
		<ins>{</ins>
			<ins>Job&lt;Simplex1D&lt;Turbulence&lt;Simplex>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex1D&lt;Turbulence&lt;Simplex>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex2D&lt;Turbulence&lt;Simplex>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex2D&lt;Turbulence&lt;Simplex>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex3D&lt;Turbulence&lt;Simplex>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Simplex3D&lt;Turbulence&lt;Simplex>>>.ScheduleParallel</ins>
		<ins>},</ins></pre>
						
						<p>This gives us functional simplex noise, but we still have to normalize it.</p>
					</section>
					
					<section>
						<h3>1D Simplex Noise</h3>
						
						<p>To normalize 1D simplex noise we have to find its unscaled maximum. Just like with Perlin noise, the maximum can only be reaches when the gradients of adjacent kernels point toward each other. Thus the maximum gradient function of a kernel can be described as `m(x)=xf(x)=x(1-x^2)^3`.</p>
						
						<figure>
							<img src="simplex-gradient-noise/1d-maximum.png" width="160" height="160">
							<figcaption>Maximum amplitude of adjacent kernels and their sum.</figcaption>
						</figure>
						
						<p>The sum of both kernels reaches its maximum at `x=1/2`. the maximum amplitude of the unscaled noise is `2m(1/2)=(3/4)^3=27/64`. But because <code>Line</code> produces a variable factor with a maximum of 2 we have to double the result. The normalization factor is the inverse of that: `32/27`. Include it in the 1D version of <code>Simplex.Evaluate</code>.</p>
						
						<pre translate="no">		public float4 Evaluate (SmallXXHash4 hash, float4 x) =>
			BaseGradients.Line(hash, x) <ins>* (32f / 27f)</ins>;</pre>
						
						<p>The final result is very similar to 1D Perlin noise.</p>
						
						<figure>
							<img src="simplex-gradient-noise/1d-simplex.png" width="420" height="80" alt="simplex">
							<img src="simplex-gradient-noise/1d-perlin.png" width="420" height="80" alt="perlin">
							<figcaption>1D simplex and Perlin noise.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>2D Simplex Noise</h3>
						
						<p>In two dimensions we have two candidates for the maximum, that coincide with the minima of the falloff sums: the midpoint of an edge and the center of the triangle.</p>
						
						<p>The edge maximum is `(lm_e)/2=(sqrt(2)/(2sqrt(3)))(16/27)=(8sqrt(2))/(27sqrt(3))~~0.2419`.</p>
						
						<p>The center maximum is `rm_c=(sqrt(2)/3)(1000/1944)=(1000sqrt(2))/5832~~0.2425`.</p>
						
						<figure>
							<img src="simplex-gradient-noise/2d-maxima-visualization.png" width="220" height="190">
							<figcaption>Maxima visualized with gradient; white is highest.</figcaption>
						</figure>
						
						<p>As the center maximum is the largest we normalize 2D simplex noise via scaling with `1/(lm_c)=5832/(1000sqrt(2))`.</p>
						
						<pre translate="no">		public float4 Evaluate (SmallXXHash4 hash, float4 x, float4 y) =>
			BaseGradients.Circle(hash, x, y) <ins>* (5.832f / sqrt(2f))</ins>;</pre>
						
						<figure>
							<img src="simplex-gradient-noise/2d-simplex.png" width="220" height="220" alt="simplex">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-gradient-noise/2d-perlin.png" width="220" height="220" alt="perlin">
							<figcaption>2D simplex and Perlin noise.</figcaption>
						</figure>
						
						<figure>
							<img src="simplex-gradient-noise/2d-simplex-turbulence.png" width="220" height="220" alt="simplex">
							<img src="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/simplex-noise/simplex-gradient-noise/2d-perlin-turbulence.png" width="220" height="220" alt="perlin">
							<figcaption>2D simplex and Perlin turbulence noise.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>3D Simplex Noise</h3>
						
						<p>To normalize the 3D gradients we first calculate the short edge maximum `(l_sm_s)/2=(125sqrt(3))/1024~~0.2114`.</p>
						
						<p>Second, the long edge maximum at its middle is `(l_lm_l)/2=1/8=0.125`. In fact, its kernels are so far apart that it has two maxima instead of one in the middle. But we don't need to calculate those because they're guaranteed to be smaller than the short edge maximum.</p>
						
						<figure>
							<img src="simplex-gradient-noise/3d-maxima-long-edge.png" width="160" height="160">
							<figcaption>Two maxima along a long edge.</figcaption>
						</figure>
						
						<p>The face triangles and tetrahedron interior also don't have a single maximum, the kernels are too far apart. Nowhere is the short edge maximum exceeded.</p>
						
						<figure>
							<img src="simplex-gradient-noise/3d-maxima-visualization.png" width="200" height="240">
							<figcaption>Maxima visualized with gradient; white is highest.</figcaption>
						</figure>
						
						<p>Thus our normalization factor is `2/(l_sm_s)=1024/(125sqrt(3))`.</p>
						
						<pre translate="no">		public float4 Evaluate (SmallXXHash4 hash, float4 x, float4 y, float4 z) =>
			BaseGradients.Sphere(hash, x, y, z) <ins>* (1024f / (125f * sqrt(3f)))</ins>;</pre>
						
						<figure>
							<img src="simplex-gradient-noise/3d-simplex.png" width="220" height="220" alt="simplex">
							<img src="simplex-gradient-noise/3d-perlin.png" width="220" height="220" alt="perlin"><br>
							<img src="simplex-gradient-noise/3d-simplex-rotated-xy.png" width="220" height="220" alt="simplex rotated">
							<img src="simplex-gradient-noise/3d-perlin-rotated-xy.png" width="220" height="220" alt="perlin rotated">
							<figcaption>3D simplex and Perlin noise; no rotation and 45&deg; XY rotation.</figcaption>
						</figure>
						
						<figure>
							<img src="simplex-gradient-noise/3d-simplex-turbulence.png" width="220" height="220" alt="simplex">
							<img src="simplex-gradient-noise/3d-perlin-turbulence.png" width="220" height="220" alt="perlin"><br>
							<img src="simplex-gradient-noise/3d-simplex-turbulence-rotated-xy.png" width="220" height="220" alt="simplex rotated">
							<img src="simplex-gradient-noise/3d-perlin-turbulence-rotated-xy.png" width="220" height="220" alt="perlin rotated">
							<figcaption>3D simplex and Perlin noise; no rotation and 45&deg; XY rotation.</figcaption>
						</figure>
						
						<figure>
							<img src="simplex-gradient-noise/3d-sphere-simplex.png" width="290" height="280" alt="simplex">
							<img src="simplex-gradient-noise/3d-sphere-perlin.png" width="270" height="280" alt="perlin">
							<figcaption>3D simplex and Perlin noise on a sphere.</figcaption>
						</figure>
						
						<p>Want to know when the next tutorial gets released? Keep tabs on my <a href="https://www.patreon.com/catlikecoding">Patreon</a> page!</p>
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/pseudorandom-noise-07-simplex-noise/" class="repository">repository</a>
					<a href="Simplex-Noise.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>