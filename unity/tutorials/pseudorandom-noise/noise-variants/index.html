<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/noise-variants/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/pseudorandom-noise/noise-variants/tutorial-image.jpg">
		<meta property="og:title" content="Noise Variants">
		<meta property="og:description" content="A Unity C# Pseudorandom Noise tutorial about creating fractal and tiling variants of Perlin and value noise.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Noise Variants</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">
		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/pseudorandom-noise/noise-variants/#article",
				"headline": "Noise Variants",
				"alternativeHeadline": "Fractals and Tiling",
				"datePublished": "2021-07-07",
				"dateModified": "2022-03-10",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity C# Pseudorandom Noise tutorial about creating fractal and tiling variants of Perlin and value noise.",
				"image": "https://catlikecoding.com/unity/tutorials/pseudorandom-noise/noise-variants/tutorial-image.jpg",
				"dependencies": "Unity 2020.3.12f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/pseudorandom-noise/", "name": "Pseudorandom Noise" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				G: 1,
				HashJob: 1,
				HashVisualization: 1,
				IGradient: 1,
				ILattice: 1,
				INoise: 1,
				IShape: 1,
				Job: 1,
				L: 1,
				Lattice1D: 1,
				Lattice2D: 1,
				Lattice3D: 1,
				LatticeNormal : 1,
				LatticeSpan4 : 1,
				LatticeTiling : 1,
				MathExtensions: 1,
				N: 1,
				Noise: 1,
				NoiseType: 1,
				NoiseVisualization: 1,
				Perlin: 1,
				Plane : 1,
				Point4: 1,
				S: 1,
				ScheduleDelegate: 1,
				Settings: 1,
				Shape: 1,
				Shapes: 1,
				SmallXXHash: 1,
				SmallXXHash4: 1,
				SpaceTRS: 1,
				Sphere: 1,
				Torus: 1,
				Turbulence: 1,
				Value: 1,
				Visualization: 1
			};
			
			var hasMath = false;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Pseudorandom Noise</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Noise Variants</h1>
					<p>Fractals and Tiling</p>
					<ul>
						<li>Combine multiple octaves of noise to create fractal patterns.</li>
						<li>Introduce turbulence version of Perlin and value noise.</li>
						<li>Add an option to create tiling noise.</li>
					</ul>
				</header>
				
				<p>This is the fifth tutorial in a series about <a href="../index.html">pseudorandom noise</a>. It adds fractal noise, turbulence, and tiling.</p>
				
				<p>This tutorial is made with Unity 2020.3.12f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>A torus showing six octaves of lacunarity 3 fractal 3D Perlin noise.</figcaption>
				</figure>
				
				<section>
					<h2>Fractal Noise</h2>
					
					<p>Up to this point we have only worked with a single sample of Perlin or value noise per point. The result appears random, but all features of the patterns have the same size. There is variety, but it is based on a uniform lattice. All variation exists at a single scale, determined by the domain transformation. The noise lacks variety at larger and smaller scales, which betrays its artificial nature.</p>
					
					<p>We can introduce variety at a second frequency by sampling the noise again at a different scale. The simplest approach is to sample it at a base scale and also at double that scale. The sum of both samples produces a noise that has both large-scale and small-scale variety. We can do this multiply times, each extra sample at a larger domain scale adding smaller features. The resulting pattern would exhibit self-similarity as smaller features resemble larger features, thus the result is known as fractal noise.</p>
					
					<section>
						<h3>Noise Settings</h3>
						
						<p>To support fractal noise we'll have to add some more configuration options to control it. To make it easy to pass the configuration to <code>Noise</code> we'll begin by creating a public <code>Noise.Settings</code> struct, initially only containing a seed integer field. As this struct is purely for conveniently grouping configuration options we make the field <code>public</code> and mark the struct as serializable with the <code>System.Serializable</code> attribute. That way Unity can save the configuration and it's easy to access its contents.</p>
						
						<pre translate="no"><ins>using System;</ins>
using Unity.Burst;
&hellip;

public static partial class Noise {

	<ins>[Serializable]</ins>
	<ins>public struct Settings {</ins>

		<ins>public int seed;</ins>
	<ins>}</ins>
	
	&hellip;
}</pre>
						
						<p>Struct fields cannot have default values other than zero or <code>null</code>, so we'll provide a default <code>Settings</code> configuration via a public static property. Initially it returns an unmodified new value, but we'll add field initializations to it later.</p>
						
						<pre translate="no">	public struct Settings {

		public int seed;

		<ins>public static Settings Default => new Settings {};</ins>
	}</pre>
						
						<p>Now adjust <code>Noise.Job</code> so it works with a <code>Settings</code> value instead of a hash directly. The hash is then intialized in <code>Execute</code> based on the configured seed.</p>
						
						<pre translate="no">		<del>//public SmallXXHash4 hash;</del>
		<ins>public Settings settings;</ins>

		public float3x4 domainTRS;

		public void Execute (int i) {
			<ins>var hash = SmallXXHash4.Seed(settings.seed);</ins>
			noise[i] = default(N).GetNoise4(
				domainTRS.TransformVectors(transpose(positions[i])), hash
			);
		}

		public static JobHandle ScheduleParallel (
			NativeArray&lt;float3x4> positions, NativeArray&lt;float4> noise, <del>//int seed,</del>
			<ins>Settings settings,</ins> SpaceTRS domainTRS, int resolution, JobHandle dependency
		) => new Job&lt;N> {
			positions = positions,
			noise = noise,
			<del>//hash = SmallXXHash.Seed(seed),</del>
			<ins>settings = settings,</ins>
			domainTRS = domainTRS.Matrix,
		}.ScheduleParallel(positions.Length, resolution, dependency);</pre>
						
						<p>Adjust the delegate type to match the new signature of <code>ScheduleParallel</code>.</p>
						
						<pre translate="no">	public delegate JobHandle ScheduleDelegate (
		NativeArray&lt;float3x4> positions, NativeArray&lt;float4> noise, <del>//int seed,</del>
		<ins>Settings settings,</ins> SpaceTRS trs, int resolution, JobHandle dependency
	);</pre>
						
						<p>Finally, replace the seed configuration field of <code>NoiseVisualization</code> with a <code>Settings</code> field and pass that to the job instead.</p>
						
						<pre translate="no">	[SerializeField]
	<del>//int seed;</del>
	<ins>Settings noiseSettings = Settings.Default;</ins>

	&hellip;

	protected override void UpdateVisualization (
		NativeArray&lt;float3x4> positions, int resolution, JobHandle handle
	) {
		noiseJobs[(int)type, dimensions - 1](
			positions, noise, <ins>noiseSettings</ins>, domain, resolution, handle
		).Complete();
		noiseBuffer.SetData(noise);
	}</pre>
						
						<figure>
							<img src="fractal-noise/settings-seed.png" width="320" height="82">
							<figcaption>Seed nested inside noise settings.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Frequency</h3>
						
						<p>We're still only sampling the noise once per point. Currently the scale of the pattern is determined by the domain scale. This scale is also known as the frequency of the noise, which describes how fast it changes. The higher the frequency or scale, the faster it changes thus the smaller its features are.</p>
						
						<p>We make it easier to adjust the frequency by adding a field for it to <code>Settings</code>. We restrict the frequency to whole numbers for reasons that will become clear later, so make it an integer. The frequency must be positive and at least one&mdash;enforced in the inspector via the <code>Min</code> attribute&mdash;and let's give it a default of 4.</p>
						
						<pre translate="no">&hellip;
<ins>using UnityEngine;</ins>

using static Unity.Mathematics.math;

public static partial class Noise {

	[Serializable]
	public struct Settings {

		public int seed;

		<ins>[Min(1)]</ins>
		<ins>public int frequency;</ins>

		public static Settings Default => new Settings {
			<ins>frequency = 4</ins>
		};
	}
	
	&hellip;
}</pre>
						
						<figure>
							<img src="fractal-noise/settings-frequency.png" width="320" height="240">
							<figcaption>Frequency set to 4, domain scale set to 1.</figcaption>
						</figure>
						
						<p>To apply the frequency, use it to scale the transformed position in <code>Noise.Job.Execute</code>.</p>
						
						<pre translate="no">		public void Execute (int i) {
			<ins>float4x3 position = domainTRS.TransformVectors(transpose(positions[i]));</ins>
			var hash = SmallXXHash4.Seed(settings.seed);
			<ins>int frequency = settings.frequency;</ins>
			noise[i] = default(N).GetNoise4(<ins>frequency * position</ins>, hash);
		}</pre>
						
						<p>From now on both the frequency and the domain scale can be used to adjust the scale of the noise. The frequency is uniform, while the domains scale can be nonuniform and even negative per dimension.</p>
					</section>
					
					<section>
						<h3>Octaves</h3>
						
						<p>Fractal noise consists of multiple samples at different frequencies. These are known as octaves. Perfect fractal noise would have an infinite amount of octaves, but we'll have to calculate each octave separately so can only support a few. The more octaves there are the more details the noise has, but it also takes longer to generate. So we add an integer field to control the amount of octaves to <code>Settings</code>. There should be at least one octave and six is a reasonable maximum. A single octave is a good default.</p>
						
						<pre translate="no">		<ins>[Range(1, 6)]</ins>
		<ins>public int octaves;</ins>

		public static Settings Default => new Settings {
			frequency = 4<ins>,</ins>
			<ins>octaves = 1</ins>
		};</pre>
						
						<figure>
							<img src="fractal-noise/settings-octaves.png" width="320" height="78">
							<figcaption>Octaves set to 3.</figcaption>
						</figure>
						
						<p>Now change <code>Noise.Job.Execute</code> so it loops over all octaves, invoking <code>GetNoise4</code> each time and doubling the frequency afterwards. Sum all samples and use that for the final noise values.</p>
						
						<pre translate="no">		public void Execute (int i) {
			float4x3 position = domainTRS.TransformVectors(transpose(positions[i]));
			var hash = SmallXXHash4.Seed(settings.seed);
			int frequency = settings.frequency;
			<ins>float4 sum = 0f;</ins>

			<ins>for (int o = 0; o &lt; settings.octaves; o++) {</ins>
				<ins>sum +=</ins> default(N).GetNoise4(frequency * position, hash);
				<ins>frequency *= 2;</ins>
			<ins>}</ins>
			noise[i] = <ins>sum;</ins>
		}</pre>
						
						<p>I'll use screenshots of value noise to demonstrate the results because its blocky pattern makes the different octaves easier to spot than those of Perlin noise.</p>
						
						<figure>
							<img src="fractal-noise/octaves-1.png" width="220" height="220" alt="1 octave">
							<img src="fractal-noise/octaves-2-full-strength.png" width="220" height="220" alt="2 octaves">
							<img src="fractal-noise/octaves-3-full-strength.png" width="220" height="220" alt="3 octaves">
							<figcaption>One, two, and three octaves of 2D value noise.</figcaption>
						</figure>
						
						<p>When summing multiple octaves of the same strength the higher frequencies will dominate the result. The idea of fractal noise is that the amplitude of an octave decreases as its frequency increases. So each time we double the frequency we should also halve the amplitude of the noise.</p>
						
						<pre translate="no">			int frequency = settings.frequency;
			<ins>float amplitude = 1f;</ins>
			float4 sum = 0f;

			for (int o = 0; o &lt; settings.octaves; o++) {
				sum += <ins>amplitude *</ins> default(N).GetNoise4(frequency * position, hash);
				frequency *= 2;
				<ins>amplitude *= 0.5f;</ins>
			}</pre>
						
						<p>Besides that, summing multiple octaves produces noise that goes outside the &minus;1&ndash;1 range. So we should normalize the result, by dividing the octave sum by the sum of the amplitudes.
						
						<pre translate="no">			float amplitude = 1f<ins>, amplitudeSum = 0f</ins>;
			float4 sum = 0f;

			for (int o = 0; o &lt; settings.octaves; o++) {
				sum += amplitude * default(N).GetNoise4(frequency * position, hash);
				<ins>amplitudeSum += amplitude;</ins>
				frequency *= 2;
				amplitude *= 0.5f;
			}
			noise[i] = sum <ins>/ amplitudeSum</ins>;</pre>
						
						<figure>
							<img src="fractal-noise/octaves-1.png" width="220" height="220" alt="1 octave">
							<img src="fractal-noise/octaves-2.png" width="220" height="220" alt="2 octaves">
							<img src="fractal-noise/octaves-3.png" width="220" height="220" alt="3 octaves">
							<figcaption>One, two, and three octaves with decreasing amplitude and normalization.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Unique Seeds Per Octave</h3>
						
						<p>We're currently summing the exact same noise pattern at different scales. A consequence of this is that at the domain origin the pattern appears to collapse into a singularity. Visually obvious repetition occurs at different scales, converging at the origin.</p>
						
						<figure>
							<img src="fractal-noise/octaves-6-same-seed.png" width="220" height="220">
							<figcaption>Six octaves with the same seed.</figcaption>
						</figure>
						
						<p>We can eliminate this visual artifact by using different hashes per octave. Incrementing the accumulator of <code>SmallXXHash4</code> is enough for this, effectively using successive seeds per octave.</p>
						
						<p>Add an addition operator method to <code>SmallXXHash4</code> to support adding an integer value to the accumulator, which yields a different hash.</p>
						
						<pre translate="no">	<ins>public static SmallXXHash4 operator + (SmallXXHash4 h, int v) =></ins>
		<ins>h.accumulator + (uint)v;</ins></pre>
						
						<p>Then add the octave iterator value to the hash passed to <code>GetNoise4</code> in the loop of <code>Noise.Job.Execute</code>.</p>
						
						<pre translate="no">				sum += amplitude * default(N).GetNoise4(frequency * position, hash <ins>+ o</ins>);</pre>
						
						<figure>
							<img src="fractal-noise/octaves-6-different-seeds.png" width="220" height="220">
							<figcaption>Six octaves with different seeds.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Lacunarity</h3>
						
						<p>We don't always have to double the frequency between successive octaves. The frequency scaling is known as the lacunarity of the noise. Let's add an option for it to <code>Settings</code>, again as an integer, with a range of 2&ndash;4 and a default of 2.</p>
						
						<pre translate="no">		<ins>[Range(2, 4)]</ins>
		<ins>public int lacunarity;</ins>

		public static Settings Default => new Settings {
			frequency = 4,
			octaves = 1<ins>,</ins>
			<ins>lacunarity = 2</ins>
		};</pre>
						
						<figure>
							<img src="fractal-noise/settings-lacunarity.png" width="320" height="98">
							<figcaption>Lacunarity set to 2.</figcaption>
						</figure>
						
						<aside>
							<h3>What does lacunarity mean?</h3>
							<div>
								<p>In this context lacunarity is a geometric description of how fractals fill space. The higher the lacunarity the more gaps or space there is between octaves. It derives from the Latin word lacuna, which means gap or lake.</p>
							</div>
						</aside>
						
						<p>To apply lacunarity use it to scale the frequency in <code>Noise.Job.Execute</code> instead of always doubling the frequency.</p>
						
						<pre translate="no">				sum += amplitude * default(N).GetNoise4(frequency * position, hash + o);
				frequency *= <ins>settings.lacunarity</ins>;
				amplitude *= 0.5f;
				amplitudeSum += amplitude;</pre>
						
						<figure>
							<img src="fractal-noise/lacunarity-2.png" width="220" height="220" alt="lacunarity 2">
							<img src="fractal-noise/lacunarity-3.png" width="220" height="220" alt="lacunarity 3">
							<img src="fractal-noise/lacunarity-4.png" width="220" height="220" alt="lacunarity 4">
							<figcaption>Lacunarity 2, 3, and 4; frequency 2 with three octaves.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Persistence</h3>
						
						<p>Just like lacunarity can be configurable instead of always being 2, so can the amplitude reduction between octaves be configurable instead of always being 0.5. This factor is known as persistence and controls how quickly the amplitude reduces per octave. It is a floating-point value in the 0&ndash;1 range. Add it to <code>Settings</code> with a default of 0.5.</p>
						
						<pre translate="no">		<ins>[Range(0f, 1f)]</ins>
		<ins>public float persistence;</ins>

		public static Settings Default => new Settings {
			frequency = 4,
			octaves = 1,
			lacunarity = 2<ins>,</ins>
			<ins>persistence = 0.5f</ins>
		};</pre>
						
						<figure>
							<img src="fractal-noise/settings-persistence.png" width="320" height="118">
							<figcaption>Persistence set to 0.5.</figcaption>
						</figure>
						
						<p>Make <code>Noise.Job.Execute</code> apply persistence instead of always scaling the amplitude by 0.5.</p>
						
						<pre translate="no">				frequency *= settings.lacunarity;
				amplitude *= <ins>settings.persistence</ins>;</pre>
						
						<figure>
							<img src="fractal-noise/persistence-25.png" width="220" height="220" alt="persistence 0.25">
							<img src="fractal-noise/persistence-50.png" width="220" height="220" alt="persistence 0.5">
							<img src="fractal-noise/persistence-75.png" width="220" height="220" alt="persistence 0.75">
							<figcaption>Persistence 0.25, 0.5, and 0.75; frequency 4 with 3 octaves.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Turbulence</h2>
					
					<p>A common variant of fractal Perlin noise is to sum the absolute value of each octave. This causes the octaves to bounce where they would pass zero, creating a crease. Layering multiple such octaves produces a result that Ken Perlin described as a turbulent pattern, hence it is commonly known as the turbulence variant of Perlin noise. It can also be applied to value noise, so we will create turbulence variants of both noise types.</p>
					
					<section>
						<h3>Evaluation After Interpolation</h3>
						
						<p>To take the absolute of an octave we have to perform an operation on the gradient noise value, after interpolation. We can generalize this to an arbitrary operation at this point, defined per gradient type. We do this by adding the signature for an <code>EvaluateAfterInterpolation</code> method to <code>IGradient</code>, which takes a vectorized noise value and evaluates it to yield the final post-interpolation noise value.</p>
						
						<pre translate="no">	public interface IGradient {
		float4 Evaluate (SmallXXHash4 hash, float4 x);

		float4 Evaluate (SmallXXHash4 hash, float4 x, float4 y);

		float4 Evaluate (SmallXXHash4 hash, float4 x, float4 y, float4 z);

		<ins>float4 EvaluateAfterInterpolation (float4 value);</ins>
	}</pre>
						
						<p>The regular <code>Value</code> and <code>Perlin</code> gradient implementations remain the same but still have to implement this method. They simply return the value unchanged.</p>
						
						<pre translate="no">	public struct Value : IGradient {

		&hellip;

		<ins>public float4 EvaluateAfterInterpolation (float4 value) => value;</ins>
	}

	public struct Perlin : IGradient {

		&hellip;

		<ins>public float4 EvaluateAfterInterpolation (float4 value) => value;</ins>
	}</pre>
						
						<p>To use the final evaluation pass the interpolated value through this new method at the end of <code>GetNoise4</code>. Do this for <code>Lattice1D</code>, <code>Lattice2D</code>, and <code>Lattice3D</code>.</p>
						
						<pre translate="no">			var g = default(G);
			return <ins>g.EvaluateAfterInterpolation(</ins>lerp(
				&hellip;
			)<ins>)</ins>;</pre>
					</section>
					
					<section>
						<h3>Generic Turbulence</h3>
						
						<p>Now we can create turbulence variants of Perlin and value noise by duplicating them and changing their <code>EvaluateAfterInterpolation</code> method to return the absolute value. However, instead of duplicating both types let's introduce a generic <code>Turbulence</code> struct to <em translate="no">Noise.Gradient</em> that wraps an arbitrary other gradient type. It forwards all method invocations to the generic gradient, only changing the final evaluation to its absolute, via the <code>abs</code> method.</p>
						
						<pre translate="no">	<ins>public struct Turbulence&lt;G> : IGradient where G : struct, IGradient {</ins>

		<ins>public float4 Evaluate (SmallXXHash4 hash, float4 x) =></ins>
			<ins>default(G).Evaluate(hash, x);</ins>

		<ins>public float4 Evaluate (SmallXXHash4 hash, float4 x, float4 y) =></ins>
			<ins>default(G).Evaluate(hash, x, y);</ins>

		<ins>public float4 Evaluate (SmallXXHash4 hash, float4 x, float4 y, float4 z) =></ins>
			<ins>default(G).Evaluate(hash, x, y, z);</ins>

		<ins>public float4 EvaluateAfterInterpolation (float4 value) =></ins>
			<ins>abs(default(G).EvaluateAfterInterpolation(value));</ins>
	<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Turbulence Perlin and Value Noise</h3>
						
						<p>We can now add turbulence variants to <code>NoiseVisualization</code> via the <code>Turbulence&lt;Perlin></code> and <code>Turbulence&lt;Value></code> gradient types. Add these to the noise jobs array, so we get regular Perlin noise followed by its turbulence versions, followed by the value versions in the same order.</p>
						
						<pre translate="no">	static ScheduleDelegate[,] noiseJobs = {
		{
			Job&lt;Lattice1D&lt;Perlin>>.ScheduleParallel,
			Job&lt;Lattice2D&lt;Perlin>>.ScheduleParallel,
			Job&lt;Lattice3D&lt;Perlin>>.ScheduleParallel
		},
		<ins>{</ins>
			<ins>Job&lt;Lattice1D&lt;Turbulence&lt;Perlin>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Lattice2D&lt;Turbulence&lt;Perlin>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Lattice3D&lt;Turbulence&lt;Perlin>>>.ScheduleParallel</ins>
		<ins>},</ins>
		{
			Job&lt;Lattice1D&lt;Value>>.ScheduleParallel,
			Job&lt;Lattice2D&lt;Value>>.ScheduleParallel,
			Job&lt;Lattice3D&lt;Value>>.ScheduleParallel
		}<ins>,</ins>
		<ins>{</ins>
			<ins>Job&lt;Lattice1D&lt;Turbulence&lt;Value>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Lattice2D&lt;Turbulence&lt;Value>>>.ScheduleParallel,</ins>
			<ins>Job&lt;Lattice3D&lt;Turbulence&lt;Value>>>.ScheduleParallel</ins>
		<ins>}</ins>
	};</pre>
						
						<p>Add them to the <code>NoiseType</code> enum as well, so they can be selected via the inspector.</p>
						
						<pre translate="no">	public enum NoiseType { Perlin€, <ins>PerlinTurbulence,</ins> Value€<ins>, ValueTurbulence</ins> }</pre>
						
						<figure>
							<img src="turbulence/perlin-regular.png" width="220" height="220" alt="Perlin regular">
							<img src="fractal-noise/persistence-50.png" width="220" height="220" alt="value regular"><br>
							<img src="turbulence/perlin-turbulence.png" width="220" height="220" alt="Perlin turbulence">
							<img src="turbulence/value-turbulence.png" width="220" height="220" alt="value turbulence">
							<figcaption>Regular Perlin and value noise, and their turbulence variants.</figcaption>
						</figure>
						
						<p>Because absolute values are never negative the turbulence patterns are always grayscale and aren't centered on zero. A positive displacement looks quite different than a negative displacement. Positive has round peaks with narrow valleys, while negative has sharp ridges with wide valleys. In contrast, regular noise appears similar with both positive and negative displacement, only the orientation of the color gradient is different.</p>
						
						<figure>
							<img src="turbulence/sphere-regular-positive.png" width="290" height="290" alt="regular positive">
							<img src="turbulence/sphere-regular-negative.png" width="290" height="290" alt="regular negative"><br>
							<img src="turbulence/sphere-turbulence-positive.png" width="290" height="290" alt="turbulence positive">
							<img src="turbulence/sphere-turbulence-negative.png" width="290" height="290" alt="turbulence negative">
							<figcaption>Sphere with 0.2 and &minus;0.2 displacement, both regular 3D Perlin and turbulence variant.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Tiling Noise</h2>
					
					<p>Another useful noise variant is one that creates repeating patterns. This isn't meant for filling a large area directly, but for generating a small texture or mesh that can then be used to seamlessly tile a larger area.</p>
					
					<p>In order for a pattern to tile, opposite sides of the sample area must be identical. As we're using a lattice grid we can do this by repeating the same sequence of lattice spans. We make the length of this sequence equal to the noise frequency. So frequency 4 noise would repeat every four spans in any dimension.</p>
					
					<p>To make this tiling possible the frequency and thus also the lacunarity must always be whole numbers, which is why we made them integers.</p>
					
					<section>
						<h3>Frequency at the Lattice Level</h3>
						
						<p>To make repetition possible we have to pass the frequency to the noise implementation, so add a parameter for it to <code>INoise.GetNoise4</code>.</p>
						
						<pre translate="no">	public interface INoise {
		float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash<ins>, int frequency</ins>);
	}</pre>
						
						<p>We'll apply the frequency at this lower level from now on, so pass it the unmodified position along with the frequency in <code>Noise.Job.Evaluate</code> instead of scaling the position in the loop.</p>
						
						<pre translate="no">				sum += amplitude * default(N).GetNoise4(<ins>position</ins>, hash + o<ins>, frequency</ins>);</pre>
						
						<p>The lattice points are determined in <code>GetLatticeSpan4</code>, so add a frequency parameter to it and scale the coordinates at the beginning of that method.</p>
						
						<pre translate="no">	static LatticeSpan4 GetLatticeSpan4 (float4 coordinates<ins>, int frequency</ins>) {
		<ins>coordinates *= frequency;</ins>
		float4 points = floor(coordinates);
		&hellip;
	}</pre>
						
						<p>The final step of this adjustment is adding the frequency parameter to the <code>GetNoise4</code> methods of the lattice structs, passing it along to all invocations of <code>GetLatticeSpan4</code>.</p>
						
						<pre translate="no">	public struct Lattice1D&lt;G> : INoise where G : struct, IGradient {

		public float4 GetNoise4(float4x3 positions, SmallXXHash4 hash<ins>, int frequency</ins>) {
			LatticeSpan4 x = GetLatticeSpan4(positions.c0<ins>, frequency</ins>);

			&hellip;
		}
	}

	public struct Lattice2D&lt;G> : INoise where G : struct, IGradient {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash<ins>, int frequency</ins>) {
			LatticeSpan4
				x = GetLatticeSpan4(positions.c0<ins>, frequency</ins>),
				z = GetLatticeSpan4(positions.c2<ins>, frequency</ins>);

			&hellip;
		}
	}

	public struct Lattice3D&lt;G> : INoise where G : struct, IGradient {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash<ins>, int frequency</ins>) {
			LatticeSpan4
				x = GetLatticeSpan4(positions.c0<ins>, frequency</ins>),
				y = GetLatticeSpan4(positions.c1<ins>, frequency</ins>),
				z = GetLatticeSpan4(positions.c2<ins>, frequency</ins>);

			&hellip;
		}
	}</pre>
					</section>
					
					<section>
						<h3>Lattice Interface</h3>
						
						<p>To support both normal and tiling noise we'll introduce a new <code>ILattice</code> interface in <em translate="no">Noise.Lattice</em> that specifies the <code>GetLatticeSpan4</code> method signature. This requires the <code>LatticeSpan4</code> struct to become public, as the method as a whole has to be public, including the types of its parameters and what it returns.</p>
						
						<pre translate="no">	<ins>public</ins> struct LatticeSpan4 { &hellip; }

	<ins>public interface ILattice {</ins>
		<ins>LatticeSpan4 GetLatticeSpan4 (float4 coordinates, int frequency);</ins>
	<ins>}</ins></pre>
						
						<p>Now wrap the <code>GetLatticeSpan4</code> method inside a new <code>LatticeNormal</code> struct type that implements <code>ILattice</code>, changing it to a public instance method.</p>
						
						<pre translate="no">	<ins>public struct LatticeNormal : ILattice {</ins>

		<ins>public</ins> LatticeSpan4 GetLatticeSpan4 (float4 coordinates, int frequency) {
			&hellip;
		}
	<ins>}</ins></pre>
						
						<p>Then adjust the lattice struct types so they rely on a generic <code>ILattice</code> type to get their lattice spans. This means that they now have two generic type parameters. The generic type constraints are written one after the other.</p>
						
						<pre translate="no">	public struct Lattice1D&lt;<ins>L,</ins> G> : INoise
		<ins>where L : struct, ILattice</ins> where G : struct, IGradient {

		public float4 GetNoise4(float4x3 positions, SmallXXHash4 hash, int frequency) {
			LatticeSpan4 x = <ins>default(L).</ins>GetLatticeSpan4(positions.c0, frequency);

			&hellip;
		}
	}

	public struct Lattice2D&lt;<ins>L,</ins> G> : INoise
		<ins>where L : struct, ILattice</ins> where G : struct, IGradient {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			<ins>var l = default(L);</ins>
			LatticeSpan4
				x = <ins>l.</ins>GetLatticeSpan4(positions.c0, frequency),
				z = <ins>l.</ins>GetLatticeSpan4(positions.c2, frequency);

			&hellip;
		}
	}

	public struct Lattice3D&lt;<ins>L,</ins> G> : INoise
		<ins>where L : struct, ILattice</ins> where G : struct, IGradient {

		public float4 GetNoise4 (float4x3 positions, SmallXXHash4 hash, int frequency) {
			<ins>var l = default(L);</ins>
			LatticeSpan4
				x = <ins>l.</ins>GetLatticeSpan4(positions.c0, frequency),
				y = <ins>l.</ins>GetLatticeSpan4(positions.c1, frequency),
				z = <ins>l.</ins>GetLatticeSpan4(positions.c2, frequency);

			&hellip;
		}
	}</pre>
						
						<p>We're now required to make explicit that we're using the normal lattice versions in <code>NoiseVisualization</code>, by providing the extra type argument in the noise jobs array.</p>
						
						<pre translate="no">	static ScheduleDelegate[,] noiseJobs = {
		{
			Job&lt;Lattice1D&lt;<ins>LatticeNormal,</ins> Perlin>>.ScheduleParallel,
			Job&lt;Lattice2D&lt;<ins>LatticeNormal,</ins> Perlin>>.ScheduleParallel,
			Job&lt;Lattice3D&lt;<ins>LatticeNormal,</ins> Perlin>>.ScheduleParallel
		},
		{
			Job&lt;Lattice1D&lt;<ins>LatticeNormal,</ins> Turbulence&lt;Perlin>>>.ScheduleParallel,
			Job&lt;Lattice2D&lt;<ins>LatticeNormal,</ins> Turbulence&lt;Perlin>>>.ScheduleParallel,
			Job&lt;Lattice3D&lt;<ins>LatticeNormal,</ins> Turbulence&lt;Perlin>>>.ScheduleParallel
		},
		{
			Job&lt;Lattice1D&lt;<ins>LatticeNormal,</ins> Value>>.ScheduleParallel,
			Job&lt;Lattice2D&lt;<ins>LatticeNormal,</ins> Value>>.ScheduleParallel,
			Job&lt;Lattice3D&lt;<ins>LatticeNormal,</ins> Value>>.ScheduleParallel
		},
		{
			Job&lt;Lattice1D&lt;<ins>LatticeNormal,</ins> Turbulence&lt;Value>>>.ScheduleParallel,
			Job&lt;Lattice2D&lt;<ins>LatticeNormal,</ins> Turbulence&lt;Value>>>.ScheduleParallel,
			Job&lt;Lattice3D&lt;<ins>LatticeNormal,</ins> Turbulence&lt;Value>>>.ScheduleParallel
		}
	};</pre>
					</section>
					
					<section>
						<h3>Tiling</h3>
						
						<p>To create a tiling lattice, duplicate <code>LatticeNormal</code> and rename it to <code>LatticeTiling</code>. Then adjust its <code>GetLatticeSpan4</code> method so it repeats the span points after an amount of spans equal to the frequency. This can be done by taking the remainder of the point divided by the frequency, via the remainder or modulo operation <code>%</code>. This must be done after calculating the base gradient values.</p>
						
						<pre translate="no">	public struct <ins>LatticeTiling</ins> : ILattice {

		public LatticeSpan4 GetLatticeSpan4 (float4 coordinates, int frequency) {
			coordinates *= frequency;
			float4 points = floor(coordinates);
			LatticeSpan4 span;
			span.p0 = (int4)points;
			span.p1 = span.p0 + 1;
			span.g0 = coordinates - span.p0;
			span.g1 = span.g0 - 1f;

			<ins>span.p0 %= frequency;</ins>
			<ins>span.p1 %= frequency;</ins>

			span.t = coordinates - points;
			span.t = span.t * span.t * span.t * (span.t * (span.t * 6f - 15f) + 10f);
			return span;
		}
	}</pre>
						
						<p>Now we can add tiling variants of all noise options that we currently support. Do this by alternating between the regular and tiling lattice versions in the array declaration of <code>NoiseVisualization</code>. I only show the change for regular Perlin noise.</p>
						
						<pre translate="no">		{
			Job&lt;Lattice1D&lt;LatticeNormal, Perlin>>.ScheduleParallel,
			<ins>Job&lt;Lattice1D&lt;LatticeTiling, Perlin>>.ScheduleParallel,</ins>
			Job&lt;Lattice2D&lt;LatticeNormal, Perlin>>.ScheduleParallel,
			<ins>Job&lt;Lattice2D&lt;LatticeTiling, Perlin>>.ScheduleParallel,</ins>
			Job&lt;Lattice3D&lt;LatticeNormal, Perlin>>.ScheduleParallel<ins>,</ins>
			<ins>Job&lt;Lattice3D&lt;LatticeTiling, Perlin>>.ScheduleParallel</ins>
		},</pre>
						
						<p>Instead of doubling the size of our dropdown enum we'll use a boolean toggle option to control tiling. The second array index them becomes equal to double the amount of dimensions, minus one if tiling is enabled and minus two otherwise.</p>
						
						<pre translate="no">	<ins>[SerializeField]</ins>
	<ins>bool tiling;</ins>
	
	&hellip;
	
	protected override void UpdateVisualization (
		NativeArray&lt;float3x4> positions, int resolution, JobHandle handle
	) {
		noiseJobs[(int)type, <ins>2 *</ins> dimensions - <ins>(tiling ?</ins> 1 <ins>: 2)</ins>](
			positions, noise, noiseSettings, domain, resolution, handle
		).Complete();
		noiseBuffer.SetData(noise);
	}</pre>
						
						<figure>
							<img src="tiling-noise/tiling-toggle.png" width="320" height="42">
							<figcaption>Tiling enabled.</figcaption>
						</figure>
						
						<p>If we enable tiling at this point we get obvious repetition, if we increase the domain scale to see it, because a single tile fits inside a unit cube.</p>
						
						<figure>
							<img src="tiling-noise/tiling-incorrect.png" width="220" height="220">
							<figcaption>One octave frequency 2 tiling 2D Perlin; domain scale 4.</figcaption>
						</figure>
						
						<p>Although there is tiling it is incorrect, because the pattern depends on the sign of the dimension. 2D noise thus shows four different patterns. This happens because the remainder is influenced by the sign. To fix this we have to adjust <code>LatticeTiling.GetLatticeSpan4</code>.</p>
						
						<p>Begin by checking whether the first point is negative after calculating its remainder. If so, we are on the wrong side, which we can fix by adding the frequency to the point.</p>
						
						<pre translate="no">			span.p0 %= frequency;
			<ins>span.p0 = select(span.p0, span.p0 + frequency, span.p0 &lt; 0);</ins>
			span.p1 %= frequency;</pre>
						
						<p>We have to fix the second point as well. As it it always one step further in the positive direction than the first point, we can do this by basing it on the tiled first point instead of the untiled one.</p>
						
						<pre translate="no">			<del>//span.p1 = span.p0 + 1;</del>
			span.g0 = coordinates - span.p0;
			span.g1 = span.g0 - 1f;

			span.p0 %= frequency;
			span.p0 = select(span.p0, span.p0 + frequency, span.p0 &lt; 0);
			span.p1 <ins>= (span.p0 + 1) %</ins> frequency;</pre>
						
						<figure>
							<img src="tiling-noise/tiling-correct-1-octave.png" width="220" height="220" alt="1 octave">
							<img src="tiling-noise/tiling-correct-3-octaves.png" width="220" height="220" alt="3 octaves">
							<figcaption>Correct tiling, one and three octaves.</figcaption>
						</figure>
						
						<p>Once again, the main use for tiling noise is to create textures or meshes that can be seamlessly tiled. It can also be used to create looping 2D animations, by sampling multiple 2D slices of 3D noise.</p>
						
						<figure>
							<img src="tiling-noise/tiling-scale-1.png" width="220" height="220" alt="1">
							<img src="tiling-noise/tiling-scale-1.png" width="220" height="220" alt="2"><br>
							<img src="tiling-noise/tiling-scale-1.png" width="220" height="220" alt="3">
							<img src="tiling-noise/tiling-scale-1.png" width="220" height="220" alt="4">
							<figcaption>Four times the same noise sample, domain scale 1.</figcaption>
						</figure>
						
						<aside>
							<h3>Is it possible to tile only some dimensions instead of all?</h3>
							<div>
								<p>Yes, by introducing a separate generic lattice parameter per dimension. So 3D noise could have up to three lattice types. I make it all-or-nothing to keep the tutorial simple.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Vectorized Tiling</h3>
						
						<p>Calculation of the integer remainder is done via integer division, which doesn't vectorize. As a result the tiling noise variants have to demultiplex the points, calculate the remainder per individual point, and then multiplex them again, which is inefficient. But this is not necessary.</p>
						
						<p>Let's consider the second point of the span. We do not have to calculate the remainder for this point at all. We can get the same result by adding one to the first point and then checking whether it's equal to the frequency. If so, we're at the point where we have to repeat the pattern. As the pattern always starts at zero that's what the second point becomes.</p>
						
						<pre translate="no">			<del>//span.p1 = (span.p0 + 1) % frequency;</del>
			<ins>span.p1 = span.p0 + 1;</ins>
			<ins>span.p1 = select(span.p1, 0, span.p1 == frequency);</ins></pre>
						
						<p>We do have to calculate the remainder of the first point, but we can do so via a floating-point division which does vectorize, by delaying the conversion to integer. The remainder is found by taking the original floored coordinate from before conversion to integer, dividing it by the frequency, then casting to integer, multiplying with the frequency, and subtracting that from the untiled first point.</p>
						
						<pre translate="no">			<del>//span.p0 %= frequency;</del>
			<ins>span.p0 -= (int4)(points / frequency) * frequency;</ins>
			span.p0 = select(span.p0, span.p0 + frequency, span.p0 &lt; 0);</pre>
						
						<p>Directly converting the result of the floating-point division&mdash;in reality a multiplication with the reciprocal of the frequency&mdash;to an integer is dangerous, due to floating-point precision issues and rounding behavior. In this case we can round up the division before converting it, which we do via the <code>ceil</code> method. This ensures that it works correctly on all CPU types.</p>
						
						<pre translate="no">			span.p0 -= (int4)<ins>ceil</ins>(points / frequency) * frequency;</pre>
						
						<p>The next tutorial is <a href="../voronoi-noise/index.html">Voronoi Noise</a>.</p>
					</section>
					
					<a href="../../license/index.html" class="license">license</a>
					<a href="https://bitbucket.org/catlikecodingunitytutorials/pseudorandom-noise-05-noise-variants/" class="repository">repository</a>
					<a href="Noise-Variants.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>