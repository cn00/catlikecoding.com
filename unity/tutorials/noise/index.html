<!DOCTYPE html>
<html>
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/noise/">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/noise/tutorial-image.png">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="1024">
		<meta property="og:description" content="A Unity C# scripting tutorial in which you will create textures and make them interesting with pseudorandom noise. You go from hashing to Value noise, to Perlin noise, to fractal noise.">
		<meta name="description" content="A Unity C# scripting tutorial in which you will create textures and make them interesting with pseudorandom noise. You go from hashing to Value noise, to Perlin noise, to fractal noise.">
		<meta property="og:title" content="Noise, a Unity C# Tutorial">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<title>Noise, a Unity C# Tutorial</title>
		<link href="../../default.css" rel="stylesheet">
		<script>
			var customTypes = {
				MeshCreator: 1,
				MeshCreatorInspector: 1,
				Noise: 1,
				NoiseMethod: 1,
				NoiseMethodType: 1,
				TextureCreator: 1,
				TextureCreatorInspector: 1
			};
		</script>
	</head>
	<body>
		<header data-type="tutorial"></header>

		<article class="tutorial" itemscope="" itemtype="http://schema.org/TechArticle">
			<h1 itemprop="name headline">Noise<span>, being a pseudorandom artist</span></h1>

			<div class="instructions">
				<span itemprop="about description">In this tutorial you will create your own texture, and make it interesting with pseudorandom noise.</span>
				You'll learn to
				<ul>
					<li>Create and fill a texture;</li>
					<li>Visualize a slice through world space;</li>
					<li>Use delegates;</li>
					<li>Use a hash array for 1D, 2D, and 3D hashing;</li>
					<li>Compute Value noise;</li>
					<li>Compute Perlin noise;</li>
					<li>Create fractal noise;</li>
					<li>Use a gradient.</li>
				</ul>
				<p><span itemprop="dependencies">This tutorial builds on the foundation laid by previous tutorials. If you completed the <a href="../curves-and-splines/index.html">Curves and Splines</a> tutorial then you're good to go.</span></p>
				<p>This tutorial has been made with Unity 4.5.2. It might not work for older versions.</p>
			</div>
			
			<aside class="share"></aside>

			<figure>
				<img src="tutorial-image.jpg" width="512" height="512" itemprop="image">
				<figcaption>A slice through colored 3D Perlin noise.</figcaption>
			</figure>
			
			<h2>Creating a Texture</h2>
			
			<div class="instructions">
				<p>Let's begin by creating a default quad object. This object has a mesh with two triangles that form a square with a width and height of one unit each.</p>
			</div>
			
			<figure>
				<img alt="quad in scene" src="01-quad-scene.png" width="260" height="250">
				<img alt="quad in project" src="01-quad-project.png" width="786" height="316">
				<figcaption>A bland quad.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>We can make the quad more interesting by giving it a material with a nice texture. We could use any image as a texture, but we're going to create one procedurally. For this we need a material to assign the texture to, so create one and have the quad use it instead of the default. Then create a <i>TextureCreator</i> component script and attach it to the quad as well.</p>
			</div>
			
			<aside>
				<ul>
					<li><a href="index.html#a-shader" id="q-shader">Why not use a procedural shader?</a></li>
				</ul>
			</aside>
			
			<pre translate="no"><mark>using UnityEngine;</mark>

<mark>public class TextureCreator : MonoBehaviour {</mark>
<mark>}</mark></pre>
			
			<figure>
				<img src="01-material-and-creator.png" width="554" height="296">
				<figcaption>Quad with custom material and texture creator.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>To create a texture, we need to know how many pixels it should have. We'll create a square texture, so we can control its size with a single <code>resolution</code> variable. Let's give it a default of 256.</p>
			</div>
			
			<aside>
				<ul>
					<li><a href="index.html#a-256" id="q-256">Why 256?</a></li>
				</ul>
			</aside>
			
			<pre translate="no">	<mark>public int resolution = 256;</mark></pre>
			
			<div class="instructions">
				<p>We will create the texture when our component awakens. As we won't use transparency, the texture's format is RGB. The fourth argument of the texture's constructor indicates that we want to use mipmaps. We also give it a descriptive name.</p>
				<p>Then we grab the <code>MeshRenderer</code> component of the game object. Because we're only using it with our quad object, it should exist so we directly assign the texture to its material.</p>
			</div>
			
			<aside>
				<ul>
					<li><a href="index.html#a-rgb24" id="q-rgb24">What does RGB24 mean?</a></li>
					<li><a href="index.html#a-mipmaps" id="q-mipmaps">What are mipmaps?</a></li>
				</ul>
			</aside>
			
			<pre translate="no">	<mark>private Texture2D texture;</mark>

	<mark>private void Awake () {</mark>
		<mark>texture = new Texture2D(resolution, resolution, TextureFormat.RGB24, true);</mark>
		<mark>texture.name = "Procedural Texture";</mark>
		<mark>GetComponent&lt;MeshRenderer>().material.mainTexture = texture;</mark>
	<mark>}</mark></pre>
			
			<figure>
				<img src="01-awoken.png" width="320" height="198">
				<figcaption>Quad awakens with a texture in play mode.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Without filling the texture this doesn't make much sense. So let's add a <code>FillTexture</code> method that uses a double loop to make all the pixels red.</p>
				<p>After setting the pixels, you have to call the texture's <code>Apply</code> method otherwise the changes won't show up.</p>
			</div>
			
			<pre translate="no">	private void Awake () {
		texture = new Texture2D(resolution, resolution, TextureFormat.RGB24, true);
		texture.name = "Procedural Texture";
		GetComponent&lt;MeshRenderer>().material.mainTexture = texture;
		<mark>FillTexture();</mark>
	}

	<mark>private void FillTexture () {</mark>
		<mark>for (int y = 0; y &lt; resolution; y++) {</mark>
			<mark>for (int x = 0; x &lt; resolution; x++) {</mark>
				<mark>texture.SetPixel(x, y, Color.red);</mark>
			<mark>}</mark>
		<mark>}</mark>
		<mark>texture.Apply();</mark>
	<mark>}</mark></pre>
			
			<figure>
				<img src="01-red.png" width="190" height="190">
				<figcaption>A red quad.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Don't like red? What about green? Go ahead and change the color, but do this while still in play mode.</p>
			</div>
			
			<pre translate="no">	private void FillTexture () {
		for (int y = 0; y &lt; resolution; y++) {
			for (int x = 0; x &lt; resolution; x++) {
				texture.SetPixel(x, y, Color.<mark>green</mark>);
			}
		}
		texture.Apply();
	}</pre>
			
			<div class="instructions">
				<p>You will see that Unity recompiles the code just fine, but the texture stays red. This is because <code>Awake</code> isn't called again when there is a recompile. However, there is another option.</p>
				<p>The <code>OnEnable</code> method is called directly after <code>Awake</code>, each time the component is activated. This also happens after a recompile while in play mode. So if we use <code>OnEnable</code> instead of <code>Awake</code>, our quad will turn green without having to toggle play mode.</p>
			</div>
			
			<pre translate="no">	private void <mark>OnEnable</mark> () {
		texture = new Texture2D(resolution, resolution, TextureFormat.RGB24, true);
		texture.name = "Procedural Texture";
		GetComponent&lt;MeshRenderer>().material.mainTexture = texture;
		FillTexture();
	}</pre>
			
			<div class="instructions">
				<p>A flat color is not interesting at all. Instead, we can use a pixel's coordinates to define its color. We can directly put <code>x</code> in the red channel and <code>y</code> in the green channel, leaving blue at zero. However, as color channels are defined in a 0&ndash;1 range, we have to divide by the resolution, which we can define outside the loop.
			</div>
			
			<aside>
				<ul>
					<li><a href="index.html#a-01-range" id="q-01-range">Why a 0&ndash;1 range?</a></li>
				</ul>
			</aside>
			
			<pre translate="no">	private void FillTexture () {
		<mark>float stepSize = 1f / resolution;</mark>
		for (int y = 0; y &lt; resolution; y++) {
			for (int x = 0; x &lt; resolution; x++) {
				texture.SetPixel(x, y, <mark>new Color(x * stepSize, y * stepSize, 0f)</mark>);
			}
		}
		texture.Apply();
	}</pre>
			
			<figure>
				<img src="01-uv-256.png" width="240" height="240">
				<figcaption>Colored with texture coordinates.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Have now visualized the texture coordinates, also known as uv coordinates. But there is something weird going on at the edge of the texture. It is easier to see this when using a smaller resolution. Unfortunately, changing the resolution has no effect while in play mode.</p>
				<p>Let's create a custom inspector for our component so we can easily detect any change to our component. It simply draws the default inspector and checks for changes. If a change happened while we are also in play mode, we should call <code>FillTexture</code>.</p>
			</div>
			
			<figure>
				<img src="01-inspector.png" width="230" height="104">
				<figcaption>Adding an inspector.</figcaption>
			</figure>
			
			<pre translate="no"><mark>using UnityEditor;</mark>
<mark>using UnityEngine;</mark>

<mark>[CustomEditor(typeof(TextureCreator))]</mark>
<mark>public class TextureCreatorInspector : Editor {</mark>

	<mark>public override void OnInspectorGUI () {</mark>
		<mark>EditorGUI.BeginChangeCheck();</mark>
		<mark>DrawDefaultInspector();</mark>
		<mark>if (EditorGUI.EndChangeCheck() &amp;&amp; Application.isPlaying) {</mark>
			<mark>(target as TextureCreator).FillTexture();</mark>
		<mark>}</mark>
	<mark>}</mark>
<mark>}</mark></pre>
			
			<div class="instructions">
				<p>Of course this means that we have to make <code>FillTexture</code> public. And it should also check whether the resolution has changed, and if so resize the texture. Let's also constrain it to some reasonable range, like 2&ndash;512.</p>
			</div>
			
			<pre translate="no">	<mark>[Range(2, 512)]</mark>
	public int resolution = 256;

	<mark>public</mark> void FillTexture () {
		<mark>if (texture.width != resolution) {</mark>
			<mark>texture.Resize(resolution, resolution);</mark>
		<mark>}</mark>
		float stepSize = 1f / resolution;
		for (int y = 0; y &lt; resolution; y++) {
			for (int x = 0; x &lt; resolution; x++) {
				texture.SetPixel(x, y, new Color(x * stepSize, y * stepSize, 0f));
			}
		}
		texture.Apply();
	}</pre>
			
			<figure>
				<img src="01-resolution-scrubbing.png" width="320" height="58">
				<figcaption>Scrubbing the resolution, still in play mode.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>We can do even better than that. We can also respond to undo and redo actions, while in play mode. We can do this by registering a method to the <code>Undo.undoRedoPerformed</code> delegate. So we create such a method and place the check whether we're in play mode there as well.</p>
				<p><code>TextureCreatorInspector</code> has to register the method when it is enabled, but should also unregister it when it is disabled. So add the appropriate methods, and also store a reference to our creator so we don't have to cast it every time.</p>
			</div>
			
			<aside>
				<ul>
					<li><a href="index.html#a-delegate" id="q-delegate">What's a delegate?</a></li>
				</ul>
			</aside>
			
			<pre translate="no">	<mark>private TextureCreator creator;</mark>

	<mark>private void OnEnable () {</mark>
		<mark>creator = target as TextureCreator;</mark>
		<mark>Undo.undoRedoPerformed += RefreshCreator;</mark>
	<mark>}</mark>

	<mark>private void OnDisable () {</mark>
		<mark>Undo.undoRedoPerformed -= RefreshCreator;</mark>
	<mark>}</mark>

	<mark>private void RefreshCreator () {</mark>
		<mark>if (</mark>Application.isPlaying<mark>) {</mark>
			<mark>creator</mark>.FillTexture();
		<mark>}</mark>
	<mark>}</mark>

	public override void OnInspectorGUI () {
		EditorGUI.BeginChangeCheck();
		DrawDefaultInspector();
		if (EditorGUI.EndChangeCheck()) {
			<mark>RefreshCreator();</mark>
		}
	}</pre>
			
			<figure>
				<img src="01-uv-8.png" width="240" height="240">
				<figcaption>UV colors at resolution 8.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Back to our weird edges! At a resolution of 8, it is a lot easier to see what is happening. At the edges, colors from opposite sides are blended together. This happens because the default wrap mode of textures is to repeat themselves. We can get rid of this by having <code>TextureCreator</code> set its texture's wrap mode to clamp.</p>
			</div>
			
			<pre translate="no">	private void OnEnable () {
		texture = new Texture2D(resolution, resolution, TextureFormat.RGB24, true);
		texture.name = "Procedural Texture";
		<mark>texture.wrapMode = TextureWrapMode.Clamp;</mark>
		GetComponent&lt;MeshRenderer>().material.mainTexture = texture;
		FillTexture();
	}</pre>
			
			<figure>
				<img src="01-uv-clamped.png" width="240" height="240">
				<figcaption>Clamped colors.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Why are we actually seeing a smooth color transition, if our texture is only 8 by 8 pixels? This is because the default filter mode is bilinear. Let's compare this with point filtering.</p>
			</div>
			
			<pre translate="no">	private void OnEnable () {
		texture = new Texture2D(resolution, resolution, TextureFormat.RGB24, true);
		texture.name = "Procedural Texture";
		texture.wrapMode = TextureWrapMode.Clamp;
		<mark>texture.filterMode = FilterMode.Point;</mark>
		GetComponent&lt;MeshRenderer>().material.mainTexture = texture;
		FillTexture();
	}</pre>
			
			<figure>
				<img src="01-uv-point.png" width="240" height="240">
				<figcaption>Point filtering.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Now we see 64 blocks of solid colors, although an optical illusion will make it look like they contain gradients.</p>
				<p>For each rendered pixel, point filter mode selects the color of the texture pixel that it covers. This visually tells us where the centers of our texture's pixels are, right in the middle of those squares. Bilinear filtering linearly interpolates between those pixel centers. Let's compare them again at a resolution of 2.</p>
				
			</div>
			
			<pre translate="no">	private void OnEnable () {
		texture = new Texture2D(resolution, resolution, TextureFormat.RGB24, true);
		texture.name = "Procedural Texture";
		texture.wrapMode = TextureWrapMode.Clamp;
		texture.filterMode = FilterMode.<mark>Bilinear</mark>;
		GetComponent&lt;MeshRenderer>().material.mainTexture = texture;
		FillTexture();
	}</pre>
			
			<figure>
				<img alt="point" src="01-uv-2-point.png" width="240" height="240">
				<img alt="bilinear" src="01-uv-2-bilinear.png" width="240" height="240">
				<figcaption>2 by 2, point and bilinear filtering.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>So the center of the bottom left texture pixel has uv coordinates (0.25, 0.25). The top right is at (0.75, 0.75). However, in <code>FillTexture</code> we currently compute the colors for (0, 0) and (0.5, 0.5) respectively. This means we are calculating the colors at the bottom left corners of our pixels, instead of their centers. To fix this, we need to add half a pixel to <code>x</code> and <code>y</code>.</p>
			</div>
			
			<pre translate="no">	public void FillTexture () {
		if (texture.width != resolution) {
			texture.Resize(resolution, resolution);
		}
		float stepSize = 1f / resolution;
		for (int y = 0; y &lt; resolution; y++) {
			for (int x = 0; x &lt; resolution; x++) {
				texture.SetPixel(x, y, new Color(<mark>(</mark>x <mark>+ 0.5f)</mark> * stepSize, <mark>(</mark>y <mark>+ 0.5f)</mark> * stepSize, 0f));
			}
		}
		texture.Apply();
	}</pre>
			
			<figure>
				<img src="01-uv-2-centered.png" width="240" height="240">
				<figcaption>2 by 2, correctly centered.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>You can let the pattern repeat inside the texture by using the remainder operator. For example, by taking the remainder of dividing by 0.1 we end up going from 0 to just below 0.1 ten times. To keep the result visible, we simply scale it up by ten.</p>
			</div>
			
			<pre translate="no">				texture.SetPixel(x, y,
					new Color((x + 0.5f) * stepSize <mark>% 0.1f</mark>, (y + 0.5f) * stepSize <mark>% 0.1f</mark>, 0f) <mark>* 10f</mark>);</pre>
			
			<figure>
				<img src="01-remainder.png" width="240" height="240">
				<figcaption>Repeating the pattern.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>After doing that, zoom out the scene view to see what happens. Especially when zooming out far, you'll see the image gets sharper and then suddenly blurrier a few times. This happens because of mipmapping, which we have enabled. We can disable this by setting our texture's fourth constructor argument to false.</p>
			</div>
			
			<pre translate="no">	private void OnEnable () {
		texture = new Texture2D(resolution, resolution, TextureFormat.RGB24, <mark>false</mark>);
		texture.name = "Procedural Texture";
		texture.wrapMode = TextureWrapMode.Clamp;
		texture.filterMode = FilterMode.Bilinear;
		GetComponent&lt;MeshRenderer>().material.mainTexture = texture;
		FillTexture();
	}</pre>
			
			<figure>
				<img alt="small with mips" src="01-with-mips.png" width="56" height="56">
				<img alt="small without mips" src="01-no-mips.png" width="56" height="56">
				<figcaption>Zoomed out, with and without mipmapping.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Mipmapping definitely produces better results when zoomed out, but it is unfortunate that there is a harsh transition between successive mipmap levels. You can also see some of these transitions when looking at the quad from a sharp angle, especially when in motion.</p>
				<p>The quad will probably turn dark in the scene view when seen at an angle, because of the way scene view lighting works. To temporarily solve this, you can enable lighting in the scene view by toggling the light button in its toolbar, and create a directional light.</p>
				<p>Fortunately, there is a trilinear filtering option which also interpolated between adjacent mipmap levels, so let's use that.</p>
			</div>
			
			<pre translate="no">	private void OnEnable () {
		texture = new Texture2D(resolution, resolution, TextureFormat.RGB24, <mark>true</mark>);
		texture.name = "Procedural Texture";
		texture.wrapMode = TextureWrapMode.Clamp;
		texture.filterMode = FilterMode.<mark>Trilinear</mark>;
		GetComponent&lt;MeshRenderer>().material.mainTexture = texture;
		FillTexture();
	}</pre>
			
			<figure>
				<img alt="bilinear" src="01-bilinear.png" width="386" height="200">
				<img alt="trilinear" src="01-trilinear.png" width="386" height="200">
				<figcaption>Bilinear and trilinear filtering.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>With trilinear filtering, our texture is now displayed smoothly, without sharp transitions. The downside is that it gets fuzzy quick when viewed at an angle. To improve this, we can use anisotropic filtering. It is enabled by setting the texture's aniso level to a value higher than one. Let's set it to nine, because that's the highest level.</p>
			</div>
			
			<aside>
				<ul>
					<li><a href="index.html#a-anisotropic" id="q-anisotropic">What's anisotropic filtering?</a></li>
				</ul>
			</aside>
			
			<pre translate="no">	private void OnEnable () {
		texture = new Texture2D(resolution, resolution, TextureFormat.RGB24, true);
		texture.name = "Procedural Texture";
		texture.wrapMode = TextureWrapMode.Clamp;
		texture.filterMode = FilterMode.Trilinear;
		<mark>texture.anisoLevel = 9;</mark>
		GetComponent&lt;MeshRenderer>().material.mainTexture = texture;
		FillTexture();
	}</pre>
			
			<figure>
				<img src="01-aniso.png" width="386" height="200">
				<figcaption>Anisotropic filtering.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Let's leave our texture with these settings. But while we're at it, we shouldn't create a new one each time our component is enabled. So add a check for that.</p>
			</div>
			
			<pre translate="no">	private void OnEnable () {
		<mark>if (texture == null) {</mark>
			texture = new Texture2D(resolution, resolution, TextureFormat.RGB24, true);
			texture.name = "Procedural Texture";
			texture.wrapMode = TextureWrapMode.Clamp;
			texture.filterMode = FilterMode.Trilinear;
			texture.anisoLevel = 9;
			GetComponent&lt;MeshRenderer>().material.mainTexture = texture;
		<mark>}</mark>
		FillTexture();
	}</pre>
			
			<h2>Visualizing World Space</h2>
			
			<div class="instructions">
				<p>Right now we are visualizing the uv coordinates of our texture's space, which is always the same. We can change this so we are visualizing world coordinates instead. Our quad will act like a measuring device for world coordinates.</p>
				<p>First, let's define the local coordinates of the four corners of our quad. Because it is centered on its own origin, these are (-0.5,-0.5,0), (0.5,-0.5,0), (-0.5,0.5,0), and (0.5,0.5,0). We name them <i>pointxy</i>, where <i>x</i> is 0 for the left side and 1 for the right size. Likewise, <i>y</i> is 0 for the bottom side and 1 for the top side.</p>
			</div>
			
			<pre translate="no">	public void FillTexture () {
		if (texture.width != resolution) {
			texture.Resize(resolution, resolution);
		}

		<mark>Vector3 point00 = new Vector3(-0.5f,-0.5f);</mark>
		<mark>Vector3 point10 = new Vector3( 0.5f,-0.5f);</mark>
		<mark>Vector3 point01 = new Vector3(-0.5f, 0.5f);</mark>
		<mark>Vector3 point11 = new Vector3( 0.5f, 0.5f);</mark>

		float stepSize = 1f / resolution;
		for (int y = 0; y &lt; resolution; y++) {
			for (int x = 0; x &lt; resolution; x++) {
				texture.SetPixel(x, y,
					new Color((x + 0.5f) * stepSize % 0.1f, (y + 0.5f) * stepSize % 0.1f, 0f) * 10f);
			}
		}
		texture.Apply();
	}
</pre>
			
			<div class="instructions">
				<p>Second, we linearly interpolate these corners inside our loops. We do this in two steps.</p>
				<p>Step one is to interpolate between the bottom left and top left corner based on <code>y</code>, which gives us a point on the left side. We name it <code>point0</code>. We do the same thing for the right side, naming the result <code>point1</code>.</p>
				<p>Step two is to interpolate between these intermediate points based on <code>x</code>.</p>
				<p>We have now used bilinear interpolation to find the final point, which we directly convert into a color.</p>
			</div>
			
			<pre translate="no">		float stepSize = 1f / resolution;
		for (int y = 0; y &lt; resolution; y++) {
			<mark>Vector3 point0 = Vector3.Lerp(point00, point01, (y + 0.5f) * stepSize);</mark>
			<mark>Vector3 point1 = Vector3.Lerp(point10, point11, (y + 0.5f) * stepSize);</mark>
			for (int x = 0; x &lt; resolution; x++) {
				<mark>Vector3 point = Vector3.Lerp(point0, point1, (x + 0.5f) * stepSize);</mark>
				texture.SetPixel(x, y, new Color(<mark>point.x</mark>, <mark>point.y</mark>, <mark>point.z</mark>));
			}
		}</pre>
			
			<figure>
				<img src="02-local.png" width="240" height="240">
				<figcaption>Local coordinates.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>We are now visualizing the local coorindates of our quad. So it is always black at the center. It is also black at the bottom left because those coordinates are negative and colors are clamped to the 0&ndash;1 range.</p>
				<p>To visualize world-space coorinates instead, all we have to do is transform our four corner points to world space.</p>
			</div>
			
			<pre translate="no">		Vector3 point00 = <mark>transform.TransformPoint(</mark>new Vector3(-0.5f,-0.5f)<mark>)</mark>;
		Vector3 point10 = <mark>transform.TransformPoint(</mark>new Vector3( 0.5f,-0.5f)<mark>)</mark>;
		Vector3 point01 = <mark>transform.TransformPoint(</mark>new Vector3(-0.5f, 0.5f)<mark>)</mark>;
		Vector3 point11 = <mark>transform.TransformPoint(</mark>new Vector3( 0.5f, 0.5f)<mark>)</mark>;</pre>
			
			<div class="instructions">
				<p>However, moving the quad currently doesn't cause the texture to change. We could add an <code>Update</code> method and simply fill our texture every frame. That will ensure that the texture is always up to date. Let's do this, but also check whether our quad's transform has actually changed. That way the texture is only refilled when necessary.</p>
			</div>
			
			<aside>
				<ul>
					<li><a href="index.html#a-has-changed" id="q-has-changed">How does <code>hasChanged</code> work?</a></li>
				</ul>
			</aside>
			
			<pre translate="no">	<mark>private void Update () {</mark>
		<mark>if (transform.hasChanged) {</mark>
			<mark>transform.hasChanged = false;</mark>
			<mark>FillTexture();</mark>
		<mark>}</mark>
	<mark>}</mark></pre>
			
			<div class="instructions">
				<p>Now you can move, rotate, and even scale the quad and it will immediately change its color to match to world position it occupies.</p>
			</div>
			
			<figure>
				<img src="02-world.png" width="314" height="224">
				<figcaption>World coordinates on a rotated and scaled quad.</figcaption>
			</figure>
			
			<h2>Making Noise</h2>
			
			<div class="instructions">
				<p>Visualizing world coordinates isn't very interesting. Instead, we could visualize some mathematical formula, like a sine wave. Such formulas are regular and predictable, while we often need irregular and unpredictale shapes. For example to simulate dirt, rust, fabric irregularities, and other patterns that appear random to us.</p>
				<p>A naive approach is to simply use <code>Random.value</code>. Unity's random methods use a function that computes its next number based on some of its previous numbers, in such a way that we cannot easily see a pattern.</p>
			</div>
			
			<pre translate="no">		for (int y = 0; y &lt; resolution; y++) {
			Vector3 point0 = Vector3.Lerp(point00, point01, (y + 0.5f) * stepSize);
			Vector3 point1 = Vector3.Lerp(point10, point11, (y + 0.5f) * stepSize);
			for (int x = 0; x &lt; resolution; x++) {
				Vector3 point = Vector3.Lerp(point0, point1, (x + 0.5f) * stepSize);
				texture.SetPixel(x, y, <mark>Color.white * Random.value</mark>);
			}
		}</pre>
			
			<figure>
				<img src="03-random.png" width="240" height="240">
				<figcaption>Noise.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>The result sure looks random. Unfortunately, it is so random that we get a different result each time the texture is filled. This is because the random sequence continues from where it ended after the previous texture fill. But we don't want this, we actually want pseudorandom noise that produces the same results each time. We can solve this by choosing a fixed initial value &ndash; known as a seed &ndash; before filling the texture.</p>
			</div>
			
			<pre translate="no">		float stepSize = 1f / resolution;
		<mark>Random.seed = 42;</mark>
		for (int y = 0; y &lt; resolution; y++) {
			Vector3 point0 = Vector3.Lerp(point00, point01, (y + 0.5f) * stepSize);
			Vector3 point1 = Vector3.Lerp(point10, point11, (y + 0.5f) * stepSize);
			for (int x = 0; x &lt; resolution; x++) {
				Vector3 point = Vector3.Lerp(point0, point1, (x + 0.5f) * stepSize);
				texture.SetPixel(x, y, Color.white * Random.value);
			}
		}</pre>
			
			<div class="instructions">
				<p>Now we get the same pattern each time. That is, until we change the resolution of the image. The value sequence does not depend on the pixel uv coordinates, but on the order in which the pixels are filled. The left side of the bottom row stays the same as you increase the resolution, but the rest of the sequence shifts as it gets applied to longer rows.</p>
			</div>
			
			<figure>
				<img alt="16" src="03-seeded-32.png" width="240" height="240">
				<img alt="64" src="03-seeded-64.png" width="240" height="240">
				<img alt="128" src="03-seeded-128.png" width="240" height="240">
				<figcaption>The same sequence at resolutions 32, 64, and 128.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>This won't do. We want our pattern to be independent of the resolution and order in which we fill our texture. It is time to write our own pseudorandom noise code!</p>
				<p>Create a script named <i>Noise</i> and turn it into a static class. This will become our noise library.</p>
			</div>
			
			<figure>
				<img src="03-noise-library.png" width="230" height="104">
				<figcaption>Noise library.</figcaption>
			</figure>
			
			<pre translate="no"><mark>using UnityEngine;</mark>

<mark>public static class Noise {</mark>
<mark>}</mark></pre>
			
			<div class="instructions">
				<p>What we want is a method that, given point in 3D space, returns a seemingly random value. Let's just return the point's x coordinate for now.</p>
			</div>
			
			<pre translate="no">	<mark>public static float Value (Vector3 point) {</mark>
		<mark>return point.x;</mark>
	<mark>}</mark></pre>
			
			<div class="instructions">
				<p>Now we can change the <code>FillTexture</code> method of <code>TextureCreator</code> so it uses this new method. Also remove the assigment to <code>Random.seed</code>, because we no longer need it.</p>
			</div>
			
			<pre translate="no">		float stepSize = 1f / resolution;
		for (int y = 0; y &lt; resolution; y++) {
			Vector3 point0 = Vector3.Lerp(point00, point01, (y + 0.5f) * stepSize);
			Vector3 point1 = Vector3.Lerp(point10, point11, (y + 0.5f) * stepSize);
			for (int x = 0; x &lt; resolution; x++) {
				Vector3 point = Vector3.Lerp(point0, point1, (x + 0.5f) * stepSize);
				texture.SetPixel(x, y, Color.white * <mark>Noise.Value(point)</mark>);
			}
		}</pre>
			
			<div class="instructions">
				<p>Of course <code>Noise.Value</code> doesn't produce anything that looks like noise yet. But how do we generate such a pattern? Let's start very simple, with alternating stripes of black and white.</p>
				<p>We can generate vertical stripes by casting the point's x coordinate to an integer, discarding its fractional part. Then we return 1 when the integer is odd, otherwise we return 0. We could do this by returning the remainder of dividing our integer by two.</p>
			</div>
			
			<pre translate="no">	public static float Value (Vector3 point) {
		<mark>int i = (int)point.x;</mark>
		return <mark>i % 2</mark>;
	}</pre>
			
			<div class="instructions">
				<p>We should now see unit-length stripes on our quad, but only if we move it far enough to the right or increase its scale. We could get a better look at our pattern if we scaled it down. Let's do so by adding a frequency parameter to our method. The idea is that if the frequency is doubled, the pattern changes twice as fast. We can do this by simply multiplying the point by the frequency.</p>
			</div>
			
			<pre translate="no">	public static float Value (Vector3 point<mark>, float frequency</mark>) {
		<mark>point *= frequency;</mark>
		int i = (int)point.x;
		return i % 2;
	}</pre>
			
			<div class="instructions">
				<p>Then add a public <code>frequency</code> variable to <code>TextureCreator</code> so it becomes configurable, and pass it to the noise method.</p>
			</div>
			
			<pre translate="no">	<mark>public float frequency = 1f;</mark>
			
	public void FillTexture () {
		if (texture.width != resolution) {
			texture.Resize(resolution, resolution);
		}
		
		Vector3 point00 = transform.TransformPoint(new Vector3(-0.5f,-0.5f));
		Vector3 point10 = transform.TransformPoint(new Vector3( 0.5f,-0.5f));
		Vector3 point01 = transform.TransformPoint(new Vector3(-0.5f, 0.5f));
		Vector3 point11 = transform.TransformPoint(new Vector3( 0.5f, 0.5f));
		
		float stepSize = 1f / resolution;
		for (int y = 0; y &lt; resolution; y++) {
			Vector3 point0 = Vector3.Lerp(point00, point01, (y + 0.5f) * stepSize);
			Vector3 point1 = Vector3.Lerp(point10, point11, (y + 0.5f) * stepSize);
			for (int x = 0; x &lt; resolution; x++) {
				Vector3 point = Vector3.Lerp(point0, point1, (x + 0.5f) * stepSize);
				texture.SetPixel(x, y, Color.white * Noise.Value(point<mark>, frequency</mark>));
			}
		}
		texture.Apply();
	}</pre>
			
			<figure>
				<img alt="stripes" src="03-stripes-half.png" width="240" height="240">
				<img alt="inspector" src="03-frequency.png" width="320" height="76">
				<figcaption>Half the stripes at frequency 10.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Assuming the quad is not transformed, at a frequency of 10 we can see a total of five stripes &ndash; three black and two white &ndash; on the positive side, but nothing on the negative side. That's because the remainder on the left side is either zero or negative one. So we should return the absolute value of the remainder.</p>
				<p>Alternatively, because integers are stored as binary numbers, we can look at the least significant bit to determine whether the number is odd. This can be done with the bitwise-and operator, discarding everything except the least significant bit. As a bonus, this approach is also very fast.</p>
			</div>
			
			<aside>
				<ul>
					<li><a href="index.html#a-bitwise-and" id="q-bitwise-and">How does <code>&amp;</code> work?</a></li>
				</ul>
			</aside>
			
			<pre translate="no">		return i <mark>&amp;</mark> 1;</pre>
			
			<figure>
				<img src="03-stripes-gap.png" width="240" height="240">
				<figcaption>Stripes with a gap.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>The stripes now appear on both sides, but the pattern is mirrored, which causes a gap. As casting to an integer discards the fractional part of a float, it effectively rounds down on the positive side, while rounding up on the negative side. We could solve this by subtracting one when on the negative side. But there's also a convenient method that does this for us, so let's use that.</p>
			</div>
			
			<pre translate="no">		int i = <mark>Mathf.FloorToInt(</mark>point.x<mark>)</mark>;
		return i &amp; 1;</pre>
			
			<figure>
				<img src="03-stripes.png" width="240" height="240">
				<figcaption>Correct stripe pattern.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Now that we have produced a correct pattern by partitioning space, we can build our noise on top of that. Such noice is known as lattice noise, because it divides space into a regular lattice. In this case it's regular 1D intervals, while in 2D it would be a square grid and in 3D a cube grid.</p>
				<p>The next step is to assign seemingly random values to each stripe coordinate, instead of just alternating black and white. This is done by using some function that converts any lattice coordinate into some other value. Such a function is known as a hash function, and there are many different flavors of those.</p>
				<p>We will use a permutation array as our hashing method. This is simply an array containing a bunch of integers, let's use 0 through 7.</p>
				<p>If we were to use our integer coordinate to index this array, we'd get a value up to seven. Let's do that and scale the result so we stay in the 0&ndash;1 range.</p>
			</div>
			
			<pre translate="no">	<mark>private static int[] hash = {</mark>
		<mark>0, 1, 2, 3, 4, 5, 6, 7</mark>
	<mark>};</mark>

	public static float Value (Vector3 point, float frequency) {
		point *= frequency;
		int i = Mathf.FloorToInt(point.x);
		return <mark>hash[</mark>i<mark>] / 7f</mark>;
	}</pre>
			
			<div class="instructions">
				<p>However, this will result in an error as <code>i</code> goes out of the index range of our array when it goes above seven or below zero. Because our array has a length of eight, if we limit ourselves to the three least significant bits of <code>i</code>, the index will wrap around exactly when it needs to.</p>
			</div>
			
			<pre translate="no">		point *= frequency;
		int i = Mathf.FloorToInt(point.x);
		<mark>i &amp;= 7;</mark>
		return hash[i] / 7f;</pre>
			
			<figure>
				<img src="03-hash.png" width="240" height="240">
				<figcaption>Using the hash array with frequency 32.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>We now see up to eight different colors, but the pattern is still obviously regular and repeating. Let's make it less obvious by shuffling the values inside the array. That will result in a different permutation of the same collection of numbers. This is why such an array is often named a permutation array or a permutation table.</p>
			</div>
			
			<pre translate="no">	private static int[] hash = {
		<mark>4, 2, 7, 5, 1, 6, 3, 0</mark>
	};</pre>
			
			<figure>
				<img src="03-permutation.png" width="240" height="240">
				<figcaption>Using a different permutation.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>The pattern now looks less regular, but it still clearly repeats. What would happen if we add another permutation of the same sequence to the array? As this increases our array's size to 16, we also need to add an additional bit to our bit mask.</p>
			</div>
			
			<pre translate="no">	private static int[] hash = {
		4, 2, 7, 5, 1, 6, 3, 0<mark>, 1, 5, 3, 7, 2, 0, 4, 6</mark>
	};

	public static float Value (Vector3 point, float frequency) {
		point *= frequency;
		int i = Mathf.FloorToInt(point.x);
		i &amp;= <mark>15</mark>;
		return hash[i] / 7f;
	}</pre>
			
			<figure>
				<img src="03-double-permutation.png" width="240" height="240">
				<figcaption>Using two permutations in one array.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>We simply got a larger sequence that contains each value twice. We might as well make every value unique and increase our output range to 16 different values.</p>
			</div>
			
			<pre translate="no">	private static int[] hash = {
		<mark>7, 3, 15, 8, 1, 6, 0, 2, 11, 5, 12, 4, 9, 14, 13, 10</mark>
	};

	public static float Value (Vector3 point, float frequency) {
		point *= frequency;
		int i = Mathf.FloorToInt(point.x);
		i &amp;= 15;
		return hash[i] / <mark>15f</mark>;
	}</pre>
			
			<figure>
				<img src="03-permutation-16.png" width="240" height="240">
				<figcaption>16 distinct values.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>The hash array will always produce a tiling pattern, but we only notice that when we see a large enough sampling of it. So let's increase its length to 256. If we also define the hash mask value as a constant, our method will work regardless of the array's size.</p>
			</div>
			
			<pre translate="no">	private static int[] hash = {
		<mark>151,160,137, 91, 90, 15,131, 13,201, 95, 96, 53,194,233,  7,225,</mark>
		<mark>140, 36,103, 30, 69,142,  8, 99, 37,240, 21, 10, 23,190,  6,148,</mark>
		<mark>247,120,234, 75,  0, 26,197, 62, 94,252,219,203,117, 35, 11, 32,</mark>
		 <mark>57,177, 33, 88,237,149, 56, 87,174, 20,125,136,171,168, 68,175,</mark>
		 <mark>74,165, 71,134,139, 48, 27,166, 77,146,158,231, 83,111,229,122,</mark>
		 <mark>60,211,133,230,220,105, 92, 41, 55, 46,245, 40,244,102,143, 54,</mark>
		 <mark>65, 25, 63,161,  1,216, 80, 73,209, 76,132,187,208, 89, 18,169,</mark>
		<mark>200,196,135,130,116,188,159, 86,164,100,109,198,173,186,  3, 64,</mark>
		 <mark>52,217,226,250,124,123,  5,202, 38,147,118,126,255, 82, 85,212,</mark>
		<mark>207,206, 59,227, 47, 16, 58, 17,182,189, 28, 42,223,183,170,213,</mark>
		<mark>119,248,152,  2, 44,154,163, 70,221,153,101,155,167, 43,172,  9,</mark>
		<mark>129, 22, 39,253, 19, 98,108,110, 79,113,224,232,178,185,112,104,</mark>
		<mark>218,246, 97,228,251, 34,242,193,238,210,144, 12,191,179,162,241,</mark>
		 <mark>81, 51,145,235,249, 14,239,107, 49,192,214, 31,181,199,106,157,</mark>
		<mark>184, 84,204,176,115,121, 50, 45,127,  4,150,254,138,236,205, 93,</mark>
		<mark>222,114, 67, 29, 24, 72,243,141,128,195, 78, 66,215, 61,156,180</mark>
	};

	<mark>private const int hashMask = 255;</mark>

	public static float Value (Vector3 point, float frequency) {
		point *= frequency;
		int i = Mathf.FloorToInt(point.x);
		i &amp;= <mark>hashMask</mark>;
		return hash[i] <mark>* (1f / hashMask)</mark>;
	}</pre>
			
			<figure>
				<img alt="32" src="03-hash-256-32.png" width="240" height="240">
				<img alt="256" src="03-hash-256-256.png" width="240" height="240">
				<img alt="512" src="03-hash-256-512.png" width="240" height="240">
				<figcaption>256 values, at frequency 32, 256, and 512.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>This particular permutation is the same one that Ken Perlin uses in his reference implementations of his noise algorithm, which we'll cover later. Besides that, there is nothing special about it.</p>
				<p>With this array it takes a while before we see it repeat. When using a frequency of 512 we can see that it repeats once, but at that point we can't even see the individual lines anymore. You can increase the array size even more, or use other tricks to dramatically increase the period length, but 256 suffices for most cases.</p>
			</div>
			
			<h2>Going Into Higher Dimensions</h2>
			
			<div class="instructions">
				<p>Let's extend this approach to two dimensions. Duplicate the <code>Value</code> method and add a <i>1D</i> and a <i>2D</i> suffix to them.</p>
			</div>
			
			<pre translate="no">	public static float <mark>Value1D</mark> (Vector3 point, float frequency) {
		point *= frequency;
		int i = Mathf.FloorToInt(point.x);
		i &amp;= hashMask;
		return hash[i] * (1f / hashMask);
	}

	<mark>public static float Value2D (Vector3 point, float frequency) {</mark>
		<mark>point *= frequency;</mark>
		<mark>int i = Mathf.FloorToInt(point.x);</mark>
		<mark>i &amp;= hashMask;</mark>
		<mark>return hash[i] * (1f / hashMask);</mark>
	<mark>}</mark></pre>
			
			<div class="instructions">
				<p>Then change <code>TextureCreator.FillTexture</code> so it uses the 2D version of our noise method.</p>
			</div>
			
			<pre translate="no">				texture.SetPixel(x, y, Color.white * Noise.Value<mark>2D</mark>(point, frequency));</pre>
			
			<div class="instructions">
				<p>Now we have to give the y coordinate the same treatment as the x coordinate. So add a second versions of the <code>i</code> variable, naming them <code>ix</code> and <code>iy</code>.</p>
				<p>Instead of directly returning the hash of <code>ix</code>, we'll add it to <code>iy</code> and use that to index the hash array a second time. Of course, we need to make sure that their sum remains within bounds.</p>
			</div>
			
			
			<pre translate="no">	public static float Value2D (Vector3 point, float frequency) {
		point *= frequency;
		int i<mark>x</mark> = Mathf.FloorToInt(point.x);
		<mark>int iy = Mathf.FloorToInt(point.y);</mark>
		i<mark>x</mark> &amp;= hashMask;
		<mark>iy &amp;= hashMask;</mark>
		return <mark>hash[(</mark>hash[<mark>ix] + iy) &amp; hashMask</mark>] * (1f / hashMask);
	}</pre>
			
			<figure>
				<img src="04-hash-2d.png" width="240" height="240">
				<figcaption>2D hashing.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>It looks pretty random, right? We are offseting the hash index of the y coordinate by the hash result of the x coordinate. But this means that the vertical patterns are all the same, they're just placed at different offsets. You can spot this in the image above if you know where to look. It contains two adjacent columns that are offset by exactly one step. This happens because the fourth and fifth numbers in the hash array are 91 and 90. So in case you cannot find them, they are the fourth and fifth column to the right of the center.</p>
				<p>So should we eliminate all such sequences from the hash array? No, because there are many more small patterns that become obvious once you are aware of them. Instead of improving the hash array, you're better off using a different hashing method altogether. But again, for most purposes the illusion of randomness is convincing enough.</p>
				<p>Of course there is also a third dimension, so let's copy our 2D method and change it into a 3D one. The approach is the same as going from 1D to 2D. Although the method is entirely new, I've only marked the adjustments needed to take the third dimension into account.</p>
			</div>
			
			<pre translate="no">	public static float <mark>Value3D</mark> (Vector3 point, float frequency) {
		point *= frequency;
		int ix = Mathf.FloorToInt(point.x);
		int iy = Mathf.FloorToInt(point.y);
		<mark>int iz = Mathf.FloorToInt(point.z);</mark>
		ix &amp;= hashMask;
		iy &amp;= hashMask;
		<mark>iz &amp;= hashMask;</mark>
		return <mark>hash[(</mark>hash[(hash[ix] + iy) &amp; hashMask] <mark>+ iz) &amp; hashMask]</mark> * (1f / hashMask);
	}</pre>
			
			<div class="instructions">
				<p>Why are we actually masking <code>iy</code> and <code>iz</code>, if we mask them again after adding them to a hash? That is a good question, because a mask operator after adding should suffice. What you'll actually encounter a lot in practice is that the additional hash doesn't happen. But then the maximum possible index that we could get is 255 + 255, which is clearly out of bounds. This problem is solved by doubling the length of the hash array, repeating its contents. That way indices 256 through 511 give the same result as indices 0 through 255, so a new mask operation is no longer needed. So let's do that as well.</p>
			</div>
			
			<pre translate="no">	private static int[] hash = {
		151,160,137, 91, 90, 15,131, 13,201, 95, 96, 53,194,233,  7,225,
		140, 36,103, 30, 69,142,  8, 99, 37,240, 21, 10, 23,190,  6,148,
		247,120,234, 75,  0, 26,197, 62, 94,252,219,203,117, 35, 11, 32,
		 57,177, 33, 88,237,149, 56, 87,174, 20,125,136,171,168, 68,175,
		 74,165, 71,134,139, 48, 27,166, 77,146,158,231, 83,111,229,122,
		 60,211,133,230,220,105, 92, 41, 55, 46,245, 40,244,102,143, 54,
		 65, 25, 63,161,  1,216, 80, 73,209, 76,132,187,208, 89, 18,169,
		200,196,135,130,116,188,159, 86,164,100,109,198,173,186,  3, 64,
		 52,217,226,250,124,123,  5,202, 38,147,118,126,255, 82, 85,212,
		207,206, 59,227, 47, 16, 58, 17,182,189, 28, 42,223,183,170,213,
		119,248,152,  2, 44,154,163, 70,221,153,101,155,167, 43,172,  9,
		129, 22, 39,253, 19, 98,108,110, 79,113,224,232,178,185,112,104,
		218,246, 97,228,251, 34,242,193,238,210,144, 12,191,179,162,241,
		 81, 51,145,235,249, 14,239,107, 49,192,214, 31,181,199,106,157,
		184, 84,204,176,115,121, 50, 45,127,  4,150,254,138,236,205, 93,
		222,114, 67, 29, 24, 72,243,141,128,195, 78, 66,215, 61,156,180<mark>,</mark>

		<mark>151,160,137, 91, 90, 15,131, 13,201, 95, 96, 53,194,233,  7,225,</mark>
		<mark>140, 36,103, 30, 69,142,  8, 99, 37,240, 21, 10, 23,190,  6,148,</mark>
		<mark>247,120,234, 75,  0, 26,197, 62, 94,252,219,203,117, 35, 11, 32,</mark>
		 <mark>57,177, 33, 88,237,149, 56, 87,174, 20,125,136,171,168, 68,175,</mark>
		 <mark>74,165, 71,134,139, 48, 27,166, 77,146,158,231, 83,111,229,122,</mark>
		 <mark>60,211,133,230,220,105, 92, 41, 55, 46,245, 40,244,102,143, 54,</mark>
		 <mark>65, 25, 63,161,  1,216, 80, 73,209, 76,132,187,208, 89, 18,169,</mark>
		<mark>200,196,135,130,116,188,159, 86,164,100,109,198,173,186,  3, 64,</mark>
		 <mark>52,217,226,250,124,123,  5,202, 38,147,118,126,255, 82, 85,212,</mark>
		<mark>207,206, 59,227, 47, 16, 58, 17,182,189, 28, 42,223,183,170,213,</mark>
		<mark>119,248,152,  2, 44,154,163, 70,221,153,101,155,167, 43,172,  9,</mark>
		<mark>129, 22, 39,253, 19, 98,108,110, 79,113,224,232,178,185,112,104,</mark>
		<mark>218,246, 97,228,251, 34,242,193,238,210,144, 12,191,179,162,241,</mark>
		 <mark>81, 51,145,235,249, 14,239,107, 49,192,214, 31,181,199,106,157,</mark>
		<mark>184, 84,204,176,115,121, 50, 45,127,  4,150,254,138,236,205, 93,</mark>
		<mark>222,114, 67, 29, 24, 72,243,141,128,195, 78, 66,215, 61,156,180</mark>
	};

	public static float Value2D (Vector3 point, float frequency) {
		point *= frequency;
		int ix = Mathf.FloorToInt(point.x);
		int iy = Mathf.FloorToInt(point.y);
		ix &amp;= hashMask;
		iy &amp;= hashMask;
		return <mark>hash[hash[ix] + iy]</mark> * (1f / hashMask);
	}

	public static float Value3D (Vector3 point, float frequency) {
		point *= frequency;
		int ix = Mathf.FloorToInt(point.x);
		int iy = Mathf.FloorToInt(point.y);
		int iz = Mathf.FloorToInt(point.z);
		ix &amp;= hashMask;
		iy &amp;= hashMask;
		iz &amp;= hashMask;
		return <mark>hash[hash[hash[ix] + iy] + iz]</mark> * (1f / hashMask);
	}</pre>
			
			<div class="instructions">
				<p>Now we could once again change which method we use in our texture-filling loop, but that is getting tedious. Let's make it configurable instead.</p>
				<p>Begin by creating a delegate type for our noise methods. As it belongs with the noise library place it in the same script, but outside of the <code>Noise</code> class.</p>
			</div>
			
			<pre translate="no">using UnityEngine;

<mark>public delegate float NoiseMethod (Vector3 point, float frequency);</mark>

public static class Noise {
	&hellip;
}</pre>
			
			<div class="instructions">
				<p>Then add a public static array containing references to the value methods to <code>Noise</code>, ordered by their dimension.</p>
			</div>
			
			<pre translate="no">	<mark>public static NoiseMethod[] valueMethods = {</mark>
		<mark>Value1D,</mark>
		<mark>Value2D,</mark>
		<mark>Value3D</mark>
	<mark>};</mark></pre>
			
			<div class="instructions">
				<p>Also add a public dimension variable to <code>TextureCreator</code> so we can configure which noise value it should use. To limit the value we can set it to via the inspector, give it a range from 1 to 3.</p>
			</div>
			
			<pre translate="no">	<mark>[Range(1, 3)]</mark>
	<mark>public int dimensions = 3;</mark></pre>
			
			<div class="instructions">
				<p>Now we can let <code>TextureCreator.FillTexture</code> select the desired method from the value methods array, using <code>dimensions</code> minus one as an index. Then we can call this method to get our noise value.</p>
			</div>
			
			<pre translate="no">		<mark>NoiseMethod method = Noise.valueMethods[dimensions - 1];</mark>
		float stepSize = 1f / resolution;
		for (int y = 0; y &lt; resolution; y++) {
			Vector3 point0 = Vector3.Lerp(point00, point01, (y + 0.5f) * stepSize);
			Vector3 point1 = Vector3.Lerp(point10, point11, (y + 0.5f) * stepSize);
			for (int x = 0; x &lt; resolution; x++) {
				Vector3 point = Vector3.Lerp(point0, point1, (x + 0.5f) * stepSize);
				texture.SetPixel(x, y, Color.white * <mark>method</mark>(point, frequency));
			}
		}</pre>
			
			<figure>
				<img alt="3D hashing" src="04-hash-3d.png" width="230" height="230">
				<img alt="dimension slider" src="04-dimension-slider.png" width="320" height="94">
				<figcaption>3D hasing and a dimension slider.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>If our quad is not rotated, the 3D version of our noise looks similar to the 2D version. The only difference is that the values are hashed an additional time by the 3D method. This similarity vanishes when we rotate the quad so it is no longer aligned with the world axes.</p>
			</div>
			
			<figure>
				<img alt="1D" src="04-rotated-1d.png" width="250" height="250">
				<img alt="2D" src="04-rotated-2d.png" width="250" height="250">
				<img alt="3D" src="04-rotated-3d.png" width="250" height="250">
				<figcaption>1D, 2D, and 3D hash values with rotation (45,45,0).</figcaption>
			</figure>
			
			<h2>Interpolating Hash Values</h2>
			
			<div class="instructions">
				<p>We can now produce reasonably random-looking patterns that are also resolution-independent. However, there is a sharp transition between adjacent hash values, which is most often undesirable. Instead, we want a pattern that smoothly transitions from one hash value to the next.</p>
				<p>For our 1D noise version, that would mean instead of one hash value we'll have to compute two. One for the lattice coordinate to the left of our sample point, and one for the lattice coordinate to the right of it. Let's rename <code>i</code> to <code>i0</code> and add <code>i1</code> to represent the next coordinate. We then retrieve the hashes for both of them, which we store in <code>h0</code> and <code>h1</code>.</p>
			</div>
			
			<pre translate="no">	public static float Value1D (Vector3 point, float frequency) {
		point *= frequency;
		int <mark>i0</mark> = Mathf.FloorToInt(point.x);
		<mark>i0</mark> &amp;= hashMask;
		<mark>int i1 = i0 + 1;</mark>

		<mark>int h0 =</mark> hash[<mark>i0</mark>];
		<mark>int h1 = hash[i1];</mark>

		return <mark>h0</mark> * (1f / hashMask);
	}</pre>
			
			<div class="instructions">
				<p>Now we have to interpolate between <code>h0</code> and <code>h1</code>. The linear interpolant value is simply the distance from the left integer coordinate to the sample point. As we must compute this before masking the coordinate, we store this value in a new variable <code>t</code>.</p>
			</div>
			
			<pre translate="no">	public static float Value1D (Vector3 point, float frequency) {
		point *= frequency;
		int i0 = Mathf.FloorToInt(point.x);
		<mark>float t = point.x - i0;</mark>
		i0 &amp;= hashMask;
		int i1 = i0 + 1;

		int h0 = hash[i0];
		int h1 = hash[i1];

		return <mark>Mathf.Lerp(</mark>h0<mark>, h1, t)</mark> * (1f / hashMask);
	}</pre>
			
			<figure>
				<img alt="sharp" src="05-1d-sharp.png" width="230" height="230">
				<img alt="linear" src="05-1d-linear.png" width="230" height="230">
				<figcaption>Sharp vs. linear transitions in 1D.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>This particular type of noise is known as Value noise.</p>
				<p>Although the values of our noise are now interpolated, there are still sharp transitions. This is because we now see adjacent linear gradients that abruptly change direction. Instead of directly using the linear distance, we can turn it into a smooth curve by using a function that has a first derivative which is zero at both ends. That way the rate of change is always zero at gradient boundaries. Actually, let's go a step further and use a function with a second derivate that has the same properties. Such a function is <b>6<i>t</i><sup>5</sup> - 15<i>t</i><sup>4</sup> + 10<i>t</i><sup>3</sup></b>.</p>
				<p>Let's add a method that puts <code>t</code> though this function. Because we don't have an atomic power operation, we program it using multiplications only, for example as <b><i>t</i> <i>t</i> <i>t</i> (<i>t</i> (<i>t</i> 6 - 15) + 10)</b>.</p>
			</div>
			
			<aside>
				<ul>
					<li><a href="index.html#a-polynomial" id="q-polynomial">Why a 5<sup>th</sup> degree polynomial?</a></li>
				</ul>
			</aside>
			
			<pre translate="no">	<mark>private static float Smooth (float t) {</mark>
		<mark>return t * t * t * (t * (t * 6f - 15f) + 10f);</mark>
	<mark>}</mark></pre>
			
			<div class="instructions">
				<p>Now we can smooth <code>t</code> before using it to interpolate between our hashes.</p>
			</div>
			
			<pre translate="no">		<mark>t = Smooth(t);</mark>
		return Mathf.Lerp(h0, h1, t) * (1f / hashMask);</pre>
			
			<figure>
				<img alt="8" src="05-1d-smooth-8.png" width="230" height="230">
				<img alt="16" src="05-1d-smooth-16.png" width="230" height="230">
				<img alt="32" src="05-1d-smooth-32.png" width="230" height="230">
				<figcaption>Smooth transitions in 1D.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>The 1D noise only needed to interpolate along the x axis, but the 2D version also needs to interpolate along the y axis, performing a bilinear interpolation between four hashes. First, let's rewrite <code>Value2D</code> a bit so it has the same structure as the 1D version.</p>
			</div>
			
			<pre translate="no">	public static float Value2D (Vector3 point, float frequency) {
		point *= frequency;
		int <mark>ix0</mark> = Mathf.FloorToInt(point.x);
		int <mark>iy0</mark> = Mathf.FloorToInt(point.y);
		ix0 &amp;= hashMask;
		iy0 &amp;= hashMask;

		<mark>int h0 =</mark> hash[<mark>ix0</mark>];
		<mark>int h00 =</mark> hash[<mark>h0</mark> + <mark>iy0</mark>];

		return <mark>h00</mark> * (1f / hashMask);
	}</pre>
			
			<div class="instructions">
				<p>Then add the hash of the opposite corner.</p>
			</div>
			
			<pre translate="no">	public static float Value2D (Vector3 point, float frequency) {
		point *= frequency;
		int ix0 = Mathf.FloorToInt(point.x);
		int iy0 = Mathf.FloorToInt(point.y);
		ix0 &amp;= hashMask;
		iy0 &amp;= hashMask;
		<mark>int ix1 = ix0 + 1;</mark>
		<mark>int iy1 = iy0 + 1;</mark>

		int h0 = hash[ix0];
		<mark>int h1 = hash[ix1];</mark>
		int h00 = hash[h0 + iy0];
		<mark>int h11 = hash[h1 + iy1];</mark>

		return h00 * (1f / hashMask);
	}</pre>
			
			<div class="instructions">
				<p>But of course we need four hashes, not only the bottom left and top right ones.</p>
			</div>
			
			<pre translate="no">		int h0 = hash[ix0];
		int h1 = hash[ix1];
		int h00 = hash[h0 + iy0];
		<mark>int h10 = hash[h1 + iy0];</mark>
		<mark>int h01 = hash[h0 + iy1];</mark>
		int h11 = hash[h1 + iy1];</pre>
			
			<div class="instructions">
				<p>And finally, we create the interpolants and perform the bilinear interpolation.</p>
			</div>
			
			<pre translate="no">		int ix0 = Mathf.FloorToInt(point.x);
		int iy0 = Mathf.FloorToInt(point.y);
		<mark>float tx = point.x - ix0;</mark>
		<mark>float ty = point.y - iy0;</mark>
		ix0 &amp;= hashMask;
		iy0 &amp;= hashMask;
		int ix1 = ix0 + 1;
		int iy1 = iy0 + 1;

		int h0 = hash[ix0];
		int h1 = hash[ix1];
		int h00 = hash[h0 + iy0];
		int h10 = hash[h1 + iy0];
		int h01 = hash[h0 + iy1];
		int h11 = hash[h1 + iy1];

		<mark>tx = Smooth(tx);</mark>
		<mark>ty = Smooth(ty);</mark>
		<mark>return Mathf.Lerp(</mark>
			<mark>Mathf.Lerp(h00, h10, tx),</mark>
			<mark>Mathf.Lerp(h01, h11, tx),</mark>
			<mark>ty)</mark> * (1f / hashMask);
	}</pre>
			
			<figure>
				<img alt="8" src="05-2d-8.png" width="230" height="230">
				<img alt="16" src="05-2d-16.png" width="230" height="230">
				<img alt="32" src="05-2d-32.png" width="230" height="230">
				<figcaption>2D Value noise.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>When applying this approach to three dimensions the process is the same, it just gets bigger. you end up with eight hashes and need to perform a trilinear interpolation. I've copied the 2D code into the 3D method and marked the changes from there.</p>
			</div>
			
			<pre translate="no">	public static float Value3D (Vector3 point, float frequency) {
		point *= frequency;
		int ix0 = Mathf.FloorToInt(point.x);
		int iy0 = Mathf.FloorToInt(point.y);
		<mark>int iz0 = Mathf.FloorToInt(point.z);</mark>
		float tx = point.x - ix0;
		float ty = point.y - iy0;
		<mark>float tz = point.z - iz0;</mark>
		ix0 &amp;= hashMask;
		iy0 &amp;= hashMask;
		<mark>iz0 &amp;= hashMask;</mark>
		int ix1 = ix0 + 1;
		int iy1 = iy0 + 1;
		<mark>int iz1 = iz0 + 1;</mark>

		int h0 = hash[ix0];
		int h1 = hash[ix1];
		int h00 = hash[h0 + iy0];
		int h10 = hash[h1 + iy0];
		int h01 = hash[h0 + iy1];
		int h11 = hash[h1 + iy1];
		<mark>int h000 = hash[h00 + iz0];</mark>
		<mark>int h100 = hash[h10 + iz0];</mark>
		<mark>int h010 = hash[h01 + iz0];</mark>
		<mark>int h110 = hash[h11 + iz0];</mark>
		<mark>int h001 = hash[h00 + iz1];</mark>
		<mark>int h101 = hash[h10 + iz1];</mark>
		<mark>int h011 = hash[h01 + iz1];</mark>
		<mark>int h111 = hash[h11 + iz1];</mark>

		tx = Smooth(tx);
		ty = Smooth(ty);
		<mark>tz = Smooth(tz);</mark>
		return Mathf.Lerp(
			Mathf.Lerp(<mark>Mathf.Lerp(h000, h100, tx)</mark>, <mark>Mathf.Lerp(h010, h110, tx)</mark>, <mark>ty</mark>),
			Mathf.Lerp(<mark>Mathf.Lerp(h001, h101, tx)</mark>, <mark>Mathf.Lerp(h011, h111, tx)</mark>, <mark>ty</mark>),
			<mark>tz</mark>) * (1f / hashMask);
	}</pre>
			
			<figure>
				<img alt="Z 0%" src="05-3d-00.png" width="126" height="126">
				<img alt="Z 20%" src="05-3d-02.png" width="126" height="126">
				<img alt="Z 40%" src="05-3d-04.png" width="126" height="126">
				<img alt="Z 60%" src="05-3d-06.png" width="126" height="126">
				<img alt="Z 80%" src="05-3d-08.png" width="126" height="126">
				<img alt="Z 100%" src="05-3d-10.png" width="126" height="126">
				<figcaption>3D Value noise, moving to the next z coordinate in the lattice grid.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>The 3D noise still appears the same as 2D noise when looking along the z axis. But now it smoothly morphs into a new pattern when moving along z, instead of abruptly changing. Because the rate of change is zero at the lattice points, when moving at constant speed the noise appears to pulse, oscillating between pure 2D patterns and fuzzy blends. Of course the picture changes dramatically when you rotate the quad.</p>
			</div>
			
			<figure>
				<img alt="1D" src="05-rotated-1d.png" width="254" height="240">
				<img alt="2D" src="05-rotated-2d.png" width="254" height="240">
				<img alt="3D" src="05-rotated-3d.png" width="254" height="240">
				<figcaption>1D, 2D, and 3D Value noise with rotation (45,45,0).</figcaption>
			</figure>
			
			<h3>Creating Gradient Noise</h3>
			
			<div class="instructions">
				<p>While Value noise is smooth, it has a blocky appearance. The patterns look random but are clearly constrained to a grid, which is undesirable when trying to create a more chaotic or natural-looking surface.</p>
				<p>Until now we've selected a single fixed value per lattice coordinate, which means only the intensity of the image varies. If we could somehow add more variety &ndash; especially a sense of direction &ndash; we might be able to obfuscate that we're using a grid.</p>
				<p>A solution is to associate gradients with each lattice coordinate, instead of constant values. If we orient those gradients in different directions and then interpolate between them, then the grid becomes a lot less obvious. As Ken Perlin was the first to use this technique, it is known as Perlin noise.</p>
				<p>So let's create some Perlin noise! Begin by copying the three Value methods in <code>Noise</code>, renaming them to Perlin. Then also add a <code>perlinMethods</code> array. Let's go one step further and create an array of noise method arrays as well, containing our two existing arrays.</p>
			</div>
			
			<pre translate="no">	<mark>public static NoiseMethod[] perlinMethods = {</mark>
		<mark>Perlin1D,</mark>
		<mark>Perlin2D,</mark>
		<mark>Perlin3D</mark>
	<mark>};</mark>

	<mark>public static NoiseMethod[][] noiseMethods = {</mark>
		<mark>valueMethods,</mark>
		<mark>perlinMethods</mark>
	<mark>};</mark>
	
	<mark>public static float Perlin1D (Vector3 point, float frequency) {</mark>
		&hellip;
	<mark>}</mark>
	
	<mark>public static float Perlin2D (Vector3 point, float frequency) {</mark>
		&hellip;
	<mark>}</mark>
	
	<mark>public static float Perlin3D (Vector3 point, float frequency) {</mark>
		&hellip;
	<mark>}</mark></pre>
			
			<div class="instructions">
				<p>Then add a noise method type enumeration, which can be used to index the double array.</p>
			</div>
			
			<pre translate="no">using UnityEngine;

public delegate float NoiseMethod (Vector3 point, float frequency);

<mark>public enum NoiseMethodType {</mark>
	<mark>Value,</mark>
	<mark>Perlin</mark>
<mark>}</mark>

public static class Noise {
	&hellip;
}</pre>
			
			<div class="instructions">
				<p>Now we can add another configuration option to <code>TextureCreator</code>, so we can use the inspector to switch between Value noise and Perlin noise.</p>
			</div>
			
			<pre translate="no">	<mark>public NoiseMethodType type;</mark>
	
	public void FillTexture () {
		if (texture.width != resolution) {
			texture.Resize(resolution, resolution);
		}
		
		Vector3 point00 = transform.TransformPoint(new Vector3(-0.5f,-0.5f));
		Vector3 point10 = transform.TransformPoint(new Vector3( 0.5f,-0.5f));
		Vector3 point01 = transform.TransformPoint(new Vector3(-0.5f, 0.5f));
		Vector3 point11 = transform.TransformPoint(new Vector3( 0.5f, 0.5f));

		NoiseMethod method = Noise.<mark>noiseMethods[(int)type]</mark>[dimensions - 1];
		float stepSize = 1f / resolution;
		for (int y = 0; y &lt; resolution; y++) {
			Vector3 point0 = Vector3.Lerp(point00, point01, (y + 0.5f) * stepSize);
			Vector3 point1 = Vector3.Lerp(point10, point11, (y + 0.5f) * stepSize);
			for (int x = 0; x &lt; resolution; x++) {
				Vector3 point = Vector3.Lerp(point0, point1, (x + 0.5f) * stepSize);
				texture.SetPixel(x, y, Color.white * method(point, frequency));
			}
		}
		texture.Apply();
	}</pre>
			
			<figure>
				<img src="06-noise-type.png" width="320" height="112">
				<figcaption>Selecing which noise type to use.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Of course we see no change yet when switching to Perlin noise, because those methods are still producing Value noise. So how how do we convert from using hash values to using hash gradients? Let's consider one-dimensional noise first, which so far is simply interpolating between two hash values.</p>
				<p>The most basic one-dimensional gradient function is <b>g(<i>x</i>) = <i>x</i></b>, which is simply <i>x</i> unmodified. In our case, we are only interested in the values of <i>x</i> in between two integer coodinates, so we can use our <code>t</code> variable, before it is smoothed. Let's visualize this gradient by simply returning <code>t</code>, ignoring the hashes for a moment.</p>
			</div>
			
			<pre translate="no">	public static float Perlin1D (Vector3 point, float frequency) {
		point *= frequency;
		int i0 = Mathf.FloorToInt(point.x);
		float t = point.x - i0;
		i0 &amp;= hashMask;
		int i1 = i0 + 1;
		
		int h0 = hash[i0];
		int h1 = hash[i1];
		
		<mark>return t</mark>;
	}</pre>
			
			<figure>
				<img src="06-gradient.png" width="220" height="220">
				<figcaption>The most basic gradient.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Now every stripe has the same gradient, except that they are offset from one another. So for every <code>t0</code>, the gradient to the right of it is <code>t1 = t0 - 1</code>. Let's smoothly interpolate them.</p>
			</div>
			
			<pre translate="no">		point *= frequency;
		int i0 = Mathf.FloorToInt(point.x);
		float <mark>t0</mark> = point.x - i0;
		<mark>float t1 = t0 - 1f;</mark>
		i0 &amp;= hashMask;
		int i1 = i0 + 1;
		
		int h0 = hash[i0];
		int h1 = hash[i1];

		<mark>float t = Smooth(t0);</mark>
		return <mark>Mathf.Lerp(t0, t1, t);</mark></pre>
			
			<figure>
				<img src="06-gradient-interpolation.png" width="220" height="220">
				<figcaption>Smoothly interpolating gradients.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>The resulting image is dark because the gradients cancel each other out. Had we used linear interpolation it would be completely black, but because we're using smooth interpolation each gradient gets more dominant as it approaches zero. As the <code>t1</code> values go below zero, we don't see them.</p>
				<p>Indeed, Perlin noise can procude both positive and negative values. Ideally, its range is -1&ndash;1. To make this range visible, <code>TextureCreator.FillTexture</code> has to scale and offset the noise samples so -1 becomes 0, 0 becomes 0.5, and 1 stays 1, but we shouldn't do this when using Value noise.</p>
			</div>
			
			<pre translate="no">		for (int y = 0; y &lt; resolution; y++) {
			Vector3 point0 = Vector3.Lerp(point00, point01, (y + 0.5f) * stepSize);
			Vector3 point1 = Vector3.Lerp(point10, point11, (y + 0.5f) * stepSize);
			for (int x = 0; x &lt; resolution; x++) {
				Vector3 point = Vector3.Lerp(point0, point1, (x + 0.5f) * stepSize);
				<mark>float sample = method(point, frequency);</mark>
				<mark>if (type != NoiseMethodType.Value) {</mark>
					<mark>sample = sample * 0.5f + 0.5f;</mark>
				<mark>}</mark>
				texture.SetPixel(x, y, Color.white * <mark>sample</mark>);
			}
		}</pre>
			
			<figure>
				<img src="06-gradient-mapped.png" width="220" height="220">
				<figcaption>Mapping -1&ndash;1 to 0&ndash;1.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>To reintroduce randomness, we have to convert the hash values into gradient functions. Assuming we have an array of 1D gradients, we can simply use the hash values to index this array, applying a mask so the arrays don't need to be the same length.</p>
			</div>
			
			<pre translate="no">	public static float Perlin1D (Vector3 point, float frequency) {
		point *= frequency;
		int i0 = Mathf.FloorToInt(point.x);
		float t0 = point.x - i0;
		float t1 = t0 - 1f;
		i0 &amp;= hashMask;
		int i1 = i0 + 1;
		
		<mark>float g0 = gradients1D[</mark>hash[i0] <mark>&amp; gradientsMask1D];</mark>
		<mark>float g1 = gradients1D[</mark>hash[i1] <mark>&amp; gradientsMask1D];</mark>

		float t = Smooth(t0);
		return Mathf.Lerp(t0, t1, t);
	}</pre>
			
			<div class="instructions">
				<p>For gradients, we simply pick the two directions of movement possible in one dimension. This means we end up using positive gradients for even hash values, and negative gradients for odd hash values.</p>
			</div>
			
			<pre translate="no">	<mark>private static float[] gradients1D = {</mark>
		<mark>1f, -1f</mark>
	<mark>};</mark>

	<mark>private const int gradientsMask1D = 1;</mark></pre>
			
			<div class="instructions">
				<p>After retrieving these gradients, we compute their values at the current point by multiplying with <code>t0</code> and <code>t1</code>, which can then be interpolated.</p>
			</div>
			
			<pre translate="no">		float g0 = gradients1D[hash[i0] &amp; gradientsMask1D];
		float g1 = gradients1D[hash[i1] &amp; gradientsMask1D];

		<mark>float v0 = g0 * t0;</mark>
		<mark>float v1 = g1 * t1;</mark>

		float t = Smooth(t0);
		return Mathf.Lerp(<mark>v0</mark>, <mark>v1</mark>, t);</pre>
			
			<figure>
				<img src="06-1d-not-normalized.png" width="220" height="220">
				<figcaption>Mixing two different gradients.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Now adjacent gradients can point in either the same or opposite directions, going either up or down. So there are four possible transitions, and the order in which they appear depends on the hash values.</p>
				<p>While this is already 1D Perlin noise, it doesn't yet cover the entire -1&ndash;1 range, so we need to normalize it. So what is currently the maximum possible value? If we were to linearly interpolate two gradients pointing in opposite directions, they would both be 0.5 at the halfway point, which means their interpolation is also 0.5 there. As the gradients start at zero, this must be the maximum possible value. Smoothly interpolating does not change this maximum. So doubling the result will produde the desired range.</p>
			</div>
			
			<pre translate="no">		return Mathf.Lerp(v0, v1, t) <mark>* 2f</mark>;</pre>
			
			<figure>
				<img alt="8" src="06-1d-perlin-8.png" width="220" height="220">
				<img alt="16" src="06-1d-perlin-16.png" width="220" height="220">
				<img alt="32" src="06-1d-perlin-32.png" width="220" height="220">
				<figcaption>Normalized 1D Perlin noise.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>For 2D Perlin noise we have to perform the same steps, but now in two dimensions. First, we need 2D gradient coefficients, so we need to use <code>Vector2</code> structs instead of floats. The most obvious gradient choices are right, left, up, and down, so let's pick those.</p>
			</div>
			
			<pre translate="no">	<mark>private static Vector2[] gradients2D = {</mark>
		<mark>new Vector2( 1f, 0f),</mark>
		<mark>new Vector2(-1f, 0f),</mark>
		<mark>new Vector2( 0f, 1f),</mark>
		<mark>new Vector2( 0f,-1f),</mark>
	<mark>};</mark>
	
	<mark>private const int gradientsMask2D = 3;</mark></pre>
			
			<div class="instructions">
				<p>This time we're using gradient functions of the form <b>g(<i>x</i>, <i>y</i>) = a<i>x</i> + b<i>y</i></b>, where a and b are either -1, 0, or 1. Let's add a convenient method to compute this function for us, given a gradient vector.</p>
			</div>
			
			<aside>
				<ul>
					<li><a href="index.html#a-dot" id="q-dot">Why name it Dot?</a></li>
				</ul>
			</aside>
			
			<pre translate="no">	<mark>private static float Dot (Vector2 g, float x, float y) {</mark>
		<mark>return g.x * x + g.y * y;</mark>
	<mark>}</mark></pre>
			
			<div class="instructions">
				<p>Next, we can compute gradients values just like we did for 1D Perlin noise.</p>
			</div>
			
			<pre translate="no">	public static float Perlin2D (Vector3 point, float frequency) {
		point *= frequency;
		int ix0 = Mathf.FloorToInt(point.x);
		int iy0 = Mathf.FloorToInt(point.y);
		float <mark>tx0</mark> = point.x - ix0;
		float <mark>ty0</mark> = point.y - iy0;
		<mark>float tx1 = tx0 - 1f;</mark>
		<mark>float ty1 = ty0 - 1f;</mark>
		ix0 &amp;= hashMask;
		iy0 &amp;= hashMask;
		int ix1 = ix0 + 1;
		int iy1 = iy0 + 1;
		
		int h0 = hash[ix0];
		int h1 = hash[ix1];
		<mark>Vector2 g00 = gradients2D[</mark>hash[h0 + iy0] <mark>&amp; gradientsMask2D];</mark>
		<mark>Vector2 g10 = gradients2D[</mark>hash[h1 + iy0] <mark>&amp; gradientsMask2D];</mark>
		<mark>Vector2 g01 = gradients2D[</mark>hash[h0 + iy1] <mark>&amp; gradientsMask2D];</mark>
		<mark>Vector2 g11 = gradients2D[</mark>hash[h1 + iy1] <mark>&amp; gradientsMask2D];</mark>

		<mark>float v00 = Dot(g00, tx0, ty0);</mark>
		<mark>float v10 = Dot(g10, tx1, ty0);</mark>
		<mark>float v01 = Dot(g01, tx0, ty1);</mark>
		<mark>float v11 = Dot(g11, tx1, ty1);</mark>
		
		<mark>float</mark> tx = Smooth(<mark>tx0</mark>);
		<mark>float</mark> ty = Smooth(<mark>ty0</mark>);
		return Mathf.Lerp(
			Mathf.Lerp(<mark>v00</mark>, <mark>v10</mark>, tx),
			Mathf.Lerp(<mark>v01</mark>, <mark>v11</mark>, tx),
			ty) <mark>* 2f</mark>;
	}</pre>
			
			<figure>
				<img alt="interpolated" src="06-four-gradients.png" width="220" height="220">
				<img alt="v00" src="06-four-gradients-v00.png" width="220" height="220">
				<figcaption>Interpolating four gradients vs. showing only v00.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>This is starting to look interesting, but the noise has a dominant horizontal and vertical alignment. What would happen if we made our gradients diagonal instead?</p>
				
			</div>
			<pre translate="no">	private static Vector2[] gradients2D = {
		<mark>new Vector2( 1f, 1f)</mark>,
		<mark>new Vector2(-1f, 1f)</mark>,
		<mark>new Vector2( 1f,-1f)</mark>,
		<mark>new Vector2(-1f,-1f)</mark>
	};
</pre>
			
			<figure>
				<img alt="interpolated" src="06-diagonal-gradients.png" width="220" height="220">
				<img alt="v00" src="06-diagonal-gradients-v00.png" width="220" height="220">
				<figcaption>Diagonal gradients that go out of range, interpolated vs. only v00.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>As you probably expected, we're now seeing a strong diagonal alignment. We also see that the noise goes out of range. That happens because when the four corner gradients of a lattice cell all end up pointing towards its center, the final interpolated value in the middle will be 1. So we shouldn't double our result when using these gradients.</p>
				<p>While using either axis-aligned gradients or diagonal gradients doesn't look varied enough, using both at the same time will give us a lot more to work with. But then we better make sure that all gradient vectors have the same length, otherwise their intensity will vary a lot. We can do that by normalizing the diagonals.</p>
			</div>
			
			<pre translate="no">	private static Vector2[] gradients2D = {
		<mark>new Vector2( 1f, 0f),</mark>
		<mark>new Vector2(-1f, 0f),</mark>
		<mark>new Vector2( 0f, 1f),</mark>
		<mark>new Vector2( 0f,-1f),</mark>
		new Vector2( 1f, 1f)<mark>.normalized</mark>,
		new Vector2(-1f, 1f)<mark>.normalized</mark>,
		new Vector2( 1f,-1f)<mark>.normalized</mark>,
		new Vector2(-1f,-1f)<mark>.normalized</mark>
	};
	
	private const int gradientsMask2D = 7;</pre>
			
			<div class="instructions">
				<p>In this case the maximum value is still reached at the center off a cell with four diagonal gradients pointing at its center, however that value is no longer 1 but &radic;&frac12;. So we need to divide by &radic;&frac12;, which is the same as multiplying by &radic;2.</p>
			</div>
			
			<aside>
				<ul>
					<li><a href="index.html#a-sqrt-one-half" id="q-sqrt-one-half">Why is it &radic;&frac12;?</a></li>
				</ul>
			</aside>
			
			<pre translate="no">		return Mathf.Lerp(
			Mathf.Lerp(v00, v10, tx),
			Mathf.Lerp(v01, v11, tx),
			ty) * <mark>sqr2</mark>;</pre>
			
			<div class="instructions">
				<p>Unfortunately the square root of 2 is not a rational number, so we cannot write it as a constant. We could write an approximation, like 1.4142136, but let's just use a static variable and have <code>Mathf.Sqrt</code> figure it out.</p>
			</div>
			
			<pre translate="no">	<mark>private static float sqr2 = Mathf.Sqrt(2f);</mark></pre>
			
			<figure>
				<img alt="8" src="06-2d-perlin-8.png" width="220" height="220">
				<img alt="16" src="06-2d-perlin-16.png" width="220" height="220">
				<img alt="32" src="06-2d-perlin-32.png" width="220" height="220">
				<figcaption>Normalized 2D Perlin noise.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>We can still see horizontal and diagonal structures, but the probability of either showing up is equal. But what if we included even more gradients, like using sixteen rotated in 22.5 degree increments? It turns out that this doesn't really increase the apparent randomness of the patterns, so we stick with eight.</p>
				<p>The same is true for three dimensions. Ken Perlin found that you don't need many gradients. He chose just twelve vectors for his improved noise, each pointing from the center of a cube to the middle of one of its edges. However, twelve is not a power of two, so bit masking doesn't work with that. He decided to lengthen his array by including four vectors twice. He picked four that form a regular tetrahedron so they don't introduce a directional bias. Let us use the same gradients.</p>
			</div>
			
			<pre translate="no">	<mark>private static Vector3[] gradients3D = {</mark>
		<mark>new Vector3( 1f, 1f, 0f),</mark>
		<mark>new Vector3(-1f, 1f, 0f),</mark>
		<mark>new Vector3( 1f,-1f, 0f),</mark>
		<mark>new Vector3(-1f,-1f, 0f),</mark>
		<mark>new Vector3( 1f, 0f, 1f),</mark>
		<mark>new Vector3(-1f, 0f, 1f),</mark>
		<mark>new Vector3( 1f, 0f,-1f),</mark>
		<mark>new Vector3(-1f, 0f,-1f),</mark>
		<mark>new Vector3( 0f, 1f, 1f),</mark>
		<mark>new Vector3( 0f,-1f, 1f),</mark>
		<mark>new Vector3( 0f, 1f,-1f),</mark>
		<mark>new Vector3( 0f,-1f,-1f),</mark>
		
		<mark>new Vector3( 1f, 1f, 0f),</mark>
		<mark>new Vector3(-1f, 1f, 0f),</mark>
		<mark>new Vector3( 0f,-1f, 1f),</mark>
		<mark>new Vector3( 0f,-1f,-1f)</mark>
	<mark>};</mark>
	
	<mark>private const int gradientsMask3D = 15;</mark></pre>
			
			<div class="instructions">
				<p>While we could normalize these gradients, as they all have the same length this is not really necessary. Furthermore, Because each individual vector only uses two dimensions, the maximum possible value is the same as for the unnormalized 2D diagonals case, which is 1. So we don't have to scale the interpolated value at all.</p>
				<p>The only extra thing we need to do is add another <code>Dot</code> method that works for three dimensions.</p>
			</div>
			
			<pre translate="no">	<mark>private static float Dot (Vector3 g, float x, float y, float z) {</mark>
		<mark>return g.x * x + g.y * y + g.z * z;</mark>
	<mark>}</mark>
	
	public static float Perlin3D (Vector3 point, float frequency) {
		point *= frequency;
		int ix0 = Mathf.FloorToInt(point.x);
		int iy0 = Mathf.FloorToInt(point.y);
		int iz0 = Mathf.FloorToInt(point.z);
		float <mark>tx0</mark> = point.x - ix0;
		float <mark>ty0</mark> = point.y - iy0;
		float <mark>tz0</mark> = point.z - iz0;
		<mark>float tx1 = tx0 - 1f;</mark>
		<mark>float ty1 = ty0 - 1f;</mark>
		<mark>float tz1 = tz0 - 1f;</mark>
		ix0 &amp;= hashMask;
		iy0 &amp;= hashMask;
		iz0 &amp;= hashMask;
		int ix1 = ix0 + 1;
		int iy1 = iy0 + 1;
		int iz1 = iz0 + 1;
		
		int h0 = hash[ix0];
		int h1 = hash[ix1];
		int h00 = hash[h0 + iy0];
		int h10 = hash[h1 + iy0];
		int h01 = hash[h0 + iy1];
		int h11 = hash[h1 + iy1];
		<mark>Vector3 g000 = gradients3D[</mark>hash[h00 + iz0] <mark>&amp; gradientsMask3D];</mark>
		<mark>Vector3 g100 = gradients3D[</mark>hash[h10 + iz0] <mark>&amp; gradientsMask3D];</mark>
		<mark>Vector3 g010 = gradients3D[</mark>hash[h01 + iz0] <mark>&amp; gradientsMask3D];</mark>
		<mark>Vector3 g110 = gradients3D[</mark>hash[h11 + iz0] <mark>&amp; gradientsMask3D];</mark>
		<mark>Vector3 g001 = gradients3D[</mark>hash[h00 + iz1] <mark>&amp; gradientsMask3D];</mark>
		<mark>Vector3 g101 = gradients3D[</mark>hash[h10 + iz1] <mark>&amp; gradientsMask3D];</mark>
		<mark>Vector3 g011 = gradients3D[</mark>hash[h01 + iz1] <mark>&amp; gradientsMask3D];</mark>
		<mark>Vector3 g111 = gradients3D[</mark>hash[h11 + iz1] <mark>&amp; gradientsMask3D];</mark>

		<mark>float v000 = Dot(g000, tx0, ty0, tz0);</mark>
		<mark>float v100 = Dot(g100, tx1, ty0, tz0);</mark>
		<mark>float v010 = Dot(g010, tx0, ty1, tz0);</mark>
		<mark>float v110 = Dot(g110, tx1, ty1, tz0);</mark>
		<mark>float v001 = Dot(g001, tx0, ty0, tz1);</mark>
		<mark>float v101 = Dot(g101, tx1, ty0, tz1);</mark>
		<mark>float v011 = Dot(g011, tx0, ty1, tz1);</mark>
		<mark>float v111 = Dot(g111, tx1, ty1, tz1);</mark>

		<mark>float</mark> tx = Smooth(<mark>tx0</mark>);
		<mark>float</mark> ty = Smooth(<mark>ty0</mark>);
		<mark>float</mark> tz = Smooth(<mark>tz0</mark>);
		return Mathf.Lerp(
			Mathf.Lerp(Mathf.Lerp(<mark>v000</mark>, <mark>v100</mark>, tx), Mathf.Lerp(<mark>v010</mark>, <mark>v110</mark>, tx), ty),
			Mathf.Lerp(Mathf.Lerp(<mark>v001</mark>, <mark>v101</mark>, tx), Mathf.Lerp(<mark>v011</mark>, <mark>v111</mark>, tx), ty),
			tz)<mark>;</mark>
	}</pre>
			
			<figure>
				<img alt="8" src="06-3d-perlin-8.png" width="220" height="220">
				<img alt="16" src="06-3d-perlin-16.png" width="220" height="220">
				<img alt="32" src="06-3d-perlin-32.png" width="220" height="220">
				<figcaption>3D Perlin noise.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Because we are using different gradients for 3D than for 2D, the two noise patterns appear slightly different when viewed along the z axis. While the 3D gradients are all the same length when taking all their dimensions into account, when you ignore one dimension this is no longer true.</p>
			</div>
			
			<figure>
				<img alt="Z 0%" src="06-3d-00.png" width="126" height="126">
				<img alt="Z 20%" src="06-3d-02.png" width="126" height="126">
				<img alt="Z 40%" src="06-3d-04.png" width="126" height="126">
				<img alt="Z 60%" src="06-3d-06.png" width="126" height="126">
				<img alt="Z 80%" src="06-3d-08.png" width="126" height="126">
				<img alt="Z 100%" src="06-3d-10.png" width="126" height="126">
				<figcaption>3D Perlin noise, moving to the next z coordinate in the lattice grid.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Of course 3D Perlin noise makes the most sense when animating 2D patterns or when really working with three dimensions.</p>
			</div>
			
			<figure>
				<img alt="1D" src="06-rotated-1d.png" width="254" height="240">
				<img alt="2D" src="06-rotated-2d.png" width="254" height="240">
				<img alt="3D" src="06-rotated-3d.png" width="254" height="240">
				<figcaption>1D, 2D, and 3D Perlin noise with rotation (45,45,0).</figcaption>
			</figure>
			
			<h2>Making Fractal Noise</h2>
			
			<div class="instructions">
				<p>Because our noise is based on a lattice, its features &ndash; though seemingly random &ndash; are all the same size. However, many things have both larger and smaller features. Think clouds, mountains, coastlines, and many plants. As you zoom in, you will discover more and more detail. Often, the details look similar to the larger shape, like a branch on a tree is could look like a smaller tree itself, with even smaller braches. These self-similar shapes are known as fractals.</p>
				<p>Our noise patterns don't have this property, but we can make a limited version of it by combining samples at different frequencies. For example, adding frequency 8 and frequency 16 together. Here the frequency 16 samples represent the details, so they should be less pronounced than the larger features. Because the frequency is doubled, it makes sense to half its strength. Of couse we can go a step further, and also add a frequency 32 sample at quarter strength, and so on. Such a summation of noise frequencies is known as 1/f noise, or fractal noise, or fractional noise, pink noise, and some other names.</p>
				
				<p>Let's add a <code>Sum</code> method to <code>Noise</code> that combines two samples, the second at double frequency and half strength or amplitude. We can give it a parameter to determine which method to use, so we don't need to create a separate summation method for all our noise types and dimensions.</p>
			</div>
			
			<pre translate="no">	<mark>public static float Sum (NoiseMethod method, Vector3 point, float frequency) {</mark>
		<mark>return method(point, frequency) + method(point, frequency * 2f) * 0.5f;</mark>
	<mark>}</mark></pre>
			
			<div class="instructions">
				<p>Now <code>TextureCreator.FillTexture</code> can pass its noise method to <code>Sum</code> instead of calling it directly.</p>
			</div>
			
			<pre translate="no">				Vector3 point = Vector3.Lerp(point0, point1, (x + 0.5f) * stepSize);
				float sample = Noise.<mark>Sum(</mark>method<mark>,</mark> point, frequency);
				if (type != NoiseMethodType.Value) {
					sample = sample * 0.5f + 0.5f;
				}
				texture.SetPixel(x, y, Color.white * sample);</pre>
			
			
			<figure>
				<img alt="4" src="07-value-2d-4.png" width="200" height="200">
				<img alt="8" src="07-value-2d-8.png" width="200" height="200">
				<img alt="4 + 8" src="07-value-2d-sum.png" width="200" height="200">
				<figcaption>2D Value noise at frequency 4 and 8, separate and summed with 8 at half strength.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Of course the range of this summation is 0&ndash;1.5, or -1.5&ndash;1.5 when using Perlin noise, so to get a normalized result we have to divide by 1.5.</p>
			</div>
			
			<pre translate="no">		return <mark>(</mark>(method(point, frequency) + method(point, frequency * 2f) * 0.5f) <mark>/ 1.5f</mark>;</pre>
			
			<figure>
				<img alt="4" src="07-value-2d-sum-normalized.png" width="200" height="200">
				<img alt="8" src="07-perlin-2d-sum-normalized.png" width="200" height="200">
				<figcaption>Normalized sum, for Value and Perlin noise.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Of course we don't always want to sum exactly two samples, so let's make configurable how many samples, or octaves, we want to include. Because each successive octave will be smaller than the previous, at some point adding more octaves won't visibly change the image any more. Besides that, more samples require more computation time, so this also limits how many octaves are practical.</p>
				<p>Let's add an <code>octaves</code> setting to <code>TextureCreator</code> and give it a range from one to eight.</p>
			</div>
			
			<pre translate="no">	public float frequency = 1f;

	<mark>[Range(1, 8)]</mark>
	<mark>public int octaves = 1;</mark>

	[Range(1, 3)]
	public int dimensions = 3;</pre>
			
			<div class="instructions">
				<p>Then pass it to <code>Sum</code> in <code>FillTexture</code>.</p>
			</div>
			
			<figure>
				<img src="07-octaves.png" width="320" height="128">
				<figcaption>Adding a slider for octaves.</figcaption>
			</figure>
			
			<pre translate="no">				float sample = Noise.Sum(method, point, frequency<mark>, octaves</mark>);</pre>
			
			<div class="instructions">
				<p><code>Noise.Sum</code> now has to accumulate all the octaves, at each step increasing the frequency, halving the amplitude, and keeping track of the total range for nomalization. Because it is pointless to ask for zero octaves, let's always compute the first, then loop through the others.</p>
			</div>
			
			<pre translate="no">	public static float Sum (NoiseMethod method, Vector3 point, float frequency<mark>, int octaves</mark>) {
		<mark>float sum =</mark> method(point, frequency);
		<mark>float amplitude = 1f;</mark>
		<mark>float range = 1f;</mark>
		<mark>for (int o = 1; o &lt; octaves; o++) {</mark>
			<mark>frequency *= 2f;</mark>
			<mark>amplitude *= 0.5f;</mark>
			<mark>range += amplitude;</mark>
			<mark>sum += method(point, frequency) * amplitude;</mark>
		<mark>}</mark>
		return <mark>sum / range;</mark>
	}</pre>
			
			<figure>
				<img alt="value 1 octave" src="07-value-1o.png" width="184" height="184">
				<img alt="value 2 octaves" src="07-value-2o.png" width="184" height="184">
				<img alt="value 3 octaves" src="07-value-3o.png" width="184" height="184">
				<img alt="value 4 octaves" src="07-value-4o.png" width="184" height="184">
				<img alt="value 5 octaves" src="07-value-5o.png" width="184" height="184"><br>
				<img alt="perlin 1 octave" src="07-perlin-1o.png" width="184" height="184">
				<img alt="perlin 2 octaves" src="07-perlin-2o.png" width="184" height="184">
				<img alt="perlin 3 octaves" src="07-perlin-3o.png" width="184" height="184">
				<img alt="perlin 4 octaves" src="07-perlin-4o.png" width="184" height="184">
				<img alt="perlin 5 octaves" src="07-perlin-5o.png" width="184" height="184">
				<figcaption>Value and Perlin noise with base frequency 3, from one to five octaves.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>It is not required that the frequency is exactly doubled each octave, neither does the amplitude need to be exactly halved. The factor by which the frequency changes is often known as the lacunarity,  while the amplitude factor is often named persistence or gain. Let's add these options to <code>TextureCreator</code> with reasonable ranges.</p>
			</div>
			
			<pre translate="no">	public float frequency = 1f;

	[Range(1, 8)]
	public int octaves = 1;

	<mark>[Range(1f, 4f)]</mark>
	<mark>public float lacunarity = 2f;</mark>

	<mark>[Range(0f, 1f)]</mark>
	<mark>public float persistence = 0.5f;</mark></pre>
			
			<figure>
				<img src="07-lacunarity-persistence.png" width="320" height="164">
				<figcaption>Lacunarity and persistence with typical values.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Of course we need to pass them to the <code>Sum</code> method.</p>
			</div>
			
			<pre translate="no">				float sample = Noise.Sum(method, point, frequency, octaves<mark>, lacunarity, persistence</mark>);</pre>
			
			<div class="instructions">
				<p>And <code>Sum</code> itself has to use them instead of contant values.</p>
			</div>
			
			<pre translate="no">	public static float Sum (
		NoiseMethod method, Vector3 point, float frequency, int octaves<mark>, float lacunarity, float persistence</mark>
	) {
		float sum = method(point, frequency);
		float amplitude = 1f;
		float range = 1f;
		for (int o = 1; o &lt; octaves; o++) {
			frequency *= <mark>lacunarity</mark>;
			amplitude *= <mark>persistence</mark>;
			range += amplitude;
			sum += method(point, frequency) * amplitude;
		}
		return sum / range;
	}</pre>
			
			<figure>
				<img alt="perlin lacunarity 2" src="07-perlin-l2.png" width="184" height="184">
				<img alt="perlin lacunarity 3" src="07-perlin-l3.png" width="184" height="184">
				<img alt="perlin lacunarity 4" src="07-perlin-l4.png" width="184" height="184">
				<figcaption>Two octaves of Perlin noise with base frequency 8, using lacunarity 2, 3, and 4.</figcaption>
			</figure>
			
			<figure>
				<img alt="perlin persistence 0.5" src="07-perlin-p050.png" width="184" height="184">
				<img alt="perlin persistence 0.75" src="07-perlin-p075.png" width="184" height="184">
				<img alt="perlin persistence 1" src="07-perlin-p100.png" width="184" height="184">
				<figcaption>Three octaves of Perlin noise with base frequency 8, using persistence &frac12;, &frac34;, and 1.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>You might have noticed that when changing the frequency or the lacunarity, it looks like you're zooming from the center of the image. This happens when the quad is placed at the origin. Because everything is relative to that point, the same features of successive octaves will overlap, producing lines or cones that are obviously not random. This is a problem in all dimensions. To avoid these artifacts, move away from the origin.</p>
			</div>
			
			<figure>
				<img alt="at origin" src="07-value-3d-000.png" width="220" height="220">
				<img alt="offset" src="07-value-3d-123.png" width="220" height="220">
				<figcaption>Rotated summed 3D Value noise, positioned at (0,0,0) and at (1,2,3).</figcaption>
			</figure>
			
			<div class="instructions">
				<p>So far we've converted the noise values to grayscale colors, but we need not limit ourselves to that. To allow more interesting color transitions, let's wrap up <code>TextureCreator</code> by adding a gradient to it.</p>
			</div>
			
			<pre translate="no">	<mark>public Gradient coloring;</mark></pre>
			
			<div class="instructions">
				<p>If you let the gradient go from black to white, you'll get the same result as before. So design something else instead. As an example, I put a narrow black region in the middle, made the lower half white&ndash;blue, and the upper half yellow&ndash;red. This will divide the patterns into two parts.</p>
			</div>
			
			<figure>
				<img src="07-gradient.png" width="320" height="184">
				<figcaption>A gradient.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>To actually show the colors, instead of multiplying our noise samples with a constant white color, we use them to evaluate the gradient in <code>FillTexture</code>.</p>
			</div>
			
			<pre translate="no">				texture.SetPixel(x, y, <mark>coloring.Evaluate(</mark>sample<mark>)</mark>);</pre>
			
			<figure>
				<img alt="2d 1 octave" src="07-value-2d-f16-1o.png" width="250" height="250"> <img alt="3d 1 octave" src="07-value-3d-f16-1o.png" width="250" height="250"><br>
				<img alt="2d 6 octaves" src="07-value-2d-f3-o6.png" width="250" height="250"> <img alt="3d 6 octaves" src="07-value-3d-f3-6o.png" width="250" height="250">
				<figcaption>Colored 2D and 3D Value noise, one octave with frequency 16, and six octaves with base frequency 3.</figcaption>
			</figure>
			
			<figure>
				<img alt="2d 1 octave" src="07-perlin-2d-f16-1o.png" width="250" height="250"> <img alt="3d 1 octave" src="07-perlin-3d-f16-1o.png" width="250" height="250"><br>
				<img alt="2d 6 octaves" src="07-perlin-2d-f3-o6.png" width="250" height="250"> <img alt="3d 6 octaves" src="07-perlin-3d-f3-6o.png" width="250" height="250">
				<figcaption>Colored 2D and 3D Perlin noise, one octave with frequency 16, and six octaves with base frequency 3.</figcaption>
			</figure>
			
			<div class="instructions">
				<p>Of course you can create many different results with other gradients, especially once you start playing with lacunarity and persistence as well. Have fun experimenting with noise settings, or immediately move on to <a href="../noise-derivatives/index.html">Noise Derivatives</a>.</p>
				<p>Enjoyed the tutorial? <a href="https://www.patreon.com/catlikecoding">Help me make more by becoming a patron!</a></p>
			</div>
			
			<aside class="share"></aside>
			
			<h2>Downloads</h2>

			<dl>
				<dt><a href="noise-01.unitypackage" onclick="_gaq.push(['_trackEvent', 'Tutorial Download', 'Noise', '01']);" target="_blank" download rel="nofollow">noise-01.unitypackage</a></dt>
				<dd>The project after Creating a Texture.</dd>
				<dt><a href="noise-02.unitypackage" onclick="_gaq.push(['_trackEvent', 'Tutorial Download', 'Noise', '02']);" target="_blank" download rel="nofollow">noise-02.unitypackage</a></dt>
				<dd>The project after Visualizing World Space.</dd>
				<dt><a href="noise-03.unitypackage" onclick="_gaq.push(['_trackEvent', 'Tutorial Download', 'Noise', '03']);" target="_blank" download rel="nofollow">noise-03.unitypackage</a></dt>
				<dd>The project after Making Noise.</dd>
				<dt><a href="noise-04.unitypackage" onclick="_gaq.push(['_trackEvent', 'Tutorial Download', 'Noise', '04']);" target="_blank" download rel="nofollow">noise-04.unitypackage</a></dt>
				<dd>The project after Going Into Higher Dimensions.</dd>
				<dt><a href="noise-05.unitypackage" onclick="_gaq.push(['_trackEvent', 'Tutorial Download', 'Noise', '05']);" target="_blank" download rel="nofollow">noise-05.unitypackage</a></dt>
				<dd>The project after Interpolating Hash Values.</dd>
				<dt><a href="noise-06.unitypackage" onclick="_gaq.push(['_trackEvent', 'Tutorial Download', 'Noise', '06']);" target="_blank" download rel="nofollow">noise-06.unitypackage</a></dt>
				<dd>The project after Making Fractal Noise.</dd>
				<dt><a href="noise-finished.unitypackage" onclick="_gaq.push(['_trackEvent', 'Tutorial Download', 'Noise', 'Final']);" target="_blank" download rel="nofollow">noise-finished.unitypackage</a></dt>
				<dd>The finished project.</dd>
			</dl>
		</article>
		
		<dl class="questions-answers">
			<dt><a href="index.html#q-shader" id="a-shader">Why not use a procedural shader?</a></dt>
			<dd>
				<p>Why create a texture on the CPU, while you could use the GPU? It's a good questions. The GPU is very good at this job, and you could even render to a texture so you don't have to compute complex noise all the time. The GPU can also be used for other massively parallel computations that need noise, like mesh deformations and particle systems. But there are lots of other applications of noise, many of which don't benefit from massive parallelism, in which case CPU noise is useful. There are also many situations in which there simply is no access to an advanced GPU, either because of software or hardware limitations.</p>
				<p>Ideally, you have access to both CPU and GPU noise and can use the best tool for the job. Both approaches use the same noise algorithms, but GPU programming is still quite arcane compared to C# programming. A big part of writing shaders is playing to the strenghts of the hardware and working around its limitations. This distracts from the noise algorithms themselves, which don't depend on specific hardware. So it makes sense to start with CPU noise.</p>
			</dd>
			<dt><a href="index.html#q-256" id="a-256">Why 256?</a></dt>
			<dd>
				<p>Because all hardware are binary systems, they like their numbers in power-of-two increments. This is most efficient and sometimes even required for textures. That's why you always see the numbers 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, and 4096 pop up.</p>
			</dd>
			<dt><a href="index.html#q-rgb24" id="a-rgb24">What does RGB24 mean?</a></dt>
			<dd>
				<p>The 24 after RGB indicates how many bits are use to store a single pixel. In this case we're only using the red, green, and blue channels, so eight bits &ndash; one byte &ndash; are available per channel. This means we can represents 2<sup>8</sup> or 256 different values per channel, and a total of 2<sup>24</sup> or 16777216 different colors.</p>
			</dd>
			<dt><a href="index.html#q-mipmaps" id="a-mipmaps">What are mipmaps?</a></dt>
			<dd>
				<p>Mipmaps are downsampled versions of the base texture, each at half the resolution of the previous level. When used, the GPU decides which level to render based on which best matches the output resolution. When a smaller area is covered, a smaller mipmap is chosen.</p>
			</dd>
			<dt><a href="index.html#q-01-range" id="a-01-range">Why a 0&ndash;1 range?</a></dt>
			<dd>
				<p>You'll often see two ranges used for color channels, either 0&ndash;1 or 0&ndash;255. Unity's <code>Color</code> struct uses the first range.</p>
				<p>The 0&ndash;255 range is an obvious choise when using one byte per color channel. However, that means your color representation is tied to whatever fidelity you're currently using. If you were to later switch to using only four bits per channel, or to sixteen bits per channel, then what? Because everything has been expressed in the 0&ndash;255 range, it is either too expensive, impractical, or simply impossible to change the range. You'll have no choice but to keep using it, even though it no longer makes sense. That is the curse of backwards compatibility. An implementation-agnostic range like 0&ndash;1 avoids this problem.</p>
				<p>On the other hand, by sticking to the range that's really being used, there is no conversion step necessary, which costs performance. That's why Unity also has the <code>Color32</code> struct, which uses bytes.</p>
			</dd>
			<dt><a href="index.html#q-delegate" id="a-delegate">What's a delegate?</a></dt>
			<dd>
				<p>Besides simple values and object references, you also store method references in a variable. Such a variable is known as a delegate.</p>
				<p>A delegate type is defined like a method, except that there's no code body. You can assign any method to such a variable, as long as its parameter types and return type match. The variable can then be called like a normal method.</p>
				<p>Actually, a delegate variable acts like a list. You can add multiple methods to it, which will all be invoked when calling the variable. That's why we're adding to and removing from the undo delegate. Had we directly assigned to it, the entire method list would've been replaced.</p>
			</dd>
			<dt><a href="index.html#q-anisotropic" id="a-anisotropic">What's anisotropic filtering?</a></dt>
			<dd>
				<p>Being anisotripic means that whatever you're doing is directionally dependent. This case, it means that how you filter depends on the view angle.</p>
				<p>If we were to rotate the view or the quad around the x or y axis, the quad's projection will turn into a rectangle, and eventually a line. As this happens, one of its dimensions visually gets smaller, while the other stays constant. As the smallest dimension dictates which mipmap level is used, the smaller dimension will look fine, but the larger one will become too blurry. Anisotropic filtering solves this by also including stretched mipmaps that are downsampled in one dimension while the other is held constant.</p>
			</dd>
			<dt><a href="index.html#q-has-changed" id="a-has-changed">How does <code>hasChanged</code> work?</a></dt>
			<dd>
				<p><code>Transform</code> has a <code>hasChanged</code> property which is set to <code>true</code> whenever one of its values is changed. So it is useful to check whether the position, rotation, or scale has been modified since the last time you checked.</p>
				<p>However, nobody sets <code>hasChanged</code> back to <code>false</code>, because there is no universal moment when this should happen. It is up to you to reset it.</p>
			</dd>
			<dt><a href="index.html#q-bitwise-and" id="a-bitwise-and">How does <code>&amp;</code> work?</a></dt>
			<dd>
				<p>While <code>&amp;&amp;</code> is the boolean AND operator, <code>&amp;</code> is the bitwise AND operator. It performs the same logic, but on each individual pair of bits of its operands. So both bits of a pair need to be 1 for the result to be 1.</p>
				<p>For example, performing the bitwise AND operation on the binary numbers 10111010 and 00000011 results in 00000010. Effectively, the second operand has erased all but the rightmost two bits of the first operand. The decimal representation of these numbers are 186, 3, and 2. As it turns out, 2 is the remainder of dividing 170 by 4. This makes sense, because the mask cuts off everything above 3. So you can use the binary bit masks 1, 11, 111, 1111, and so on to produce the remainder of dividing by 2, 4, 8, 16, and so on.</p>
				<p>But how does this work for negative numbers? The <code>int</code> type is used to represent signed 32-bit integers. This means that they contain 32 bits, of which one is used to indicate the sign of the number. The sign bit is placed in front of the most significant bit. As the bitwise AND operator doesn't care about the meaning of individual bits, the sign will be masked out like any other bit, effectively making the remainder positive. However, this is not the only difference between positive and negative numbers, because they're stores using a two's complement representation. This means that when you drop the sign bit, -1 becomes 2<sup>31</sup> - 1, - 2 becomes 2<sup>31</sup> - 2, and so on. The result is that masked number sequences aren't mirrored around zero, they simply keep repeating.</p>
			</dd>
			<dt><a href="index.html#q-polynomial" id="a-polynomial">Why a 5<sup>th</sup> degree polynomial?</a></dt>
			<dd>
				<p>Typically, when desiring a smooth interpolation, people will use the 3<sup>rd</sup> degree polynomial <b>3<i>t</i><sup>2</sup> - 2<i>t</i><sup>3</sup></b>, which is known as <i>smoothstep</i>. This works fine, except when the noise is used for bump mapping. In that case you're effectively showing the derivative function, which for smoothstep is <b>6<i>t</i> - 6<i>t</i><sup>2</sup></b>. Because the derivative of that function &ndash; the second derivative of smoothstep &ndash; is <b>6 - 12<i>t</i></b>, its rate of change is not zero when <i>t</i> is zero or one. This causes visible discontinuities at lattice boundaries as the curvature suddenly changes direction.</p>
				<p>For his improved noise, Ken Perlin suggested to use <b>6<i>t</i><sup>5</sup> - 15<i>t</i><sup>4</sup> + 10<i>t</i><sup>3</sup></b> instead. The first derivative of this alternative function is <b>30<i>t</i><sup>4</sup> - 60<i>t</i><sup>3</sup> + 30<i>t</i><sup>2</sup></b> and the second derivative is <b>120<i>t</i><sup>3</sup> - 180<i>t</i><sup>2</sup> + 60<i>t</i></b>. Both are zero when <i>t</i> is zero or one.</p>
			</dd>
			<dt><a href="index.html#q-dot" id="a-dot">Why name it Dot?</a></dt>
			<dd>
				<p>We name it so because this function is known as the dot product, or sometimes scalar product. Simply put, the dot operation between two vectors <b>(a,b,c) &middot; (x,y,z)</b> yields <b>ax + by + cz</b>.</p>
				<p>The dot product shows up a lot when performing geometric calculations with vectors. For example, <b>(x,y) &middot; (x,y)</b> yields <b>x<sup>2</sup> + y<sup>2</sup></b>, which is the square length of the vector. Also, the dot product of two vectors of unit length yields the cosine of the absolute angle between them.</p>
			</dd>
			<dt><a href="index.html#q-sqrt-one-half" id="a-sqrt-one-half">Why is it &radic;&frac12;?</a></dt>
			<dd>
				<p>The Pythagorean theorem states that for a right triangle with edge lenghts a, b, and c, <b>a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></b>, where c is the length of the side opposite to the right angle. In case of our diagonal gradients, a and b are the same length while c is 1. Therefore <b>a<sup>2</sup> = b<sup>2</sup> = &frac12;</b>.</p>
			</dd>
		</dl>
		
		<footer></footer>
		<script src="../../jquery.js"></script>
		<script src="../../default.js"></script>
	</body>
</html>