<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/object-management/more-game-state/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/object-management/more-game-state/tutorial-image.jpg">
		<meta property="og:title" content="More Game State">
		<meta property="og:description" content="A Unity Object Management tutorial about saving and loading game and level state.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>More Game State</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/object-management/more-game-state/#article",
				"headline": "More Game State",
				"alternativeHeadline": "Saving All That Matters",
				"datePublished": "2018-09-21",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Object Management tutorial about saving and loading game and level state.",
				"image": "https://catlikecoding.com/unity/tutorials/object-management/more-game-state/tutorial-image.jpg",
				"dependencies": "Unity 2017.4.4f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/object-management/", "name": "Object Management" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				CompositeSpawnZone: 1,
				CubeSpawnZone: 1,
				Game: 1,
				GameDataReader: 1,
				GameDataWriter: 1,
				GameLevel: 1,
				PersistableObject: 1,
				PersistentStorage: 1,
				RotatingObject: 1,
				Shape: 1,
				ShapeFactory: 1,
				SpawnZone: 1,
				SphereSpawnZone: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Object Management</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>More Game State</h1>
					<p>Saving All That Matters</p>
					<ul>
						<li>Keep track of randomness.</li>
						<li>Save level data.</li>
						<li>Loop through spawn zones.</li>
						<li>Create a rotating level object.</li>
					</ul>
				</header>
				
				<p>This is the sixth tutorial in a series about <a href="../index.html">Object Management</a>. It covers saving more game state, in addition to the spawned shapes and level index.
				
				<p>This tutorial is made with Unity 2017.4.4f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>A reproducible trail of random shapes.</figcaption>
				</figure>
				
				<section>
					<h2>Saving Randomness</h2>
					
					<p>The point of using randomness when spawning shapes is to get unpredictable results. But this isn't always desirable. Suppose you save the game, then spawn a few more shapes. Then you load, and spawn the same amount of shapes again. Should you end up with the exact same shapes, or different ones? Currently, you'll get different ones. But the other option is equally valid, so let's support it.</p>
					
					<p>The numbers generated by Unity's <code>Random</code> methods aren't truly random. They're pseudorandom. It's a sequence of numbers generated by a mathematical formula. At the start of the game, this sequence gets initialized with an arbitrary seed value, based on the current time. If you start a new sequence with the same seed, you'll get the same numbers.</p>
					
					<section>
						<h3>Writing Random State</h3>
						
						<p>Storing the initial seed value is not enough, because that would bring us back to the start of the sequence, instead of the point in the sequence when the game got saved. But <code>Random</code> must keep track of where in the sequence it is. If we can get to this state, then we can later restore it, continuing the old sequence.</p>
						
						<p>The random state is defined as a <code>State</code> struct, nested inside the <code>Random</code> class. So we can declare a field or parameter of this type, <code>Random.State</code>. To save it, we have to add a method to <code>GameDataWriter</code> that can write such a value. Let's add this method now, but leave its implementation for later.</p>
						
						<pre translate="no">	<ins>public void Write (Random.State value) {}</ins></pre>
						
						<p>With this method, we can save the random state of the game. We'll do this at the start of <code>Game.Save</code>, right after writing the shape count. Again, increment the save version to signal a new format.</p>
						
						<pre translate="no">	const int saveVersion = <ins>3</ins>;

	&hellip;

	public override void Save (GameDataWriter writer) {
		writer.Write(shapes.Count);
		<ins>writer.Write(Random.state);</ins>
		writer.Write(loadedLevelBuildIndex);
		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Reading Random State</h3>
						
						<p>To read the random state, add a <code>ReadRandomState</code> method to <code>GameDataReader</code>. As we're not writing anything yet, skip reading anything for now. Instead, return the current random state, so nothing changes. The current state can be found via the static <code>Random.state</code> property.</p>
						
						<pre translate="no">	<ins>public Random.State ReadRandomState () {</ins>
		<ins>return Random.state;</ins>
	<ins>}</ins></pre>
						
						<p>Setting the random state is done via the same property, which we'll do in <code>Game.Load</code>, but only for save file versions 3 and higher.</p>
						
						<pre translate="no">	public override void Load (GameDataReader reader) {
		&hellip;
		int count = version &lt;= 0 ? -version : reader.ReadInt();

		<ins>if (version >= 3) {</ins>
			<ins>Random.state = reader.ReadRandomState();</ins>
		<ins>}</ins>

		StartCoroutine(LoadLevel(version &lt; 2 ? 1 : reader.ReadInt()));
		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>JSON Serialization</h3>
						
						<p><code>Random.State</code> contains four floating-point numbers. However, they aren't publicly accessible, so it is not possible for us to simply write them. We have to use an indirect approach instead.</p>
						
						<p>Fortunately, <code>Random.State</code> is a serializable type, so it is possible to convert it to a string representation of the same data, using the <code>ToJson</code> method of Unity's <code>JsonUtility</code> class. This gives us a JSON string. To see what that looks like, log it to the console.</p>
						
						<pre translate="no">	public void Write (Random.State value) {
		<ins>Debug.Log(JsonUtility.ToJson(value));</ins>
	}</pre>
						
						<aside>
							<h3>What does Json mean?</h3>
							<div>
								<p>The proper spelling is JSON, all capital letters. It stands for JavaScript Object Notation. It defines a simple human-readable data format.</p>
							</div>
						</aside>
						
						<p>After saving a game, the console will now log a string of four numbers named <em translate="no">s0</em> through <em translate="no">s3</em>, between curly brackets. Something like <em translate="no">{"s0":-1409360059,"s1":1814992068,"s2":-772955632,"s3":1503742856}</em>.</p>
						
						<p>We'll write this string to our file. If you were to open the saved file with a text editor, you'll be able to see this string near the beginning of the file.</p>
						
						<pre translate="no">	public void Write (Random.State value) {
		<ins>writer.Write</ins>(JsonUtility.ToJson(value));
	}</pre>
						
						<p>In <code>ReadRandomState</code>, read this string by invoking <code>ReadString</code> and then use <code>JsonUtility.FromJson</code> to convert it back to a proper random state.</p>
						
						<pre translate="no">	public Random.State ReadRandomState () {
		return <ins>JsonUtility.FromJson(reader.ReadString())</ins>;
	}</pre>
						
						<p>Besides the data, <code>FromJson</code> also needs to know the type of whatever it's supposed to create from the JSON data. We can use the generic version of the method, specifying that it should create a <code>Random.State</code> value.</p>
						
						<pre translate="no">	public Random.State ReadRandomState () {
		return JsonUtility.FromJson<ins>&lt;Random.State></ins>(reader.ReadString());
	}</pre>
					</section>
					
					<section>
						<h3>Decoupling Levels</h3>
						
						<p>Our game now saves and restores the random state. You can verify this by beginning a game, saving, creating a few shapes, then loading, and creating the exact same shapes again. But you can go a step further. You could even begin a new game after loading, and still create the same shapes after that. So we can influence the randomness of a new game by loading a game right before it. This is not desirable. Ideally, the randomness of distinct games is separate, as if we restarted the whole game. We can achieve this by seeding a new random sequence each time we begin a new game.</p>
						
						<p>To pick a new seed value, we have to use randomness. We can use <code>Random.value</code> for that, but have to make sure that these values come from their own random sequence. To do this, add a main random state field to <code>Game</code>. At the start of the game, set it to the random state that was initialized by Unity.</p>
						
						<pre translate="no">	<ins>Random.State mainRandomState;</ins>

	&hellip;

	void Start () {
		<ins>mainRandomState = Random.state;</ins>
		&hellip;
	}</pre>
						
						<p>When the player begins a new game, the first step is now to restore the main random state. Then grab a random value and use that as the seed to initialize a new pseudorandom sequence, via the <code>Random.InitState</code> method.</p>
						
						<pre translate="no">	void BeginNewGame () {
		<ins>Random.state = mainRandomState;</ins>
		<ins>int seed = Random.Range(0, int.MaxValue);</ins>
		<ins>Random.InitState(seed);</ins>

		&hellip;
	}</pre>
						
						<p>To make the seeds a little more unpredictable, we'll mix them with the current play time, accessible via <code>Time.unscaledTime</code>. The bitwise exclusive-OR operator <code>^</code> is good for this.</p>
						
						<pre translate="no">		int seed = Random.Range(0, int.MaxValue) <ins>^ (int)Time.unscaledTime</ins>;</pre>
						
						<aside>
							<h3>What does exclusive-OR do?</h3>
							<div>
								<p>For each bit, the result is 1 if exactly one of the two inputs is 1 and the other is 0. Otherwise, the result is 0. In other words, whether the inputs are different. Because it is a bit manipulation, the result isn't mathematically obvious, like addition would be.</p>
							</div>
						</aside>
						
						<p>To keep track of the progression of the main random sequence, store its state after grabbing the next value, before initializing the state for the new game.</p>
						
						<pre translate="no">		Random.state = mainRandomState;
		int seed = Random.Range(0, int.MaxValue);
		<ins>mainRandomState = Random.state;</ins>
		Random.InitState(seed);</pre>
						
						<p>Now loading games and what you do in each game no longer affects the randomness of other games played during the same session. But to make sure this works correctly we also have to invoke <code>BeginNewGame</code> for the first game of each session.</p>
						
						<pre translate="no">	void Start () {
		&hellip;

		<ins>BeginNewGame();</ins>
		StartCoroutine(LoadLevel(1));
	}</pre>
					</section>
					
					<section>
						<h3>Supporting Both Approaches</h3>
						
						<p>You might not want reproducible randomness, instead preferring to get new results after loading. So let's support both approaches, by adding a <code>reseedOnLoad</code> toggle to <code>Game</code>.</p>
						
						<pre translate="no">	<ins>[SerializeField] bool reseedOnLoad;</ins></pre>
						
						<figure>
							<img src="saving-randomness/reseed-on-load.png" width="320" height="37">
							<figcaption>Option to reseed on load.</figcaption>
						</figure>
						
						<p>All we have to change is whether the random state is set when a game is loaded. We can keep saving&mdash;and loading&mdash;it, so the save files always support both options.</p>
						
						<pre translate="no">	public override void Load (GameDataReader reader) {
		&hellip;

		if (version >= 3) {
			<del>//Random.state = reader.ReadRandomState();</del>
			<ins>Random.State state = reader.ReadRandomState();</ins>
			<ins>if (!reseedOnLoad) {</ins>
				<ins>Random.state = state;</ins>
			<ins>}</ins>
		}

		&hellip;
	}</pre>
					</section>
				</section>

				<section>
					<h2>Persisting Level Data</h2>
					
					<p>We can save shapes that have been spawned during a game, we can save which level we're playing, and we can save the random state. We could use the same approach to save comparable data, like how many shapes were spawned and destroyed, or other things that could be created while playing. But what if we would like to save the state of something that is part of the level? Something we put in the level scene, but changes during play? To support that, we would have to save the state of the level too.</p>

					<section>
						<h3>Current Level Instead of Game Singleton</h3>
						
						<p>To save the level, <code>Game</code> must include it when saving itself. This means that it must somehow get a reference to the current level. We could add a property to <code>Game</code> and have the loaded level assign itself to that, but then we're putting knowledge of two level-related things directly inside <code>Game</code>: the level itself and its spawn zone. This can be a valid approach, but let's turn it around. Instead of relying on a <code>Game</code> singleton, make the current level globally accessible.</p>
						
						<p>Add a static <code>Current</code> property to <code>GameLevel</code>. Everyone can get the current level, but only the level itself can set it, which it does when it becomes enabled.</p>

						<pre translate="no">	<ins>public static GameLevel Current { get; private set; }</ins>

	&hellip;

	<ins>void OnEnable () {</ins>
		<ins>Current = this;</ins>
	<ins>}</ins></pre>
						
						<p>Now instead of setting the game's spawn point, the level can expose its spawn point for the game to use. In fact, we can go a step further and have <code>GameLevel</code> directly offer a <code>SpawnPoint</code> property, forwarding the request to its spawn zone. Thus, the level acts as a facade for its spawn zone.</p>
						
						<pre translate="no">	<ins>public Vector3 SpawnPoint {</ins>
		<ins>get {</ins>
			<ins>return spawnZone.SpawnPoint;</ins>
		<ins>}</ins>
	<ins>}</ins>

	&hellip;

	<del>//void Start () {</del>
	<del>//	Game.Instance.SpawnZoneOfLevel = spawnZone;</del>
	<del>//}</del></pre>
						
						<p>This means that <code>Game</code> no longer needs to know about spawn zones. It just asks the current level for a point.</p>
						
						<pre translate="no">	<del>//public SpawnZone SpawnZoneOfLevel { get; set; }</del>
	
	&hellip;
	
	void CreateShape () {
		&hellip;
		t.localPosition = <ins>GameLevel.Current</ins>.SpawnPoint;
		&hellip;
	}</pre>
						
						<figure>
							<img src="persisting-level-data/current-level-diagram.png" width="325" height="163">
							<figcaption>Game only knows about the current level.</figcaption>
						</figure>
						
						<p>At this point, <code>GameLevel</code> doesn't need to reference <code>Game</code> anymore. As the static instance isn't used anywhere else, let's remove it.</p>

						<pre translate="no">	<del>//public static Game Instance { get; private set; }</del>

	&hellip;

	<del>//void OnEnable () {</del>
	<del>//	Instance = this;</del>
	<del>//}</del>

	void Start () {
		mainRandomState = Random.state;
		<del>//Instance = this;</del>
		&hellip;
	}</pre>
						
						<aside>
							<h3>Can't we keep <code>Game.Instance</code>, even if it isn't used?</h3>
							<div>
								<p>You can, but leaving unused code&mdash;known as dead code&mdash;in a project makes it harder to maintain. It's such simple code that if we need it in the future, we'll just add it again.</p>
							</div>
						</aside>
					</section>

					<section>
						<h3>Persistable Game Level</h3>
						
						<p>To make it possible to save the level, make it a <code>PersistableObject</code>. The transformation data of the level object itself is of no use, so overwrite the <code>Save</code> and <code>Load</code> methods so they do nothing, for now.</p>

						<pre translate="no">public class GameLevel : <ins>PersistableObject</ins> {

	&hellip;

	<ins>public override void Save (GameDataWriter writer) {}</ins>

	<ins>public override void Load (GameDataReader reader) {}</ins>
}</pre>
						
						<p>In <code>Game.Save</code>, it makes sense to write the level data before everything that was created while playing. Let's put it directly after the level build index.</p>

						<pre translate="no">	public override void Save (GameDataWriter writer) {
		writer.Write(shapes.Count);
		writer.Write(Random.state);
		writer.Write(loadedLevelBuildIndex);
		<ins>GameLevel.Current.Save(writer);</ins>
		for (int i = 0; i &lt; shapes.Count; i++) {
			&hellip;
		}
	}</pre>
					</section>

					<section>
						<h3>Loading Level Data</h3>
						
						<p>When loading, we must now read the level data after reading the level build index. However, we can only do so after the level scene has been loaded, otherwise we would be applying it to the level scene that is about to be unloaded. Thus, we must postpone reading the rest of the save file until after the <code>LoadLevel</code> coroutine has finished. To make this possible, let's turn the entire loading process into a coroutine.</p>
						
						<p>After verifying that the save version is supported, start a new <code>LoadGame</code> coroutine and then end <code>Game.Load</code>. The code that used to come after this point becomes the new <code>LoadGame</code> coroutine method, which requires the reader as a parameter.</p>
						
						<pre translate="no">	public override void Load (GameDataReader reader) {
		int version = reader.Version;
		if (version > saveVersion) {
			Debug.LogError("Unsupported future save version " + version);
			return;
		}
		<ins>StartCoroutine(LoadGame(reader));</ins>
	<ins>}</ins>

	<ins>IEnumerator LoadGame (GameDataReader reader) {</ins>
		<ins>int version = reader.Version;</ins>
		int count = version &lt;= 0 ? -version : reader.ReadInt();

		if (version >= 3) {
			Random.State state = reader.ReadRandomState();
			if (!reseedOnLoad) {
				Random.state = state;
			}
		}

		StartCoroutine(LoadLevel(version &lt; 2 ? 1 : reader.ReadInt()));

		for (int i = 0; i &lt; count; i++) {
			int shapeId = version > 0 ? reader.ReadInt() : 0;
			int materialId = version > 0 ? reader.ReadInt() : 0;
			Shape instance = shapeFactory.Get(shapeId, materialId);
			instance.Load(reader);
			shapes.Add(instance);
		}
	}</pre>
						
						<p>In <code>LoadGame</code>, yield on <code>LoadLevel</code> instead of invoking <code>StartCoroutine</code>. After that we can invoke <code>GameLevel.Current.Load</code>, assuming we have a file version 3 or higher.</p>
						
						<pre translate="no">		<del>//StartCoroutine(LoadLevel(version &lt; 2 ? 1 : reader.ReadInt()));</del>
		<ins>yield return LoadLevel(version &lt; 2 ? 1 : reader.ReadInt());</ins>
		<ins>if (version >= 3) {</ins>
			<ins>GameLevel.Current.Load(reader);</ins>
		<ins>}</ins></pre>
						
						<p>Unfortunately, we get an error at this point when trying to load a game.</p>
					</section>
					
					<section>
						<h3>Buffering the Data</h3>
						
						<p>The error that we get tells us that we're trying to read from a closed <code>BinaryReader</code> instance. It got closed because of the <code>using</code> block inside <code>PersistentStorage.Load</code>. It guarantees that the hold that we got on the file gets released as soon as that method invocation finishes. We're now trying to read the level data later&mdash;via the coroutine&mdash;so it fails.</p>

						<p>There are two ways to solve this problem. The first is to do away with the <code>using</code> block, instead releasing the hold on the save file manually later, by closing the reader explicitly. That would require us to carefully track whether we're holding on to a reader and make sure to close it, even if we encounter an error along the way. The second approach is to read the entire file in one go, buffering it, and then reading from the buffer later. That means that we don't have to worry about releasing the file, but have to store its entire contents in memory for a while. As our save files are small, we'll use the buffer.</p>
						
						<p>Reading the entire file can be done by invoking <code>File.ReadAllBytes</code>, which gives us a byte array. This will be our new approach in <code>PersistentStorage.Load</code>.</p>

						<pre translate="no">	public void Load (PersistableObject o) {
		<del>//using (</del>
		<del>//	var reader = new BinaryReader(File.Open(savePath, FileMode.Open))</del>
		<del>//) {</del>
		<del>//	o.Load(new GameDataReader(reader, -reader.ReadInt32()));</del>
		<del>//}</del>
		
		<ins>byte[] data = File.ReadAllBytes(savePath);</ins>
	}</pre>
						
						<p>We still have to use a <code>BinaryReader</code>, which requires a stream, not an array. We can create a <code>MemoryStream</code> instance that wraps the array, and give that to the reader. Then load with a <code>GameDataReader</code>, as before.</p>
							
						<pre translate="no">	public void Load (PersistableObject o) {
		byte[] data = File.ReadAllBytes(savePath);
		<ins>var reader = new BinaryReader(new MemoryStream(data));</ins>
		<ins>o.Load(new GameDataReader(reader, -reader.ReadInt32()));</ins>
	}</pre>
					</section>
				</section>
				
				<section>
					<h2>Level State</h2>
					
					<p>We've made it possible to save level data, but at this point we don't have anything to store yet. So let's come up with something to save.</p>
					
					<section>
						<h3>Sequential Composite Spawn Zone</h3>
						
						<p>The most complex level structure that we have so far is the composite spawn zone. It has an array of spawn zones, of which one element is used each time a new spawn point is needed. When looking at this in action, you cannot predict which zone is used next. The placement of shapes is arbitrary and need not be uniform, although it will average out across all zones in the long run.</p>
						
						<figure>
							<div class="vid" style="width: 300px; height:200px;"><iframe src='https://gfycat.com/ifr/GreenScornfulGangesdolphin?controls=0'></iframe></div>
							<figcaption>Random spawning.</figcaption>
						</figure>
						
						<p>We can change this by looping through the spawn zones in sequence. Both approaches are valid, so we'll support both. Add a toggle option to <code>CompositeSpawnZone</code> to make it sequential.</p>
						
						<pre translate="no">	<ins>[SerializeField]</ins>
	<ins>bool sequential;</ins></pre>
						
						<figure>
							<img src="level-state/sequential.png" width="320" height="74">
							<figcaption>Sequential composite spawn zone.</figcaption>
						</figure>
						
						<p>Sequential spawning requires us to keep track of which zone index has to be used next. So add a <code>nextSequentialIndex</code> field and use that for the index in <code>SpawnPoint</code>, if we're in sequential mode. Increment the field afterwards.</p>
						
						<pre translate="no">	<ins>int nextSequentialIndex;</ins>

	public override Vector3 SpawnPoint {
		get {
			int index<ins>;</ins>
			<ins>if (sequential) {</ins>
				<ins>index = nextSequentialIndex++;</ins>
			<ins>}</ins>
			<ins>else {</ins>
				<ins>index =</ins> Random.Range(0, spawnZones.Length)<ins>;</ins>
			<ins>}</ins>
			return spawnZones[index].SpawnPoint;
		}
	}</pre>
						
						<p>To make it loop, jump back to the first index when we move past the end of the array.</p>
						
						<pre translate="no">			if (sequential) {
				index = nextSequentialIndex++;
				<ins>if (nextSequentialIndex >= spawnZones.Length) {</ins>
					<ins>nextSequentialIndex = 0;</ins>
				<ins>}</ins>
			}</pre>
						
						<p>A sequential spawn zone behaves noticeably different than a random one. Its spawn pattern is clear and the shapes are evenly distributed among the zones, although their placement inside each zone is still random.</p>
						
						<figure>
							<div class="vid" style="width: 300px; height:200px;"><iframe src='https://gfycat.com/ifr/NeighboringSimpleDrake?controls=0'></iframe></div>
							<figcaption>Sequential spawning.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Remembering the Next Index</h3>
						
						<p>When saving a game, the state of the sequential composite spawn zone must now be saved, otherwise the sequence will reset after a load. So it must become a persistable object. It already extends <code>SpawnZone</code>, so we must make <code>SpawnZone</code> extend <code>PersistableObject</code>. That makes it possible for all spawn zone types to persist their state.</p>
						
						<pre translate="no">public abstract class SpawnZone : <ins>PersistableObject</ins> {

	public abstract Vector3 SpawnPoint { get; }
}</pre>
						
						<p>Overwrite the <code>Save</code> and <code>Load</code> methods in <code>CompositeSpawnZone</code>, simply writing and reading <code>nextSequentialIndex</code>. We'll do this regardless whether the zone is sequential or not. We could also invoke the base methods, to also save the zone's transform data, but let's focus on the sequence only. The zone doesn't move on its own.</p>
						
						<pre translate="no">	<ins>public override void Save (GameDataWriter writer) {</ins>
		<ins>writer.Write(nextSequentialIndex);</ins>
	<ins>}</ins>

	<ins>public override void Load (GameDataReader reader) {</ins>
		<ins>nextSequentialIndex = reader.ReadInt();</ins>
	<ins>}</ins></pre>
					</section>
					
					
					<section>
						<h3>Tracking Persistable Objects</h3>
						
						<p>The spawn zones are now persistable, but they aren't getting saved yet. <code>GameLevel</code> has to invoke their <code>Save</code> and <code>Load</code> methods. We could simply use the <code>spawnZone</code> field, but that only allows a single spawn zone to be saved. What if we want to put multiple sequential spawn zones in a level, all part of a hierarchy of composite zones?</p>
						
						<p>We could make the composite zone responsible for also saving and loading all zones it contains, but what if we add other things to the level that should also be saved? To make it as flexible as possible, let's add a way to configure which objects are supposed to be persisted when a level is saved. The simplest approach is to add an array of persistent objects to <code>GameLevel</code> that we can fill when designing the level scene.</p>

						<pre translate="no">	<ins>[SerializeField]</ins>
	<ins>PersistableObject[] persistentObjects;</ins></pre>
						
						<p>Now <code>GameLevel</code> can save how many such objects there are, then save each of them, just like <code>Game</code> does for its shape list.</p>
						
						<pre translate="no">	public override void Save (GameDataWriter writer) {
		<ins>writer.Write(persistentObjects.Length);</ins>
		<ins>for (int i = 0; i &lt; persistentObjects.Length; i++) {</ins>
			<ins>persistentObjects[i].Save(writer);</ins>
		<ins>}</ins>
	}</pre>
						
						<p>And the same goes for loading, but because the level object is part of the scene, nothing needs to be instantiated.</p>

						<pre translate="no">	public override void Load (GameDataReader reader) {
		<ins>int savedCount = reader.ReadInt();</ins>
		<ins>for (int i = 0; i &lt; savedCount; i++) {</ins>
			<ins>persistentObjects[i].Load(reader);</ins>
		<ins>}</ins>
	}</pre>
						
						<p>Note that from now on you must ensure that what you put into this array stays in it, at the same index, otherwise you break backwards compatibility with older save files. However, you can add more to it in the future. Those new objects will be skipped when loading old files, remaining how they were saved in the scene.</p>
						
						<p>Another important point is that the <code>GameLevel</code> instances in all our scenes haven't automatically gained the new array. You have to open and save all level scenes, otherwise you can end up with a null-reference exception when loading a level. Alternatively, we can check whether an array exists when a level object is enabled in play. If not, create one. That's a more convenient approach if you have many levels and the only option if third parties have created levels for your game that you still wish to support.</p>

						<pre translate="no">	void OnEnable () {
		Current = this;
		<ins>if (persistentObjects == null) {</ins>
			<ins>persistentObjects = new PersistableObject[0];</ins>
		<ins>}</ins>
	}</pre>
						
						<p>Now we can finally save the sequential composite spawn zone, by explicitly adding it to the persistent objects of the level.</p>
						
						<figure>
							<img src="level-state/level-3-persistent-object.png" width="320" height="110">
							<figcaption>Level 3 with persistent spawn zone.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Reloading for a New Game</h3>
						
						<p>The sequence index now gets restored when loading a level, but it currently doesn't get reset when the player begins a new game in the same level. The solution is to also load the level in this case, resetting the entire level state.</p>
						
						<pre translate="no">		else if (Input.GetKeyDown(newGameKey)) {
			BeginNewGame();
			<ins>StartCoroutine(LoadLevel(loadedLevelBuildIndex));</ins>
		}</pre>
					</section>
					
					<section>
						<h3>Rotating Objects</h3>
						
						<p>Let's add another kind of level object that also has to store state. A simple rotating object. It's a persistable object that has a configurable angular velocity. Use a 3D vector, so the velocity can be in any direction. To make it rotate, give it an <code>Update</code> method that invokes the <code>Rotate</code> method of its transformation, with the velocity scaled by the time delta as its argument.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public class RotatingObject : PersistableObject {</ins>

	<ins>[SerializeField]</ins>
	<ins>Vector3 angularVelocity;</ins>

	<ins>void Update () {</ins>
		<ins>transform.Rotate(angularVelocity * Time.deltaTime);</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>To demonstrate the rotating object, I have created a fourth scene. In it, there is a root object that rotates around the Y axis with a velocity of 90. Its only child is another rotating object with a velocity of 15 around the X axis. One level deeper sits a sequential composite spawn zone, with two sphere spawn zone children. Both spheres have a radius of 1 and are positioned ten units from the origin in both directions along the Z axis.</p>
						
						<figure>
							<img src="level-state/rotating-hierarchy.png" width="227" height="130">
							<figcaption>Rotating spawn zone hierarchy.</figcaption>
						</figure>
						
						<p>To persist the level state, both rotating objects and the composite spawn zone must be put in the persistent object array. Their order doesn't matter, but should not be changed later.</p>
						
						<figure>
							<img src="level-state/level-4.png" width="320" height="146">
							<figcaption>Persistent objects of level 4.</figcaption>
						</figure>
						
						<p>This configuration creates two small spawn zones on opposite sides of a larger sphere, spinning around it, and going up and down.</p>
						
						<figure>
							<div class="vid" style="width: 250px; height:240px;"><iframe src='https://gfycat.com/ifr/PleasantPowerfulArachnid?controls=0'></iframe></div>
							<figcaption>Rotating Spawn Zones.</figcaption>
						</figure>
						
						<p>It is easiest to see it in action by using an automatic creation speed, instead of spawning shapes manually. You can then also test saving and loading, to verify that the level state is indeed persisted and restored. However, sometimes we can end up with different spawn results. We'll deal with that in the next section.</p>
					</section>
				</section>
				
				<section>
					<h2>Creation and Destruction</h2>
					
					<p>The automatic creation and destruction process is also part of the game state. We're currently not saving that, so the creation and destruction progress is unaffected by saving and loading. This means that when the creation speed is larger than zero, you likely won't get the exact same shape placement after loading a game. The same goes for the timing of shape destruction. We should make sure that the timing remains exactly the same.</p>
					
					<section>
						<h3>Saving and Loading</h3>
						
						<p>Saving the progress is simply a matter of writing both values in <code>Game.Save</code>. Let's do so after writing the random state.</p>
						
						<pre translate="no">	public override void Save (GameDataWriter writer) {
		writer.Write(shapes.Count);
		writer.Write(Random.state);
		<ins>writer.Write(creationProgress);</ins>
		<ins>writer.Write(destructionProgress);</ins>
		writer.Write(loadedLevelBuildIndex);
		GameLevel.Current.Save(writer);
		&hellip;
	}</pre>
						
						<p>When loading, read them back at the appropriate moment.</p>
						
						<pre translate="no">	IEnumerator LoadGame (GameDataReader reader) {
		int version = reader.Version;
		int count = version &lt;= 0 ? -version : reader.ReadInt();

		if (version >= 3) {
			Random.State state = reader.ReadRandomState();
			if (!reseedOnLoad) {
				Random.state = state;
			}
			<ins>creationProgress = reader.ReadFloat();</ins>
			<ins>destructionProgress = reader.ReadFloat();</ins>
		}

		yield return LoadLevel(version &lt; 2 ? 1 : reader.ReadInt());
		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Exact Timing</h3>
						
						<p>We still don't get the exact same timing. That's because our game's frame rate is not perfectly stable. The time delta of each frame is variable. If a frame takes longer than before, it might be enough for a shape to be spawned a frame earlier than the previous time. Or it might appear a frame later. Combined with a moving spawn zone based on the same time delta, the shape can end up somewhere else.</p>
						
						<p>We can make the timing exact by use a fixed time delta to update the creation and destruction progress. This is done by moving the relevant code from the <code>Update</code> method to a new <code>FixedUpdate</code> method.</p>
						
						<pre translate="no">	void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateShape();
		}
		&hellip;
		else {
			&hellip;
		}
	<ins>}</ins>

	<ins>void FixedUpdate () {</ins>
		creationProgress += Time.deltaTime * CreationSpeed;
		while (creationProgress >= 1f) {
			creationProgress -= 1f;
			CreateShape();
		}

		destructionProgress += Time.deltaTime * DestructionSpeed;
		while (destructionProgress >= 1f) {
			destructionProgress -= 1f;
			DestroyShape();
		}
	}</pre>
						
						<p>Now the automatic creation and destruction of shapes is no longer affected by the variable frame rate. But the rotator still is. To make it perfect, we should use <code>FixedUpdate</code> for the rotation in <code>RotatingObject</code> as well.</p>
						
						<pre translate="no">	void <ins>FixedUpdate</ins> () {
		transform.Rotate(angularVelocity * Time.deltaTime);
	}</pre>
						
						<aside>
							<h3>When does <code>FixedUpdate</code> get invoked?</h3>
							<div>
								<p>It gets invoked each frame, after <code>Update</code>. How many times it gets invoked depends on the frame time and the fixed time step, which you can configure via <em translate="no">Edit / Project Settings / Time</em>.</p>
								
								<p>The default fixed time step is 0.02, which is 50 times per second. So if your game runs at exactly 10 frames per second, <code>FixedUpdate</code> would get invoked five times each frame. And if your game runs at more than 50 frames per second, then sometimes <code>FixedUpdate</code> won't be invoked at all during a frame. You can use a different time step, if you need more or less time granularity.</p>
								
								<p>You use <code>FixedUpdate</code> when working with the physics engine, or when you want reliable reproducible timing, which is the case in this tutorial.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Speed Settings</h3>
						
						<p>Besides the progress, we can also consider the speed settings part of the game state. All we have to do is write the speed properties too, when saving.</p>
						
						<pre translate="no">	public override void Save (GameDataWriter writer) {
		writer.Write(shapes.Count);
		writer.Write(Random.state);
		<ins>writer.Write(CreationSpeed);</ins>
		writer.Write(creationProgress);
		<ins>writer.Write(DestructionSpeed);</ins>
		writer.Write(destructionProgress);
		writer.Write(loadedLevelBuildIndex);
		GameLevel.Current.Save(writer);
		for (int i = 0; i &lt; shapes.Count; i++) {
			writer.Write(shapes[i].ShapeId);
			writer.Write(shapes[i].MaterialId);
			shapes[i].Save(writer);
		}
	}</pre>
						
						<p>And read them when loading.</p>
						
						<pre translate="no">		if (version >= 3) {
			Random.State state = reader.ReadRandomState();
			if (!reseedOnLoad) {
				Random.state = state;
			}
			<ins>CreationSpeed = reader.ReadFloat();</ins>
			creationProgress = reader.ReadFloat();
			<ins>DestructionSpeed = reader.ReadFloat();</ins>
			destructionProgress = reader.ReadFloat();
		}</pre>
						
						<p>It also makes sense to reset the speeds when beginning a new game.</p>
						
						<pre translate="no">	void BeginNewGame () {
		&hellip;
		Random.InitState(seed);

		<ins>CreationSpeed = 0;</ins>
		<ins>DestructionSpeed = 0;</ins>

		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Updating the Labels</h3>
						
						<p>The speed settings are now saved, and get restored when we load a game. But the UI isn't aware of this, so won't change if we happen to load a different speed. We have to manually refresh the sliders after loading. To make this possible, <code>Game</code> needs to reference the sliders, so add two configuration fields for them.</p>
						
						<pre translate="no">&hellip;
<ins>using UnityEngine.UI;</ins>

[DisallowMultipleComponent]
public class Game : PersistableObject {

	&hellip;

	<ins>[SerializeField] Slider creationSpeedSlider;</ins>
	<ins>[SerializeField] Slider destructionSpeedSlider;</ins>
	
	&hellip;
}</pre>
						
						<figure>
							<img src="creation-and-destruction/slider-references.png" width="320" height="54">
							<figcaption>References to the sliders.</figcaption>
						</figure>
						
						<aside>
							<h3>Isn't there a way to bind the UI to the properties?</h3>
							<div>
								<p>There is no built-in way to do this. We could come up with a custom solution, but that's out of the scope of this tutorial. For our simple case, slider references suffice.</p>
							</div>
						</aside>
						
						<p>When resetting the speeds, we can now also update the sliders, by assigning to their <code>value</code> properties as well.</p>
						
						<pre translate="no">		CreationSpeed = 0;
		<ins>creationSpeedSlider.value = 0;</ins>
		DestructionSpeed = 0;
		<ins>destructionSpeedSlider.value = 0;</ins></pre>
						
						<p>This code can be made more concise by chaining the assignments.</p>
						
						<pre translate="no">		<del>//CreationSpeed = 0;</del>
		<ins>creationSpeedSlider.value =</ins> CreationSpeed = 0;
		<del>//DestructionSpeed = 0;</del>
		<ins>destructionSpeedSlider.value =</ins> DestructionSpeed = 0;</pre>
						
						<p>Do the same in the <code>Load</code> method.</p>
						
						<pre translate="no">			<ins>creationSpeedSlider.value =</ins> CreationSpeed = reader.ReadFloat();
			creationProgress = reader.ReadFloat();
			<ins>destructionSpeedSlider.value =</ins> DestructionSpeed = reader.ReadFloat();
			destructionProgress = reader.ReadFloat();</pre>
						
						<p>The UI now also updates after loading or beginning a new game.</p>
						
						<p>The next tutorial is <a href="../configuring-shapes/index.html">Configuring Shapes</a>.</p>
					</section>
					
					<a href="https://bitbucket.org/catlikecodingunitytutorials/object-management-06-more-game-state" class="repository">repository</a>
					<a href="More-Game-State.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>