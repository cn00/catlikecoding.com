<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/object-management/satellites/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/object-management/satellites/tutorial-image.jpg">
		<meta property="og:title" content="Satellites">
		<meta property="og:description" content="A Unity Object Management tutorial about creating behavior for satellite shapes.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Satellites</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/object-management/satellites/#article",
				"headline": "Satellites",
				"alternativeHeadline": "Shape Relationships",
				"datePublished": "2019-01-22",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Object Management tutorial about creating behavior for satellite shapes.",
				"image": "https://catlikecoding.com/unity/tutorials/object-management/satellites/tutorial-image.jpg",
				"dependencies": "Unity 2017.4.12f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/object-management/", "name": "Object Management" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				ColorRangeHSV: 1,
				CompositeSpawnZone: 1,
				CubeSpawnZone: 1,
				FloatRange: 1,
				FloatOrIntRangeDrawer: 1,
				FloatRangeDrawer: 1,
				FloatRangeSlider: 1,
				FloatRangeSliderAttribute: 1,
				FloatRangeSliderDrawer: 1,
				Game: 1,
				GameDataReader: 1,
				GameDataWriter: 1,
				GameLevel: 1,
				IntRange: 1,
				MovementDirection: 1,
				MovementShapeBehavior: 1,
				OscillationShapeBehavior: 1,
				PersistableObject: 1,
				PersistentStorage: 1,
				RotatingObject: 1,
				RotationShapeBehavior: 1,
				SatelliteConfiguration: 1,
				SatelliteShapeBehavior: 1,
				Shape: 1,
				ShapeBehavior: 1,
				ShapeBehaviorPool: 1,
				ShapeBehaviorType: 1,
				ShapeBehaviorTypeMethods: 1,
				ShapeFactory: 1,
				ShapeInstance: 1,
				SpawnConfiguration: 1,
				SpawnMovementDirection: 1,
				SpawnZone: 1,
				SphereSpawnZone: 1,
				T: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Object Management</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Satellites</h1>
					<p>Shape Relationships</p>
					<ul>
						<li>Spawn multiple shapes at once.</li>
						<li>Make a shape orbit another shape.</li>
						<li>Keep track of references to specific shape instances.</li>
						<li>Enforce a shape population limit.</li>
					</ul>
				</header>
				
				<p>This is the tenth tutorial in a series about <a href="../index.html">Object Management</a>. It adds a satellite behavior, which introduces relationships between shapes.</p>
				
				<p>This tutorial is made with Unity 2017.4.12f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>The big shapes are popular; they have orbiters.</figcaption>
				</figure>
				
				<section>
					<h2>Spawning Multiple Shapes</h2>
					
					<p>In this tutorial we're going to create a behavior that lets a shape orbit another shape, like a satellite. We'll decide whether a shape has a satellite when it is spawned. If so, then we'll also spawn its satellite. This means that each time that we spawn a shape we might end up with two new shapes instead of always one.</p>
					
					<section>
						<h3>Spawning a Satellite Per Shape</h3>
						
						<p>To spawn a satellite we'll add a <code>CreateSatelliteFor</code> method to <code>SpawnZone</code>, with a parameter for the focal shape. The focal shape is what the satellite will orbit. We could use separate factories for the satellites, but we'll simply use the same factories for the regular shape to spawn a random one and give it an arbitrary rotation.</p>
						
						<pre translate="no">	<ins>void CreateSatelliteFor (Shape focalShape) {</ins>
		<ins>int factoryIndex = Random.Range(0, spawnConfig.factories.Length);</ins>
		<ins>Shape shape = spawnConfig.factories[factoryIndex].GetRandom();</ins>
		<ins>Transform t = shape.transform;</ins>
		<ins>t.localRotation = Random.rotation;</ins>
	<ins>}</ins></pre>
						
						<p>We won't create a real satellite just yet. For now, we make the satellite half the size of the focus shape, position it one unit above it, and make it move upwards.</p>
						
						<pre translate="no">		t.localRotation = Random.rotation;
		<ins>t.localScale = focalShape.transform.localScale * 0.5f;</ins>
		<ins>t.localPosition = focalShape.transform.localPosition + Vector3.up;</ins>
		<ins>shape.AddBehavior&lt;MovementShapeBehavior>().Velocity = Vector3.up;</ins></pre>
						
						<p>We'll also have to give the satellite a color, the same way we give the focus shape a color. Put the relevant code in a <code>SetupColor</code> method so we can reuse it.</p>
						
						<pre translate="no">	public virtual Shape SpawnShape () {
		&hellip;
		<del>//if (spawnConfig.uniformColor) {</del>
		<del>//	shape.SetColor(spawnConfig.color.RandomInRange);</del>
		<del>//}</del>
		<del>//else {</del>
		<del>//	&hellip;</del>
		<del>//}</del>
		<ins>SetupColor(shape);</ins>

		&hellip;
	}

	void CreateSatelliteFor (Shape focalShape) {
		&hellip;
		<ins>SetupColor(shape);</ins>
	}

	<ins>void SetupColor (Shape shape) {</ins>
		<ins>if (spawnConfig.uniformColor) {</ins>
			<ins>shape.SetColor(spawnConfig.color.RandomInRange);</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>for (int i = 0; i &lt; shape.ColorCount; i++) {</ins>
				<ins>shape.SetColor(spawnConfig.color.RandomInRange, i);</ins>
			<ins>}</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Give each new shape a satellite companion by invoking <code>CreateSatteliteFor</code> at the end of <code>SpawnShape</code>, so we spawn shapes in pairs.</p>
						
						<pre translate="no">	public virtual Shape SpawnShape () {
		&hellip;

		<ins>CreateSatelliteFor(shape);</ins>
		return shape;
	}</pre>
					</section>
					
					<section>
						<h3>Adding Shapes to the Game</h3>
						
						<p>The idea of <code>SpawnShape</code> was that it brings a new shape into the game, which is returned so that <code>Game</code> can add it to its list of shapes. That still happens for the regular shape, but the satellite shape isn't added to the list, which means that it doesn't get updated and remains frozen.</p>
						
						<p>We could have <code>SpawnShape</code> return a list of shapes, but the goal is to get the shapes added to the shape list when they are spawned, no matter when or where that happens. We can do that by turning the responsibility around, and once again make <code>Game</code> available via a static <code>Instance</code> property. Then it's up to whoever spawns a shape to pass it to <code>Game</code>.</p>
						
						<pre translate="no">	<ins>public static Game Instance { get; private set; }</ins>

	&hellip;

	void OnEnable () {
		<ins>Instance = this;</ins>
		&hellip;
	}</pre>
						
						<p>In order to receive new shapes, give <code>Game</code> a public <code>AddShape</code> method that simply adds a shape to its list.</p>
						
						<pre translate="no">	<ins>public void AddShape (Shape shape) {</ins>
		<ins>shapes.Add(shape);</ins>
	<ins>}</ins></pre>
						
						<p>We'll make <code>ShapeFactory.Get</code> responsible for adding each shape to <code>Game</code>. This makes <code>ShapeFactory</code> aware of <code>Game</code>, but also makes it so that we never need to worry about whether a shape has been added to <code>Game</code> yet, assuming that all shapes are retrieved via a factory.</p>
						
						<pre translate="no">	public Shape Get (int shapeId = 0, int materialId = 0) {
		&hellip;
		<ins>Game.Instance.AddShape(instance);</ins>
		return instance;
	}</pre>
						
						<p>This is also true in <code>Game.LoadGame</code>, so we must no longer explicitly add loaded shapes to the list. To do so would result in duplicate entries.</p>
						
						<pre translate="no">	IEnumerator LoadGame (GameDataReader reader) {
		&hellip;
		
		for (int i = 0; i &lt; count; i++) {
			int factoryId = version >= 5 ? reader.ReadInt() : 0;
			int shapeId = version > 0 ? reader.ReadInt() : 0;
			int materialId = version > 0 ? reader.ReadInt() : 0;
			Shape instance = shapeFactories[factoryId].Get(shapeId, materialId);
			instance.Load(reader);
			<del>//shapes.Add(instance);</del>
		}
	}</pre>
					</section>
					
					<section>
						<h3>Spawning Any Amount of Shapes</h3>
						
						<p>At this point the old design of the <code>SpawnZone.SpawnShape</code> method is no longer appropriate. First, it no longer needs to return a shape. Second, it no longer needs to be restricted to spawning a single shape, as it currently spawns two per invocation. So change it to <code>void SpawnShapes</code>.</p>
						
						<pre translate="no">	<del>//public virtual Shape SpawnShape () {</del>
	<ins>public virtual void SpawnShapes () {</ins>
	int factoryIndex = Random.Range(0, spawnConfig.factories.Length);
		&hellip;

		CreateSatelliteFor(shape);
		<del>//return shape;</del>
	}</pre>
						
						<p>This also requires an update of <code>CompositeSpawnZone</code>.</p>
						
						<pre translate="no">	<del>//public override Shape SpawnShape () {</del>
	<ins>public override void SpawnShapes () {</ins>
		if (overrideConfig) {
			<del>//return</del>
			base.<ins>SpawnShapes</ins>();
		}
		else {
			&hellip;
			<del>//return</del>
			spawnZones[index].<ins>SpawnShapes</ins>();
		}
	}</pre>
						
						<p>Also adjust the <code>SpawnShape</code> method of <code>GameLevel</code> to match.</p>
						
						<pre translate="no">	<del>//public Shape SpawnShape () {</del>
	<ins>public void SpawnShapes () {</ins>
		<del>//return</del>
		spawnZone.<ins>SpawnShapes</ins>();
	}</pre>
						
						<p>We can now remove the <code>Game.CreateShape</code> method. Instead, directly invoke <code>GameLevel.Current.SpawnShapes</code> in <code>Update</code> and <code>FixedUpdate</code>.</p>
						
						<pre translate="no">	void Update () {
		if (Input.GetKeyDown(createKey)) {
			<del>//CreateShape();</del>
			<ins>GameLevel.Current.SpawnShapes();</ins>
		}
		&hellip;
	}

	void FixedUpdate () {
		&hellip;
		while (creationProgress >= 1f) {
			creationProgress -= 1f;
			<del>//CreateShape();</del>
			<ins>GameLevel.Current.SpawnShapes();</ins>
		}

		&hellip;
	}

	&hellip;
	
	<del>//void CreateShape () {</del>
	<del>//	shapes.Add(GameLevel.Current.SpawnShape());</del>
	<del>//}</del></pre>
						
						<figure>
							<div class="vid" style="width: 200px; height:185px;"><iframe src='https://gfycat.com/ifr/SomberGeneralLacewing?controls=0'></iframe></div>
							<figcaption>Spawning pairs of shapes.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Satellite Behavior</h2>
					
					<p>To turn the companion shape into an actual satellite we have to make it behave like one, which requires us to create a new behavior type.
					
					<section>
						<h3>New Shape Behavior</h3>
						
						<p>Add a <code>Satellite</code> option to the <code>ShapeBehaviorType</code> enum, along with an accompanying case in the <code>GetInstance</code> method that returns a <code>SatelliteShapeBehavior</code> instance.</p>
						
						<pre translate="no">public enum ShapeBehaviorType {
	Movement,
	Rotation,
	Oscillation<ins>,</ins>
	<ins>Satellite</ins>
}

public static class ShapeBehaviorTypeMethods {

	public static ShapeBehavior GetInstance (this ShapeBehaviorType type) {
		switch (type) {
			&hellip;
			<ins>case ShapeBehaviorType.Satellite:</ins>
				<ins>return ShapeBehaviorPool&lt;SatelliteShapeBehavior>.Get();</ins>
		}
		UnityEngine.Debug.Log("Forgot to support " + type);
		return null;
	}
}</pre>
						
						<p>Create a minimal <code>SatelliteShapeBehavior</code> component that does nothing, for now.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public sealed class SatelliteShapeBehavior : ShapeBehavior {</ins>

	<ins>public override ShapeBehaviorType BehaviorType {</ins>
		<ins>get {</ins>
			<ins>return ShapeBehaviorType.Satellite;</ins>
		<ins>}</ins>
	<ins>}</ins>

	<ins>public override void GameUpdate (Shape shape) {}</ins>

	<ins>public override void Save (GameDataWriter writer) {}</ins>

	<ins>public override void Load (GameDataReader reader) {}</ins>

	<ins>public override void Recycle () {</ins>
		<ins>ShapeBehaviorPool&lt;SatelliteShapeBehavior>.Reclaim(this);</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>Add this behavior to the shape in <code>SpawnZone.CreateSatelliteFor</code> and remove the test position and movement behavior.</p>
						
						<pre translate="no">	void CreateSatelliteFor (Shape focalShape) {
		&hellip;
		<del>//t.localPosition = focalShape.transform.localPosition + Vector3.up;</del>
		<del>//shape.AddBehavior&lt;MovementShapeBehavior>().Velocity = Vector3.up;</del>
		SetupColor(shape);
		<ins>shape.AddBehavior&lt;SatelliteShapeBehavior>();</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Satellite Configuration</h3>
						
						<p>Like for regular spawn, we'll also make it possible to configure satellites via the inspector of the spawn zone. We'll support a few options, so define a <code>SatelliteConfiguration</code> struct inside <code>SpawnConfiguration</code> that we'll use to group them. Begin with a single range to control the scale of the satellite. Make it relative to its focal shape, from 0.1 to 1.</p>
						
						<pre translate="no">	[System.Serializable]
	public struct SpawnConfiguration {

		&hellip;

		<ins>[System.Serializable]</ins>
		<ins>public struct SatelliteConfiguration {</ins>

			<ins>[FloatRangeSlider(0.1f, 1f)]</ins>
			<ins>public FloatRange relativeScale;</ins>
		<ins>}</ins>

		<ins>public SatelliteConfiguration satellite;</ins>
	}</pre>
						
						<figure>
							<img src="satellite-behavior/relative-scale.png" width="320" height="74">
							<figcaption>Satellite configuration, relative scale.</figcaption>
						</figure>
						
						<p>Use a random value in this range instead of the fixed 0.5 that we used up to this point.</p>
						
						<pre translate="no">		t.localScale =
			focalShape.transform.localScale <ins>*</ins>
			<ins>spawnConfig.satellite.relativeScale.RandomValueInRange</ins>;</pre>
						
						<p>We also need an orbit radius to control the distance between the satellite and its focus, plus an orbit frequency to control how quickly it orbits around its focus.</p>
						
						<pre translate="no">		public struct SatelliteConfiguration {

			[FloatRangeSlider(0.1f, 1f)]
			public FloatRange relativeScale;

			<ins>public FloatRange orbitRadius;</ins>

			<ins>public FloatRange orbitFrequency;</ins>
		}</pre>
						
						<figure>
							<img src="satellite-behavior/orbit-radius-frequency.png" width="320" height="74">
							<figcaption>Satellite orbit radius and frequency.</figcaption>
						</figure>
						
						<p>Turning those configuration values into orbital motion requires math specific to satellites, so we won't put the code for that in <code>SpawnZone</code>. Instead, we'll add a public <code>Initialize</code> method to <code>SatelliteShapeBehavior</code>. Like <code>GameUpdate</code>, give it its own shape as a parameter. Besides that, also add parameters for the focal shape, radius, and frequency.</p>
						
						<pre translate="no">	<ins>public void Initialize (</ins>
		<ins>Shape shape, Shape focalShape, float radius, float frequency</ins>
	<ins>) {}</ins></pre>
						
						<p>Now we can initialize the satellite's behavior with a randomized orbit radius and frequency.</p>
						
						<pre translate="no">		shape.AddBehavior&lt;SatelliteShapeBehavior>()<ins>.Initialize(</ins>
			<ins>shape, focalShape,</ins>
			<ins>spawnConfig.satellite.orbitRadius.RandomValueInRange,</ins>
			<ins>spawnConfig.satellite.orbitFrequency.RandomValueInRange</ins>
		<ins>);</ins></pre>
					</section>
					
					<section>
						<h3>Orbiting</h3>
						
						<p>To make the satellite shape orbit its focus, we have to move it in a circle around it. We can do that with trigonometry, offsetting the satellite's position along two orthogonal vectors scaled by the cosine and sine of the shape's age. This requires <code>SatelliteShapeBehavior</code> to keep track of the focal shape, the frequency, and the two offset vectors. The radius can be factored into the offsets.</p>
						
						<p>We'll begin by always using the X axis for the cosine offset and the Z axis for the sine offset. When looking from above, it will result in the satellite starting at the right of the focal shape and circling around it counter-clockwise.</p> 
						
						<pre translate="no">	<ins>Shape focalShape;</ins>

	<ins>float frequency;</ins>

	<ins>Vector3 cosOffset, sinOffset;</ins>

	public void Initialize (
		Shape shape, Shape focalShape, float radius, float frequency
	) {
		<ins>this.focalShape = focalShape;</ins>
		<ins>this.frequency = frequency;</ins>
		<ins>cosOffset = Vector3.right;</ins>
		<ins>sinOffset = Vector3.forward;</ins>
		<ins>cosOffset *= radius;</ins>
		<ins>sinOffset *= radius;</ins>
	}</pre>
						
						<p>To make the satellite move, we have to adjust its position in <code>GameUpdate</code>. Set it to the focal position plus both offsets, each scaled by either the cosine or sine of 2&pi; times the frequency times its age.</p>
						
						<pre translate="no">	public override void GameUpdate (Shape shape) {
		<ins>float t = 2f * Mathf.PI * frequency * shape.Age;</ins>
		<ins>shape.transform.localPosition =</ins>
			<ins>focalShape.transform.localPosition +</ins>
			<ins>cosOffset * Mathf.Cos(t) + sinOffset * Mathf.Sin(t);</ins>
	}</pre>
						
						<p>To make sure that the satellite's initial position is valid, invoke <code>GameUpdate</code> once at the end of <code>Initialize</code>. This is necessary because <code>GameUpdate</code> won't be invoked during the same frame that a shape is spawned.</p>
						
						<pre translate="no">	public void Initialize (
		Shape shape, Shape focalShape, float radius, float frequency
	) {
		&hellip;

		<ins>GameUpdate(shape);</ins>
	}</pre>
						
						<figure>
							<div class="vid" style="width: 235px; height:215px;"><iframe src='https://gfycat.com/ifr/SardonicHandsomeDogwoodtwigborer?controls=0'></iframe></div>
							<figcaption>Orbiting satellites.</figcaption>
						</figure>
						
						<aside>
							<h3>What about elliptic orbits?</h3>
							<div>
								<p>Elliptic orbits are also possible, but are more complex than circular orbits. You can turn the orbit into an ellipse by using a different radius for each offset. Besides that, the orbit must be offset such that the focal shape ends up in one of the two foci of the ellipse. Also, the orbital velocity should no longer be constant, but depend on the distance between the satellite and its focus.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Randomized Orbit Axis</h3>
						
						<p>Our satellites are currently always orbiting in the XZ plane, rotating around an Y axis centered on the focal shape. We can randomize the orbit axis, by retrieving one via <code>Random.onUnitSphere</code>.</p>
						
						<pre translate="no">		<ins>Vector3 orbitAxis = Random.onUnitSphere;</ins>
		cosOffset = Vector3.right;
		sinOffset = Vector3.forward;</pre>
						
						<p>That gives us an axis. The next step it to find an arbitrary offset vector that lies in the plane defined by the axis. We can do that by taking the cross product of the orbit axis and another random vector. That gives us a random vector projected onto the orbit plane, which is most likely not of unit length, so we should normalize it.</p>
						
						<pre translate="no">		Vector3 orbitAxis = Random.onUnitSphere;
		<ins>cosOffset = Vector3.Cross(orbitAxis, Random.onUnitSphere).normalized;</ins></pre>
						
						<aside>
							<h3>What's a cross product?</h3>
							<div>
								<p>See <a href="../../rendering/part-6/index.html">Rendering 6, Bumpiness</a> for an explanation.</p>
							</div>
						</aside>
						
						<p>This works, unless the second random vector ends up being the same as or the negative version of the orbit axis. That would result in a zero vector, which cannot be normalized. Or specifically, <code>Vector3.normalized</code> will return the zero vector when the vector ends up too short to normalize. We can detect that by checking whether the offset vector's square magnitude is less than one. But because of numerical precision we should check for a smaller value, so let's use 0.1 instead. It's going to be either very close to 1 or exactly zero.</p>
						
						<p>Getting an invalid offset is very unlikely, so when it happens we'll just try again. We can do that with a <code>do while</code> loop.</p>
						
						<pre translate="no">		<ins>do {</ins>
			cosOffset = Vector3.Cross(orbitAxis, Random.onUnitSphere).normalized;
		<ins>}</ins>
		<ins>while (cosOffset.sqrMagnitude &lt; 0.1f);</ins></pre>
						
						<aside>
							<h3>How does a <code>do while</code> loop work?</h3>
							<div>
								<p>It is an alternative <code>while</code> loop, for when the code block of the loop has to be executed at least once. You begin with <code>do</code> instead of <code>while</code>, followed by the code block, after which comes the <code>while</code> statement, terminated with a semicolon. Had you used a regular <code>while</code> loop instead, you'd have to repeat the code block once before the loop to get the same effect.</p>
								
								<p><code>do { Work(); } while (Condition());</code> is the same as <code>Work(); while (Condition()) { Work(); }</code>.</p>
							</div>
						</aside>
						
						<p>The second offset can be found by taking the cross product of the first offset and the orbit axis. After that the offset are scaled.</p>
						
						<pre translate="no">		sinOffset = <ins>Vector3.Cross(cosOffset, orbitAxis)</ins>;
		cosOffset *= radius;
		sinOffset *= radius;</pre>
						
						<figure>
							<div class="vid" style="width: 235px; height:215px;"><iframe src='https://gfycat.com/ifr/UnnaturalAgedAfricancivet?controls=0'></iframe></div>
							<figcaption>Random orbits.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Tidal Locking</h3>
						
						<p>Although our satellites orbit, they currently do not rotate. We could give then arbitrary rotation velocities, but we could also tidally lock them. This means that their rotation matches their orbit, so they always face their focal shape with the same side.</p>
						
						<p>To give each satellite a matching rotation, add a rotation behavior with an angular velocity equal to the orbit axis scaled by the frequency, multiplied by 360 degrees. Also, because of the way that we construct the orbit, we have to negate the velocity.</p>
						
						<pre translate="no">		cosOffset *= radius;
		sinOffset *= radius;

		<ins>shape.AddBehavior&lt;RotationShapeBehavior>().AngularVelocity =</ins>
			<ins>-360f * frequency * orbitAxis;</ins></pre>
						
						<p>However, because the angular velocity is applied in the shape's local space, directly using the orbit axis only works when the satellite has no rotation of its own. As we gave it an arbitrary rotation, we have to convert the orbit axis to the shape's local space, by invoking <code>InverseTransformDirection</code> on its transformation.</p>
						
						<pre translate="no">		shape.AddBehavior&lt;RotationShapeBehavior>().AngularVelocity =
			-360f * frequency *
			<ins>shape.transform.InverseTransformDirection(</ins>orbitAxis<ins>)</ins>;</pre>
						
						<figure>
							<div class="vid" style="width: 285px; height:215px;"><iframe src='https://gfycat.com/ifr/BlackTheseBarnswallow?controls=0'></iframe></div>
							<figcaption>Tidally locked satellites.</figcaption>
						</figure>
						
						<p>If you wanted to, you could also make the tidal locking imperfect by slightly randomizing the velocity. The satellite could either rotate too fast, too slow, have a retrograde rotation, and could have axial tilt.</p>
					</section>
				</section>
				
				<section>
					<h2>Shape References</h2>
					
					<p>Satellites function correctly as long as their focus shape exists, but things get weird when the focus is recycled while the satellite is still around. Initially, the satellite will keep orbiting the last position of its focus. When the focus shape gets reused for a new spawn, the satellite still orbits it, teleporting to its new position.</p>
					
					<p>We have to sever the connection between a satellite and its focus when the focus is recycled. If we destroyed the focus, then all we needed to do was check whether the <code>focusShape</code> reference has become null. But we recycle shapes, so the reference remains intact even though the shape isn't part of the game anymore. So we have to find a way to determine whether a shape reference is still valid.</p>
					
					<section>
						<h3>Instance Identification</h3>
						
						<p>We can distinguish between different incarnations of the same shape by adding an instance identifier property to <code>Shape</code>. Just like <code>Age</code>, it has to be publicly accessible but will only be modified by the shape itself.</p>
						
						<pre translate="no">	public float Age { get; private set; }

	<ins>public int InstanceId { get; private set; }</ins></pre>
						
						<p>Each time a shape is recycled, increment its instance identifier. That way we can tell whether we're dealing with the same or a recycled shape instance.</p>
						
						<pre translate="no">	public void Recycle () {
		Age = 0f;
		<ins>InstanceId += 1;</ins>
		&hellip;
	}</pre>
						<p>By keeping track of both a reference to the shape and the correct instance identifier, we're able to check whether the shape's identifier is still the same each update. If not, it got recycled and is no longer valid.</p>
					</section>
					
					<section>
						<h3>Indirect References</h3>
						
						<p>Rather than explicitly add an identifier field each time we need a <code>Shape</code> reference, lets combine both in a new <code>ShapeInstance</code> struct. We'll make this a serializable struct with a <code>Shape</code> and an instance identifier field. The shape has to be publicly accessible, but the instance identifier is a technicality that doesn't have to be public.</p>
						
						<pre translate="no"><ins>[System.Serializable]</ins>
<ins>public struct ShapeInstance {</ins>

	<ins>public Shape Shape€ { get; private set; }</ins>
	
	<ins>int instanceId;</ins>
<ins>}</ins></pre>
						
						<p>The idea is that a <code>ShapeInstance</code> struct is immutable, representing a reference to a specific shape instance that's only valid until that shape is recycled. The only way to create a valid instance reference is via a constructor method that has a single shape parameter, which we use to set the reference and copy its current instance identifier.</p>
						
						<pre translate="no">	<ins>public ShapeInstance (Shape shape) {</ins>
		<ins>Shape€ = shape;</ins>
		<ins>instanceId = shape.InstanceId;</ins>
	<ins>}</ins></pre>
						
						<p>To verify whether the instance reference is valid, add an <code>IsValid</code> getter property that checks whether the shape's instance identifier is still the same.</p>
						
						<pre translate="no">	<ins>public bool IsValid {</ins>
		<ins>get {</ins>
			<ins>return instanceId == Shape€.InstanceId;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>But there is still a default constructor, which is used for example when a <code>ShapeInstance</code> array is created. That would result in null references, so we should also check whether we have a shape reference at all. That also guarantees that instances become invalid if for some reason a shape object is destroyed instead of recycled.</p>
						
						<pre translate="no">			return <ins>Shape€ &amp;&amp;</ins> instanceId == Shape€.InstanceId;</pre>
					</section>
					
					<section>
						<h3>Casting from Shape to Instance</h3>
						
						<p>Converting a <code>Shape shape</code> reference to a <code>ShapeInstance</code> value can now be done by via <code>new ShapeInstance(shape)</code>. But we can made the code even shorter by adding a casting operator to <code>ShapeInstance</code>. An operator is defined like a method, except that it is static, includes the <code>operator</code> keyword, and doesn't have a method name. In the case of an explicit cast, we have to add the <code>explicit</code> keyword in front of <code>operator</code>.</p>
						
						<pre translate="no">	<ins>public static explicit operator ShapeInstance (Shape shape) {</ins>
		<ins>return new ShapeInstance(shape);</ins>
	<ins>}</ins></pre>
						
						<p>Now the conversion can be done via <code>(ShapeInstance)shape</code>. But it can become even shorter, by making the cast implicit instead of explicit. Then a direct assignment of <code>shape</code> to a <code>ShapeInstance</code> field or variable is enough. That's also how Unity supports implicit conversions between <code>Vector2</code> and <code>Vector3</code> and other struct types.</p>
						
						<pre translate="no">	public static <ins>implicit</ins> operator ShapeInstance (Shape shape) {
		return new ShapeInstance(shape);
	}</pre>
					</section>
					
					<section>
						<h3>Focal Shape Instance</h3>
						
						<p>Change the <code>focalShape</code> reference in <code>SatelliteShapeBehavior</code> into a <code>ShapeInstance</code> value. Because of the implicit cast, we don't have to change the code in <code>Initialize</code>.</p>
						
						<pre translate="no">	<ins>ShapeInstance</ins> focalShape;</pre>
						
						<p>We do have to change <code>GameUpdate</code>, because we now have to indirectly access the focal shape via <code>focalShape.Shape€</code>. Also, we must only do this if the focal shape is still valid.</p>
						
						<pre translate="no">	public override void GameUpdate (Shape shape) {
		<ins>if (focalShape.IsValid) {</ins>
			float t = 2f * Mathf.PI * frequency * shape.Age;
			shape.transform.localPosition =
				focalShape.<ins>Shape€</ins>.transform.localPosition +
				cosOffset * Mathf.Cos(t) + sinOffset * Mathf.Sin(t);
		<ins>}</ins>
	}</pre>
					</section>
				</section>
				
				<section>
					<h2>Free Satellites</h2>
					
					<p>From now on, satellites orbit their focus as long as it is still in the game and stop moving when the focus is recycled. At that point the link between them has become invalid and is no longer used to update the satellite. But the <code>SatelliteShapeBehavior</code> is still attached to the satellite shape. Its <code>GameUpdate</code> method still gets invoked each update, even though that is now pointless. Ideally, the behavior is recycled too.</p>
					
					<section>
						<h3>Removing Behavior</h3>
						
						<p>It is possible for satellite behavior to become useless, and we could create many other kinds of temporary behavior. So let's make it possible for shapes to rid themselves of behavior that is no longer useful. We'll do that by having the behavior tell their shape whether they're still needed. We'll have <code>GameUpdate</code> return a boolean to indicate this, so adjust the method definition in <code>ShapeBehavior</code>.</p>
						
						<pre translate="no">	public abstract <ins>bool</ins> GameUpdate (Shape shape);</pre>
						
						<p>Adjust the <code>GameUpdate</code> overrides in all shape behaviors too, always returning <code>true</code> at the end.</p>
						
						<pre translate="no">	public override <ins>bool</ins> GameUpdate (Shape shape) {
		&hellip;
		<ins>return true;</ins>
	}</pre>
						
						<p>Except for <code>SatelliteShapeBehavior</code>, which should return <code>true</code> only when the focus shape is valid. Otherwise, it returns <code>false</code>, indicating that it is no longer useful and can be removed.</p>
						
						<pre translate="no">	public override <ins>bool</ins> GameUpdate (Shape shape) {
		if (focalShape.IsValid) {
			&hellip;
			<ins>return true;</ins>
		}
		
		<ins>return false;</ins>
	}</pre>
						
						<p>In <code>Shape.GameUpdate</code>, we must now check each iteration whether the behavior is still needed. If not, recycle it, remove it from the behavior list, and then decrement the iterator so we won't skip any behavior. We can simply invoke <code>RemoveAt</code> on the list, so the order of behavior isn't changed. The behavior list should be short, so we don't need to worry about optimizing the removal by shuffling the order like we do when deleting from the shape list.</p>
						
						<pre translate="no">	public void GameUpdate () {
		Age += Time.deltaTime;
		for (int i = 0; i &lt; behaviorList.Count; i++) {
			<ins>if (!</ins>behaviorList[i].GameUpdate(this)<ins>) {</ins>
				<ins>behaviorList[i].Recycle();</ins>
				<ins>behaviorList.RemoveAt(i--);</ins>
			<ins>}</ins>
		}
	}</pre>
					</section>
					
					<section>
						<h3>Conservation of Momentum</h3>
						
						<p>Satellites now become regular shapes when their focus shape ceases to exist. Without their satellite behavior, they no longer move, but they keep their rotation because that's a separate behavior. But it is both more interesting and more realistic if the shapes keep moving in whatever direction they were going when the focus shape disappeared. It would be as if the satellites got ejected from their system.</p>
						
						<p>To make continued motion possible, we have to know the satellite's velocity at all times, which depends on both its orbital motion and the movement of its focus. Rather than figure that out, we'll simply keep track of the satellite's position before its last update. We can use that to determine the last position delta and convert that to a velocity when we need it.</p>
						
						<p>Add a <code>previousPosition</code> vector field to <code>SatelliteShapeBehavior</code>, copy the current position to it before calculating the new position, and add a movement behavior to the shape when the satellite behavior is no longer needed.</p>
						
						<pre translate="no">	<ins>Vector3 previousPosition;</ins>

	&hellip;
	
	public override bool GameUpdate (Shape shape) {
		if (focalShape.IsValid) {
			float t = 2f * Mathf.PI * frequency * shape.Age;
			<ins>previousPosition = shape.transform.localPosition;</ins>
			shape.transform.localPosition =
				focalShape.Shape.transform.localPosition +
				cosOffset * Mathf.Cos(t) + sinOffset * Mathf.Sin(t);
			return true;
		}

		<ins>shape.AddBehavior&lt;MovementShapeBehavior>().Velocity =</ins>
			<ins>(shape.transform.localPosition - previousPosition);</ins>
		return false;
	}</pre>
						
						<p>To arrive at a correct velocity, we have to divide the position delta by the time delta of the previous frame. We'll simply assume that the delta is the same as for the current frame, which is true because we're using a fixed time step.</p>
						
						<pre translate="no">		shape.AddBehavior&lt;MovementShapeBehavior>().Velocity =
			(shape.transform.localPosition - previousPosition) <ins>/ Time.deltaTime</ins>;</pre>
						
						<p>This works, except when the focal shape ends up invalid before the first game update of the satellite, which is unlikely but possible. In that case, the previous position vector is arbitrary, either zero for a new behavior or still containing the value of a recycled satellite behavior. At this point the satellite hasn't moved yet, so initially set the previous position to its current position, at the end of <code>Initialize</code>.</p>
						
						<pre translate="no">	public void Initialize (
		Shape shape, Shape focalShape, float radius, float frequency
	) {
		&hellip;

		GameUpdate(shape);
		<ins>previousPosition = shape.transform.localPosition;</ins>
	}</pre>
						
						<figure>
							<div class="vid" style="width: 110px; height:75px;"><iframe src='https://gfycat.com/ifr/LinearLazyBlacklemur?controls=0'></iframe></div>
							<figcaption>Escaping satellite.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Saving and Loading</h2>
					
					<p>Satellites are now fully functional, can deal with recycled focus shapes, and can even survive recompilation. However, we haven't supported saving and loading them yet.</p>
					
					<p>We know what that needs to be stored to persist satellite behavior. The frequency, both offset vectors, and the previous position are straightforward. We can save and load them as usual.
					
					<pre translate="no">	public override void Save (GameDataWriter writer) {
		<ins>writer.Write(frequency);</ins>
		<ins>writer.Write(cosOffset);</ins>
		<ins>writer.Write(sinOffset);</ins>
		<ins>writer.Write(previousPosition);</ins>
	}

	public override void Load (GameDataReader reader) {
		<ins>frequency = reader.ReadFloat();</ins>
		<ins>cosOffset = reader.ReadVector3();</ins>
		<ins>sinOffset = reader.ReadVector3();</ins>
		<ins>previousPosition = reader.ReadVector3();</ins>
	}</pre>
					
					<p>But saving the focus shape instance requires more work. We somehow have to persist a relationship between shapes.</p>
					
					<section>
						<h3>Shape Index</h3>
						
						<p>Because all shapes that are currently in the game are stored in the game's shape list, we can use the indices of this list to uniquely identify shapes. So we can suffice with writing the shape's index when saving the shape instance. That means that we have to know the shape's index when saving the focus shape, so let's add add a <code>SaveIndex</code> property to <code>Shape</code> for that.
						
						<pre translate="no">	<ins>public int SaveIndex { get; set; }</ins></pre>
						
						<p>This property is set in <code>Game.AddShape</code> and is only useful when saving shape references.</p>
						
						<pre translate="no">	public void AddShape (Shape shape) {
		<ins>shape.SaveIndex = shapes.Count;</ins>
		shapes.Add(shape);
	}</pre>
						
						<p>We also have to make sure that the index remains correct when we shuffle the order of the shapes in <code>DestroyShape</code>.</p>
						
						<pre translate="no">	void DestroyShape () {
		if (shapes.Count > 0) {
			int index = Random.Range(0, shapes.Count);
			shapes[index].Recycle();
			int lastIndex = shapes.Count - 1;
			<ins>shapes[lastIndex].SaveIndex = index;</ins>
			shapes[index] = shapes[lastIndex];
			shapes.RemoveAt(lastIndex);
		}
	}</pre>
						
						<section>
							<h3>Saving a Shape Instance</h3>
							
							<p>Because shape instances represent a low-level fundamental part of our game and because we want to keep them as easy to work with as possible, we'll add support for directly saving them to <code>GameDataWriter</code>. It only has to write the save index of the shape.</p>
							
							<pre translate="no">	<ins>public void Write (ShapeInstance value) {</ins>
		<ins>writer.Write(value.Shape€.SaveIndex);</ins>
	<ins>}</ins></pre>
							
							<p>Now we can write the focal shape just like the other state in <code>SatelliteShapeBehavior.Save</code>.</p>
							
							<pre translate="no">	public override void Save (GameDataWriter writer) {
		<ins>writer.Write(focalShape);</ins>
		&hellip;
	}</pre>
						</section>
						
						<section>
							<h3>Loading a Shape Instance</h3>
							
							<p>When loading a shape instance, we will end up reading a save index. We need to be able to convert that to an actual shape reference. Add a public <code>GetShape</code> method to <code>Game</code> for that, with an index parameter. It simply returns a reference to the corresponding shape.</p>
							
							<pre translate="no">	<ins>public Shape GetShape (int index) {</ins>
		<ins>return shapes[index];</ins>
	<ins>}</ins></pre>
							
							<p>To convert directly from a save index to a shape instance, let's add an alternative constructor method to <code>ShapeInstance</code> that has an index parameter instead of a <code>Shape</code> parameter. It can use the new <code>GetShape</code> method to retrieve the shape and then set its instance identifier.</p>
							
							<pre translate="no">	<ins>public ShapeInstance (int saveIndex) {</ins>
		<ins>Shape€ = Game.Instance.GetShape(saveIndex);</ins>
		<ins>instanceId = Shape€.InstanceId;</ins>
	<ins>}</ins></pre>
							
							<p>Add a <code>ReadShapeInstance</code> method to <code>GameDataReader</code> that reads an integer and uses it to construct a new shape instance.</p>
							
							<pre translate="no">	<ins>public ShapeInstance ReadShapeInstance () {</ins>
		<ins>return new ShapeInstance(reader.ReadInt32());</ins>
	<ins>}</ins></pre>
							
							<p>That allows us to read the shape instance in <code>SatelliteShapeBehavior.Load</code>.</p>
							
							<pre translate="no">	public override void Load (GameDataReader reader) {
		<ins>focalShape = reader.ReadShapeInstance();</ins>
		&hellip;
	}</pre>
						</section>
						
						<section>
							<h3>Resolving Shape Instances</h3>
							
							<p>Saving and loading satellite data now works, but only if no shapes have been removed during the game before saving. If shapes have been destroyed, the order of the shape list changed and it is possible that satellite shapes end up with a lower index than their focus shape. If a satellite is loaded before its focus shape, it makes no sense to immediately retrieve a reference to its focus. We have to postpone retrieving the shapes until after all shapes have been loaded.</p>
							
							<p>We can still load the shape instances, but delay resolving the shape references until later. This requires us to temporarily store the save index in the shape instance. Rather than using a separate field for that and increase the size of <code>ShapeInstance</code>, we can have the instance identifier field perform double duty as a save index too. Rename the field accordingly.</p>
							
							<pre translate="no">	int <ins>instanceIdOrSaveIndex</ins>;</pre>
							
							<p>The constructor with a save index parameter will now store the index and set the shape reference to null instead of immediately resolving it.</p>
							
							<pre translate="no">	public ShapeInstance (int saveIndex) {
		Shape€ = <ins>null</ins>;
		instanceIdOrSaveIndex = <ins>saveIndex</ins>;
	}</pre>
							
							<p>Resolving the shape reference becomes an explicit separate step, for which we'll add a public <code>Resolve</code> method. This approach breaks the immutability principle of the struct, but we'll only use it once, after loading a game.</p>
							
							<pre translate="no">	<ins>public void Resolve () {</ins>
		<ins>Shape€ = Game.Instance.GetShape(instanceIdOrSaveIndex);</ins>
		<ins>instanceIdOrSaveIndex = Shape€.InstanceId;</ins>
	<ins>}</ins></pre>
							
							<p>Next, we need a way to signal behavior that it is time to resolve any shape instances that they might have. Add a <code>ResolveShapeInstances</code> method to <code>ShapeBehavior</code> for that purpose. Because only one behavior so far has need for this, we'll provide a default empty implementation of the method, by marking it as <code>virtual</code> instead of <code>abstract</code> and giving it an empty code block.</p>							
							<pre translate="no">	<ins>public virtual void ResolveShapeInstances () {}</ins></pre>
							
							<p>Only <code>SatelliteShapeBehavior</code> needs to override this method, in which it invokes <code>Resolve</code> on its focal shape instance.</p>
							
							<pre translate="no">	<ins>public override void ResolveShapeInstances () {</ins>
		<ins>focalShape.Resolve();</ins>
	<ins>}</ins></pre>
							
							<p>We also have to add a <code>ResolveShapeInstances</code> method to <code>Shape</code>, which forwards the request to all its behavior.</p>
							
							<pre translate="no">	<ins>public void ResolveShapeInstances () {</ins>
		<ins>for (int i = 0; i &lt; behaviorList.Count; i++) {</ins>
			<ins>behaviorList[i].ResolveShapeInstances();</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
							
							<p>Finally, at the end of <code>Game.LoadGame</code>, we'll resolve the shape instances of all shapes.</p>
							
							<pre translate="no">	IEnumerator LoadGame (GameDataReader reader) {
		&hellip;

		<ins>for (int i = 0; i &lt; shapes.Count; i++) {</ins>
			<ins>shapes[i].ResolveShapeInstances();</ins>
		<ins>}</ins>
	}</pre>
						</section>
						
						<section>
							<h3>Dealing with Invalid Instances</h3>
							
							<p>Up to this point we have assumed that all shape instances are valid at the moment that the game is saved, but this is not guaranteed. We have to be able to cope with the saving and loading of invalid instances. We can indicate an invalid shape instance by writing &minus;1.</p>
							
							<pre translate="no">	public void Write (ShapeInstance value) {
		writer.Write(<ins>value.IsValid ?</ins> value.Shape€.SaveIndex <ins>: -1</ins>);
	}</pre>
							
							<p>Reading a shape instance doesn't require extra attention, but <code>ShapeInstance.Resolve</code> can only do its job when it has a valid save index. If not, its shape reference has to remain null and thus invalid.</p>
							
							<pre translate="no">	public void Resolve () {
		<ins>if (instanceIdOrSaveIndex >= 0) {</ins>
			Shape€ = Game.Instance.GetShape(instanceIdOrSaveIndex);
			instanceIdOrSaveIndex = Shape€.InstanceId;
		<ins>}</ins>
	}</pre>
						</section>
					</section>
				</section>
				
				<section>
					<h2>Shape Population Explosion</h2>
					
					<p>A side effect of spawning satellites along with regular shapes is that we have increased the rate at which new shapes are spawn. Currently each shape gets a satellite, thus to keep the amount of shapes stable the destruction speed has to be set to double the creation speed.</p>
					
					<section>
						<h3>Multiple Satellites Per Shape</h3>
						
						<p>We don't have to limit ourselves to exactly one satellite per regular shape. Let's make it configurable by adding a range for the amount of satellites per shape. We need an <code>IntRange</code> struct value for that, which we can create by duplicating <code>FloatRange</code> and changing the types used from <code>float</code> to <code>int</code>. Also, to keep the random range inclusive on both ends, we have to add one to the maximum when invoking the integer variant of <code>Random.Range€</code>.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>[System.Serializable]</ins>
<ins>public struct IntRange {</ins>

	<ins>public int min, max;</ins>

	<ins>public int RandomValueInRange {</ins>
		<ins>get {</ins>
			<ins>return Random.Range€(min, max + 1);</ins>
		<ins>}</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>We can also duplicate <code>FloatRangeDrawer</code> to create a variant for the new integer range, but we don't need to do that. The code in <code>FloatRangeDrawer</code> doesn't care about the type of the minimum and maximum values, only that they exist. So we can use the same drawer for both <code>FloatRange</code> and <code>IntRange</code>. All we have to do is add a second <code>CustomPropertyDrawer</code> attribute to it. Let's also rename the drawer to <code>FloatOrIntRangeDrawer</code>, renaming its asset file too.</p>
						
						<pre translate="no">[CustomPropertyDrawer(typeof(FloatRange))<ins>, CustomPropertyDrawer(typeof(IntRange))</ins>]
public class <ins>FloatOrIntRangeDrawer</ins> : PropertyDrawer { &hellip; }</pre>
						
						<aside>
							<h3>Can we do the same for <code>FloatRangeSliderDrawer</code>?</h3>
							<div>
								<p>Yes, but the code of that drawer specifically works with floats, so needs to be adapted to work for either floats or integers. I'm not bothering with that here, because I don't have a limited range for the satellite amount in mind. Even negative values are useful, as they can be used to make it less likely for satellites to appear.</p>
							</div>
						</aside>
						
						<p>Add an integer range option to <code>SatelliteConfiguration</code> to configure the amount of satellites spawned per shape.</p>
						
						<pre translate="no">		public struct SatelliteConfiguration {

			<ins>public IntRange amount;</ins>

			&hellip;
		}</pre>
						
						<p>In <code>SpawnShapes</code>, determine a random count and invoke <code>CreateSatelliteFor</code> that many times.</p>
						
						<pre translate="no">	int factoryIndex = Random.Range(0, spawnConfig.factories.Length);
		&hellip;

		<ins>int satelliteCount = spawnConfig.satellite.amount.RandomValueInRange;</ins>
		<ins>for (int i = 0; i &lt; satelliteCount; i++) {</ins>
			CreateSatelliteFor(shape);
		<ins>}</ins>
	}</pre>
						<figure>
							<img src="shape-population-explosion/amount-range.png" width="320" height="90" alt="inspector">
							<div class="vid" style="width: 280px; height:200px;"><iframe src='https://gfycat.com/ifr/FirsthandDismalDevilfish?controls=0'></iframe></div>
							<figcaption>Between zero and three satellites per shape.</figcaption>
						</figure>
						
						<aside>
							<h3>Could we create satellites for other satellites?</h3>
							<div>
								<p>Yes, besides their behavior a satellite is like any other shape and can act as the focus for another satellite. Nested satellite relationships can quickly produce cluttered movement though, and you have to avoid creating an infinite chain of satellites.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Population Limit</h3>
						
						<p>With the amount of satellites per shape no longer constant, we cannot rely on a fixed creation and destruction speed to keep the amount of shapes constant. The destruction speed is still useful, but if we want to limit the amount of shapes then we have no choice but to add a hard limit. Let's define a shape population limit and make it configurable per level, so add a field for it to <code>GameLevel</code>.</p>
						
						<pre translate="no">	<ins>[SerializeField]</ins>
	<ins>int populationLimit;</ins></pre>
						
						<figure>
							<img src="shape-population-explosion/population-limit.png" width="320" height="92">
							<figcaption>Population limited to 100.</figcaption>
						</figure>
						
						<p>Make the limit available via a public getter property, so <code>Game</code> can access it.</p>
						
						<pre translate="no">	<ins>public int PopulationLimit {</ins>
		<ins>get {</ins>
			<ins>return populationLimit;</ins>
		<ins>}</ins>
	<ins>}</ins>
</pre>
						
						<p>To enforce the limit, destroy shapes at the end of <code>Game.FixedUpdate</code> as long as there are too many of them. We'll only do that if the limit is positive, so zero or a negative value indicates that there is no limit.</p>
						
						<pre translate="no">	void FixedUpdate () {
		&hellip;
		
		<ins>int limit = GameLevel.Current.PopulationLimit;</ins>
		<ins>if (limit > 0) {</ins>
			<ins>while (shapes.Count > limit) {</ins>
				<ins>DestroyShape();</ins>
			<ins>}</ins>
		<ins>}</ins>
	}</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:200px;"><iframe src='https://gfycat.com/ifr/ObviousHotFoal?controls=0'></iframe></div>
							<figcaption>Enforced population limit.</figcaption>
						</figure>
						
						<p>The next tutorial is <a href="../lifecycle/index.html">Lifecycle</a>.</p>
					</section>
									
					<a href="https://bitbucket.org/catlikecodingunitytutorials/object-management-10-satellites/" class="repository">repository</a>
					<a href="Satellites.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>