<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/object-management/more-complex-levels/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/object-management/more-complex-levels/tutorial-image.jpg">
		<meta property="og:title" content="More Complex Levels">
		<meta property="og:description" content="A Unity Object Management tutorial about dealing with more complex levels.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>More Complex Levels</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/object-management/lifecylce/#article",
				"headline": "More Complex Levels",
				"alternativeHeadline": "Spawn, Kill, and Life Zones",
				"datePublished": "2019-03-20",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Object Management tutorial about dealing with more complex levels.",
				"image": "https://catlikecoding.com/unity/tutorials/object-management/more-complex-levels/tutorial-image.jpg",
				"dependencies": "Unity 2017.4.12f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/object-management/", "name": "Object Management" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				ColorRangeHSV: 1,
				CompositeSpawnZone: 1,
				CubeSpawnZone: 1,
				DyingShapeBehavior: 1,
				FloatRange: 1,
				FloatOrIntRangeDrawer: 1,
				FloatRangeDrawer: 1,
				FloatRangeSlider: 1,
				FloatRangeSliderAttribute: 1,
				FloatRangeSliderDrawer: 1,
				Game: 1,
				GameDataReader: 1,
				GameDataWriter: 1,
				GameLevel: 1,
				GameLevelInspector: 1,
				GameLevelObject: 1,
				GrowingShapeBehavior: 1,
				IntRange: 1,
				KillZone: 1,
				LifecycleConfiguration: 1,
				LifecycleShapeBehavior: 1,
				LifeZone: 1,
				MovementDirection: 1,
				MovementShapeBehavior: 1,
				OscillationShapeBehavior: 1,
				PersistableObject: 1,
				PersistentStorage: 1,
				RegisterLevelObjectMenuItem: 1,
				RotatingObject: 1,
				RotationShapeBehavior: 1,
				SatelliteConfiguration: 1,
				SatelliteShapeBehavior: 1,
				Shape: 1,
				ShapeBehavior: 1,
				ShapeBehaviorPool: 1,
				ShapeBehaviorType: 1,
				ShapeBehaviorTypeMethods: 1,
				ShapeFactory: 1,
				ShapeInstance: 1,
				SpawnConfiguration: 1,
				SpawnMovementDirection: 1,
				SpawnZone: 1,
				SphereSpawnZone: 1,
				T: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Object Management</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>More Complex Levels</h1>
					<p>Spawn, Kill, and Life Zones</p>
					<ul>
						<li>Make spawning automatic.</li>
						<li>Create zones antithetical to or essential for life.</li>
						<li>Control which zones affect which shapes.</li>
						<li>Centralize level object updates and add editor support.</li>
						<li>Use partial classes.</li>
					</ul>
				</header>
				
				<p>This is the twelfth and final tutorial in a series about <a href="../index.html">Object Management</a>. It covers the addition of kill zones and more strict management of level objects.</p>
				
				<p>This tutorial is made with Unity 2017.4.12f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Sculpting with life and death.</figcaption>
				</figure>
				
				<aside>
					<h3>Tutorial Update</h3>
					<div>
						<p>When behavior removal got added earlier, I forgot to add a line of code to recycle the behavior. If you haven't already done so, add a <code>Recycle</code> invocation in <code>Shape.GameUpdate</code>.</p>
						
						<pre>	public void GameUpdate () {
		Age += Time.deltaTime;
		for (int i = 0; i &lt; behaviorList.Count; i++) {
			if (!behaviorList[i].GameUpdate(this)) {
				<ins>behaviorList[i].Recycle();</ins>
				behaviorList.RemoveAt(i--);
			}
		}
	}</pre>
					</div>
				</aside>
				
				<section>
					<h2>Automatic Spawn Zones</h2>
					
					<p>To kill shapes they must first be spawned. We already have spawn zones, but they are inert by default. The player has to increase the creation speed or spawn shapes manually. To show off the interaction between spawn and kill zones it would be convenient if the spawn zones could activate on their own.</p>
					
					<section>
						<h3>Spawn Speed</h3>
						
						<p>Not all spawn zones need to be always active. There can be a distinction between automatic and manual zones. So let's add a spawn speed configuration option to <code>SpawnZone</code>. Give it a slider with a pretty big range, like 0&ndash;50.</p>
						
						<pre>	<ins>[SerializeField, Range(0f, 50f)]</ins>
	<ins>float spawnSpeed;</ins></pre>
						
						<p>To make this work <code>SpawnZone</code> now needs to keep track of its spawn progress and update it in a <code>FixedUpdate</code> method, just like <code>Game</code> does.</p>
						
						<pre>	<ins>float spawnProgress;</ins>

	&hellip;
	
	<ins>void FixedUpdate () {</ins>
		<ins>spawnProgress += Time.deltaTime * spawnSpeed;</ins>
		<ins>while (spawnProgress >= 1f) {</ins>
			<ins>spawnProgress -= 1f;</ins>
			<ins>SpawnShapes();</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<figure>
							<img src="automatic-spawn-zones/spawn-speed.png" width="320" height="92" alt="inspector">
							<div class="vid" style="width:250px; height:250px;"><iframe src='https://gfycat.com/ifr/MisguidedEsteemedAffenpinscher?controls=0'></iframe></div>
							<figcaption>Automatic spawn speed set to 50.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Saving Progress</h3>
						
						<p>From now on, spawn zones must also keep track of their spawn progress when saving the game. Add the required <code>Save</code> and <code>Load</code> methods for that.</p>
						
						<pre>	<ins>public override void Save (GameDataWriter writer) {</ins>
		<ins>writer.Write(spawnProgress);</ins>
	<ins>}</ins>

	<ins>public override void Load (GameDataReader reader) {</ins>
		<ins>spawnProgress = reader.ReadFloat();</ins>
	<ins>}</ins></pre>
						
						<p>Every spawn zone that has a positive spawn speed must be included in the persistent object list of its level, otherwise it won't be saved and loaded.</p>
						
						<figure>
							<img src="automatic-spawn-zones/persisting-spawn-zone.png" width="320" height="128">
							<figcaption>Persisting the automatic spawn zone.</figcaption>
						</figure>
						
						<p>Note that a zone can be both automatic and controlled by the player. The two don't interfere.</p>
					</section>
					
					<section>
						<h3>Composite Spawn Zones</h3>
						
						<p><code>CompositeSpawnZone</code> already had its own <code>Save</code> and <code>Load</code> methods, because it has to keep track of its next sequential index. We have to make sure that these methods invoke their base versions, so the spawn progress of a composite zone also gets saved.</p>
						
						<pre>	public override void Save (GameDataWriter writer) {
		<ins>base.Save(writer);</ins>
		writer.Write(nextSequentialIndex);
	}

	public override void Load (GameDataReader reader) {
		<ins>base.Load(reader);</ins>
		nextSequentialIndex = reader.ReadInt();
	}</pre>
						
						<p>But old save files don't include the spawn progress, so we should only do this for new save games, which will be version 7.</p>
						
						<pre>	public override void Load (GameDataReader reader) {
		<ins>if (reader.Version >= 7) {</ins>
			base.Load(reader);
		<ins>}</ins>
		nextSequentialIndex = reader.ReadInt();
	}</pre>
						
						<p>Increment the save version in <code>Game</code> to match.</p>
						
						<pre>	const int saveVersion = <ins>7</ins>;</pre>
					</section>
					
				</section>
				
				<section>
					<h2>Kill Zones</h2>
					
					<p>A kill zone is a space that kills all shapes that enter it. This means that we have to figure out whether a shape entered a zone. We can use collider triggers and Unity's 3D physics engine for game objects to detect this.</p>
					
					<section>
						<h3>Physics Trigger</h3>
						
						<p>Create a new <code>KillZone</code> component type and give it an <code>OnTriggerEnter</code> method with a <code>Collider</code> parameter. That method will get invoked when something enters the trigger attached to the game object that has this component, with the entering collider as an argument.</p>
						
						<pre><ins>using UnityEngine;</ins>

<ins>public class KillZone : MonoBehaviour {</ins>

	<ins>void OnTriggerEnter (Collider other) {}</ins>
<ins>}</ins></pre>
						
						<p>In this method, retrieve the <code>Shape</code> component from the collider. If it exists, make it die.</p>
						
						<pre>	void OnTriggerEnter (Collider other) {
		<ins>var shape = other.GetComponent&lt;Shape>();</ins>
		<ins>if (shape) {</ins>
			<ins>shape.Die();</ins>
		<ins>}</ins>
	}</pre>
						
						<p>Now we can create a kill zone by adding an empty game object to a level and giving it a collider and a kill zone component. It has to be a specific kind of collider, for example a box or sphere collider. Make sure that you enable its <em>Is Trigger</em> option.</p>
						
						<figure>
							<img src="kill-zones/box-kill-zone.png" width="320" height="258">
							<figcaption>A box kill zone.</figcaption>
						</figure>
						
						<p>That's not enough to detect entering shapes. Although both the zone and all shapes have colliders, at least one of each much have a rigidbody component attached before the physics engine will make them interact. It doesn't matter which gets the rigidbody, so let's add it to the zone, to keep the shapes as simple as possible.</p>
						
						<p>Adding a rigidbody to something will make it act like a physical object, which includes being affected by gravity. We don't want that, so enable the <em>Is Kinematic</em> option of the rigidbody. That indicates that the object is immovable as far as the physics engine is concerned.</p>
						
						<figure>
							<img src="kill-zones/rigidbody.png" width="320" height="202">
							<figcaption>Kill zone with kinematic rigid body.</figcaption>
						</figure>
						
						<p>Now shapes that enter the zone immediately die, both when they move into or spawn in the zone. So you can use it to both cut holes in spawn zones and get rid of shapes that move into a forbidden area.</p>
						
						<figure>
							<img src="kill-zones/kill-zone-in-action.png" width="260" height="280">
							<figcaption>Kill zone is pruning shapes.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Slow Death</h3>
						
						<p>The effect of a kill zone doesn't need to be immediate. As with the manual or automatic destruction of shapes, we can add a dying duration to the zone. If this duration is positive then we add a dying behavior to the shape instead.</p>
						
						<pre>	<ins>[SerializeField]</ins>
	<ins>float dyingDuration;</ins>
	
	void OnTriggerEnter (Collider other) {
		var shape = other.GetComponent&lt;Shape>();
		if (shape) {
			<ins>if (dyingDuration &lt;= 0f) {</ins>
				shape.Die();
			<ins>}</ins>
			<ins>else {</ins>
				<ins>shape.AddBehavior&lt;DyingShapeBehavior>().Initialize(</ins>
					<ins>shape, dyingDuration</ins>
				<ins>);</ins>
			<ins>}</ins>
		}
	}</pre>
						
						<p>Again, we'll only do that if the shape isn't already dying.</p>
						
						<pre>			else <ins>if (!shape.IsMarkedAsDying)</ins> {
				shape.AddBehavior&lt;DyingShapeBehavior>().Initialize(
					shape, dyingDuration
				);
			}</pre>
						
						<figure>
							<img src="kill-zones/dying-duration.png" width="320" height="58" alt="inspector">
							<div class="vid" style="width:185px; height:185px;"><iframe src='https://gfycat.com/ifr/calmgooddanishswedishfarmdog?controls=0'></iframe></div>
							<figcaption>Dying duration set to two seconds.</figcaption>
						</figure>
						
						<aside>
							<h3>Why is memory allocated each time <code>OnTriggerEnter</code> is invoked?</h3>
							<div>
								<p>That happens because it invokes <code>GetComponent</code>, which allocates a little bit of memory. This memory allocation only happens when playing in the Unity Editor, because it dynamically creates an error message string, even if it isn't used. It doesn't happen in builds, which is one of the reasons why it's important to profile builds instead of only in the editor.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Animated Kill Zones</h3>
						
						<p>Like spawn zones, kill zone don't need to be fixed in place. They can be animated by making them a child of a rotating object.</p>
						
						<figure>
							<div class="vid" style="width:215px; height:215px;"><iframe src='https://gfycat.com/ifr/unsightlyinexperiencedblesbok?controls=0'></iframe></div>
							<figcaption>Rotating kill zone.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Life Zones</h3>
						
						<p>We can also take the concept of a kill zone and invert it. The result is a zone in which objects survive, but die as soon as they leave. This works exactly the same, except we need to use an <code>OnTriggerExit</code> method instead of <code>OnTriggerEnter</code>. Duplicate <code>KillZone</code> and turn it into a <code>LifeZone</code> component type with this change.</p>
						
						<pre>using UnityEngine;

public class <ins>LifeZone</ins> : MonoBehaviour {

	[SerializeField]
	float dyingDuration;

	void <ins>OnTriggerExit</ins> (Collider other) {
		var shape = other.GetComponent&lt;Shape>();
		if (shape) {
			if (dyingDuration &lt;= 0f) {
				shape.Die();
			}
			else if (!shape.IsMarkedAsDying) {
				shape.AddBehavior&lt;DyingShapeBehavior>().Initialize(
					shape, dyingDuration
				);
			}
		}
	}
}</pre>
						
						<figure>
							<div class="vid" style="width:195px; height:195px;"><iframe src='https://gfycat.com/ifr/secondadolescentirishdraughthorse?controls=0'></iframe></div>
							<figcaption>Leaving the zone means death.</figcaption>
						</figure>
						
						<p>Note that life zones only affect shapes that leave, which means that they must first enter. Thus, shapes that are spawned outside the zone are unaffected by it. But once they enter the zone leaving will mean death.</p>
					</section>
					
					<section>
						<h3>Gizmos</h3>
						
						<p>Just like for spawn zones, it's convenient to have a visual indication where kill and life zones are when designing a level. So let's give each an <code>OnDrawGizmos</code> method as well. But while each spawn zone has its own shape, the kill and life zones are defined by their collider. So we have to retrieve the collider and then figure out what type it is. First create a method for <code>KillZone</code>, with a magenta color.</p>
						
						<pre>	<ins>void OnDrawGizmos () {</ins>
		<ins>Gizmos.color = Color.magenta;</ins>
		<ins>Gizmos.matrix = transform.localToWorldMatrix;</ins>
		<ins>var c = GetComponent&lt;Collider>();</ins>
	<ins>}</ins></pre>
						
						<p>Let's support box and sphere colliders, as they're easiest. Try to cast the collider to <code>BoxCollider</code>. If that works, draw a wire cube and return. If that fails, try <code>SphereCollider</code>. If you want to support more visualizations you'd add them after that.</p>
						
						<pre>		var c = GetComponent&lt;Collider>();
		<ins>var b = c as BoxCollider;</ins>
		<ins>if (b != null) {</ins>
			<ins>Gizmos.DrawWireCube(b.center, b.size);</ins>
			<ins>return;</ins>
		<ins>}</ins>
		<ins>var s = c as SphereCollider;</ins>
		<ins>if (s != null) {</ins>
			<ins>Gizmos.DrawWireSphere(s.center, s.radius);</ins>
			<ins>return;</ins>
		<ins>}</ins></pre>
						
						<aside>
							<h3>What does <code>as</code> do?</h3>
							<div>
								<p>It is an operator that checks whether an object can be cast to a specific type. If so, it performs the cast. If not, the result is <code>null</code>.</p>
								<p>You could also do this explicitly by using the <code>is</code> operator to check whether the cast is possible, and if so cast, but that would require a redundant check.</p>
								
								<pre>		if (c is BoxCollider) {
			var b = (BoxCollider)c;
			Gizmos.DrawWireCube(b.center, b.size);
			return;
		}</pre>
							</div>
						</aside>
						
						<p>Copy the method to <code>LifeZone</code> and change the color to yellow.</p>
						
						<pre>	void OnDrawGizmos () {
		Gizmos.color = Color.<ins>yellow</ins>;
		&hellip;
	}</pre>
						
						<figure>
							<img src="kill-zones/gizmos.png" width="260" height="190">
							<figcaption>A spawn, kill, and life zone.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Colliders and Scale</h3>
						
						<p>The gizmos appear to work correctly, but things go wrong when you give a zone a scale that isn't uniform. Try this with a sphere collider. Our gizmo deforms as expected, but the collider visualization remains a sphere. This happens because the physics engine doesn't support deformed colliders. When playing, you'll find that indeed the collider's visualization matches the space affected by the zone.</p>
						
						<figure>
							<img src="kill-zones/gizmo-wrong-scale.png" width="200" height="200">
							<figcaption>Incorrect sphere scale.</figcaption>
						</figure>
						
						<p>What ends up happening is that the maximum absolute component of the collider's scale is used as its uniform scale. To reproduce this we have to create our own transformation matrix for the sphere gizmo. First, remove the usage of <code>localToWorldMatrix</code>.</p>
						
						<pre>		<del>//Gizmos.matrix = transform.localToWorldMatrix;</del></pre>
						
						<p>Then construct a custom matrix using the <code>Matrix4x4.TRS</code> method, with the world-space position, rotation, and lossy scale as separate arguments. Do this for both the box and sphere collider. That's enough to fix the box, but the sphere will need more work.</p>
						
						
						<pre>		if (b != null) {
			<ins>Gizmos.matrix = Matrix4x4.TRS(</ins>
				<ins>transform.position, transform.rotation, transform.lossyScale</ins>
			<ins>);</ins>
			Gizmos.DrawWireCube(b.center, b.size);
			return;
		}
		var s = c as SphereCollider;
		if (s != null) {
			<ins>Vector3 scale = transform.lossyScale;</ins>
			<ins>Gizmos.matrix = Matrix4x4.TRS(</ins>
				<ins>transform.position, transform.rotation, scale</ins>
			<ins>);</ins>
			Gizmos.DrawWireSphere(s.center, s.radius);
			return;
		}</pre>
						
						<aside>
							<h3>What's the lossy scale?</h3>
							<div>
								<p>It is an approximation of the object's scale in world space. It is an approximation because the object can be a child in an object hierarchy with a rotation inside a non-uniform scale, which deforms the object. That cannot be represented by just a scale, hence the wold-space scale is defined as lossy.</p>
							</div>
						</aside>
						
						<p>Next, set the sphere's scale to the maximum absolute component of the lossy scale.</p>
						
						<pre>			Vector3 scale = transform.lossyScale;
			<ins>scale = Vector3.one * Mathf.Max(</ins>
				<ins>Mathf.Abs(scale.x), Mathf.Abs(scale.y), Mathf.Abs(scale.z)</ins>
			<ins>);</ins></pre>
						
						<figure>
							<img src="kill-zones/gizmo-correct-scale.png" width="200" height="200">
							<figcaption>Correct sphere scale.</figcaption>
						</figure>
						
						<p>Apply the same changes to both <code>KillZone</code> and <code>LifeZone</code>.</p>
					</section>
					
					<section>
						<h3>Shape Colliders</h3>
						
						<p>While we're dealing with colliders, let's take a look at the colliders used by our shapes. The simple shapes are fine, but the complex shapes each consist of multiple objects, so also have multiple colliders. The trigger event method will get invoked for all their colliders, but only the collider attached to the root game object that has the <code>Shape</code> component will cause death. For example, only one of the colliders of the composite capsule is used.</p>
						
						<figure>
							<img src="kill-zones/composite-capsule-three-collider.png" width="220" height="220">
							<figcaption>Composite capsule, three colliders.</figcaption>
						</figure>
						
						<p>We can solve this by removing the colliders from the two child objects and adding them to the root object. But we can go a step further. We only care about interaction with zones, which doesn't need to be very precise. So we can make do with a single sphere collider instead, which reduces the memory footprint of the shape and speeds up the physics engine.</p>
						
						<figure>
							<img src="kill-zones/composite-capsule-one-collider.png" width="226" height="226">
							<figcaption>Only one collider.</figcaption>
						</figure>
						
						<p>A default sphere collider will fit the entire shape inside it, but extends quite a bit beyond most of it. So let's reduce its radius to 0.9.</p>
						
						<figure>
							<img src="kill-zones/composite-capsule-reduced-radius.png" width="200" height="200">
							<figcaption>Collider radius reduced to 0.9.</figcaption>
						</figure>
						
						<p>Likewise, we can make do with a single sphere collider for the composite cube, with a radius of 0.8.</p>
						
						<figure>
							<img src="kill-zones/composite-cube.png" width="200" height="200">
							<figcaption>Composite cube, one collider.</figcaption>
						</figure>
						
						<p>And in case of the cube-with-sphere shape we can simply remove the sphere collider of its child object, using only the box collider.</p>
					</section>
					
					<section>
						<h3>Layers</h3>
						
						<p>By mixing spawn, kill, and life zones we can create interesting shape patterns and behavior, but we're limited by the fact that the kill and life zones affect all shapes that touch them. For example, we cannot currently create a region where some shapes can live while others will die. But it is possible to use layers to control which physics entities are able to interact. So all we have to do is assign layers to shapes and zones.</p>
						
						<p>Instead of defining the layer per shape prefab, we'll define them per spawn zone. The zone's layer can be set in the top of the inspector window.</p>
						
						<figure>
							<img src="kill-zones/default-layer.png" width="320" height="48">
							<figcaption>Spawn zone on default layer.</figcaption>
						</figure>
						
						<p>When <code>SpawnZone</code> spawns a shape, have it move the shape to its own layer. That can be done by copying the <code>layer</code> property from one game object to the other.</p>
						
						<pre>	public virtual void SpawnShapes () {
		int factoryIndex = Random.Range(0, spawnConfig.factories.Length);
		Shape shape = spawnConfig.factories[factoryIndex].GetRandom();
		<ins>shape.gameObject.layer = gameObject.layer;</ins>
		&hellip;
	}

	void CreateSatelliteFor (Shape focalShape, Vector3 lifecycleDurations) {
		int factoryIndex = Random.Range(0, spawnConfig.factories.Length);
		Shape shape = spawnConfig.factories[factoryIndex].GetRandom();
		<ins>shape.gameObject.layer = gameObject.layer;</ins>
		&hellip;
	}</pre>
						
						<p>Unity has a few predefined layers that all interact with each other. We'll leave those unchanged and instead add some new layers. That's done via the <em>Tags & Layers</em> window, which you can open via the <em>Layer</em> dropdown menu of a game object and choosing the <em>Add Layer...</em> option. I'll just add two layers, named A and B.</p>
						
						<figure>
							<img src="kill-zones/custom-layers.png" width="320" height="288">
							<figcaption>Custom layers A and B.</figcaption>
						</figure>
						
						<p>Which layers interact can be adjusted via the <em>Physics</em> window under <em>Edit / Project Settings</em>. It contains a matrix with interaction toggles. Disabled the interaction of the relevant layers.</p>
						
						<figure>
							<img src="kill-zones/layer-interaction.png" width="200" height="200">
							<figcaption>Layers A and B don't interact.</figcaption>
						</figure>
						
						<p>Now you can control which shapes are killed by which zones. Shapes spawned by A zones are killed by A zones, but not by B zones, and vice versa. Shapes spawned by zones on the default layer are killed by both A and B zones. And zones on the default layer kill all shapes.</p>
						
						<figure>
							<div class="vid" style="width:145px; height:255px;"><iframe src='https://gfycat.com/ifr/complicatedbiodegradableasp?controls=0'></iframe></div>
							<figcaption>Selective killing.</figcaption>
						</figure>
						
					</section>
				</section>
				
				<section>
					<h2>Updating Level Objects</h2>
					
					<p>Having lots of automatic spawn zones and rotating objects means that Unity is once again invoking <code>FixedUpdate</code> methods on multiple objects. Like we did for shapes, we can also consolidate those invocations with our own <code>GameUpdate</code> approach. Besides being a potential performance improvement for complex levels, this also makes it possible to exactly control the update order of everything in our game.</p>
					
					<section>
						<h3>Game Level Objects</h3>
						
						<p>Introduce a new <code>GameLevelObject</code> type, which extends <code>PersistableObject</code> and adds a virtual <code>GameUpdate</code> method.</p>
						
						<pre><ins>public class GameLevelObject : PersistableObject {</ins>

	<ins>public virtual void GameUpdate () {}</ins>
<ins>}</ins></pre>
						
						<p>Change <code>RotatingObject</code> so it extends <code>GameLevelObject</code> instead of <code>PersistableObject</code>. Then change its <code>FixedUpdate</code> method so it becomes <code>GameUpdate</code>.</p>
						
						<pre>public class RotatingObject : <ins>GameLevelObject</ins> {

	[SerializeField]
	Vector3 angularVelocity;

	<del>//void FixedUpdate () {</del>
	<ins>public override void GameUpdate () {</ins>
		transform.Rotate(angularVelocity * Time.deltaTime);
	}
}</pre>
						
						<p>Do the same for <code>SpawnZone</code>.</p>
						
						<pre>public abstract class SpawnZone : <ins>GameLevelObject</ins> {

	&hellip;
	
	<del>//void FixedUpdate () {</del>
	<ins>public override void GameUpdate () {</ins>
		spawnProgress += Time.deltaTime * spawnSpeed;
		while (spawnProgress >= 1f) {
			spawnProgress -= 1f;
			SpawnShapes();
		}
	}

	&hellip;
}</pre>
						
						<p>If you have other active level object types, change those too.</p>
					</section>
					
					<section>
						<h3>Refactoring Game Level</h3>
						
						<p>To make the level objects update again we have to invoke their <code>GameUpdate</code> methods. To make that possible, change the type of the <code>GameLevel.persistentObjects</code> elements to <code>GameLevelObject</code>. Because it extends <code>PersistableObject</code> all references in the level scenes remain intact.</p>
						
						<pre>	[SerializeField]
	<ins>GameLevelObject</ins>[] persistentObjects;

	&hellip;

	void OnEnable () {
		Current = this;
		if (persistentObjects == null) {
			persistentObjects = new <ins>GameLevelObject</ins>[0];
		}
	}</pre>
						
						<p>As the <code>persistentObject</code> name is no longer accurate, it makes sense to refactor rename the field to <code>levelObjects</code>. However, if we do that the scenes will lose their data. To prevent that, we can tell Unity that we want it to use the old data, if it still exists in the scene asset. That's done by giving it the <code>FormerlySerializedAs</code> attribute from the <code>UnityEngine.Serialization</code> namespace, with its old name as a string argument.</p>
						
						<pre>	<ins>[UnityEngine.Serialization.FormerlySerializedAs("persistentObjects")]</ins>
	[SerializeField]
	GameLevelObject[] levelObjects;</pre>
						
						<figure>
							<img src="updating-level-objects/level-objects.png" width="320" height="146">
							<figcaption>Now known as level objects.</figcaption>
						</figure>
						
						<aside>
							<h3>How long do we have to keep the <code>FormerlySerializedAs</code> attribute?</h3>
							<div>
								<p>You can keep it forever, as it doesn't get in the way of anything. You can remove it once you're sure that there are no old scenes left. Just opening a scene and directly saving it isn't enough, you have to make a change so the editor decides that there is a reason to write the scene asset file.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Updating the Objects</h3>
						
						<p>It is now up to <code>GameLevel</code> to update all its level objects. Give it its own public <code>GameUpdate</code> method for this purpose.</p>
						
						<pre>	<ins>public void GameUpdate () {</ins>
		<ins>for (int i = 0; i &lt; levelObjects.Length; i++) {</ins>
			<ins>levelObjects[i].GameUpdate();</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Finally, have <code>Game</code> invoke the current level's <code>GameUpdate</code> method, as part of its update loop. Update the level after the shapes, so shapes that are automatically spawned aren't immediately updated.</p> 
						
						<pre>	void FixedUpdate () {
		inGameUpdateLoop = true;
		for (int i = 0; i &lt; shapes.Count; i++) {
			shapes[i].GameUpdate();
		}
		<ins>GameLevel.Current.GameUpdate();</ins>
		inGameUpdateLoop = false;

		&hellip;
	}</pre>
					</section>
					
				</section>
				
				<section>
					<h2>Editing Game Level Objects</h2>
					
					<p>Centralizing the update of level objects gives us total control, but it also requires that we keep the level objects array of each level up to date. We have to do this manually, but we can add a little editor functionality to make this easier.</p>
					
					<section>
						<h3>Missing Objects</h3>
						
						<p>If we forget to add a level object to the array the level is still valid. The object just won't update, which we should notice soon enough. But when designing a level it's not uncommon to delete objects, which causes trouble if they've been added to the array. The missing objects create holes that will generate exceptions in play mode.</p>
						
						<figure>
							<img src="editing-game-level-objects/missing-object.png" width="320" height="108">
							<figcaption>One object is missing.</figcaption>
						</figure>
						
						<p>We could have <code>GameLevel</code> skip missing objects, but such errors should be taken care of during the design process. Checking the inspector of the level object should be sufficient to spot missing objects, but they can be hard to notice. So let's make it more obvious.</p>
						
						<p>First, we need a way to determine that we have missing level objects. Add a <code>HasMissingLevelObjects</code> getter property that checks this, returning <code>true</code> when a hole is found and <code>false</code> otherwise. As we'll use the property in the Unity editor the <code>levelObjects</code> array might not exist yet, so we'll have to check that too.</p>
						
						<pre>	<ins>public bool HasMissingLevelObjects {</ins>
		<ins>get {</ins>
			<ins>if (levelObjects != null) {</ins>
				<ins>for (int i = 0; i &lt; levelObjects.Length; i++) {</ins>
					<ins>if (levelObjects[i] == null) {</ins>
						<ins>return true;</ins>
					<ins>}</ins>
				<ins>}</ins>
			<ins>}</ins>
			<ins>return false;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Next, create a custom inspector class for <code>GameLevel</code> in an <em>Editor</em> folder. That's done by extending <code>Editor</code> and attaching the <code>CustomEditor</code> attribute to it with the <code>GameLevel</code> type as an argument. We'll tweak the inspector by overriding the <code>OnInspectorGUI</code> method. We reproduce the default inspector by invoking <code>DrawDefaultInspector</code>.</p>
						
						<pre><ins>using UnityEditor;</ins>
<ins>using UnityEngine;</ins>

<ins>[CustomEditor(typeof(GameLevel))]</ins>
<ins>public class GameLevelInspector : Editor {</ins>

	<ins>public override void OnInspectorGUI () {</ins>
		<ins>DrawDefaultInspector();</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>The component being edited can be accessed via the <code>target</code> property. After casting it to <code>GameLevel</code> we can check whether it has missing level objects. If so, make this visually obvious by showing an error message underneath the default inspector. That's done by invoking <code>EditorGUILayout.HelpBox</code> with a string and the error message type.</p>
						
						<pre>		DrawDefaultInspector();

		<ins>var gameLevel = (GameLevel)target;</ins>
		<ins>if (gameLevel.HasMissingLevelObjects) {</ins>
			<ins>EditorGUILayout.HelpBox("Missing level objects!", MessageType.Error);</ins>
		<ins>}</ins></pre>
						
						<figure>
							<img src="editing-game-level-objects/error-message.png" width="320" height="152">
							<figcaption>Something is obviously wrong.</figcaption>
						</figure>
						
					</section>
					
					<section>
						<h3>Removing Missing Elements</h3>
						
						<p>Level objects should never be removed, because that would make it impossible to load old data of the level. But when designing an unreleased level we can do as we like. As we're already showing a message when there are missing objects, let's go a step further and also provide a simple way to get rid of all the holes in the array.</p>
						
						<p>Add a public <code>RemoveMissingLevelObjects</code> method to <code>GameLevel</code>. Begin by looping through the array and only counting the holes.</p>
						
						<pre>	<ins>public void RemoveMissingLevelObjects () {</ins>
		<ins>int holes = 0;</ins>
		<ins>for (int i = 0; i &lt; levelObjects.Length; i++) {</ins>
			<ins>if (levelObjects[i] == null) {</ins>
				<ins>holes += 1;</ins>
			<ins>}</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Each time we encounter a hole we have to close it, by shifting the rest of the array up one element. We can do that by invoking the <code>System.Array.Copy</code> method. Its first and third arguments are the source and destination array, which are both <code>levelObjects</code> in this case. Its second argument is the index to start copying from and the fourth argument is the first index where it should be copied to. Its final argument is the amount of elements to copy, which is the array's length minus the iterator and the hole.</p>
						
						<pre>			if (levelObjects[i] == null) {
				holes += 1;
				<ins>System.Array.Copy(</ins>
					<ins>levelObjects, i + 1, levelObjects, i,</ins>
					<ins>levelObjects.Length - i - 1</ins>
				<ins>);</ins>
			}</pre>
						
						<p>Each time we encounter a hole we shift the array, so we should again visit the same index in case we shifted another hole into it. So decrement the iterator after copying. But we've dealt with one element so should reduce the amount of iterations to match. That can be done by subtracting the amount of holes encountered so far from the array's length in the loop's condition. Likewise, we don't have to copy redundant elements at the end of the array, which we can avoid by subtracting all holes from the amount to copy, instead of always subtracting just one.</p>
						
						<pre>		for (int i = 0; i &lt; levelObjects.Length <ins>- holes</ins>; i++) {
			if (levelObjects[i] == null) {
				holes += 1;
				System.Array.Copy(
					levelObjects, i + 1, levelObjects, i,
					levelObjects.Length - i - <ins>holes</ins>
				);
				<ins>i -= 1;</ins>
			}
		}</pre>
						
						<p>Once we're done with that we have to get rid of the redundant tail of the array, by reducing its length by the number of holes. We can use <code>System.Array.Resize</code> for that, with the array as a reference parameter along with its new length.</p>
						
						<pre>		for (int i = 0; i &lt; levelObjects.Length - holes; i++) {
			&hellip;
		}
		<ins>System.Array.Resize(ref levelObjects, levelObjects.Length - holes);</ins></pre>
						
						<aside>
							<h3>Wouldn't this be easier if we used <code>List</code>?</h3>
							<div>
								<p>Yes, but <code>levelObjects</code> is an array because the idea is that it never changes during play. So we don't need the extra functionality and overhead provided by <code>List</code>, except in this editor-only case. Making it a list would suggest that it's fine to change during play, which isn't how we designed it.</p>
							</div>
						</aside>
						
						<p>Add a button underneath the error message in our custom inspector, by invoking <code>GUILayout.Button</code> with a label. It returns true when the button got pressed, in which case we'll invoke our new <code>RemoveMissingLevelObjects</code> method.</p>
						
						<pre>			EditorGUILayout.HelpBox("Missing level objects!", MessageType.Error);
			<ins>if (GUILayout.Button("Remove Missing Elements")) {</ins>
				<ins>gameLevel.RemoveMissingLevelObjects();</ins>
			<ins>}</ins></pre>
						
						<p>To make this work with Unity's undo system, invoke <code>Undo.RecordObject</code> with the game level and a label before making the change.</p>
						
						<pre>			if (GUILayout.Button("Remove Missing Elements")) {
				<ins>Undo.RecordObject(gameLevel, "Remove Missing Level Objects.");</ins>
				gameLevel.RemoveMissingLevelObjects();
			}</pre>
						
						<figure>
							<img src="editing-game-level-objects/remove-missing-elements.png" width="320" height="68">
							<figcaption>Button to remove missing elements.</figcaption>
						</figure>
						
						<p>The idea is that <code>RemoveMissingLevelObjects</code> only gets invoked while editing the level. Let's enforce that by checking whether <code>Application.isPlayer</code> returns <code>true</code>. If so, log an error and abort the method.</p>
						
						<pre>	public void RemoveMissingLevelObjects () {
		<ins>if (Application.isPlaying) {</ins>
			<ins>Debug.LogError("Do not invoke in play mode!");</ins>
			<ins>return;</ins>
		<ins>}</ins>

		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Registering Game Level Objects</h3>
						
						<p>We can also make it easier to add level objects to level's array. Add a public <code>RegisterLevelObject</code> method to <code>GameLevel</code> for that, with a level object parameter. If there isn't a <code>levelObjects</code> array yet, create one with the provided object. Otherwise, increase the size of the array by one and assign the object to its last element. Again, we only support this while not in play mode.</p>
						
						<pre>	<ins>public void RegisterLevelObject (GameLevelObject o) {</ins>
		<ins>if (Application.isPlaying) {</ins>
			<ins>Debug.LogError("Do not invoke in play mode!");</ins>
			<ins>return;</ins>
		<ins>}</ins>
		
		<ins>if (levelObjects == null) {</ins>
			<ins>levelObjects = new GameLevelObject[] { o };</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>System.Array.Resize(ref levelObjects, levelObjects.Length + 1);</ins>
			<ins>levelObjects[levelObjects.Length - 1] = o;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Each level object should only be included in the array once. Add a public <code>HasLevelObject</code> method to check whether the array already contains the provided object. That makes it possible to check if it is correct to invoke <code>RegisterLevelObject</code>, but also have that method verify this on its own and abort if needed.</p>
						
						<pre>	<ins>public bool HasLevelObject (GameLevelObject o) {</ins>
		<ins>if (levelObjects != null) {</ins>
			<ins>for (int i = 0; i &lt; levelObjects.Length; i++) {</ins>
				<ins>if (levelObjects[i] == o) {</ins>
					<ins>return true;</ins>
				<ins>}</ins>
			<ins>}</ins>
		<ins>}</ins>
		<ins>return false;</ins>
	<ins>}</ins>
	
	public void RegisterLevelObject (GameLevelObject o) {
		if (Application.isPlaying) {
			Debug.LogError("Do not invoke in play mode!");
			return;
		}

		<ins>if (HasLevelObject(o)) {</ins>
			<ins>return;</ins>
		<ins>}</ins>

		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Register Menu Item</h3>
						
						<p>We're going to add an item to Unity's menu to register a selected level object to the appropriate game level. Let's put the code for the menu item in its own static class, inside an <em>Editor</em> folder. The menu item is created by attaching the <em>MenuItem</em> attribute to a static method, with the item's menu path as an argument. We'll make it available via <em>GameObject / Register Level Object</em>.</p>
						
						<pre><ins>using UnityEditor;</ins>
<ins>using UnityEngine;</ins>

<ins>static class RegisterLevelObjectMenuItem {</ins>

	<ins>[MenuItem("GameObject/Register Level Object")]</ins>
	<ins>static void RegisterLevelObject () {}</ins>
<ins>}</ins></pre>
						
						<p>The currently selected game object can be accessed via <code>Selection.activeGameObject</code>.</p>
						
						<pre>	static void RegisterLevelObject () {
		<ins>GameObject o = Selection.activeGameObject;</ins>
	}</pre>
						
						<p>If there is no such object, log a warning and abort.</p>
						
						<pre>		GameObject o = Selection.activeGameObject;

		<ins>if (o == null) {</ins>
			<ins>Debug.LogWarning("No level object selected.");</ins>
			<ins>return;</ins>
		<ins>}</ins></pre>
						
						<p>If a game object is selected, it's either a scene object or part of a prefab asset. We can only register objects in scenes, so should abort if it turns out to be a prefab. We can check that by invoking <code>PrefabUtility.GetPrefabType</code> with the object as an argument. If the result indicates a prefab then we should abort after logging a warning. Provide the object as an additional parameter when logging, so it gets temporarily highlighted in the editor.</p>
						
						<pre>		if (o == null) {
			Debug.LogWarning("No level object selected.");
			return;
		}

		<ins>if (PrefabUtility.GetPrefabType(o) == PrefabType.Prefab) {</ins>
			<ins>Debug.LogWarning(o.name + " is a prefab asset.", o);</ins>
			<ins>return;</ins>
		<ins>}</ins></pre>
						
						<p>Next, get the <code>GameLevelObject</code> component. If there isn't one, abort.</p>
						
						<pre>		if (PrefabUtility.GetPrefabType(o) == PrefabType.Prefab) {
			Debug.LogWarning(o.name + " is a prefab asset.", o);
			return;
		}

		<ins>var levelObject = o.GetComponent&lt;GameLevelObject>();</ins>
		<ins>if (levelObject == null) {</ins>
			<ins>Debug.LogWarning(o.name + " isn't a game level object.", o);</ins>
			<ins>return;</ins>
		<ins>}</ins></pre>
						
						<p>If we got this far, we must find the appropriate game level to register to. We're going to assume that the level object is always a root object of its scene. Get the object's scene via its <code>scene</code> property. Then loop through the scene's root object array, accessible via its <code>GetRootGameObjects</code> method. If a game level is found, return for now. Otherwise, log a warning.</p>
						
						<pre>		if (levelObject == null) {
			Debug.LogWarning(o.name + " isn't a game level object.", o);
			return;
		}

		<ins>foreach (GameObject rootObject in o.scene.GetRootGameObjects()) {</ins>
			<ins>var gameLevel = rootObject.GetComponent&lt;GameLevel>();</ins>
			<ins>if (gameLevel != null) {</ins>
				<ins>return;</ins>
			<ins>}</ins>
		<ins>}</ins>
		<ins>Debug.LogWarning(o.name + " isn't part of a game level.", o);</ins></pre>
						
						<aside>
							<h3>How does <code>foreach</code> work?</h3>
							<div>
								<p><code>foreach</code> is a convenient alternative of a <code>for</code> loop if you don't need the index. When used with an array, it's just syntactic sugar. You could also write the following:</p>
								
								<pre>		GameObject[] rootObjects = o.scene.GetRootGameObjects();
		for (int i = 0; i &lt; rootObjects.length; i++) {
			var rootObject = rootObjects[i];
			&hellip;
		}</pre>
								
								<p>However, this is not true when looping over other collections or enumerators, including <code>List</code>. In those cases <code>foreach</code> creates a temporary iterator object, which allocates memory. So the rule of thumb is to not rely on <code>foreach</code> for your game logic. It's fine for arrays, but if those get refactored to lists at some point you'll suddenly get temporary memory allocations in your game.</p>
							</div>
						</aside>
						
						<p>If we found the game level, check whether the object has already been registered and abort if that is the case.</p>
												
						<pre>		foreach (GameObject rootObject in o.scene.GetRootGameObjects()) {
			var gameLevel = rootObject.GetComponent&lt;GameLevel>();
			if (gameLevel != null) {
				<ins>if (gameLevel.HasLevelObject(levelObject)) {</ins>
					<ins>Debug.LogWarning(o.name + " is already registered.", o);</ins>
					<ins>return;</ins>
				<ins>}</ins>
				return;
			}
		}</pre>
						
						<p>If we're still going, then we can finally register the object, after recording the game level for the undo system. Let's also log what got registered where, so the designer can be sure that it worked and not silently failed.</p>
						
						<pre>				if (gameLevel.HasLevelObject(levelObject)) {
					Debug.LogWarning(o.name + " is already registered.", o);
					return;
				}
				
				<ins>Undo.RecordObject(gameLevel, "Register Level Object.");</ins>
				<ins>gameLevel.RegisterLevelObject(levelObject);</ins>
				<ins>Debug.Log(</ins>
					<ins>o.name + " registered to game level " +</ins>
					<ins>gameLevel.name + " in scene " + o.scene.name + ".", o</ins>
				<ins>);</ins>
				return;</pre>
					</section>
					
					<section>
						<h3>Multiselection</h3>
						
						<p>We don't have to limit the menu item to work with only a single object. Let's make it possible for the designer to select multiple level objects and register them all at once, even if they're part of different levels. We do that by looping through <code>Selection.objects</code> instead of only using <code>Selection.activeGameObject</code>. In this case we're dealing with <code>Object</code> references. So cast each to <code>GameObject</code> if possible and pass the result to the original code, moved to a separate method.</p>
						
						<pre>	[MenuItem("GameObject/Register Level Object")]
	static void RegisterLevelObject () {
		<ins>foreach (Object o in Selection.objects) {</ins>
			<ins>Register(o as GameObject);</ins>
		<ins>}</ins>
	<ins>}</ins>

	<ins>static void Register (GameObject o) {</ins>
		<del>//GameObject o = Selection.activeGameObject;</del>

		&hellip;
	}</pre>
						
						<p>It is now possible for our menu item to get invoked while having a mix of assets and scene objects selected, which doesn't make sense. Ideally, the menu item should only be enabled when nothing but game objects are selected. We can enforce that via a validation method.</p>
						
						<p>A validation method works the same as a regular menu item method, except that its attribute has <code>true</code> as an additional argument and it returns whether the menu item should be enabled. By default, all items are always enabled.</p>
						
						<pre>	<ins>const string menuItem = "GameObject/Register Level Object";</ins>

	<ins>[MenuItem(menuItem, true)]</ins>
	<ins>static bool ValidateRegisterLevelObject () {</ins>
		<ins>return true;</ins>
	<ins>}</ins>

	[MenuItem(<ins>menuItem</ins>)]
	static void RegisterLevelObject () {
		&hellip;
	}</pre>
						
						<p>Our item works on a selection, so if nothing is selected&mdash;the array's length is zero&mdash;then it shouldn't be enabled.</p>
						
						<pre>	static bool ValidateRegisterLevelObject () {
		<ins>if (Selection.objects.Length == 0) {</ins>
			<ins>return false;</ins>
		<ins>}</ins>
		return true;
	}</pre>
						
						<p>And when at least one of the selected objects isn't a game object our menu item should also be disabled.</p>
						
						<pre>		if (Selection.objects.Length == 0) {
			return false;
		}
		<ins>foreach (Object o in Selection.objects) {</ins>
			<ins>if (!(o is GameObject)) {</ins>
				<ins>return false;</ins>
			<ins>}</ins>
		<ins>}</ins>
		return true;</pre>
						
						<p>Now we can do away with the <code>null</code> check, because we're guaranteed to work on game objects.</p>
						
						<pre>	<ins>static void Register (GameObject o) {</ins>
		<del>//if (o == null) {</del>
		<del>//	Debug.LogWarning("No level object selected.");</del>
		<del>//	return;</del>
		<del>//}</del>
		
		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Editor-Only Game Level Code</h3>
						
						<p>This all works, but we now have some code in <code>GameLevel</code> that is only used in the Unity editor, so it doesn't need to be included in builds. We can ensure that by using conditional compilation. However, that still mixes editor-only code with other code. It would be convenient if we could extract the editor-only code and put it in a separate asset file. That's possible by using partial classes.</p>
						
						<aside>
							<h3>What are partial classes?</h3>
							<div>
								<p>It's a way to split a class&mdash;or struct&mdash;definition into multiple parts, stored in different files. The only purpose is to organize code. The typical use case is to keep automatically-generated code separate from manually-written code. As far as the compiler is concerned, it's all part of the same class definition.
							</div>
						</aside>
						
						<p>First, add the <code>partial</code> keyword to <code>GameLevel</code>. On its own, this doesn't change anything.</p>
						
						<pre>public <ins>partial</ins> class GameLevel : PersistableObject { &hellip; }</pre>
						
						<p>Next, duplicate the <code>GameLevel</code> asset file and rename it. The typical naming convention for partial classes is to use <em>ClassName.Purpose.cs</em> for additional partial class files. As we're separating editor-only code, name it <em>GameLevel.Editor</em>.</p>
						
						<figure>
							<img src="editing-game-level-objects/partial-class.png" width="228" height="32">
							<figcaption>Two assets for the same class.</figcaption>
						</figure>
						
						<p>Open the new file and remove all code except the class definition itself, <code>HasMissingLevelObjects</code>, <code>HasLevelObject</code>, <code>RegisterLevelObject</code>, and <code>RemoveMissingLevelObjects</code>. Or start with an empty file and add the required code. The class definition only has to include <code>partial class GameLevel</code>. You can add <code>public</code> and the extension declaration too, but that's not required. Either leave it all out or use the exact same class declaration.</p>
						
						<pre><ins>using UnityEngine;</ins>

<ins>partial class GameLevel {</ins>

	<ins>public bool HasMissingLevelObjects { &hellip; }</ins>

	<ins>public bool HasLevelObject (GameLevelObject o) { &hellip; }</ins>

	<ins>public void RegisterLevelObject (GameLevelObject o) { &hellip; }</ins>

	<ins>public void RemoveMissingLevelObjects () { &hellip; }</ins>
<ins>}</ins></pre>
						
						<p>Now we can make do with a single conditional compilation block, wrapping the whole class.</p>
						
						<pre><ins>#if UNITY_EDITOR</ins>

using UnityEngine;

partial class GameLevel { &hellip; }

<ins>#endif</ins></pre>
						
						<p>Finally, remove the identical code from the original class definition, because that has become duplicate code.</p>
						
						<p>This concludes the <a href="../index.html">Object Management</a> series. You should have a decent grasp of how to manage objects in Unity at this point. Want to know when the next tutorial series starts? Keep tabs on my <a href="https://www.patreon.com/catlikecoding">Patreon</a> page!
					</section>
									
					<a href="https://bitbucket.org/catlikecodingunitytutorials/object-management-12-more-complex-levels/" class="repository">repository</a>
					<a href="More-Complex-Levels.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>