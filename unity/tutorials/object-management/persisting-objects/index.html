<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/tutorial-image.jpg">
		<meta property="og:title" content="Persisting Objects">
		<meta property="og:description" content="A Unity Object Management tutorial about persisting object data between game sessions.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Persisting Objects</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/#article",
				"headline": "Persisting Objects",
				"alternativeHeadline": "Creating, Saving, and Loading",
				"datePublished": "2018-04-18",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Object Management tutorial about persisting object data between game sessions.",
				"image": "https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/tutorial-image.jpg",
				"dependencies": "Unity 2017.3.1p4",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/object-management/", "name": "Object Management" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				Game: 1,
				GameDataReader: 1,
				GameDataWriter: 1,
				PersistableObject: 1,
				PersistentStorage: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Object Management</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Persisting Objects</h1>
					<p>Creating, Saving, and Loading</p>
					<ul>
						<li>Spawn random cubes in response to a key press.</li>
						<li>Use a generic type and virtual methods.</li>
						<li>Write data to a file and read it back.</li>
						<li>Save the game state so it can be loaded later.</li>
						<li>Encapsulate the details of persisting data.</li>
					</ul>
				</header>
				
				<p>This is the first tutorial in a series about managing objects. It covers creating, tracking, saving, and loading simple prefab instances. It builds on the foundation laid by the tutorials in the <a href="../../basics/index.html">Basics</a> section.
				
				<p>This tutorial is made with Unity 2017.3.1p4.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>These cubes survived the termination of their game.</figcaption>
				</figure>
				
				<section>
					<h2>Creating Objects On Demand</h2>
					
					<p>You can create scenes in the Unity editor and populate them with object instances. This allows you to design fixed levels for your game. The objects can have behavior attached to them, which can alter the state of the scene while in play mode. Often, new object instances are created during play. Bullets are fired, enemies spawn, random loot appears, and so on. It might even be possible for players to create custom levels inside the game.</p>
					
					<p>Creating new stuff during play is one thing. Remembering it all, so the player can quit and later return to the game is something else. Unity doesn't automatically keep track of the potential changes for us. We have to do that ourselves.</p>
					
					<p>In this tutorial we'll create a very simple game. All it does is spawn random cubes in response to pressing a key. Once we're able to keep track of the cubes between play sessions, we can increase the game's complexity in a later tutorial.</p>
					
					<section>
						<h3>Game Logic</h3>
						
						<p>Because our game is so simple, we'll control it with a single <code>Game</code> component script. It will spawn cubes, for which we'll use a prefab. So it should contain a public field to hook up a prefab instance.</p>

						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public class Game : MonoBehaviour {</ins>

	<ins>public Transform prefab;</ins>
<ins>}</ins></pre>
						
						<p>Add a game object to the scene and attach this component to it. Then also create a default cube, turn it into a prefab, and give the game object a reference to it.</p>

						<figure>
							<img alt="inspector" src="creating-objects-on-demand/game-inspector.png" width="320" height="123">
							<img alt="hierarchy and project" src="creating-objects-on-demand/hierarchy-project.png" width="438" height="102">
							<figcaption>Game setup.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Player Input</h3>
						
						<p>We're going to spawn cubes in response to player input, so our game must be able to detect this. We'll use Unity's input system to detect key presses. Which key should be used to spawn a cube? The C key seems appropriate, but we can make this configurable via the inspector, by adding a public <code>KeyCode</code> enumeration field to <code>Game</code>. Use C as the default option when defining the field, via an assignment.</p>
						
						<pre translate="no">	<ins>public KeyCode createKey = KeyCode.C;</ins></pre>
						
						<figure>
							<img src="creating-objects-on-demand/create-key.png" width="320" height="74">
							<figcaption>Create key set to C.</figcaption>
						</figure>
						
						<p>We can detect whether the key is pressed by querying the static <code>Input</code> class in an <code>Update</code> method. The <code>Input.GetKeyDown</code> method returns a boolean that tells us whether a specific key was pressed in the current frame. If so, we have to instantiate our prefab.</p>
						
						<pre translate="no">	<ins>void Update () {</ins>
		<ins>if (Input.GetKeyDown(createKey)) {</ins>
			<ins>Instantiate(prefab);</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<aside>
							<h3>When exactly does <code>Input.GetKeyDown</code> return <code>true</code>?</h3>
							<div>
								<p>It does so only during the frame that the key's state has changed from not-pressed to pressed, because the player pressed on it. Typically, the key remains in the pressed state for a few frames until the player lets go of the button, but <code>Input.GetKeyDown</code> returns <code>true</code> only during the first frame. In contrast, <code>Input.GetKey</code> keeps returning <code>true</code> each frame that the key is held down. There is also <code>Input.GetKeyUp</code>, which returns <code>true</code> during the frame that the player let go of the key.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Randomized Cubes</h3>
						
						<p>While in play mode, our game now spawns a cube each time we press the C key, or whichever key you configured it to respond to. But it looks like we only get a single cube, because they all end up at the same position. So let's randomize the position of each cube that we create.</p>
						
						<p>Keep track of the instantiated <code>Transform</code> component, so we can change its local position. Use the static <code>Random.insideUnitSphere</code> property to get a random point, scale it up to a radius of five units, and use that as the final position. Because that's more work than just a trivial instantiation, put the code for that in a separate <code>CreateObject</code> method and invoke it when the key is pressed.</p>
						
						<pre translate="no">	void Update () {
		if (Input.GetKeyDown(createKey)) {
<del>//			Instantiate(prefab);</del>
			<ins>CreateObject();</ins>
		}
	}

	<ins>void CreateObject () {</ins>
		<ins>Transform t = Instantiate(prefab);</ins>
		<ins>t.localPosition = Random.insideUnitSphere * 5f;</ins>
	<ins>}</ins></pre>
						
						<figure>
							<img src="creating-objects-on-demand/random-position.png" width="240" height="210">
							<figcaption>Randomly placed cubes.</figcaption>
						</figure>
						
						<p>The cubes now spawn inside a sphere instead of all at the exact same position. They can still overlap, but that's fine. However, they're all aligned and that doesn't look interesting. So let's give each cube a random rotation, for which we can use the static <code>Random.rotation</code> property.</p>
						
						<pre translate="no">	void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		<ins>t.localRotation = Random.rotation;</ins>
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/creating-objects-on-demand/random-rotation.png" width="240" height="210">
							<figcaption>Randomized rotations.</figcaption>
						</figure>
						
						<p>Finally, we can also vary the size of the cubes. We'll use uniformly-scaled cubes, so they're always perfect cubes, just with different sizes. The static <code>Random.Range</code> method can be used to get a random <code>float</code> inside a certain range. Let's go from small size 0.1 cubes up to regular size 1 cubes. To use this value for all three dimensions of the scale, simple multiply <code>Vector3.one</code> with it, then assign the result to the local scale.</p>
						
						<pre translate="no">	void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		t.localRotation = Random.rotation;
		<ins>t.localScale = Vector3.one * Random.Range(0.1f, 1f);</ins>
	}</pre>
						
						<figure>
							<img src="creating-objects-on-demand/random-scale.png" width="240" height="210">
							<figcaption>Randomized uniform scale.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Starting a New Game</h3>
						
						<p>If we want to begin a new game, we have to exit play mode and then enter it again. But that's only possible in the Unity Editor. The player would need to quit our app and start it again to be able to play a new game. It's much better if we could begin a new game while remaining in play mode.</p>
						
						<p>We could start a new game by reloading the scene, but this isn't necessary. We can suffice with destroying all the cubes that were spawned. Let's use another configurable key for that, using N as the default.</p>
						
						<pre translate="no">	public KeyCode createKey = KeyCode.C;
	<ins>public KeyCode newGameKey = KeyCode.N;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/creating-objects-on-demand/new-game-key.png" width="320" height="92">
							<figcaption>New-game key set to N.</figcaption>
						</figure>
						
						<p>Check whether this key is pressed in <code>Update</code>, and if so invoke a new <code>BeginNewGame</code> method. We should only handle one key at a time, so only check for the N key if the C key isn't pressed.</p>
						
						<pre translate="no">	void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateObject();
		}
		<ins>else if (Input.GetKey(newGameKey)) {</ins>
			<ins>BeginNewGame();</ins>
		<ins>}</ins>
	}

	<ins>void BeginNewGame () {}</ins></pre>
					</section>
					
					<section>
						<h3>Keeping Track of Objects</h3>
						
						<p>Our game can spawn an arbitrary number of randomized cubes, which all get added to the scene. But <code>Game</code> has no memory of what it spawned. In order to destroy the cubes, we first need to find them. To make this possible, we'll have <code>Game</code> keep track of a list of references to the objects it instantiated.</p>
						
						<aside>
							<h3>Why not just use <code>GameObject.Find</code>?</h3>
							<div>
								<p>This is possible for simple cases, where it's easy to distinguish between objects and there aren't many in the scene. For larger scenes, relying on <code>GameObject.Find</code> is a bad idea. <code>GameObject.FindWithTag</code> is better, but it's best to keep track of things yourself if you know you'll need them later.</p>
							</div>
						</aside>
						
						<p>We could add an array field to <code>Game</code> and fill it with references, but we don't know ahead of time how many cubes will be created. Fortunately, the <code>System.Collections.Generic</code> namespace contains a <code>List</code> class that we can use. It works like an array, except that its size isn't fixed.</p>
						
						<aside>
							<h3>How can the list's size be dynamic?</h3>
							<div>
								<p>Internally, <code>List</code> uses an array to store its contents, which it initializes at some size. Items added to the list get put in this array, until it is full. If more items are added, the list will copy the contents of the full array to a new larger array and uses that one from now on. We could do this array management manually, but <code>List</code> takes care of it for us. Also, Unity supports <code>List</code> fields just like it supports array fields. They're editable via the inspector, their contents are saved by the editor, and they survive recompilation while in play mode.</p>
							</div>
						</aside>
						
						<pre translate="no"><ins>using System.Collections.Generic;</ins>
using UnityEngine;

public class Game : MonoBehaviour {

	&hellip;

	<ins>List objects;</ins>

	&hellip;
}</pre>
						
						<p>But we don't want a generic list. We specifically want a list of <code>Transform</code> references. In fact, <code>List</code> insists that we specify the type of its contents. <code>List</code> is a generic type, which means that it acts like a template for specific list classes, each for a concrete content type. The syntax is <code>List&lt;T></code>, where the template type <code>T</code> is appended to the generic type, between angle brackets. In our case the correct type is <code>List&lt;Transform></code>.</p>
						
						<pre translate="no">		List<ins>&lt;Transform></ins> objects;</pre>
						
						<p>Like an array, we have to ensure that we have a list object instance before we use it. We'll do that by creating the new instance in the <code>Awake</code> method. In the case of an array, we'd have to use <code>new Transform[]</code>. But because we're using a list, we have to use <code>new List&lt;Transform>()</code> instead. This invokes the special constructor method of the list class, which can have parameters, which is why we have to append round brackets after the type name.</p>
						
						<pre translate="no">	<ins>void Awake () {</ins>
		<ins>objects = new List&lt;Transform>();</ins>
	<ins>}</ins></pre>
						
						<p>Next, add a <code>Transform</code> reference to our list each time we instantiate a new one, via the <code>Add</code> method of <code>List</code>.</p>
						
						<pre translate="no">	void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		t.localRotation = Random.rotation;
		t.localScale = Vector3.one * Random.Range(0.1f, 1f);
		<ins>objects.Add(t);</ins>
	}</pre>
						
						<aside>
							<h3>Do we have to wait until the end of <code>CreateObject</code> before adding the reference?</h3>
							<div>
								<p>We could have added the reference to the list as soon as we got hold of it, so directly after the assignment of the result of <code>Instantiate</code> to the local variable. I just put it at the end to point out that we should only add fully-initialized things to the list.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Clearing the List</h3>
						
						<p>Now we can loop through the list in <code>BeginNewGame</code> and destroy all the game objects that were instantiated. This works the same as for array, except that the length of the list is found via its <code>Count</code> property.</p>
						
						<pre translate="no">	void BeginNewGame () {
		<ins>for (int i = 0; i &lt; objects.Count; i++) {</ins>
			<ins>Destroy(objects[i].gameObject);</ins>
		<ins>}</ins>
	}</pre>
						
						<p>This leaves us with a list of references to destroyed objects. We must get rid of these as well, by emptying the list via invoking its <code>Clear</code> method.</p>
						
						<pre translate="no">	void BeginNewGame () {
		for (int i = 0; i &lt; objects.Count; i++) {
			Destroy(objects[i].gameObject);
		}
		<ins>objects.Clear();</ins>
	}</pre>
					</section>
				</section>
				
				<section>
					<h2>Saving and Loading</h2>
					
					<p>To support saving and loading during a single play session, it would be sufficient to keep a list of transformation data in memory. Copy the position, rotation, and scale of all cubes on a save, and reset the game and spawn cubes using the remembered data on a load. However, a true save system is able to remember the game state even after the game is terminated. This requires the game state to be persisted somewhere outside the game. The most straightforward way is to store the data in a file.</p>
					
					<aside>
						<h3>What about using <code>PlayerPrefs</code>?</h3>
						<div>
							<p>As its name suggests, <code>PlayerPrefs</code> is designed with game settings and preferences in mind, not game state. While it's possible to pack game state in strings, this is inefficient, hard to manage, and doesn't scale.</p>
						</div>
					</aside>
					
					<section>
						<h3>Save Path</h3>
						
						<p>Where game files should be stored depends on the file system. Unity takes care of the differences for us, making the path to the folder that we can use available via the <code>Application.persistentDataPath</code> property. We can grab the text string from this property and store it in a <code>savePath</code> field in <code>Awake</code>, so we need to retrieve it only once.</p>
						
						<pre translate="no">	<ins>string savePath;</ins>

	void Awake () {
		objects = new List&lt;Transform>();
		<ins>savePath = Application.persistentDataPath;</ins>
	}</pre>
						
						<p>This gives us the path to a folder, not a file. We have to append a file name to the path. Let's just use <em translate="no">saveFile</em>, not bothering with a file extension. Whether we should use a forward or backward slash to separate the file name from the rest of the path again depends on the operating system. We can use the <code>Path.Combine</code> method to take care of the specifics for us. <code>Path</code> is part of the <code>System.IO</code> namespace.</p>
						
						<pre translate="no">using System.Collections.Generic;
<ins>using System.IO;</ins>
using UnityEngine;

public class Game : MonoBehaviour {

	&hellip;

	void Awake () {
		objects = new List&lt;Transform>();
		savePath = <ins>Path.Combine(</ins>Application.persistentDataPath<ins>, "saveFile")</ins>;
	}

	&hellip;
}</pre>
					</section>
					
					<section>
						<h3>Opening a File for Writing</h3>
						
						<p>To be able to write data to our save file, we first have to open it. This is done via the <code>File.Open</code> method, providing it with a path argument. It also needs to know why we're opening the file. We want to write data to it, creating the file if it didn't already exist, or replacing an already existing file. We specify this by providing <code>FileMode.Create</code> as a second argument. Do this in a new <code>Save</code> method.</p>
						
						<pre translate="no">	<ins>void Save () {</ins>
		<ins>File.Open(savePath, FileMode.Create);</ins>
	<ins>}</ins></pre>
						
						<p><code>File.Open</code> returns a file stream, which isn't useful on its own. We need a data stream that we could write data into. This data has to be of a certain format. We'll use the most compact uncompressed format available, which is raw binary data. The <code>System.IO</code> namespace has the <code>BinaryWriter</code> class to make this possible. Create a new instance of this class, using its constructor method, providing the file stream as an argument. We don't need to keep a reference to the file stream, so we can directly use the <code>File.Open</code> invocation as the argument. We do need to keep a reference to the writer, so assign it to a variable.</p>
						
						<pre translate="no">	void Save () {
		<ins>BinaryWriter writer =</ins>
			<ins>new BinaryWriter(</ins>File.Open(savePath, FileMode.Create)<ins>)</ins>;
	}</pre>
						
						<p>We now have a binary writer variable named writer that references a new binary writer. That's using the word "writer" three times in one expression, which is a bit much. As we're explicitly creating a new <code>BinaryWriter</code>, it is redundant to explicitly declare the variable's type as well. Instead, we can use the <code>var</code> keyword. This implicitly declares the variable's type to match whatever is immediately assigned to it, which is something that the compiler can figure out in this case.</p>
						
						<pre translate="no">	void Save () {
		<ins>var</ins> writer = new BinaryWriter(File.Open(savePath, FileMode.Create));
	}</pre>
						
						<p>We now have a writer variable that references a new binary writer. Its type is obvious.</p>
						
						<aside>
							<h3>When should <code>var</code> be used?</h3>
							<div>
								<p>The <code>var</code> keyword is syntactic sugar that you don't need to use at all. While you could use it everywhere that the compiler can infer which type is meant, it's better to only do this when readability is improved and types are explicit. I only use <code>var</code> in these tutorials when a variable is declared and immediately assigned to, using the <code>new</code> keyword. So only in expressions of the form <code>var t = new Type</code>.</p>
								
								<p>The <code>var</code> keyword is very useful when working with Language Integrated Query (LINQ) and anonymous types, but that's outside the scope of these tutorials.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Closing the File</h3>
						
						<p>If we open a file, we must make sure that we also close it. It's possible to do this via a <code>Close</code> method, but this isn't safe. If something goes wrong between opening and closing the file, an exception could be raised and execution of the method could be terminated before it got to closing the file. We have to carefully handle exceptions to ensure that the file is always closed. There is syntactic sugar to make this easy. Put the declaration and assignment of the <code>writer</code> variable inside round brackets, place the <code>using</code> keyword in front of it, and a code block after it. The variable is available inside that block, just like the iterator variable <code>i</code> of a standard <code>for</code> loop.</p>
						
						<pre translate="no">	void Save () {
		<ins>using (</ins>
			var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))
		<ins>) {}</ins>
	}</pre>
						
						<p>This will ensure that whatever <code>writer</code> references will be properly disposed of, after code execution exits the block, no matter how. This works for special disposable types, which the writer and stream are.</p>
						
						<aside>
							<h3>How does <code>using</code> work, without the sugar?</h3>
							<div>
								<p>In our case, it would look like the following code.</p>
								
								<pre translate="no">var writer = new BinaryWriter(File.Open(savePath, FileMode.Create);
try { &hellip; }
finally {
	if (writer != null) {
		((IDisposable)writer).Dispose();
	}
}</pre>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Writing Data</h3>
						
						<p>We can write data to our file by invoking our writer's <code>Write</code> method. It is possible to write simple values, like a boolean, integer, and so on, one at a time. Let's begin by writing only how many objects we have instantiated.</p>
						
						<pre translate="no">	void Save () {
		using (
			var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))
		) {
			<ins>writer.Write(objects.Count);</ins>
		}
	}</pre>
						
						<p>To actually save this data, we have to invoke the <code>Save</code> method. We'll again control this via a key, in this case using S as the default.</p>
						
						<pre translate="no">	public KeyCode createKey = KeyCode.C;
	<ins>public KeyCode saveKey = KeyCode.S;</ins>

	&hellip;

	void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateObject();
		}
		else if (Input.GetKey(newGameKey)) {
			BeginNewGame();
		}
		<ins>else if (Input.GetKeyDown(saveKey)) {</ins>
			<ins>Save();</ins>
		<ins>}</ins>
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/saving-and-loading/save-key.png" width="320" height="110">
							<figcaption>Save key set to S.</figcaption>
						</figure>
						
						<p>Enter play mode, create a few cubes, then save the game by pressing the key. This will have created a <em translate="no">saveFile</em> file on your file system. If you're not sure where it is located, you can use <code>Debug.Log</code> to write the file's path to the Unity console.</p>
						
						<p>You'll find that the file contains four bytes of data. Opening the file in a text editor will show nothing useful, because the data is binary. It might show nothing at all, or might interpret the data as weird characters. There are four bytes because that's the size of an integer.</p>
						
						<p>Besides writing how many cubes we have, we must also store the transformation data of each cube. We do this by looping through the objects and writing their data, one number at a time. For now, we'll limit ourselves to just their positions. So write the X, Y, and Z components of each cube's position, in that order.</p>
						
						<pre translate="no">			writer.Write(objects.Count);
			<ins>for (int i = 0; i &lt; objects.Count; i++) {</ins>
				<ins>Transform t = objects[i];</ins>
				<ins>writer.Write(t.localPosition.x);</ins>
				<ins>writer.Write(t.localPosition.y);</ins>
				<ins>writer.Write(t.localPosition.z);</ins>
			<ins>}</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/saving-and-loading/file-contents-positions.png" width="315" height="140">
							<figcaption>File containing seven positions, in four-byte blocks.</figcaption>
						</figure>
						
						<aside>
							<h3>Why not use <code>BinaryFormatter</code>?</h3>
							<div>
								<p>While relying on <code>BinaryFormatter</code> can be convenient, it isn't possible to just serialize a game object hierarchy using a <code>BinaryFormatter</code> and deserialize it later. The game object hierarchy has to be recreated manually. Also, writing every bit of data ourselves gives us total control and understanding. Besides that, manually writing data requires less space and memory, is quicker, and makes it easier to support an evolving save file format. Sometimes, games that have already been released drastically change what's stored after an update or expansion. Some of those games can then no longer load a player's old save files. Ideally, a game remains backwards-compatible with all its save file versions.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Loading Data</h3>
						
						<p>To load the data that we just saved, we have to again open the file, this time with <code>FileMode.Open</code> as the second argument. Instead of a <code>BinaryWriter</code>, we have to use a <code>BinaryReader</code>. Do this in a new <code>Load</code> method, once again with a <code>using</code> statement.</p>
						
						<pre translate="no">	<ins>void Load () {</ins>
		<ins>using (</ins>
			<ins>var reader = new BinaryReader(File.Open(savePath, FileMode.Open))</ins>
		<ins>) {}</ins>
	<ins>}</ins></pre>
						
						<p>The first thing we wrote to the file was the count property of our list, so that is also the first thing to read. We do this with the <code>ReadInt32</code> method of our reader. We have to be explicit what we read, because there is no parameter that makes this clear. The suffix 32 refers to the size of the integer, which is four bytes, thus 32 bits. There are also larger and smaller integer variants, but we don't use those.</p>
						
						<pre translate="no">		using (
			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))
		) {
			<ins>int count = reader.ReadInt32();</ins>
		}</pre>
						
						<p>After reading the count, we know how many objects were saved. We have to read that many positions from the file. Do this with a loop, reading three floats per iteration, for the X, Y, and Z components of a position vector. A single-precision <code>float</code> is read with the <code>ReadSingle</code> method. A double-precision <code>double</code> would be read with the <code>ReadDouble</code> method.</p>
						
						<pre translate="no">			int count = reader.ReadInt32();
			<ins>for (int i = 0; i &lt; count; i++) {</ins>
				<ins>Vector3 p;</ins>
				<ins>p.x = reader.ReadSingle();</ins>
				<ins>p.y = reader.ReadSingle();</ins>
				<ins>p.z = reader.ReadSingle();</ins>
			<ins>}</ins></pre>
						
						<p>Use the vector to set the position of a newly instantiated cube, and add it to the list.</p>
						
						<pre translate="no">			for (int i = 0; i &lt; count; i++) {
				Vector3 p;
				p.x = reader.ReadSingle();
				p.y = reader.ReadSingle();
				p.z = reader.ReadSingle();
				<ins>Transform t = Instantiate(prefab);</ins>
				<ins>t.localPosition = p;</ins>
				<ins>objects.Add(t);</ins>
			}</pre>
						
						<p>At this point we can recreate all cubes that we saved, but they get added to the cubes that were already in the scene. To properly load a previously saved game, we have to reset the game before recreating it. We can do this by invoking <code>BeginNewGame</code> before loading the data.</p>
						
						<pre translate="no">	void Load () {
		<ins>BeginNewGame();</ins>
		using (
			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))
		) {
			&hellip;
		}
	}</pre>
						
						<p>Have <code>Game</code> invoke <code>Load</code> when a key is pressed, using L as the default.</p>
						
						<pre translate="no">	public KeyCode createKey = KeyCode.C;
	public KeyCode saveKey = KeyCode.S;
	<ins>public KeyCode loadKey = KeyCode.L;</ins>

	&hellip;

	void Update () {
		&hellip;
		else if (Input.GetKeyDown(saveKey)) {
			Save();
		}
		<ins>else if (Input.GetKeyDown(loadKey)) {</ins>
			<ins>Load();</ins>
		<ins>}</ins>
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/saving-and-loading/load-key.png" width="320" height="128">
							<figcaption>Load key set to L.</figcaption>
						</figure>
						
						<p>Now the player can save their cubes and later load them, either during the same play session or another one. But because we're only storing the position data, the rotation and scale of cubes are not stored. As a result, loaded cubes all end up with the default rotation and scale of the prefab.</p>
						
						<aside>
							<h3>What would happen if we loaded before saving anything?</h3>
							<div>
								<p>Then you would try to open a file that doesn't exist, which would result in an exception. This tutorial doesn't bother with checking whether the file exists or contains valid data, but we'll be more careful in a future tutorial.</p>
							</div>
						</aside>
					</section>
				</section>
				
				<section>
					<h2>Abstracting Storage</h2>
					
					<p>Although we need to know the specifics of reading and writing binary data, that's rather low-level. Writing a single 3D vector requires three invocations of <code>Write</code>. When saving and loading our objects, it's more convenient if we could work at a slightly higher level, reading or writing an entire 3D vector with a single method invocation. Also, it would be nice if we could just use <code>ReadInt</code> and <code>ReadFloat</code>, instead of having to worry about all the different variants that we don't use. Finally, it shouldn't matter whether the data is stored in binary, plain text, base-64, or another encoding method. <code>Game</code> doesn't need to know such details.</p>
					
					<section>
						<h3>Game Data Writer and Reader</h3>
						
						<p>To hide the details of reading and writing data, we're going to create our own reader and writer classes. Let's begin with the writer, naming it <code>GameDataWriter</code>.</p>
						
						<p><code>GameDataWriter</code> does not extend <code>MonoBehaviour</code>, because we won't attach it to a game object. It will act as a wrapper for <code>BinaryWriter</code>, so give it a single writer field.</p>
						
						<pre translate="no"><ins>using System.IO;</ins>
<ins>using UnityEngine;</ins>

<ins>public class GameDataWriter {</ins>

	<ins>BinaryWriter writer;</ins>
<ins>}</ins></pre>
						
						<p>A new object instance of our custom writer type can be created via <code>new GameDataWriter()</code>. But this only makes sense if we have a writer to wrap. So create a custom constructor method with a <code>BinaryWriter</code> parameter. This is a method with the type name of its class as its own name, which also acts as its return type. It replaces the implicit default constructor method.</p>
						
						<pre translate="no">	<ins>public GameDataWriter (BinaryWriter writer) {</ins>
	<ins>}</ins></pre>
						
						<p>Although invoking a constructor method results in a new object instance, such methods don't explicitly return anything. The object gets created before the constructor is invoked, which can then take care of any required initialization. In our case, that's simply assigning the writer parameter to the object's field. As I've used the same name for both, I have to use the <code>this</code> keyword to explicitly indicate that I'm referring to the object's field instead of the parameter.</p>
						
						<pre translate="no">	public GameDataWriter (BinaryWriter writer) {
		<ins>this.writer = writer;</ins>
	}</pre>
						
						<p>The most basic functionality is to write a single <code>float</code> or <code>int</code> value. Add public <code>Write</code> methods for this, simply forwarding the invocation to the actual writer.</p>
						
						<pre translate="no">	<ins>public void Write (float value) {</ins>
		<ins>writer.Write(value);</ins>
	<ins>}</ins>

	<ins>public void Write (int value) {</ins>
		<ins>writer.Write(value);</ins>
	<ins>}</ins></pre>
						
						<p>Besides that, also add methods to write a <code>Quaternion</code>&mdash;for rotations&mdash;and a <code>Vector3</code>. These methods have to write all the components of their parameter. In the case of a quaternion, that's four components.</p>
						
						<pre translate="no">	<ins>public void Write (Quaternion value) {</ins>
		<ins>writer.Write(value.x);</ins>
		<ins>writer.Write(value.y);</ins>
		<ins>writer.Write(value.z);</ins>
		<ins>writer.Write(value.w);</ins>
	<ins>}</ins>
	
	<ins>public void Write (Vector3 value) {</ins>
		<ins>writer.Write(value.x);</ins>
		<ins>writer.Write(value.y);</ins>
		<ins>writer.Write(value.z);</ins>
	<ins>}</ins></pre>
						
						<p>Next, create a new <code>GameDataReader</code> class, using the same approach as for the writer. In this case, we wrap a <code>BinaryReader</code>.</p>
						
						<pre translate="no"><ins>using System.IO;</ins>
<ins>using UnityEngine;</ins>

<ins>public class GameDataReader {</ins>

	<ins>BinaryReader reader;</ins>

	<ins>public GameDataReader (BinaryReader reader) {</ins>
		<ins>this.reader = reader;</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>Give it methods that are simply named <code>ReadFloat</code> and <code>ReadInt</code>, that forward the invocations to <code>ReadSingle</code> and <code>ReadInt32</code>.</p>
						
						<pre translate="no">	<ins>public float ReadFloat () {</ins>
		<ins>return reader.ReadSingle();</ins>
	<ins>}</ins>

	<ins>public int ReadInt () {</ins>
		<ins>return reader.ReadInt32();</ins>
	<ins>}</ins></pre>
						
						<p>Also create <code>ReadQuaternion</code> and <code>ReadVector3</code> methods. Read their components in the same order that we write them.</p>
						
						<pre translate="no">	<ins>public Quaternion ReadQuaternion () {</ins>
		<ins>Quaternion value;</ins>
		<ins>value.x = reader.ReadSingle();</ins>
		<ins>value.y = reader.ReadSingle();</ins>
		<ins>value.z = reader.ReadSingle();</ins>
		<ins>value.w = reader.ReadSingle();</ins>
		<ins>return value;</ins>
	<ins>}</ins>

	<ins>public Vector3 ReadVector3 () {</ins>
		<ins>Vector3 value;</ins>
		<ins>value.x = reader.ReadSingle();</ins>
		<ins>value.y = reader.ReadSingle();</ins>
		<ins>value.z = reader.ReadSingle();</ins>
		<ins>return value;</ins>
	<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Persistable Objects</h3>
						
						<p>Now it's a lot simpler to write the transform data of cubes in <code>Game</code>. But we can go one step further. What if <code>Game</code> could simply invoke <code>writer.Write(objects[i])</code>? That would be very convenient, but would require <code>GameDataWriter</code> to know the details of writing a game object. But it's better to keep the writer simple, limited to primitive values and simple structs.</p>
						
						<p>We can turn this reasoning around. <code>Game</code> doesn't need to know how to save a game object, that's the responsibility of the object itself. All the object needs is a writer to save itself. Then <code>Game</code> could use  <code>objects[i].Save(writer)</code>.</p>
						
						<p>Our cubes are simple objects, without any custom components attached. So the only thing that's to save is the transform component. Let's create a <code>PersistableObject</code> component script that knows how to save and load that data. It simply extends <code>MonoBehaviour</code> and has a public <code>Save</code> method and <code>Load</code> method with a <code>GameDataWriter</code> or <code>GameDataReader</code> parameter respectively. Have it save the transform position, rotation, and scale, and load them in the same order.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public class PersistableObject : MonoBehaviour {</ins>

	<ins>public void Save (GameDataWriter writer) {</ins>
		<ins>writer.Write(transform.localPosition);</ins>
		<ins>writer.Write(transform.localRotation);</ins>
		<ins>writer.Write(transform.localScale);</ins>
	<ins>}</ins>

	<ins>public void Load (GameDataReader reader) {</ins>
		<ins>transform.localPosition = reader.ReadVector3();</ins>
		<ins>transform.localRotation = reader.ReadQuaternion();</ins>
		<ins>transform.localScale = reader.ReadVector3();</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>The idea is that a game object that can be persisted only has one <code>PersistableObject</code> component attached to it. Having multiple such components makes no sense. We can enforce this by adding the <code>DisallowMultipleComponent</code> attribute to the class.</p>
						
						<pre translate="no"><ins>[DisallowMultipleComponent]</ins>
public class PersistableObject : MonoBehaviour {

	&hellip;
}</pre>
						
						<p>Add this component to our cube prefab.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/abstracting-storage/persistable-prefab.png" width="320" height="212">
							<figcaption>Persistable prefab.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Persistent Storage</h3>
						
						<p>Now that we have a persistent object type, let's also create a <code>PersistentStorage</code> class to save such an object. It contains the same saving and loading logic as <code>Game</code>, except that it only saves and loads a single <code>PersistableObject</code> instance, provided via a parameter to public <code>Save</code> and <code>Load</code> methods. Make it a <code>MonoBehaviour</code>, so we can attach it to a game object and it can initialize its save path.</p>
						
						<pre translate="no"><ins>using System.IO;</ins>
<ins>using UnityEngine;</ins>

<ins>public class PersistentStorage : MonoBehaviour {</ins>

	<ins>string savePath;</ins>

	<ins>void Awake () {</ins>
		<ins>savePath = Path.Combine(Application.persistentDataPath, "saveFile");</ins>
	<ins>}</ins>

	<ins>public void Save (PersistableObject o) {</ins>
		<ins>using (</ins>
			<ins>var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))</ins>
		<ins>) {</ins>
			<ins>o.Save(new GameDataWriter(writer));</ins>
		<ins>}</ins>
	<ins>}</ins>

	<ins>public void Load (PersistableObject o) {</ins>
		<ins>using (</ins>
			<ins>var reader = new BinaryReader(File.Open(savePath, FileMode.Open))</ins>
		<ins>) {</ins>
			<ins>o.Load(new GameDataReader(reader));</ins>
		<ins>}</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>Add a new game object to the scene with this component attached. It represents the persistent storage of our game. Theoretically, we could have multiple such storage objects, used to store different things, or to provide access to different storage types. But in this tutorial we use just this single file storage object.</p>
						
						<figure>
							<img src="abstracting-storage/storage.png" width="320" height="105">
							<figcaption>Storage object.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Persistable Game</h3>
						
						<p>To make use of the new persistable object approach, we have to rewrite <code>Game</code>. Change the <code>prefab</code> and <code>objects</code> content type to <code>PersistableObject</code>. Adjust <code>CreateObject</code> so it can deal with this type change. Then remove all the code specific to reading from and writing to files.</p>
						
						<pre translate="no">using System.Collections.Generic;
<del>//using System.IO;</del>
using UnityEngine;

public class Game : MonoBehaviour {

	public <ins>PersistableObject</ins> prefab;

	&hellip;

	List&lt;<ins>PersistableObject</ins>> objects;

<del>//	string savePath;</del>

	void Awake () {
		objects = new List&lt;<ins>PersistableObject</ins>>();
<del>//		savePath = Path.Combine(Application.persistentDataPath, "saveFile");</del>
	}

	void Update () {
		&hellip;
		else if (Input.GetKeyDown(saveKey)) {
<del>//			Save();</del>
		}
		else if (Input.GetKeyDown(loadKey)) {
<del>//			Load();</del>
		}
	}
	
	&hellip;

	void CreateObject () {
		<ins>PersistableObject o = Instantiate(prefab);</ins>
		Transform t = <ins>o.transform</ins>;
		&hellip;
		objects.Add(<ins>o</ins>);
	}

<del>//	void Save () {</del>
<del>//		&hellip;</del>
<del>//	}</del>

<del>//	void Load () {</del>
<del>//		&hellip;</del>
<del>//	}</del>
}</pre>
						
						<p>We'll have <code>Game</code> rely on a <code>PersistentStorage</code> instance to take care of the details of storing data. Add a public <code>storage</code> field of this type, so we can give <code>Game</code> a reference to our storage object. To again save and load the game state, we have <code>Game</code> itself extend <code>PersistableObject</code>. Then it can load and save itself, using the storage.</p>
						
						<pre translate="no">public class Game : <ins>PersistableObject</ins> {

	&hellip;

	<ins>public PersistentStorage storage;</ins>

	&hellip;

	void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateObject();
		}
		else if (Input.GetKeyDown(saveKey)) {
			<ins>storage.Save(this);</ins>
		}
		else if (Input.GetKeyDown(loadKey)) {
			<ins>BeginNewGame();</ins>
			<ins>storage.Load(this);</ins>
		}
	}

	&hellip;
}</pre>
						
						<p>Connect the storage via the inspector. Also reconnect the prefab, as its reference was lost due to the field's type change.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/abstracting-storage/persistable-game.png" width="320" height="146">
							<figcaption>Game connected to prefab and storage.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Overriding Methods</h3>
						
						<p>When we save and load the game now, we end up writing and reading the transformation data of our main game object. This is useless. Instead, we have to save and load its list of objects.</p>
						
						<aside>
							<h3>I loaded before saving, and the game object got a strange position?</h3>
							<div>
								<p>If you're loading an older save file at this point, you end up misinterpreting the data. The count integer will be mistaken for the X position, the first saved position's X and Y end up used for the Y and Z position, then the rotation will be filled with the next values, and so on. If you had saved less than four positions, the file would contain too little data to load a complete transform. Then you'd get an error complaining that you tried to read beyond the end of the file.</p>
							</div>
						</aside>
						
						<p>Instead of relying on the <code>Save</code> method defined in <code>PersistableObject</code>, we have to give <code>Game</code> its own public version of <code>Save</code> with a <code>GameDataWriter</code> parameter. In it, write the list as we did before, now using the convenient <code>Save</code> method of the objects.</p>
						
						<pre translate="no">	<ins>public void Save (GameDataWriter writer) {</ins>
		<ins>writer.Write(objects.Count);</ins>
		<ins>for (int i = 0; i &lt; objects.Count; i++) {</ins>
			<ins>objects[i].Save(writer);</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>This is not yet enough to make it work. The compiler complains that <code>Game.Save</code> hides the inherited member <code>PersistableObject.Save</code>. While <code>Game</code> can work with its own <code>Save</code> version, <code>PersistentStorage</code> only knows about <code>PersistableObject.Save</code>. So it would invoke this method, not the one from <code>Game</code>. To make sure that the correct <code>Save</code> method gets invoked, we have to explicitly declare that we override the method that <code>Game</code> inherited from <code>PersistableObject</code>. That's done by adding the <code>override</code> keyword to the method declaration.</p>
						
						<pre translate="no">	public <ins>override</ins> void Save (GameDataWriter writer) {
		&hellip;
	}</pre>
						
						<p>However, we cannot just override any method we like. By default, we're not allowed to do this. We have to explicitly enable it, by adding the <code>virtual</code> keyword to the <code>Save</code> and <code>Load</code> method declarations in <code>PersistableObject</code>.</p>
						
						<pre translate="no">	public <ins>virtual</ins> void Save (GameDataWriter writer) {
		writer.Write(transform.localPosition);
		writer.Write(transform.localRotation);
		writer.Write(transform.localScale);
	}

	public <ins>virtual</ins> void Load (GameDataReader reader) {
		transform.localPosition = reader.ReadVector3();
		transform.localRotation = reader.ReadQuaternion();
		transform.localScale = reader.ReadVector3();
	}</pre>
						
						<aside>
							<h3>What does the <code>virtual</code> keyword mean?</h3>
							<div>
								<p>At a very low level, there aren't really objects or methods. There is just data, a portion of which is used as instructions to be executed by the CPU. Method invocations&mdash;unless optimized away&mdash;become instructions that tell the CPU to jump to another data point and continue execution from there. Besides that, it might also put some argument values in place. So when <code>PersistentStorage</code> invokes the <code>Save</code> method of the <code>PersistableObject</code> type, it becomes an instruction to jump to a fixed location. That we passed it an instance of <code>Game</code>&mdash;a subtype of <code>PersistableObject</code>&mdash;doesn't affect this at all. The object instance used to invoke the method is just another argument.</p>
								
								<p>The <code>virtual</code> keyword changes this approach. Instead of using a hard-coded location, the compiler adds instructions to look up where to jump to, based on the type that was involved. Instead of going "It's this method, so always jump there." it becomes "Does this type contain the jump destination for this method? If yes, go there. If no, check its direct parent type. Repeat until the destination is found." This approach is known as a virtual method, function, or call table. Hence <code>virtual</code>. It allows subtypes to override the functionality of their parent types.</p>
								
								<p>Note that the specifics of the low-level instructions that end up executed by the CPU can vary a lot, especially when using Unity's <em translate="no">IL2CPP</em> to create native executables. Wherever possible, <em translate="no">IL2CPP</em> eliminates the use of virtual method tables.</p>
							</div>
						</aside>
						
						<p><code>PersistentStorage</code> will now end up invoking our <code>Game.Save</code> method, even though it's passed to it as a <code>PersistableObject</code> argument. Also have <code>Game</code> override the <code>Load</code> method.</p>
						
						<pre translate="no">	<ins>public override void Load (GameDataReader reader) {</ins>
		<ins>int count = reader.ReadInt();</ins>
		<ins>for (int i = 0; i &lt; count; i++) {</ins>
			<ins>PersistableObject o = Instantiate(prefab);</ins>
			<ins>o.Load(reader);</ins>
			<ins>objects.Add(o);</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<figure>
							<img src="abstracting-storage/file-contents-transforms.png" width="315" height="140">
							<figcaption>File containing two transforms.</figcaption>
						</figure>
						
						<p>The next tutorial is <a href="../object-variety/index.html">Object Variety</a>.</p>
					</section>
					
					<a href="https://bitbucket.org/catlikecodingunitytutorials/object-management-01-persisting-objects" class="repository">repository</a>
					<a href="Persisting-Objects.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>