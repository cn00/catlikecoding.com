<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/object-management/configuring-shapes/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/object-management/configuring-shapes/tutorial-image.jpg">
		<meta property="og:title" content="Configuring Shapes">
		<meta property="og:description" content="A Unity Object Management tutorial about configuring and moving shapes.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Configuring Shapes</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/object-management/configuring-shapes/#article",
				"headline": "Configuring Shapes",
				"alternativeHeadline": "Variety of Randomness",
				"datePublished": "2018-10-25",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Object Management tutorial about adding configuring and controlling shapes.",
				"image": "https://catlikecoding.com/unity/tutorials/object-management/configuring-shapes/tutorial-image.jpg",
				"dependencies": "Unity 2017.4.12f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/object-management/", "name": "Object Management" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				ColorRangeHSV: 1,
				CompositeSpawnZone: 1,
				CubeSpawnZone: 1,
				FloatRange: 1,
				FloatRangeDrawer: 1,
				FloatRangeSlider: 1,
				FloatRangeSliderAttribute: 1,
				FloatRangeSliderDrawer: 1,
				Game: 1,
				GameDataReader: 1,
				GameDataWriter: 1,
				GameLevel: 1,
				MovementDirection: 1,
				SpawnConfiguration: 1,
				SpawnMovementDirection: 1,
				PersistableObject: 1,
				PersistentStorage: 1,
				RotatingObject: 1,
				Shape: 1,
				ShapeFactory: 1,
				SpawnZone: 1,
				SphereSpawnZone: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Object Management</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Configuring Shapes</h1>
					<p>Variety of Randomness</p>
					<ul>
						<li>Make shapes rotate and move.</li>
						<li>Centralize game updates.</li>
						<li>Add configuration per spawn zone.</li>
						<li>Improve the inspector.</li>
					</ul>
				</header>
				
				<p>This is the seventh tutorial in a series about <a href="../index.html">Object Management</a>. It adds some behavior to shapes and makes it possible to configure them, per spawn zone.
				
				<p>This tutorial is made with Unity 2017.4.12f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Each spawn zone does its own thing.</figcaption>
				</figure>
				
				<section>
					<h2>Shape Rotation</h2>
					
					<p>We can create shapes with varied appearance, but they just sit in place until destroyed. Let's spice things up by making them do something. Specifically, we'll make all shapes spin.
					
					<section>
						<h3>Adding Spin</h3>
						
						<p>The most straightforward way to make an object spin is by invoking the <code>Rotate</code> method of its <code>Transform</code> component, just like we did for <code>RotatingObject</code>. In this case, we have to add a <code>FixedUpdate</code> method to <code>Shape</code> and invoke it there. We begin by using the object's local forward direction as its rotation axis.</p>
						
						<pre translate="no">	<ins>void FixedUpdate () {</ins>
		<ins>transform.Rotate(Vector3.forward);</ins>
	<ins>}</ins></pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:220px;"><iframe src='https://gfycat.com/ifr/MaleIncompatibleBlacklemur?controls=0'></iframe></div>
							<figcaption>Spinning shapes.</figcaption>
						</figure>
						
						<p>The default time step is 0.02, which means that <code>FixedUpdate</code> gets invoked 50 times per second. Hence, we end up with shapes that rotate 50&deg; per second. But let's make the rotation speed explicit, by multiplying the forward vector by 50 multiplied by the time delta. That makes the rotation independent of the time step.</p>
						
						<pre translate="no">		transform.Rotate(Vector3.forward <ins>* 50f * Time.deltaTime</ins>);</pre>
					</section>
					
					<section>
						<h3>Randomized Rotation</h3>
						
						<p>The next step is to give each shape a random angular velocity. Add a public <code>AngularVelocity</code> property to make it possible to configure, then use that to determine the rotation each update.
						
						<pre translate="no">	<ins>public Vector3 AngularVelocity { get; set; }</ins>
	
	&hellip;
	
	void FixedUpdate () {
		transform.Rotate(<ins>AngularVelocity</ins> * Time.deltaTime);
	}</pre>
						
						<p><code>Game</code> now has to set the shape's angular velocity in <code>CreateShape</code>. We can use <code>Random.onUnitSphere</code> to get a random rotation axis. Multiply it by 50 so we once again end up with a rotation of 50&deg; per second.
						
						<pre translate="no">	void CreateShape () {
		&hellip;
		<ins>instance.AngularVelocity = Random.onUnitSphere * 50f;</ins>
		shapes.Add(instance);
	}</pre>
	
						<figure>
							<div class="vid" style="width: 250px; height:220px;"><iframe src='https://gfycat.com/ifr/AdvancedNervousHoneycreeper?controls=0'></iframe></div>
							<figcaption>Random angular velocities.</figcaption>
						</figure>
						
						<p>To randomize the rotation speed as well, replace 50 with a random range, say between 0 and 90 degrees per second.</p>
						
						<pre translate="no">		instance.AngularVelocity = Random.onUnitSphere * <ins>Random.Range(0f, 90f)</ins>;</pre>
					</section>
					
					<section>
						<h3>Saving Angular Velocity</h3>
						
						<p>At this point we're not saving the angular velocity yet. Loading a game will produce shapes with arbitrary angular velocities, because recycled shapes keep their old velocity. As saving the angular velocity changes the safe file format, increase the save version to 4.</p>
						
						<pre translate="no">	const int saveVersion = <ins>4</ins>;</pre>
						
						<p>Write the angular velocity after the shape's color.</p>
						
						<pre translate="no">	public override void Save (GameDataWriter writer) {
		base.Save(writer);
		writer.Write(color);
		<ins>writer.Write(AngularVelocity);</ins>
	}</pre>
						
						<p>Read the angular velocity when loading as well, when the save version is high enough. Older saved games didn't have an angular velocity, so use the zero vector for those.</p>
						
						<pre translate="no">	public override void Load (GameDataReader reader) {
		base.Load(reader);
		SetColor(reader.Version > 0 ? reader.ReadColor() : Color.white);
		<ins>AngularVelocity =</ins>
			<ins>reader.Version >= 4 ? reader.ReadVector3() : Vector3.zero;</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Updating all Shapes Together</h3>
						
						<p>Before shapes rotated, they didn't need to be updated. But now Unity has to invoke the <code>FixedUpdate</code> method of all active shapes. While a regular method invocation isn't really a problem, <code>FixedUpdate</code> and other special Unity methods require additional overhead which can slow things down. This isn't an issue when there are only a few active shapes, but can become a performance bottleneck when dealing with lots of shapes. </p>
						
						<figure>
							<img src="shape-rotation/profiler-separate-update.png" width="555" height="65">
							<figcaption>Profiler showing 1000 separate <code>FixedUpdate</code> invocations.</figcaption>
						</figure>
						
						<p>Instead of leaving the updating of shapes to Unity, we can manage it ourselves. <code>Game</code> already contains a list of all active shapes, which we can use to update them. But we cannot just invoke <code>FixedUpdate</code>, because Unity will still invoke that method as well. We have to rename it to something else. Let's use <code>GameUpdate</code>, and make it public so that <code>Game</code> can access it.</p>
						
						<pre translate="no">	<del>//void FixedUpdate () {</del>
	<ins>public void GameUpdate () {</ins>
		transform.Rotate(AngularVelocity * Time.deltaTime);
	}</pre>
						
						<p>In the <code>FixedUpdate</code> method of <code>Game</code>, loop through the <code>shapes</code> list and invoke the new <code>GameUpdate</code> of each shape. Do this at the beginning, before new shapes are spawn. That keeps the behavior consistent with earlier versions of our game.</p>
						
						<pre translate="no">	void FixedUpdate () {
		<ins>for (int i = 0; i &lt; shapes.Count; i++) {</ins>
			<ins>shapes[i].GameUpdate();</ins>
		<ins>}</ins>

		&hellip;
	}</pre>
						<figure>
							<img src="shape-rotation/profiler-combined-update.png" width="555" height="48">
							<figcaption>All updates combined.</figcaption>
						</figure>
						
						<aside>
							<h3>Is this optimization really worth it?</h3>
							<div>
								<p>When you're dealing with thousands of similar objects, they all need to update, and you're already keeping track of them yourself, then it can be worth it. How much performance you gain should be profiled, as it varies per target platform. The most gains can be had in the editor. Note that when you find yourself in this situation, it is also a good idea to investigate whether the Entity Component System introduced in Unity 2018 is a better fit, but I won't cover that in this tutorial.</p>
							</div>
						</aside>
					</section>
				</section>
				
				<section>
					<h2>Shape Movement</h2>
					
					<p>Our shapes can now rotate, but they still remain where they were spawned. Let's change that, by giving each shape a random velocity as well.</p>
					
					<section>
						<h3>Adding Velocity</h3>
						
						<p>Like we did for the angular velocity, give <code>Shape</code> a <code>Velocity</code> property.</p>
						
						<pre translate="no">	<ins>public Vector3 Velocity { get; set; }</ins></pre>
						
						<p>Each update, add the velocity multiplied by the time delta to the shape's position. We can use the local position instead of the more costly <code>position</code> property, because the shapes should always be root objects.</p>
						
						<pre translate="no">	public void GameUpdate () {
		transform.Rotate(AngularVelocity * Time.deltaTime);
		<ins>transform.localPosition += Velocity * Time.deltaTime;</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Saving Velocity</h3>
						
						<p>Save the velocity too, writing it directly after the angular velocity.</p>
						
						<pre translate="no">	public override void Save (GameDataWriter writer) {
		base.Save(writer);
		writer.Write(color);
		writer.Write(AngularVelocity);
		<ins>writer.Write(Velocity);</ins>
	}</pre>
						
						<p>And load it, once again using the zero vector when reading from old files.</p>
						
						<pre translate="no">	public override void Load (GameDataReader reader) {
		base.Load(reader);
		SetColor(reader.Version > 0 ? reader.ReadColor() : Color.white);
		AngularVelocity =
			reader.Version >= 4 ? reader.ReadVector3() : Vector3.zero;
		<ins>Velocity = reader.Version >= 4 ? reader.ReadVector3() : Vector3.zero;</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Randomized Velocity</h3>
						
						<p>When a new shape is created in <code>CreateShape</code>, give it a random direction and speed, by multiplying <code>Random.onUnitSphere</code> with <code>Random.Range</code>, for example with speeds between zero and two units per second.</p>
						
						<pre translate="no">	void CreateShape () {
		&hellip;
		instance.AngularVelocity = Random.onUnitSphere * Random.Range(0f, 90f);
		<ins>instance.Velocity = Random.onUnitSphere * Random.Range(0f, 2f);</ins>
		shapes.Add(instance);
	}</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:220px;"><iframe src='https://gfycat.com/ifr/GiftedShallowAcornbarnacle?controls=0'></iframe></div>
							<figcaption>Random velocities.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Velocity Per Spawn Zone</h3>
						
						<p>Giving each shape a random movement direction produces a rather chaotic scene. Instead, we could have all shapes move in the same direction. But rather than using a single uniform direction, we could use a unique velocity per spawn zone. That makes it possible to create more elaborate levels.</p>
						
						<p>Currently, <code>Game</code> creates and configures each new shape and asks the level for a spawn point. If we want to make the velocity dependent on the spawn zone as well, then <code>Game</code> must ask for a velocity too. Rather than do that, we'll instead move the entire responsibility for shape configuration from <code>Game</code> to <code>SpawnZone</code>.</p>
						
						<p>Add a public <code>ConfigureSpawn</code> method to <code>SpawnZone</code>, with a shape parameter. Copy the code from <code>Game.CreateShape</code> to this method, except for the first and last lines that create the instance and add it to the list. The method's parameter replaces the <code>instance</code> variable, and <code>SpawnPoint</code> can now be accessed directly, instead of having to go through the level.</p>
						
						<pre translate="no">	<ins>public void ConfigureSpawn (Shape shape) {</ins>
		Transform t = <ins>shape</ins>.transform;
		t.localPosition = <ins>SpawnPoint</ins>;
		t.localRotation = Random.rotation;
		t.localScale = Vector3.one * Random.Range(0.1f, 1f);
		<ins>shape</ins>.SetColor(Random.ColorHSV(
			hueMin: 0f, hueMax: 1f,
			saturationMin: 0.5f, saturationMax: 1f,
			valueMin: 0.25f, valueMax: 1f,
			alphaMin: 1f, alphaMax: 1f
		));
		<ins>shape</ins>.AngularVelocity = Random.onUnitSphere * Random.Range(0f, 90f);
		<ins>shape</ins>.Velocity = Random.onUnitSphere * Random.Range(0f, 2f);
	<ins>}</ins></pre>
						
						<p>In <code>GameLevel</code>, remove the <code>SpawnPoint</code> property and add a <code>ConfigureSpawn</code> method, which simply forwards to the method of its spawn zone.</p>
						
						<pre translate="no">	<del>//public Vector3 SpawnPoint {</del>
	<del>//	&hellip;</del>
	<del>//}</del>

	<ins>public void ConfigureSpawn(Shape shape) {</ins>
		<ins>spawnZone.ConfigureSpawn(shape);</ins>
	<ins>}</pre>
						
						<p>Finally, remove all configuration code from <code>CreateShape</code>, instead relying on the <code>ConfigureSpawn</code> method of the level.</p>
						
						<pre translate="no">	void CreateShape () {
		Shape instance = shapeFactory.GetRandom();
		<del>//Transform t = instance.transform;</del>
		<del>//&hellip;</del>
		<del>//instance.Velocity = Random.onUnitSphere * Random.Range(0f, 2f);</del>
		<ins>GameLevel.Current.ConfigureSpawn(instance);</ins>
		shapes.Add(instance);
	}</pre>
						
						<p>At this point everything still works as before, except that it's now <code>SpawnZone</code> that configures the shapes.</p>
					</section>
					
					<section>
						<h3>Relative Velocity</h3>
						
						<p>Now that we configure the shape inside <code>SpawnZone</code>, we have access to the transformation data of the zone. We can use that to make the shape's velocity relative to the zone's orientation, just like the shape's position is also relative. Let's use the zone's local forward direction, multiplied by a random speed.
						
						<pre translate="no">	public void ConfigureSpawn (Shape shape) {
		&hellip;
		shape.Velocity = <ins>transform.forward</ins> * Random.Range(0f, 2f);
	}</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:220px;"><iframe src='https://gfycat.com/ifr/FluidUltimateAsianlion?controls=0'></iframe></div>
							<figcaption>Shapes moving forward.</figcaption>
						</figure>
						
						<p>This works as expected for sphere and cube zones, but not when using a composite spawn zone. Right now the forward direction of the composite spawn zone itself is used, instead of those of its sub zones. To make this work, <code>CompositeSpawnZone</code> must override <code>ConfigureSpawn</code> to forward the invocation to one of its sub zones, just like it does for <code>SpawnPoint</code>. The code can be copied from that property, only changing what it does at the end.</p>
						
						
					<pre translate="no">	public override Vector3 SpawnPoint {
		&hellip;
	}
	
	<ins>public override void ConfigureSpawn (Shape shape) {</ins>
		int index;
		if (sequential) {
			index = nextSequentialIndex++;
			if (nextSequentialIndex >= spawnZones.Length) {
				nextSequentialIndex = 0;
			}
		}
		else {
			index = Random.Range(0, spawnZones.Length);
		}
		spawnZones[index].<ins>ConfigureSpawn(shape)</ins>;
	<ins>}</ins></pre>
						
						<p>To make it possible to override <code>ConfigureSpawn</code>, we have to mark it as <code>virtual</code> in <code>SpawnZone</code>.</p>
						
						<pre translate="no">	public <ins>virtual</ins> void ConfigureSpawn (Shape shape) {
		&hellip;
	}</pre>
					
						<figure>
							<div class="vid" style="width: 250px; height:220px;"><iframe src='https://gfycat.com/ifr/FantasticDistinctJapanesebeetle?controls=0'></iframe></div>
							<figcaption>Relative movement per sub zone.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Configuration per Spawn Zone</h2>
					
					<p>Migrating the responsibility for shape configuration from <code>Game</code> to <code>SpawnZone</code> doesn't just make it easy to set a relative movement direction. It also makes it possible to use different kinds of movement per spawn zone.</p>
					
					<section>
						<h3>Movement Direction</h3>
						
						<p>First, let's make it possible to choose between either a forward or an upward movement direction. To make this choice explicit, create a <code>SpawnMovementDirection</code> enumeration type. Because this type only really makes sense in the context of shape configuration per spawn zone, define it inside the <code>SpawnZone</code> class, instead of putting it in its own script file. Then give <code>SpawnZone</code> a configuration field of this type.</p>
						
						<pre translate="no">	<ins>public enum SpawnMovementDirection {</ins>
		<ins>Forward,</ins>
		<ins>Upward</ins>
	<ins>}</ins>
	
	<ins>[SerializeField]</ins>
	<ins>SpawnMovementDirection spawnMovementDirection;</ins></pre>
						
						<aside>
							<h3>Does the nested type have to be declared public?</h3>
							<div>
								<p>No, but there is no compelling reason to make it protected either. You might need it to be public when working directly with the enumeration outside the class, for example for a custom editor. Outside the <code>SpawnZone</code> class and those that extend it, the enumeration type can be accessed via its fully-qualified name <code>SpawnZone.SpawnMovementDirection</code>.</p>
							</div>
						</aside>
						
						<p>Now we can check in <code>ConfigureSpawn</code> whether the movement direction is set to upward. If so, use <code>transform.up</code>, otherwise keep using <code>transform.forward</code>.</p>
						
						<pre translate="no">	public virtual void ConfigureSpawn (Shape shape) {
		&hellip;
		shape.AngularVelocity = Random.onUnitSphere * Random.Range(0f, 90f);

		<ins>Vector3 direction;</ins>
		<ins>if (spawnMovementDirection == SpawnMovementDirection.Upward) {</ins>
			<ins>direction = transform.up;</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>direction = transform.forward;</ins>
		<ins>}</ins>
		shape.Velocity = <ins>direction</ins> * Random.Range(0f, 2f);
	}</pre>
						
						<figure>
							<img src="configuration-per-spawn-zone/upward-movement.png" width="320" height="74">
							<figcaption>Upward movement direction selected.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Outward Movement</h3>
						
						<p>Besides choosing a uniform movement direction, it is also possible to make the shapes move away from the center of the spawn zone. Add an <code>Outward</code> option to the enumeration for that.</p>
						
						<pre translate="no">	public enum SpawnMovementDirection {
		Forward,
		Upward<ins>,</ins>
		<ins>Outward</ins>
	}</pre>
						
						<p>The correct direction for outward movement is found by subtracting the zone's position from the shape's position and normalizing the result. Note that we have to use <code>transform.position</code> and not the local position, because spawn zones need not be root objects. Also, the relation doesn't last after configuration, so the direction doesn't change if the zone happens to move.</p>
						
						<pre translate="no">		if (spawnMovementDirection == SpawnMovementDirection.Upward) {
			direction = transform.up;
		}
		<ins>else if (spawnMovementDirection == SpawnMovementDirection.Outward) {</ins>
			<ins>direction = (t.localPosition - transform.position).normalized;</ins>
		<ins>}</ins>
		else {
			direction = transform.forward;
		}</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:220px;"><iframe src='https://gfycat.com/ifr/SandyImaginaryFallowdeer?controls=0'></iframe></div>
							<figcaption>Outward movement.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Random Movement</h3>
						
						<p>Let's also support a random direction, which is what we started with. Add <code>Random€</code> to the enumeration.</p>
						
						<pre translate="no">	public enum SpawnMovementDirection {
		Forward,
		Upward,
		Outward<ins>,</ins>
		<ins>Random€</ins>
	}</pre>
						
						<p>And use <code>Random.onUnitSphere</code> to produce a random direction vector.</p>
						
						<pre translate="no">		else if (spawnMovementDirection == SpawnMovementDirection.Outward) {
			direction = (t.localPosition - transform.position).normalized;
		}
		<ins>else if (spawnMovementDirection == SpawnMovementDirection.Random€) {</ins>
			<ins>direction = Random.onUnitSphere;</ins>
		<ins>}</ins>
		else {
			direction = transform.forward;
		}</pre>
						
						<figure>
							<div class="vid" style="width: 250px; height:220px;"><iframe src='https://gfycat.com/ifr/AltruisticAnxiousAdder?controls=0'></iframe></div>
							<figcaption>Random movement.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Speed Range</h3>
						
						<p>Besides the direction of movement, we can also control the speed range. All we need is configuration fields for both the minimum speed and the maximum speed.</p>
						
						<pre translate="no">	<ins>[SerializeField] float spawnSpeedMin, spawnSpeedMax;</ins>

	public virtual void ConfigureSpawn (Shape shape) {
		&hellip;
		shape.Velocity = direction * Random.Range(<ins>spawnSpeedMin</ins>, <ins>spawnSpeedMax</ins>);
	}</pre>
						
						<figure>
							<img src="configuration-per-spawn-zone/spawn-speed-min-max.png" width="320" height="110" alt="inspector"><br>
							<div class="vid" style="width: 250px; height:220px;"><iframe src='https://gfycat.com/ifr/SeparateFemaleFrilledlizard?controls=0'></iframe></div>
							<figcaption>Speeds between 1.5 and 2.5.</figcaption>
						</figure>
						
						<p>Having to use two fields to control a single range is inconvenient, especially if we want to add more ranges later. Unity doesn't have a range type for floats, so let's make one ourselves. Create a struct type named <code>FloatRange</code> with public min and max float fields. Essentially, it's a <code>Vector2</code> with appropriately-named fields and without the vector-related functionality. Instead, give it a convenient <code>RandomValueInRange</code> property that takes care of the invocation of <code>Random.Range</code>.</p>
						
						<p>Note that <code>FloatRange</code> is not specific to shape configuration and is defined in its own script file, as usual.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public struct FloatRange {</ins>

	<ins>public float min, max;</ins>

	<ins>public float RandomValueInRange {</ins>
		<ins>get {</ins>
			<ins>return Random.Range(min, max);</ins>
		<ins>}</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>To make Unity save float range values, mark the type with the <code>Serializable</code> attribute. The attribute exists in the <code>System</code> namespace, but that namespace also contains a <code>Random</code> type, which clashes with Unity's version. To avoid that, just write <code>System.Serializable</code> instead of using the namespace.</p>
						
						<pre translate="no"><ins>[System.Serializable]</ins>
public struct FloatRange {
	&hellip;
}</pre>
						
						<p>Now we can use one <code>FloatRange</code> field and its convenient property in <code>SpawnZone</code>.</p>
						
						<pre translate="no">	<del>//[SerializeField] float spawnSpeedMin, spawnSpeedMax;</del>
	<ins>[SerializeField]</ins>
	<ins>FloatRange spawnSpeed;</ins>

	public virtual void ConfigureSpawn (Shape shape) {
		&hellip;
		shape.Velocity = direction * <ins>spawnSpeed.RandomValueInRange</ins>;
	}</pre>
						
						<figure>
							<img src="configuration-per-spawn-zone/spawn-speed-range.png" width="320" height="128">
							<figcaption>Speed range.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Isolating the Configuration</h3>
						
						<p>We can also create a type to contain all configuration options for spawning. That neatly groups them together and makes it so we don't have to prefix all fields with <code>spawn</code>. So define a serializable <code>SpawnConfiguration</code> struct type inside <code>SpawnZone</code> and put relevant fields plus the enumeration type in it, with their prefixes removed. Then <code>SpawnZone</code> only needs a single spawn configuration field.</p>
						
						<pre translate="no">	<del>//public enum SpawnMovementDirection {</del>
	<del>//	&hellip;</del>
	<del>//}</del>

	<del>//[SerializeField]</del>
	<del>//SpawnMovementDirection spawnMovementDirection;</del>

	<del>//[SerializeField]</del>
	<del>//FloatRange spawnSpeed;</del>

	<ins>[System.Serializable]</ins>
	<ins>public struct SpawnConfiguration {</ins>

		<ins>public enum MovementDirection {</ins>
			<ins>Forward,</ins>
			<ins>Upward,</ins>
			<ins>Outward,</ins>
			<ins>Random€</ins>
		<ins>}</ins>

		<ins>public MovementDirection movementDirection;</ins>

		<ins>public FloatRange speed;</ins>
	<ins>}</ins>

	<ins>[SerializeField]</ins>
	<ins>SpawnConfiguration spawnConfig;</ins></pre>
						
						<aside>
							<h3>Shouldn't <code>SpawnConfiguration</code> be a class?</h3>
							<div>
								<p>The point is to group data together, while keeping it inside the <code>SpawnZone</code> object, which is exactly what the struct type does. As a class, the data would exist as its own object somewhere else in memory and <code>spawnConfig</code> would be a reference to that object. If we were to pass around configurations then a class would be appropriate, but we're not going to do that.</p>
							</div>
						</aside>
						
						<p>Adjust the references in <code>ConfigureSpawn</code> to match. At this point, because the movement direction names have become very long, it can be convenient to replace the <code>if</code>-<code>else</code> sequence with a <code>switch</code> block.</p> 
						
						<pre translate="no">	public virtual void ConfigureSpawn (Shape shape) {
		&hellip;

		Vector3 direction;
		<ins>switch (spawnConfig.movementDirection) {</ins>
			<ins>case SpawnConfiguration.MovementDirection.Upward:</ins>
				direction = transform.up;
				<ins>break;</ins>
			<ins>case SpawnConfiguration.MovementDirection.Outward:</ins>
				direction = (t.localPosition - transform.position).normalized;
				<ins>break;</ins>
			<ins>case SpawnConfiguration.MovementDirection.Random:</ins>
				direction = Random.onUnitSphere;
				<ins>break;</ins>
			<ins>default:</ins>
				direction = transform.forward;
				<ins>break;</ins>
		<ins>}</ins>
		shape.Velocity = direction * <ins>spawnConfig.speed</ins>.RandomValueInRange;
	}</pre>
						
						<figure>
							<img src="configuration-per-spawn-zone/spawn-configuration.png" width="320" height="146">
							<figcaption>Spawn configuration section.</figcaption>
						</figure>
						
						<aside>
							<h3>How does <code>switch</code> work?</h3>
							<div>
								<p>A <code>switch</code> block is an archaic way to branch based on a single variable or field. It uses labels to control the flow of execution. Each label is defined by <code>case</code> followed by a value and a colon. If the value used to switch matches a label, code execution jumps to just after that label. There is also a special <code>default</code> label, which is used when none of the other labels match.</p>
								
								<p>Instead of using code blocks for each case, the relevant code sections have to be terminated with a <code>break</code> or a <code>return</code> statement.</p>
								
								<pre translate="no">if (x == 1) { DoA(); } else if (x == 2) { DoB(); } else { doC(); }</pre>
								
								<p>is functionally the same as</p>
								
								<pre translate="no">switch (x) { case 1: DoA(); break; case 2: DoB(); break; default: DoC(); break; }</pre>
								
								<p>Besides that, it is possible to declare multiple labels together, like <code>case 1: case 2: DoAB(); break;</code> which is equivalent to <code>if (x == 1 || x == 2) { DoAB(); }</code>. It is also possible to use <code>goto</code> to jump to another case. But that use case is rare. I'm only using it here to keep code lines shorter by not having to repeat <code>spawnConfig.movementDirection</code>.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Composite Spawn Zone Override</h3>
						
						<p>Note that all spawn zone types now have spawn configuration options, thus also the composite spawn zone. We can use that to override the configuration of its sub zones. Add a toggle to <code>CompositeSpawnZone</code> to make that optional. If it should override, then have it invoke the base implementation of <code>ConfigureSpawn</code> instead of forwarding it to one of the sub zones. It will then use its own configuration, while still selecting a spawn point from a sub zone.</p>
						
						<pre translate="no">	<ins>[SerializeField]</ins>
	<ins>bool overrideConfig;</ins>
	
	&hellip;
	
	public override void ConfigureSpawn (Shape shape) {
		<ins>if (overrideConfig) {</ins>
			<ins>base.ConfigureSpawn(shape);</ins>
		<ins>}</ins>
		<ins>else {</ins>
			int index;
			if (sequential) {
				index = nextSequentialIndex++;
				if (nextSequentialIndex >= spawnZones.Length) {
					nextSequentialIndex = 0;
				}
			}
			else {
				index = Random.Range(0, spawnZones.Length);
			}
			spawnZones[index].ConfigureSpawn(shape);
		<ins>}</ins>
	}</pre>

						<figure>
							<img src="configuration-per-spawn-zone/spawn-config-override.png" width="320" height="182" alt="inspector"><br>
							<div class="vid" style="width: 250px; height:220px;"><iframe src='https://gfycat.com/ifr/ThriftyClassicGelding?controls=0'></iframe></div>
							<figcaption>One config for all zones.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Advanced Configuration</h2>
					
					<p>Now that we have created a way to configure spawn movement per zone, we can extend this approach. There are more things that we can control, and we can improve the presentation of these options further.</p>
					
					<section>
						<h3>Angular Speed and Scale</h3>
						
						<p>Additional candidates for configuration are the rotation speed and scale of the shapes. Add a <code>FloatRange</code> field for both to <code>SpawnConfiguration</code> and use them in <code>ConfigureSpawn</code>.</p>
						
						<pre translate="no">	public struct SpawnConfiguration {

		&hellip;

		<ins>public FloatRange angularSpeed;</ins>

		<ins>public FloatRange scale;</ins>
	}
	
	&hellip;
						
	public virtual void ConfigureSpawn (Shape shape) {
		Transform t = shape.transform;
		t.localPosition = SpawnPoint;
		t.localRotation = Random.rotation;
		t.localScale = Vector3.one * <ins>spawnConfig.scale.RandomValueInRange</ins>;
		shape.SetColor(Random.ColorHSV(
			hueMin: 0f, hueMax: 1f,
			saturationMin: 0.5f, saturationMax: 1f,
			valueMin: 0.25f, valueMax: 1f,
			alphaMin: 1f, alphaMax: 1f
		));
		shape.AngularVelocity =
			Random.onUnitSphere * <ins>spawnConfig.angularSpeed.RandomValueInRange</ins>;

		&hellip;
	}</pre>
						
						<figure>
							<img src="advanced-configuration/angular-speed-and-scale.png" width="320" height="254">
							<figcaption>Taking up lots of space.</figcaption>
						</figure>
						
						<p>We can add even more options&mdash;like a way to control the angular rotation axis&mdash;but the point is that the inspector of our configuration quickly becomes large and unwieldy. Each float range takes up three lines when expanded, which is a lot. It would be better if each could fit on a single line.</p>
					</section>
					
					<section>
						<h3>Custom Property Drawer</h3>
						
						<p>We can override Unity's default way to draw a <code>FloatRange</code> value by creating a custom property drawer for it. Add a <code>FloatRangeDrawer</code> class for this purpose. As it deals with the editor, its file should be placed in an <em translate="no">Editor</em> folder. That tells Unity to compile and combine it with all the other editor-related code and keep it out of builds.</p>
						
						<figure>
							<img src="advanced-configuration/editor-script.png" width="170" height="96">
							<figcaption>An editor script.</figcaption>
						</figure>
						
						<p>Editor classes rely on things from the <code>UnityEditor</code> namespace, so use that in addition to <code>UnityEngine</code>. To make the class a property drawer, it has to extend the <code>PropertyDrawer</code> class.</p>
						
						<pre translate="no"><ins>using UnityEditor;</ins>
<ins>using UnityEngine;</ins>

<ins>public class FloatRangeDrawer : PropertyDrawer {}</ins></pre>
						
						<p>Besides that, we have to tell Unity what type we want to create a custom property drawer for. That's done by adding the <code>CustomPropertyDrawer</code> attribute to our class. We have to supply it with the relevant type as an argument, which we can specify with the help of <code>typeof</code>.</p>
						
						<pre translate="no"><ins>[CustomPropertyDrawer(typeof(FloatRange))]</ins>
public class FloatRangeDrawer : PropertyDrawer {}</pre>
						
						<p>Now Unity will invoke the <code>OnGUI</code> method of our property drawer each time it has to show the UI for a <code>FloatRange</code> value. We have to override that method to create our own UI. It has three parameters: a <code>Rect</code> defining a region to draw in, a <code>SerializedProperty</code> representing the float range value, and a <code>GUIContent</code> containing the default label to use for it. Initially, leave the method empty.</p>
						
						<aside>
							<h3>Shouldn't <code>position</code> be named <code>area</code>, <code>rect</code>, or something similar?</h3>
							<div>
								<p>That would make more sense, because it really describes a rectangular UI region and not just a position. But Unity consistently uses <code>position</code>, so I'll do that too.</p>
							</div>
						</aside>
						
						<pre translate="no">	<ins>public override void OnGUI (</ins>
		<ins>Rect position, SerializedProperty property, GUIContent label</ins>
	<ins>) {}</ins></pre>
						
						<figure>
							<img src="advanced-configuration/empty-properties.png" width="320" height="146">
							<figcaption>Empty lines.</figcaption>
						</figure>
						
						<p>Because we're not doing anything in <code>OnGUI</code>, nothing gets drawn. But the default property reserves a single line for itself, so the inspector for our spawn configuration has already shrunk to the desired size.</p>
						
						<p>We should start by telling the Unity editor that we're creating the UI for our property, by invoking <code>EditorGUI.BeginProperty</code> with the same arguments as <code>OnGUI</code>, only with the label and property swapped. And once we're done we invoke <code>EditorGUI.EndProperty</code>. We'll create the UI in between these invocations. While it doesn't seem to do anything, this ensures that the editor will be able to deal with prefabs and prefab overrides.</p>
						
						<pre translate="no">	public override void OnGUI (
		Rect position, SerializedProperty property, GUIContent label
	) {
		<ins>EditorGUI.BeginProperty(position, label, property);</ins>
		<ins>EditorGUI.EndProperty();</ins>
	}</pre>
						
						<p>Our float range property consists of two sub-properties, its min and max floats. We can access them by invoking <code>FindPropertyRelative</code> on the property, with the appropriate name as a string argument. That once again gives us a <code>SerializedProperty</code> instance. The simplest way to show the UI for such a property is to invoke <code>EditorGUI.PropertyField</code> with the position and the property as arguments. Do this for the min value.</p>
						
						<pre translate="no">		EditorGUI.BeginProperty(position, label, property);
		<ins>EditorGUI.PropertyField(position, property.FindPropertyRelative("min"));</ins>
		EditorGUI.EndProperty();</pre>
						
						<figure>
							<img src="advanced-configuration/min-only.png" width="320" height="74">
							<figcaption>Minimum only.</figcaption>
						</figure>
						
						<p>We end up with the min value for each range, fully editable. Let's add the max values as well, using the same approach.</p>
						
						<pre translate="no">		EditorGUI.BeginProperty(position, label, property);
		EditorGUI.PropertyField(position, property.FindPropertyRelative("min"));
		<ins>EditorGUI.PropertyField(position, property.FindPropertyRelative("max"));</ins>
		EditorGUI.EndProperty();</pre>
						
						<figure>
							<img src="advanced-configuration/min-max-superimposed.png" width="320" height="54">
							<figcaption>Minimum and maximum superimposed.</figcaption>
						</figure>
						
						<p>The UI for the min and max fields end up drawn on top of each other, because we used the same position settings for both. When drawing properties, Unity gives us a rectangular region to drawn in and we have to take care of layout ourselves. In this case, we can simply halve the width of the region and increase the horizontal coordinate by that width for the second field.</p>
						
						<pre translate="no">		EditorGUI.BeginProperty(position, label, property);
		<ins>position.width = position.width / 2f;</ins>
		EditorGUI.PropertyField(position, property.FindPropertyRelative("min"));
		<ins>position.x += position.width;</ins>
		EditorGUI.PropertyField(position, property.FindPropertyRelative("max"));
		EditorGUI.EndProperty();</pre>
						
						<figure>
							<img src="advanced-configuration/min-max-separate.png" width="320" height="54">
							<figcaption>Minimum and maximum next to each other.</figcaption>
						</figure>
						
						<p>Next, we'll have to add the label for the range. That is done by invoking <code>EditorGUI.PrefixLabel</code> with the position and label that was given to us. As the label takes up some space, the method returns a modified region that gives us the remaining space for the rest of our UI.</p>
						
						<pre translate="no">		EditorGUI.BeginProperty(position, label, property);
		<ins>position = EditorGUI.PrefixLabel(position, label);</ins>
		position.width = position.width / 2f;</pre>
						
						<figure>
							<img src="advanced-configuration/prefix-label.png" width="320" height="54">
							<figcaption>With prefix label.</figcaption>
						</figure>
						
						<p>This screws up our layout, because Unity uses a fixed width for the labels, which is too wide for our min and max fields. We can override that width by setting the <code>EditorGUIUtility.labelWidth</code> property. Let's set it to half of the width we use per field.</p>
						
						<pre translate="no">		position.width = position.width / 2f;
		<ins>EditorGUIUtility.labelWidth = position.width / 2f;</ins></pre>
						
						<figure>
							<img src="advanced-configuration/resized-labels.png" width="320" height="54">
							<figcaption>Resized labels.</figcaption>
						</figure>
						
						<p>That looks good, but only because our range fields end up with an indentation of one step. Unity keeps track of the UI indentation globally, but we can override it by setting the <code>EditorGUI.indentLevel</code> property. Make sure it's set to 1, which pushes the label text one step to the right.</p>
						
						<pre translate="no">		EditorGUIUtility.labelWidth = position.width / 2f;
		<ins>EditorGUI.indentLevel = 1;</ins></pre>
						
						<figure>
							<img src="advanced-configuration/min-selection-incorrect.png" width="320" height="54">
							<figcaption>Selecting Min highlights too much.</figcaption>
						</figure>
						
						<p>Notice that when an input field is selected, the corresponding label turns blue. But when a min fields is selected, the label of its range also turns blue. That's because they end up with the same UI control ID. We can avoid that by adding a specific control ID as an argument when invoking <code>PrefixLabel</code>. Selecting the entire range is pointless, so use <code>GUIUtility.GetControlID(FocusType.Passive)</code>. That prevents it from becoming blue and skips it when you use the tab key to step through the UI controls in the editor.</p>
						
						<pre translate="no">		position = EditorGUI.PrefixLabel(
			position, <ins>GUIUtility.GetControlID(FocusType.Passive),</ins> label
		);</pre>
						
						<figure>
							<img src="advanced-configuration/min-selection-correct.png" width="320" height="54">
							<figcaption>Selecting Min only highlights its label.</figcaption>
						</figure>
						
						<p>Finally, we should restore the indent level and label width to their original values when we're done. It doesn't matter in this case, because Unity's default editor restores the values for us, but we cannot rely on that in general.</p>
						
						<pre translate="no">		<ins>int originalIndentLevel = EditorGUI.indentLevel;</ins>
		<ins>float originalLabelWidth = EditorGUIUtility.labelWidth;</ins>
		EditorGUI.BeginProperty(position, label, property);

		&hellip;
		
		EditorGUI.EndProperty();
		<ins>EditorGUI.indentLevel = originalIndentLevel;</ins>
		<ins>EditorGUIUtility.labelWidth = originalLabelWidth;</ins></pre>
					</section>
					
					<section>
						<h3>Configurable Color</h3>
						
						<p>Another thing that we can make configurable is the allowed range of random colors. Up to now this was fixed, but we have neat float ranges that we can use to configure it. In fact, we can create a dedicated <code>ColorRangeHSV</code> struct to contain these ranges and provide a convenient property to get a random color out of it. Once again&mdash;like <code>FloatRange</code>&mdash;this struct stands on its own and is not specific to spawn configuration.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>[System.Serializable]</ins>
<ins>public struct ColorRangeHSV {</ins>

	<ins>public FloatRange hue, saturation, value;</ins>

	<ins>public Color RandomInRange {</ins>
		<ins>get {</ins>
			<ins>return Random.ColorHSV(</ins>
				<ins>hue.min, hue.max,</ins>
				<ins>saturation.min, saturation.max,</ins>
				<ins>value.min, value.max,</ins>
				<ins>1f, 1f</ins>
			<ins>);</ins>
		<ins>}</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>Adding color configuration to <code>SpawnConfiguration</code> is now simply a matter of adding a <code>ColorRangeHSV</code> field to it.</p>
						
						<pre translate="no">	public struct SpawnConfiguration {

		&hellip;

		<ins>public ColorRangeHSV color;</ins>
	}</pre>
						
						<p>Now <code>ConfigureSpawn</code> can use the new property instead of worrying about the details of creating a random color.</p>
						
						<pre translate="no">		<del>//shape.SetColor(Random.ColorHSV(</del>
		<del>//	hueMin: 0f, hueMax: 1f,</del>
		<del>//	saturationMin: 0.5f, saturationMax: 1f,</del>
		<del>//	valueMin: 0.25f, valueMax: 1f,</del>
		<del>//	alphaMin: 1f, alphaMax: 1f</del>
		<del>//));</del>
		<ins>shape.SetColor(spawnConfig.color.RandomInRange);</ins></pre>

						<figure>
							<img src="advanced-configuration/color-config.png" width="320" height="218" alt="inspector">
							<img src="advanced-configuration/colors.png" width="260" height="210" alt="scene">
							<figcaption>Now with color options.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Range Sliders</h3>
						
						<p>The hue, saturation, and value must all fall between 0 and 1, so it doesn't make sense to allow any other values. If they were simple float fields, then we could have used the <code>Range</code> attribute to enforce this in the editor, turning the input fields into sliders.</p>
						
						<pre translate="no">	<ins>[Range(0f, 1f)]</ins>
	public FloatRange hue, saturation, value;</pre>
						
						<figure>
							<img src="advanced-configuration/range-attribute.png" width="320" height="72">
							<figcaption>Range attribute doesn't work.</figcaption>
						</figure>
						
						<p>But that doesn't work, because <code>Range</code> only works for a float or int. So let's create our own attribute. That's done by defining a class that extends <code>PropertyAttribute</code>. The convention is to add <code>Attribute</code> as a suffix, so we'll name it <code>FloatRangeSliderAttribute</code>. Although we only use this metadata in the editor, its script file must not be placed in an <em translate="no">Editor</em> folder, as we're going to use this type in <code>ColorRangeHSV</code>.</p>
						
						<p>The attribute is just a container for two properties, <code>Min</code> and <code>Max</code>. They should be publicly readable, but only have to be set by the attribute itself.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public class FloatRangeSliderAttribute : PropertyAttribute {</ins>

	<ins>public float Min { get; private set; }</ins>
	
	<ins>public float Max { get; private set; }</ins>
<ins>}</ins></pre>
						
						<p>Add a constructor method that has the minimum and maximum as parameters, to initialize the properties. To keep the range sensible, enforce that the maximum isn't less than the minimum.</p>
						
						<pre translate="no">	<ins>public FloatRangeSliderAttribute (float min, float max) {</ins>
		<ins>if (max &lt; min) {</ins>
			<ins>max = min;</ins>
		<ins>}</ins>
		<ins>Min = min;</ins>
		<ins>Max = max;</ins>
	<ins>}</ins></pre>
						
						<p>Now we can use our own attribute instead of <code>Range</code>. As an attribute, we can refer to it as <code>FloatRangeSlider</code>, omitting the <code>Attribute</code> suffix.</p>
						
						<pre translate="no">	[<ins>FloatRangeSlider</ins>(0f, 1f)]
	public FloatRange hue, saturation, value;</pre>
						
						<p>That by itself doesn't change how the float ranges are drawn, because all we've done is attach some metadata to the field definitions. We have to create another custom property drawer, this time for <code>FloatRangeSliderAttribute</code> instead of for <code>FloatRange</code>. Again begin with a basic drawer that leaves the UI empty.</p>
						
						<pre translate="no"><ins>using UnityEditor;</ins>
<ins>using UnityEngine;</ins>

<ins>[CustomPropertyDrawer(typeof(FloatRangeSliderAttribute))]</ins>
<ins>public class FloatRangeSliderDrawer : PropertyDrawer {</ins>

	<ins>public override void OnGUI (</ins>
		<ins>Rect position, SerializedProperty property, GUIContent label</ins>
	<ins>) {</ins>
		<ins>EditorGUI.BeginProperty(position, label, property);</ins>
		<ins>EditorGUI.EndProperty();</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>Before drawing a property, the Unity editor checks whether there is a drawer that applies to an attribute attached to it. If so, it uses that one. Otherwise, it checks whether there is a drawer that applies to the property's type and uses that one. If not, it will use its default drawer. So attributes take precedence, and we once again end up with empty lines.</p>
						
						<p>We still need to access the min and max properties, but this time we want to draw a slider to indicate a range, not two separate float fields. So keep hold of them with variables.</p>
						
						<pre translate="no">		EditorGUI.BeginProperty(position, label, property);
		<ins>SerializedProperty minProperty = property.FindPropertyRelative("min");</ins>
		<ins>SerializedProperty maxProperty = property.FindPropertyRelative("max");</ins>
		EditorGUI.EndProperty();</pre>
						
						<p>We can access the float values of min and max via the <code>floatValue</code> property. First we have to get them, then after we've shown the range slider we'll have to set them, in case they were changed. Unity will take care of detecting changes and supporting undo and redo for us.</p>
						
						<pre translate="no">		EditorGUI.BeginProperty(position, label, property);
		SerializedProperty minProperty = property.FindPropertyRelative("min");
		SerializedProperty maxProperty = property.FindPropertyRelative("max");
		<ins>float minValue = minProperty.floatValue;</ins>
		<ins>float maxValue = maxProperty.floatValue;</ins>
		<ins>minProperty.floatValue = minValue;</ins>
		<ins>maxProperty.floatValue = maxValue;</ins>
		EditorGUI.EndProperty();</pre>
						
						<p>Next, we need to know the limit of the slider that we are about to show, which is stored in our attribute. We can access it via the <code>attribute</code> property of <code>PropertyDrawer</code>. The type of <code>attribute</code> is <code>PropertyAttribute</code>, so we have to cast it to our own type, by writing <code>attribute as FloatRangeSliderAttribute</code>.</p>
						
						<pre translate="no">		float minValue = minProperty.floatValue;
		float maxValue = maxProperty.floatValue;
		<ins>FloatRangeSliderAttribute limit = attribute as FloatRangeSliderAttribute;</ins>
		minProperty.floatValue = minValue;
		maxProperty.floatValue = maxValue;</pre>
						
						<p>Now we have all that we need to draw a slider range, by invoking <code>EditorGUI.MinMaxSlider</code>. As arguments we'll use the position and label, followed by the min and max values, finishing with the min and max limits. Because the min and max can be changed by the slider, we have to supply them as reference arguments, by putting <code>ref</code> in front of them. That turns them into references to the variables&mdash;as if they were objects instead of floats&mdash;so <code>MinMaxSlider</code> can alter them. That is necessary because a method cannot return two values.</p>
						
						<pre translate="no">		FloatRangeSliderAttribute limit = attribute as FloatRangeSliderAttribute;
		<ins>EditorGUI.MinMaxSlider(</ins>
			<ins>position, label, ref minValue, ref maxValue, limit.Min€, limit.Max€</ins>
		<ins>);</ins></pre>

						<figure>
							<img src="advanced-configuration/sliders.png" width="320" height="72">
							<figcaption>Sliders for ranges between 0 to 1.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Sliders with Values</h3>
						
						<p>While the sliders are nice, it isn't possible to specify exact values, except for the extremes. This might not be a problem as colors don't need to be exact, but it makes it impossible to check the values of one slider to copy for use somewhere else. So let's add regular input fields for the min and max values too.</p>
						
						<p>First, we'll remove the label from the slider, which makes it possible to put it in between two float fields. Simply remove the label argument from the invocation of <code>MinMaxSlider</code>.</p>
						
						<pre translate="no">		EditorGUI.MinMaxSlider(
			<del>//position, label, ref minValue, ref maxValue, limit.Min, limit.Max</del>
			<ins>position, ref minValue, ref maxValue, limit.Min€, limit.Max€</ins>
		);</pre>
						
						<figure>
							<img src="advanced-configuration/sliders-no-labels.png" width="320" height="72">
							<figcaption>Sliders without labels.</figcaption>
						</figure>
						
						<p>Next, we have to draw the label separately, using <code>PrefixLabel</code> as before. Also, we don't want the indent level to mess with our layout, so set it to zero after the label, and reset it when we're done.</p>
						
						<pre translate="no">		<ins>int originalIndentLevel = EditorGUI.indentLevel;</ins>
		EditorGUI.BeginProperty(position, label, property);

		<ins>position = EditorGUI.PrefixLabel(</ins>
			<ins>position, GUIUtility.GetControlID(FocusType.Passive), label</ins>
		<ins>);</ins>
		<ins>EditorGUI.indentLevel = 0;</ins>
		&hellip;
		
		EditorGUI.EndProperty();
		<ins>EditorGUI.indentLevel = originalIndentLevel;</ins></pre>
						
						<p>We'll begin by dividing the remaining space equally between the three parts. First use <code>EditorGUI.FloatField</code> to draw a float input field for min, without a label. It returns the possibly changed value. After that comes the slider, followed by the max input field.
						
						<pre translate="no">		float minValue = minProperty.floatValue;
		float maxValue = maxProperty.floatValue;
		<ins>position.width /= 3;</ins>
		<ins>minValue = EditorGUI.FloatField(position, minValue);</ins>
		<ins>position.x += position.width;</ins>
		FloatRangeSliderAttribute limit = attribute as FloatRangeSliderAttribute;
		EditorGUI.MinMaxSlider(
			position, ref minValue, ref maxValue, limit.Min€, limit.Max€
		);
		<ins>position.x += position.width;</ins>
		<ins>maxValue = EditorGUI.FloatField(position, maxValue);</ins>
		minProperty.floatValue = minValue;
		maxProperty.floatValue = maxValue;</pre>
						
						<figure>
							<img src="advanced-configuration/sliders-with-values.png" width="320" height="65">
							<figcaption>Sliders with value fields.</figcaption>
						</figure>
						
						<p>We can improve the layout by dedicating half of the width to the slider, leaving the float fields with a quarter each. Also, it looks better if we add a little padding between the slider and floats. Do this by subtracting four pixels from the width of the float fields, shifting the horizontal positions to compensate.</p>
						
						<pre translate="no">		<ins>float fieldWidth = position.width / 4f - 4f;</ins>
		<ins>float sliderWidth = position.width / 2f;</ins>
		position.width = <ins>fieldWidth</ins>;
		minValue = EditorGUI.FloatField(position, minValue);
		position.x += <ins>fieldWidth + 4f</ins>;
		<ins>position.width = sliderWidth;</ins>
		FloatRangeSliderAttribute limit = attribute as FloatRangeSliderAttribute;
		EditorGUI.MinMaxSlider(
			position, ref minValue, ref maxValue, limit.Min€, limit.Max€
		);
		position.x += <ins>sliderWidth + 4f</ins>;
		<ins>position.width = fieldWidth;</ins>
		maxValue = EditorGUI.FloatField(position, maxValue);</pre>
						
						<figure>
							<img src="advanced-configuration/sliders-pretty.png" width="320" height="56">
							<figcaption>Sliders with pretty layout.</figcaption>
						</figure>
						
						<p>We wrap up by enforcing that the direct input fields cannot go beyond the limits and that max is never less than min.</p>
						
						<pre translate="no">		maxValue = EditorGUI.FloatField(position, maxValue);
		<ins>if (minValue &lt; limit.Min€) {</ins>
			<ins>minValue = limit.Min€;</ins>
		<ins>}</ins>
		<ins>else if (minValue > limit.Max€) {</ins>
			<ins>minValue = limit.Max€;</ins>
		<ins>}</ins>
		<ins>if (maxValue &lt; minValue) {</ins>
			<ins>maxValue = minValue;</ins>
		<ins>}</ins>
		<ins>else if (maxValue > limit.Max€) {</ins>
			<ins>maxValue = limit.Max;</ins>
		<ins>}</ins>
		minProperty.floatValue = minValue;
		maxProperty.floatValue = maxValue;</pre>
		
						<p>The next tutorial is <a href="../more-factories/index.html">More Factories</a>.</p>
					</section>
					
					
					<a href="https://bitbucket.org/catlikecodingunitytutorials/object-management-07-configuring-shapes/" class="repository">repository</a>
					<a href="Configuring-Shapes.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>