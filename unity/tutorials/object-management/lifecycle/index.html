<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/object-management/lifecycle/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/object-management/lifecycle/tutorial-image.jpg">
		<meta property="og:title" content="Lifecycle">
		<meta property="og:description" content="A Unity Object Management tutorial about growing and dying shapes.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Lifecycle</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/object-management/lifecylce/#article",
				"headline": "Lifecycle",
				"alternativeHeadline": "Growth and Death",
				"datePublished": "2019-02-19",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Object Management tutorial about growing and dying shapes.",
				"image": "https://catlikecoding.com/unity/tutorials/object-management/lifecycle/tutorial-image.jpg",
				"dependencies": "Unity 2017.4.12f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/object-management/", "name": "Object Management" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				ColorRangeHSV: 1,
				CompositeSpawnZone: 1,
				CubeSpawnZone: 1,
				DyingShapeBehavior: 1,
				FloatRange: 1,
				FloatOrIntRangeDrawer: 1,
				FloatRangeDrawer: 1,
				FloatRangeSlider: 1,
				FloatRangeSliderAttribute: 1,
				FloatRangeSliderDrawer: 1,
				Game: 1,
				GameDataReader: 1,
				GameDataWriter: 1,
				GameLevel: 1,
				GrowingShapeBehavior: 1,
				IntRange: 1,
				LifecycleConfiguration: 1,
				LifecycleShapeBehavior: 1,
				MovementDirection: 1,
				MovementShapeBehavior: 1,
				OscillationShapeBehavior: 1,
				PersistableObject: 1,
				PersistentStorage: 1,
				RotatingObject: 1,
				RotationShapeBehavior: 1,
				SatelliteConfiguration: 1,
				SatelliteShapeBehavior: 1,
				Shape: 1,
				ShapeBehavior: 1,
				ShapeBehaviorPool: 1,
				ShapeBehaviorType: 1,
				ShapeBehaviorTypeMethods: 1,
				ShapeFactory: 1,
				ShapeInstance: 1,
				SpawnConfiguration: 1,
				SpawnMovementDirection: 1,
				SpawnZone: 1,
				SphereSpawnZone: 1,
				T: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Object Management</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Lifecycle</h1>
					<p>Growth and Death</p>
					<ul>
						<li>Make shapes grow and shrink.</li>
						<li>Allow behavior to kill shapes.</li>
						<li>Delay killing until after the game update loop.</li>
						<li>Replace immediate shape destruction with shrinking.</li>
					</ul>
				</header>
				
				<p>This is the eleventh tutorial in a series about <a href="../index.html">Object Management</a>. It introduces more fluid shape creation and destruction, by adding behavior for growing and dying.</p>
				
				<p>This tutorial is made with Unity 2017.4.12f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Limited lifespans keep the population stable.</figcaption>
				</figure>
				
				<section>
					<h2>Growing Shapes</h2>
					
					<p>Whenever a shape is spawned it instantly appears, at full size. Shapes pop into existence without warning, which can be a jarring experience. One way to make the introduction of a new shape smoother and more gradual is to give them an initial scale of zero and slowly grow them to their full size. Another approach is to initially make them fully transparent and gradually make them more opaque. It's also possible do both at the same time, or do something else. We don't need to limit ourselves to a single approach, so the most flexible way to go about it is to create a behavior, rather than build it into the <code>Shape</code> class. In this tutorial we'll go for the first approach: growth.</p>
					
					<section>
						<h3>Growing Behavior</h3>
						
						<p>To support growing shapes, add a <code>Growing</code> option to the <code>ShapeBehaviorType</code> enum.</p>
												
						<pre translate="no">public enum ShapeBehaviorType {
	Movement,
	Rotation,
	Oscillation,
	Satellite<ins>,</ins>
	<ins>Growing</ins>
}</pre>
						
						<p>Add a corresponding case to the <code>GetInstance</code> method that returns a <code>GrowingShapeBehavior</code>.</p>
						
						<pre translate="no">			case ShapeBehaviorType.Satellite:
				return ShapeBehaviorPool&lt;SatelliteShapeBehavior>.Get();
			<ins>case ShapeBehaviorType.Growing:</ins>
				<ins>return ShapeBehaviorPool&lt;GrowingShapeBehavior>.Get();</ins></pre>
						
						<p>Create a bare-bones implementation for the new <code>GrowingShapeBehavior</code> class.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public sealed class GrowingShapeBehavior : ShapeBehavior {</ins>

	<ins>public override ShapeBehaviorType BehaviorType {</ins>
		<ins>get {</ins>
			<ins>return ShapeBehaviorType.Growing;</ins>
		<ins>}</ins>
	<ins>}</ins>

	<ins>public override bool GameUpdate (Shape shape) {</ins>
		<ins>return true;</ins>
	<ins>}</ins>

	<ins>public override void Save (GameDataWriter writer) {}</ins>

	<ins>public override void Load (GameDataReader reader) {}</ins>

	<ins>public override void Recycle () {</ins>
		<ins>ShapeBehaviorPool&lt;GrowingShapeBehavior>.Reclaim(this);</ins>
	<ins>}</ins>
<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Going from Zero to Full Scale</h3>
						
						<p>The purpose of <code>GrowingShapeBehavior</code> is to grow the shape from zero to the scale that we originally gave it. So we have to keep track of the original scale in a field. Also, it takes a while to grow, so we also need a duration field. Both values must also be saved and loaded.</p>
						
						<pre translate="no">	<ins>Vector3 originalScale;</ins>
	<ins>float duration;</ins>

	&hellip;

	public override void Save (GameDataWriter writer) {
		<ins>writer.Write(originalScale);</ins>
		<ins>writer.Write(duration);</ins>
	}

	public override void Load (GameDataReader reader) {
		<ins>originalScale = reader.ReadVector3();</ins>
		<ins>duration = reader.ReadFloat();</ins>
	}</pre>
						
						<p>The idea is that we add this behavior to a shape that already has its final scale. We'll configure the behavior with via an <code>Initialize</code> method, in which we can retrieve the original scale and provide the duration via a parameter. Then we set the shape's scale to zero.</p>
						
						<pre translate="no">	<ins>public void Initialize (Shape shape, float duration) {</ins>
		<ins>originalScale = shape.transform.localScale;</ins>
		<ins>this.duration = duration;</ins>
		<ins>shape.transform.localScale = Vector3.zero;</ins>
	<ins>}</ins></pre>
						
						<p>In <code>GameUpdate</code>, we have to adjust the shape's scale as long as its age is less than the growth duration. The scale factor is simply the age divided by the duration. When the shape is old enough we revert to the original scale and the behavior is no longer needed.</p>
						
						<pre translate="no">	public override bool GameUpdate (Shape shape) {
		<ins>if (shape.Age &lt; duration) {</ins>
			<ins>float s = shape.Age / duration;</ins>
			<ins>shape.transform.localScale = s * originalScale;</ins>
			return true;
		<ins>}</ins>
		<ins>shape.transform.localScale = originalScale;</ins>
		<ins>return false;</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Configuring Growth</h3>
						
						<p>The duration of the growing phase is something that we'll configure per spawn zone. Like for the satellite options, we'll define a nested <code>LifecycleConfiguration</code> struct in <code>SpawnZone.SpawnConfiguration</code> to group all options related to a shape's lifecycle. Right now that's just the growing duration, but we'll add more later. The growing duration can be randomized, but shouldn't be too long, like Somewhere between zero and two seconds.</p>
						
						<pre translate="no">	public struct SpawnConfiguration {
		&hellip;

		<ins>[System.Serializable]</ins>
		<ins>public struct LifecycleConfiguration {</ins>

			<ins>[FloatRangeSlider(0f, 2f)]</ins>
			<ins>public FloatRange growingDuration;</ins>
		<ins>}</ins>

		<ins>public LifecycleConfiguration lifecycle;</ins>
	}</pre>
						
						<figure>
							<img src="growing-shapes/growing-duration.png" width="320" height="72">
							<figcaption>Growing takes between one and two seconds.</figcaption>
						</figure>
						
						<p>Add a method to <code>SpawnZone</code> to take care of setting up the lifecycle of a shape. Besides the shape parameter, also add a parameter for the desired growing duration. If that duration is larger than zero, add a <code>GrowingShapeBehavior</code> to the shape. Otherwise we don't need to bother with the behavior.</p>
						
						<pre translate="no">	<ins>void SetupLifecycle (Shape shape, float growingDuration) {</ins>
		<ins>if (growingDuration > 0f) {</ins>
			<ins>shape.AddBehavior&lt;GrowingShapeBehavior>().Initialize(</ins>
				<ins>shape, growingDuration</ins>
			<ins>);</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>We made the growing duration a parameter so we can use the same duration for a shape and all its satellites. To make that work, add a duration parameter to <code>CreateSatelliteFor</code> and have it invoke <code>SetupLifecycle</code> for the satellite shape at the end.</p>
						
						<pre translate="no">	void CreateSatelliteFor (Shape focalShape<ins>, float growingDuration</ins>) {
		&hellip;
		<ins>SetupLifecycle(shape, growingDuration);</ins>
	}</pre>
						
						<p>At the end of <code>SpawnShapes</code>, randomly determine the growing duration and pass it to all satellites. After the satellites are created we can set up the lifecycle of the main shape. We cannot do that earlier because the scales of the satellites depend on the scale of the focal shape. Initializing the growing behavior sets the scale to zero, so it must be delayed.</p>
						
						<pre translate="no">	public virtual void SpawnShapes () {
		&hellip;

		<ins>float growingDuration =</ins>
			<ins>spawnConfig.lifecycle.growingDuration.RandomValueInRange;</ins>

		int satelliteCount = spawnConfig.satellite.amount.RandomValueInRange;
		for (int i = 0; i &lt; satelliteCount; i++) {
			CreateSatelliteFor(shape<ins>, growingDuration</ins>);
		}

		<ins>SetupLifecycle(shape, growingDuration);</ins>
	}</pre>
						
						<figure>
							<div class="vid" style="width: 225px; height:190px;"><iframe src='https://gfycat.com/ifr/earnestwateryhoki?controls=0'></iframe></div>
							<figcaption>Growing shapes.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Smooth Growth</h3>
						
						<p>When the growing behavior is used, shapes no longer pop into existence immediatetly. But the growth is linear, so the player has no clue when a shape is done growing. The growing phase just stops at an arbitrary moment. We can make that a bit more smooth and organic by using `3s^2-2s^3` instead of the linear `s` scale factor. That's known as the smoothstep curve.</p>						
						<figure>
							<img src="growing-shapes/smoothstep-curve.png" width="200" height="200">
							<figcaption>Linear and smoothstep.</figcaption>
						</figure>
						
						<pre translate="no">			float s = shape.Age / duration;
			<ins>s = (3f - 2f * s) * s * s;</ins>
			shape.transform.localScale = s * originalScale;</pre>
						
						<p>The difference is subtle, but shapes now vary how fast they grow, starting slow, being fastest halfway, and slowing down again when they're almost done.</p>
						
						<figure>
							<div class="vid" style="width: 225px; height:165px;"><iframe src='https://gfycat.com/ifr/slimyenlightenedamericancrayfish?controls=0'></iframe></div>
							<figcaption>Smooth growing shapes.</figcaption>
						</figure>
					</section>
				</section>
				
				<section>
					<h2>Dying Shapes</h2>
					
					<p>If we support growing shapes, it's not a big jump to also support dying shapes. Rather than increasing their scale, dying shapes shrink until their scale has been reduced to zero.</p>
					
					<section>
						<h3>Dying Behavior</h3>
						
						<p>Add a <code>Dying</code> option to <code>ShapeBehaviorType</code> and a corresponding case to the <code>GetInstance</code> method. Then create a <code>DyingShapeBehavior</code> class, by duplicating and renaming <code>GrowingShapeBehavior</code> and adjusting the <code>BehaviorType</code> property and <code>Recycle</code> method as needed. Such adjustments should be routine by now, so I'm not explicitly showing them.</p>
						
						<p>The dying behavior needs the original scale and a duration, just like growing. But growing assumes that we start at age zero, while dying can start at any age. So we also need to keep track of the age at which we began dying, which is when <code>Initialize</code> is invoked. Also, because we're shrinking, the original scale should not be set to zero in <code>Initialize</code>.</p>
						
						<pre translate="no">	Vector3 originalScale;
	float duration<ins>, dyingAge</ins>;
	
	public void Initialize (Shape shape, float duration) {
		originalScale = shape.transform.localScale;
		this.duration = duration;
		<ins>dyingAge = shape.Age;</ins>
		<del>//shape.transform.localScale = Vector3.zero;</del>
	}

	&hellip;

	public override void Save (GameDataWriter writer) {
		writer.Write(originalScale);
		writer.Write(duration);
		<ins>writer.Write(dyingAge);</ins>
	}

	public override void Load (GameDataReader reader) {
		originalScale = reader.ReadVector3();
		duration = reader.ReadFloat();
		<ins>dyingAge = reader.ReadFloat();</ins>
	}</pre>
						
						<p><code>GameUpdate</code> only needs slight modification. The dying duration is found by subtracting the dying age from the shape's current age. The final scale is zero. And the scalar is reversed, which is done by using 1 minus the duration division as the initial scalar, before smoothing.</p>
						
						<pre translate="no">	public override bool GameUpdate (Shape shape) {
		<ins>float dyingDuration = shape.Age - dyingAge;</ins>
		if (<ins>dyingDuration</ins> &lt; duration) {
			float s = <ins>1f - dyingDuration</ins> / duration;
			s = (3f - 2f * s) * s * s;
			shape.transform.localScale = s * originalScale;
			return true;
		}
		shape.transform.localScale = <ins>Vector3.zero</ins>;
		return false;
	}</pre>
					</section>
					
					<section>
						<h3>Configuring Death</h3>
						
						<p>How long dying lasts is also something that we'll configure per spawn zone, so add a field for that to <code>LifecycleConfiguration</code>, using the same range as for the growing duration.</p>
						
						<pre translate="no">			[FloatRangeSlider(0f, 2f)]
			public FloatRange growingDuration;

			<ins>[FloatRangeSlider(0f, 2f)]</ins>
			<ins>public FloatRange dyingDuration;</ins></pre>
						
						<p>Because we now have to determine two durations for the lifecycle, let's add a convenient property to <code>LifecycleConfiguration</code> that returns two random durations at once, as a <code>Vector2</code> with growing as its first and dying as its second component.</p>
						
						<pre translate="no">			<ins>public Vector2 RandomDurations {</ins>
				<ins>get {</ins>
					<ins>return new Vector2(</ins>
						<ins>growingDuration.RandomValueInRange,</ins>
						<ins>dyingDuration.RandomValueInRange</ins>
					<ins>);</ins>
				<ins>}</ins>
			<ins>}</ins></pre>
						
						<aside>
							<h3>Shouldn't we use a custom struct instead of relying on <code>Vector2</code>?</h3>
							<div>
								<p>That would be a good idea if the functionality was publicly available and used in other parts of our project. But we're only using it once in <code>SpawnZone</code>, so a generic vector is fine.</p>
							</div>
						</aside>
						
						<p>Change <code>SetupLifecycle</code> so it uses such a vector as its parameter, instead of a single duration. To quickly test our dying behavior in isolation, we'll have it either add a growing or a dying behavior, but not both. Only if there's no growing duration while we do have a dying duration will we add a dying behavior.</p>
						
						<pre translate="no">	void SetupLifecycle (Shape shape, <ins>Vector2 durations</ins>) {
		if (<ins>durations.x</ins> > 0f) {
			shape.AddBehavior&lt;GrowingShapeBehavior>().Initialize(
				shape, <ins>durations.x</ins>
			);
		}
		<ins>else if (durations.y > 0f) {</ins>
			<ins>shape.AddBehavior&lt;DyingShapeBehavior>().Initialize(</ins>
				<ins>shape, durations.y</ins>
			<ins>);</ins>
		}
	}</pre>
						
						<p>Adjust <code>CreateSatelliteFor</code> so it passes through the vector instead of a single duration.</p>
						
						<pre translate="no">	void CreateSatelliteFor (Shape focalShape, <ins>Vector2 lifecycleDurations</ins>) {
		&hellip;
		SetupLifecycle(shape, <ins>lifecycleDurations</ins>);
	}</pre>
						
						<p>And update <code>SpawnShapes</code> as well.</p>
						
						<pre translate="no">		<del>//float growingDuration =</del>
		<del>//  spawnConfig.lifecycle.growingDuration.RandomValueInRange;</del>
		<ins>Vector2 lifecycleDurations = spawnConfig.lifecycle.RandomDurations;</ins>

		int satelliteCount = spawnConfig.satellite.amount.RandomValueInRange;
		for (int i = 0; i &lt; satelliteCount; i++) {
			CreateSatelliteFor(shape, <ins>lifecycleDurations</ins>);
		}

		SetupLifecycle(shape, <ins>lifecycleDurations</ins>);</pre>
						
						<figure>
							<img src="dying-shapes/dying-duration.png" width="320" height="56" alt="inspector">
							<div class="vid" style="width: 200px; height:155px;"><iframe src='https://gfycat.com/ifr/enragedlineardeermouse?controls=0'></iframe></div>
							<figcaption>Instant growth, slow dying.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Killing Shapes</h3>
						
						<p>When only the dying behavior is in use, we'll see shapes pop into existence that immediately start shrinking and disappear. But even though their scale is reduced to zero they're still alive. The amount of shapes will increase until the level maximum is reached&mdash;if set&mdash;at which point shapes will get destroyed at random.</p>
						
						<p>The point of the dying behavior is that shapes should die when their scale reaches zero. To support this we have to make it possible for other classes besides <code>Game</code> to terminate shapes. So add a public <code>Kill</code> method with a shape parameter to <code>Game</code>. Just like when destroying a shape, grab its save index, recycle the shape, move the last shape into the hole in the list, then remove the last element of the list.</p>
						
						<pre translate="no">	<ins>public void Kill (Shape shape) {</ins>
		<ins>int index = shape.SaveIndex;</ins>
		<ins>shape.Recycle();</ins>
		<ins>int lastIndex = shapes.Count - 1;</ins>
		<ins>shapes[lastIndex].SaveIndex = index;</ins>
		<ins>shapes[index] = shapes[lastIndex];</ins>
		<ins>shapes.RemoveAt(lastIndex);</ins>
	<ins>}</ins></pre>
						
						<p>Now we can kill shapes anywhere by invoking <code>Game.Instance.Kill(shape)</code>, but let's add a convenient <code>Die</code> method to <code>Shape</code> to make this easier.</p>
						
						<pre translate="no">	<ins>public void Die () {</ins>
		<ins>Game.Instance.Kill(this);</ins>
	<ins>}</ins></pre>
						
						<p>This makes it possible to simply invoke <code>shape.Die()</code> in <code>DyingShapeBehavior.GameUpdate</code> when it is finished, instead of setting the scale to zero. But because the shape gets recycled&mdash;which recycles all its behavior&mdash;we must no longer indicate that the behavior should be removed. So return <code>true</code> instead of <code>false</code>.</p>
						
						<pre translate="no">	public override bool GameUpdate (Shape shape) {
		&hellip;
		<del>//shape.transform.localScale = Vector3.zero;</del>
		<ins>shape.Die();</ins>
		return <ins>true</ins>;
	}</pre>
					</section>
					
					<section>
						<h3>Delayed Killing</h3>
						
						<p>While dead shapes indeed get removed at this point, we're killing them while <code>Game</code> is working through its shape list. This causes the order of the shape list to change, moving the last shape in the list to the index that is currently getting updated. A consequence of this is that the shuffled shape gets skipped this update. While shuffling the order in which shapes get updated doesn't matter much, we must ensure that they do always get updated.</p>
						
						<p>To detect the problem when it is about to happen, we must first know whether <code>Game</code> is currently working through its shape list. We can do that by adding a boolean field to indicate whether we're currently in the game update loop. Set it to <code>true</code> immediately before the loop and to <code>false</code> immediately after it.</p>
						
						<pre translate="no">	<ins>bool inGameUpdateLoop;</ins>

	&hellip;
	
	void FixedUpdate () {
		<ins>inGameUpdateLoop = true;</ins>
		for (int i = 0; i &lt; shapes.Count; i++) {
			shapes[i].GameUpdate();
		}
		<ins>inGameUpdateLoop = false;</ins>

		&hellip;
	}</pre>
						
						<p>If we are inside the loop, then we must not mess with the list. If a shape is killed, its removal from the list has to be postponed. We can do that by adding killed shapes to a separate kill list, which we have to keep track of besides the regular shape list.</p>
						
						<pre translate="no">	List&lt;Shape> shapes<ins>, killList</ins>;

	&hellip;

	void Start () {
		mainRandomState = Random.state;
		shapes = new List&lt;Shape>();
		<ins>killList = new List&lt;Shape>();</ins>

		&hellip;
	}</pre>
						
						<p>Now <code>Kill</code> can check whether we're in the game update loop. If so, add the shape to the kill list. Otherwise, the shape can be killed immediately. Move the original kill code to a separate <code>KillImmediately</code> method, which should be private.</p>
						
						<pre translate="no">	public void Kill (Shape shape) {
		<ins>if (inGameUpdateLoop) {</ins>
			<ins>killList.Add(shape);</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>KillImmediately(shape);</ins>
		<ins>}</ins>
	<ins>}</ins>

	<ins>void KillImmediately (Shape shape) {</ins>
		int index = shape.SaveIndex;
		shape.Recycle();
		int lastIndex = shapes.Count - 1;
		shapes[lastIndex].SaveIndex = index;
		shapes[index] = shapes[lastIndex];
		shapes.RemoveAt(lastIndex);
	}</pre>
						
						<p>At the end of <code>FixedUpdate</code>, check whether there are any shapes in the kill list. If so, kill them all immediately and then clear the list.</p>
						
						<pre translate="no">	void FixedUpdate () {
		&hellip;
		
		<ins>if (killList.Count > 0) {</ins>
			<ins>for (int i = 0; i &lt; killList.Count; i++) {</ins>
				<ins>KillImmediately(killList[i]);</ins>
			<ins>}</ins>
			<ins>killList.Clear();</ins>
		<ins>}</ins>
	}</pre>
						
						<p>We can also use <code>KillImmediately</code> in <code>DestroyShape</code>, getting rid of duplicate code.</p>
						
						<pre translate="no">	void DestroyShape () {
		if (shapes.Count > 0) {
			<del>//int index = Random.Range(0, shapes.Count);</del>
			<del>//&hellip;</del>
			<del>//shapes.RemoveAt(lastIndex);</del>
			<ins>Shape shape = shapes[Random.Range(0, shapes.Count)];</ins>
			<ins>KillImmediately(shape);</ins>
		}
	}</pre>
					</section>
					
					<section>
						<h3>Preventing Redundant Kills</h3>
						
						<p>The delayed killing approach guarantees that all shapes get updated as they should, but it introduces another potential problem. It is now possible that the same shape gets killed more than once. For example, it's possible for a dying behavior to kill a shape, which then immediately gets destroyed due to the shape limit. And maybe there will be other behaviors that could kill any shape at any time.</p>
						
						<p>We must avoid killing a shape a second time when it's already dead, because that would cause it to get recycled when it shouldn't. Maybe it's already recycled, which would cause it to get pooled twice, leading to trouble later. Maybe it already got reused and immediately gets recycled again when it shouldn't. We can guard agains all these problems by turning the kill list into a list of shape instances and checking whether they're still valid before the kill.</p>
						
						<pre translate="no">	List&lt;Shape> shapes<ins>;</ins>

	<ins>List&lt;ShapeInstance></ins> killList;
	
	&hellip;
	
	void Start () {
		mainRandomState = Random.state;
		shapes = new List&lt;Shape>();
		killList = new List&lt;<ins>ShapeInstance</ins>>();
		
		&hellip;
	}
	
	&hellip;
	
	void FixedUpdate () {
		&hellip;

		if (killList.Count > 0) {
			for (int i = 0; i &lt; killList.Count; i++) {
				<ins>if (killList[i].IsValid) {</ins>
					KillImmediately(killList[i]<ins>.Shape€</ins>);
				<ins>}</ins>
			}
			killList.Clear();
		}
	}</pre>
					</section>
				</section>
				
				<section>
					<h2>Complete Lifecycle</h2>
					
					<p>We have a behavior for growing and a behavior for dying. If we put them together, with a span of adult life in between, we get an entire lifecycle. We could do that by creating a single behavior that contains all the code for growing and dying, but it's also possible to keep using the behavior that we already have, plus an additional lifecycle behavior that adds the others when needed. That might be overkill in this case, but it's an interesting approach to try out so we'll go for it.</p>
					
					<section>
						<h3>Lifecycle Behavior</h3>
						
						<p>Create a new <code>LifecycleShapeBehavior</code>, linked to a <code>Lifecycle</code> enum option. Start with a duplicate of <code>DyingShapeBehavior</code> and make the required changes.</p>
						
						<p>The lifecycle consists of three phases&mdash;growing, adult, and dying&mdash;each with its own duration. The growing phase begins immediately, so <code>Lifecyclebehavior</code> can immediately add the required behavior in <code>Initialize</code>, if needed. This means that it does not need to keep track of the growing duration in a field of its own, just pass the duration to the growing behavior. It also doesn't need to know the original scale. It does need to keep track of both the adult duration and the dying duration. Besides that, the dying age is equal to the growing duration plus the adult duration.</p>
						
						<pre translate="no">	<del>//Vector3 originalScale;</del>
	float <ins>adultDuration, dyingDuration</ins>, dyingAge;

	public void Initialize (
		Shape shape,
		float <ins>growingDuration, float adultDuration, float dyingDuration</ins>
	) {
		<del>//originalScale = shape.transform.localScale;</del>
		<del>//this.duration = duration;</del>
		<ins>this.adultDuration = adultDuration;</ins>
		<ins>this.dyingDuration = dyingDuration;</ins>
		dyingAge = <ins>growingDuration + adultDuration</ins>;
		
		<ins>if (growingDuration > 0f) {</ins>
			<ins>shape.AddBehavior&lt;GrowingShapeBehavior>().Initialize(</ins>
				<ins>shape, growingDuration</ins>
			<ins>);</ins>
		<ins>}</ins>
	}

	&hellip;

	public override void Save (GameDataWriter writer) {
		<ins>writer.Write(adultDuration);</ins>
		writer.Write(<ins>dyingDuration</ins>);
		writer.Write(dyingAge);
	}

	public override void Load (GameDataReader reader) {
		<ins>adultDuration = reader.ReadFloat();</ins>
		<ins>dyingDuration</ins> = reader.ReadFloat();
		dyingAge = reader.ReadFloat();
	}</pre>
						
						<p>In <code>GameUpdate</code>, the lifecycle only needs to check whether the shape has reached its dying age. When that happens, it adds the dying behavior and removes itself. This will probably trigger a little too late, so reduce the final dying duration by the lost time, by adding the dying age and subtracting the current age.</p>
						
						<pre translate="no">	public override bool GameUpdate (Shape shape) {
		<ins>if (shape.Age >= dyingAge) {</ins>
			<ins>shape.AddBehavior&lt;DyingShapeBehavior>().Initialize(</ins>
				<ins>shape, dyingDuration + dyingAge - shape.Age</ins>
			<ins>);</ins>
			<ins>return false;</ins>
		<ins>}</ins>
		return true;
	}</pre>
						
						<p>Actually, a dying behavior is only needed if there is a duration for it. If not, the shape can die immediately and the lifecycle behavior doesn't need to be removed explicitly.</p>
						
						<pre translate="no">		if (shape.Age >= dyingAge) {
			<ins>if (dyingDuration &lt;= 0f) {</ins>
				<ins>shape.Die();</ins>
				<ins>return true;</ins>
			<ins>}</ins>
			shape.AddBehavior&lt;DyingShapeBehavior>().Initialize(
				shape, dyingDuration + dyingAge - shape.Age
			);
			return false;
		}</pre>
					</section>
					
					<section>
						<h3>Configuring the Lifecycle</h3>
						
						<p>To configure the full lifecycle, add an adult duration to <code>LifecycleConfiguration</code>. Its <code>Durations</code> property becomes a <code>Vector3</code>, with the adult duration in place of the dying duration, which moves to the third component.</p>
						
						<pre translate="no">			[FloatRangeSlider(0f, 2f)]
			public FloatRange growingDuration;

			<ins>[FloatRangeSlider(0f, 100f)]</ins>
			<ins>public FloatRange adultDuration;</ins>

			[FloatRangeSlider(0f, 2f)]
			public FloatRange dyingDuration;

			public <ins>Vector3</ins> RandomDurations {
				get {
					return new <ins>Vector3</ins>(
						growingDuration.RandomValueInRange,
						<ins>adultDuration.RandomValueInRange,</ins>
						dyingDuration.RandomValueInRange
					);
				}
			}</pre>
						
						<p>We only have to change the vector type in <code>SpawnZone.SpawnShapes</code>.</p>
						
						<pre translate="no">		<ins>Vector3</ins> lifecycleDurations = spawnConfig.lifecycle.RandomDurations;</pre>
						
						<p>And in <code>CreateSatelliteFor</code>.</p>
						
						<pre translate="no">	void CreateSatelliteFor (Shape focalShape, <ins>Vector3</ins> lifecycleDurations) {
		&hellip;
	}</pre>
						
						<p><code>SetupLifecycle</code> becomes a bit more complicated. If there's a growing duration, then if we have at least one of the other durations, we need a full lifecycle. Otherwise only growth is needed. Otherwise, if we have an adult duration then we also need a lifecycle. Finally, we can make do with dying is there's only a dying duration. Make sure to change that code so it uses the third component of the vector.</p>
						
						<pre translate="no">	void SetupLifecycle (Shape shape, <ins>Vector3</ins> durations) {
		if (durations.x > 0f) {
			<ins>if (durations.y > 0f || durations.z > 0f) {</ins>
				<ins>shape.AddBehavior&lt;LifecycleShapeBehavior>().Initialize(</ins>
					<ins>shape, durations.x, durations.y, durations.z</ins>
				<ins>);</ins>
			<ins>}</ins>
			<ins>else {</ins>
				shape.AddBehavior&lt;GrowingShapeBehavior>().Initialize(
					shape, durations.x
				);
			<ins>}</ins>
		}
		<ins>else if (durations.y > 0f) {</ins>
			<ins>shape.AddBehavior&lt;LifecycleShapeBehavior>().Initialize(</ins>
				<ins>shape, durations.x, durations.y, durations.z</ins>
			<ins>);</ins>
		<ins>}</ins>
		else if (durations.<ins>z</ins> > 0f) {
			shape.AddBehavior&lt;DyingShapeBehavior>().Initialize(
				shape, durations.<ins>z</ins>
			);
		}
	}</pre>
						
						<figure>
							<img src="complete-lifecycle/complete-lifecycle.png" width="320" height="74" alt="inspector">
							<div class="vid" style="width: 250px; height:210px;"><iframe src='https://gfycat.com/ifr/polishedinsignificantkingbird?controls=0'></iframe></div>
							<figcaption>Adult between one and five seconds.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Different Lifecyle per Satellite</h3> 
						
						<p>Currently, a shape and all its satellites have the same lifecycle, but that is not required. Let's add a toggle option to the satellite configuration to control whether the lifecycles are uniform.</p>
						
						<pre translate="no">		public struct SatelliteConfiguration {

			&hellip;

			<ins>public bool uniformLifecycles;</ins>
		}</pre>
						
						<p>In the case of uniform life cycles we keep using the same approach. Otherwise, we use a new set of random durations per satellite.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; satelliteCount; i++) {
			CreateSatelliteFor(
				shape,
				<ins>spawnConfig.satellite.uniformLifecycles ?</ins>
					lifecycleDurations <ins>: spawnConfig.lifecycle.RandomDurations</ins>
			);
		}</pre>
						
						<figure>
							<img src="complete-lifecycle/nonuniform-lifecycles.png" width="320" height="108" alt="inspector">
							<div class="vid" style="width: 250px; height:210px;"><iframe src='https://gfycat.com/ifr/linedgleamingaustraliancurlew?controls=0'></iframe></div>
							<figcaption>Non-uniform lifecycles.</figcaption>
						</figure>
						
						<p>Now deaths due to the lifecycle can result in escaping satellites, if the focal shape ended up dying first.</p>
					</section>
				</section>
				
				<section>
					<h2>Destroying Slowly</h2>
					
					<p>Killing shapes causes them to shrink and then die, instead of immediately disappearing. But when a shapes gets destroyed&mdash;either by the player or because there were too many shapes&mdash;they still disappear immediately. We can change such destructions so they become slow shrinking deaths too, but this requires some care.</p>
					
					<p>If shape destruction is just another way to kill them, then we shouldn't bother destroying shapes that are already dying. And as dying shapes are already on their way out, it makes sense to not consider them when checking the shape limit. To be able to do that it must be possible to distinguish between shapes that are dying and those that are not.</p>
					
					<p>One way to make the distinction is to put all dying shapes in a separate shape list and removing them from the regular shape list. Then we automatically ignore dying shapes when picking a random one to destroy and when checking the limit. However, that affects the save index and all places where we manipulate the shape list, because we'd have two lists instead of one.</p>
					
					<p>Another way to make the distinction is via the order of the shape list. We can split the list in two sections, effectively working with two lists while all the code that works with a single list remains valid. That minimizes the changes that we have to make, so we'll use that approach.</p>
					
					<figure>
						<img src="destroying-slowly/segregated-list.png" width="315" height="65">
						<figcaption>Dying and alive shapes in a single list.</figcaption>
					</figure>
					
					<section>
						<h3>Segregating Dying Shapes</h3>
						
						<p>We'll split the shapes list into a dying and non-dying section by moving all dying shapes to the front of the list. As that is a list-order manipulation, it's something that we must be careful with. Add a private <code>MarkAsDyingImmediately</code> method to <code>Game</code> to put a shape in the dying section. Keep track of the dying shape count in a field and use that as the new index for a shape that's marked as dying, swapping the places with the shape at that index. Afterwards, increment the dying shape count.</p>
						
						<pre translate="no">	<ins>int dyingShapeCount;</ins>
	
	&hellip;
	
	<ins>void MarkAsDyingImmediately (Shape shape) {</ins>
		<ins>int index = shape.SaveIndex;</ins>
		<ins>shapes[dyingShapeCount].SaveIndex = index;</ins>
		<ins>shapes[index] = shapes[dyingShapeCount];</ins>
		<ins>shape.SaveIndex = dyingShapeCount;</ins>
		<ins>shapes[dyingShapeCount++] = shape;</ins>
	<ins>}</ins></pre>
						
						<p>Marking a shape as dying more than once should have no effect, so abort if the shape is already in the dying section. That's the case when its index is lower than the dying shape count.</p>
						
						<pre translate="no">		int index = shape.SaveIndex;
		<ins>if (index &lt; dyingShapeCount) {</ins>
			<ins>return;</ins>
		<ins>}</ins>
		shapes[dyingShapeCount].SaveIndex = index;</pre>
						
						<p>This change does affect <code>KillShapeImmediately</code>. First, we have to decrement the dying count if a dying shape gets removed. Second, we can no longer blindly move the last shape to the remove shape's index. Doing so could put a non-dying shape in the dying section. That's only the case when a dying shape is removed, if it is not the last in the dying section. In other words, when the shape's index is less than the dying count and also less than the dying count minus one. When that is the case we have to perform a double move: the last dying shape to the removed shape, and the last shape in the list to the hole that was created.</p>
						
						<figure>
							<img src="destroying-slowly/double-move-kill.png" width="315" height="215">
							<figcaption>Double move when killing a dying shape.</figcaption>
						</figure>
						
						<pre translate="no">		shape.Recycle();

		<ins>if (index &lt; dyingShapeCount &amp;&amp; index &lt; --dyingShapeCount) {</ins>
			<ins>shapes[dyingShapeCount].SaveIndex = index;</ins>
			<ins>shapes[index] = shapes[dyingShapeCount];</ins>
			<ins>index = dyingShapeCount;</ins>
		<ins>}</ins>

		int lastIndex = shapes.Count - 1;</pre>
						
						<aside>
							<h3>How does that conditional statement work?</h3>
							<div>
								<p>The first condition evaluates as true if we're dealing with a dying shape. Only if that is the case will the second condition get evaluated, which first decrements the dying count and then performs the other comparison. You could also turn it into two nested <code>if</code> blocks:</p>
								
								<pre translate="no">		if (index &lt; dyingShapeCount) {
			dyingShapeCount -= 1;
			if(index &lt; dyingShapeCount) {
				shapes[dyingShapeCount].SaveIndex = index;
				shapes[index] = shapes[dyingShapeCount];
				index = dyingShapeCount;
			}
		}</pre>
							</div>
						</aside>
						
						<p>But a double move only is only possible if there is at least a single non-dying shape. If there isn't, the hole that we created is at the end of the list, so we don't need to bother moving the last shape at all. As it's never needed to fill a hole at the end of the list, we can just skip that step in general.</p>
						
						<pre translate="no">		int lastIndex = shapes.Count - 1;
		<ins>if (index &lt; lastIndex) {</ins>
			shapes[lastIndex].SaveIndex = index;
			shapes[index] = shapes[lastIndex];
		<ins>}</ins>
		shapes.RemoveAt(lastIndex);</pre>
						
						<p>Now that we know the dying shape count, subtract it from the shape count when checking whether we've exceeded the limit in <code>FixedUpdate</code>. That makes it only apply to non-dying shapes. So the total amount of shapes could exceed the limit, until all dying shapes are dead.</p>
						
						<pre translate="no">		int limit = GameLevel.Current.PopulationLimit;
		if (limit > 0) {
			while (shapes.Count <ins>- dyingShapeCount</ins> > limit) {
				DestroyShape();
			}
		}</pre>
						
						<p>Likewise, in <code>DestroyShape</code> we only go ahead if there are non-dying shapes and then only pick a random shape from the second segment of the list.</p>
						
						<pre translate="no">	void DestroyShape () {
		if (shapes.Count <ins>- dyingShapeCount</ins> > 0) {
			Shape shape = shapes[Random.Range(<ins>dyingShapeCount</ins>, shapes.Count)];
			KillImmediately(shape);
		}
	}</pre>
						
						<p>Finally, make sure to set the dying shape count back to zero each time we begin a new game.</p>
						
						<pre translate="no">	void BeginNewGame () {
		&hellip;
		<ins>dyingShapeCount = 0;</ins>
	}</pre>
						
					</section>
					
					<section>
						<h3>Delayed Marking</h3>
						
						<p>Because marking a shape as dying alters the order of the shape list, we have to make sure that this doesn't happen when we're in the game update loop. We can use the same approach that we use for the kill list, so add a second list for shapes that need to be marked.</p>
						
						<pre translate="no">	List&lt;ShapeInstance> killList<ins>, markAsDyingList</ins>;

	&hellip;

	void Start () {
		mainRandomState = Random.state;
		shapes = new List&lt;Shape>();
		killList = new List&lt;ShapeInstance>();
		<ins>markAsDyingList = new List&lt;ShapeInstance>();</ins>

		&hellip;
	}</pre>
						
						<p>Loop through this list at the end of <code>FixedUpdate</code>, immediately marking those elements that are still valid.</p>
						
						<pre translate="no">	void FixedUpdate () {
		&hellip;

		<ins>if (markAsDyingList.Count > 0) {</ins>
			<ins>for (int i = 0; i &lt; markAsDyingList.Count; i++) {</ins>
				<ins>if (markAsDyingList[i].IsValid) {</ins>
					<ins>MarkAsDyingImmediately(markAsDyingList[i].Shape€);</ins>
				<ins>}</ins>
			<ins>}</ins>
			<ins>markAsDyingList.Clear();</ins>
		<ins>}</ins>
	}</pre>
						
						<p>Now we can add a public <code>MarkAsDying</code> method that either add a shape to the list or immediately marks it.</p>
						
						<pre translate="no">	<ins>public void MarkAsDying (Shape shape) {</ins>
		<ins>if (inGameUpdateLoop) {</ins>
			<ins>markAsDyingList.Add(shape);</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>MarkAsDyingImmediately(shape);</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>And we can also add another convenient method to <code>Shape</code>.</p>
						
						<pre translate="no">	<ins>public void MarkAsDying () {</ins>
		<ins>Game.Instance.MarkAsDying(this);</ins>
	<ins>}</ins></pre>
						
						<p>The only place where we need to invoke this method is when a <code>DyingShapeBehavior</code> is initialized.</p>
						
						<pre translate="no">	public void Initialize (Shape shape, float duration) {
		&hellip;
		<ins>shape.MarkAsDying();</ins>
	}</pre>
						
						<p>If there were other behaviors that represented different ways to die, then those should also mark their shape as dying during initialization.</p>
					</section>
					
					<section>
						<h3>Slow Destruction</h3>
						
						<p>To finally support slow destruction we need to decide on a destruction duration. Make that configurable by adding a serializable field to <code>Game</code>.</p>
						
						<pre translate="no">	<ins>[SerializeField] float destroyDuration;</ins></pre>
						
						<p>When the duration is positive, have <code>DestroyShape</code> add a dying behavior to the shape with that duration, instead of killing it immediately.</p>
						
						<pre translate="no">	void DestroyShape () {
		if (shapes.Count - dyingShapeCount > 0) {
			Shape shape = shapes[Random.Range(dyingShapeCount, shapes.Count)];
			<ins>if (destroyDuration &lt;= 0f) {</ins>
				KillImmediately(shape);
			<ins>}</ins>
			<ins>else {</ins>
				<ins>shape.AddBehavior&lt;DyingShapeBehavior>().Initialize(</ins>
					<ins>shape, destroyDuration</ins>
				<ins>);</ins>
			<ins>}</ins>
		}</pre>
						
						<figure>
							<img src="destroying-slowly/destroy-duration.png" width="320" height="58" alt="inspector">
							<div class="vid" style="width: 250px; height:210px;"><iframe src='https://gfycat.com/ifr/littleunripecivet?controls=0'></iframe></div>
							<figcaption>Destruction takes one second; population limit 20.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Preventing Double Dying</h3>
						
						<p>The destruction of shapes happens independent of their lifecycle. That means that a random destruction could add the dying behavior to a shape that is still growing. That isn't a problem, because the dying behavior was added later so overrides the scale change of the growing behavior. What's more troublesome is that the lifecycle can still add a dying behavior even though one has already been added. The second behavior initiates a new shrinking effect that overrides the first, but whichever completes first decides when the shape is killed.</p>
						
						<p>To prevent adding a second dying behavior to a shape it must be possible to check whether the shape is already dying, no matter why. We can add an <code>IsMarkedAsDying</code> method to <code>Game</code> to check this. All it has to do is check whether the shape's index is less than the dying count.</p>
						
						<pre translate="no">	<ins>public bool IsMarkedAsDying (Shape shape) {</ins>
		<ins>return shape.SaveIndex &lt; dyingShapeCount;</ins>
	<ins>}</ins></pre>
						
						<p>Once again we make this conveniently available via <code>Shape</code>, though in this case a readonly property is appropriate.</p>
						
						<pre translate="no">	<ins>public bool IsMarkedAsDying {</ins>
		<ins>get {</ins>
			<ins>return Game.Instance.IsMarkedAsDying(this);</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Finally, in <code>LifecycleShapeBehavior.GameUpdate</code> check whether the shape is already dying when it reached its dying age. If so, don't add the dying behavior.</p>
						
						<pre translate="no">			if (dyingDuration &lt;= 0f) {
				shape.Die();
				return true;
			}
			<ins>if (!shape.IsMarkedAsDying) {</ins>
				shape.AddBehavior&lt;DyingShapeBehavior>().Initialize(
					shape, dyingDuration + dyingAge - shape.Age
				);
			<ins>}</ins>
			return false;</pre>
					</section>
				</section>
				
				<section>
					
					<section>
						
						
						<p>The next tutorial is <a href="../more-complex-levels/index.html">More Complex Levels</a>.</p>
					</section>
									
					<a href="https://bitbucket.org/catlikecodingunitytutorials/object-management-11-lifecycle/" class="repository">repository</a>
					<a href="Lifecycle.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>