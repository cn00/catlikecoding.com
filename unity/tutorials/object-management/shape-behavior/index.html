<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/object-management/shape-behavior/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/object-management/shape-behavior/tutorial-image.jpg">
		<meta property="og:title" content="Shape Behavior">
		<meta property="og:description" content="A Unity Object Management tutorial about adding modular behavior to shapes.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Shape Behavior</title>
		<link href="../../tutorials.css" rel="stylesheet">
		<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/object-management/shape-behavior/#article",
				"headline": "Shape Behavior",
				"alternativeHeadline": "Modular Functionality",
				"datePublished": "2018-12-21",
				"dateModified": "2019-01-22",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Object Management tutorial about adding modular behavior to shapes.",
				"image": "https://catlikecoding.com/unity/tutorials/object-management/shape-behavior/tutorial-image.jpg",
				"dependencies": "Unity 2017.4.12f1",
				"proficiencyLevel": "Beginner"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/object-management/", "name": "Object Management" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				ColorRangeHSV: 1,
				CompositeSpawnZone: 1,
				CubeSpawnZone: 1,
				FloatRange: 1,
				FloatRangeDrawer: 1,
				FloatRangeSlider: 1,
				FloatRangeSliderAttribute: 1,
				FloatRangeSliderDrawer: 1,
				Game: 1,
				GameDataReader: 1,
				GameDataWriter: 1,
				GameLevel: 1,
				MovementDirection: 1,
				MovementShapeBehavior: 1,
				OscillationShapeBehavior: 1,
				PersistableObject: 1,
				PersistentStorage: 1,
				RotatingObject: 1,
				RotationShapeBehavior: 1,
				Shape: 1,
				ShapeBehavior: 1,
				ShapeBehaviorPool: 1,
				ShapeBehaviorType: 1,
				ShapeBehaviorTypeMethods: 1,
				ShapeFactory: 1,
				SpawnConfiguration: 1,
				SpawnMovementDirection: 1,
				SpawnZone: 1,
				SphereSpawnZone: 1,
				T: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Object Management</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Shape Behavior</h1>
					<p>Modular Functionality</p>
					<ul>
						<li>Define abstract and concrete behavior for shapes.</li>
						<li>Only include behavior when needed.</li>
						<li>Create a generic method and class.</li>
						<li>Use conditional compilation.</li>
						<li>Add a method to an enumeration.</li>
						<li>Make shapes oscillate.</li>
					</ul>
				</header>
				
				<p>This is the ninth tutorial in a series about <a href="../index.html">Object Management</a>. It adds support for modular behavior to shapes.</p>
				
				<p>This tutorial is made with Unity 2017.4.12f1.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Shapes doing their thing.</figcaption>
				</figure>
				
				<section>
					<h2>Behavior Components</h2>
					
					<p>Currently, all shapes move and rotate, but that's not the only thing that they could do. We could come up with different behavior that we'd like shapes to exhibit. To make shapes do something else, we just have to add code for it to <code>Shape.GameUpdate</code>. But if we define lots of behavior, then that method would become quite large. Also, we might not want all shapes to behave the same. We could use toggles to control what a shape does, but that would bloat <code>Shape</code> with toggles and configuration options for all possible behavior. Ideally, the behavior is modular and can be defined in isolation. That's exactly what Unity's <code>MonoBehaviour</code> offers, so it makes sense to implement each behavior pattern as its own Unity component.</p>
					
					<section>
						<h3>Abstract Behavior</h3>
						
						<p>Create a new <code>ShapeBehavior</code> component script and have it extend <code>MonoBehaviour</code>, as usual. This will be the base class for our behavior, which we'll extend with concrete behavior, like movement. The base <code>ShapeBehavior</code> type shouldn't be instantiated, because it doesn't do anything on its own. To enforce this, mark the class as <code>abstract</code>.</p>
						
						<aside>
							<h3>Why not name it <code>ShapeBehaviour</code>?</h3>
							<div>
								<p>Unity uses the British spelling for its <code>MonoBehaviour</code> class, which deviates from the otherwise consistent usage of American spelling. We're defining our own behavior base, so I stick to the American spelling.</p>
							</div>
						</aside>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public abstract class ShapeBehavior : MonoBehaviour {}</ins></pre>
						
						<p>Just like with <code>Shape</code>, we won't rely on separate <code>Update</code> methods but instead use our own <code>GameUpdate</code> method, so add it to <code>ShapeBehavior</code>. But <code>ShapeBehavior</code> just defines common functionality, not an actual implementation. So we'll only define the method signature, followed by a semicolon instead of a code block. That defines an abstract method, which has to be implemented by classes that extend <code>ShapeBehavior</code>.</p>
						
						<pre translate="no">	<ins>public void GameUpdate ();</ins></pre>
						
						<p>Abstract methods must be defined as such explicitly, with the <code>abstract</code> keyword.
						
						<pre translate="no">	public <ins>abstract</ins> void GameUpdate ();</pre>
						
						<p>Also, the behavior acts on a shape, so we'll add one as a parameter. That way we don't have to keep track of it with a field.</p>
						
						<pre translate="no">	public abstract void GameUpdate (<ins>Shape shape</ins>);</pre>
						
						<p>Besides that, each shape behavior will probably have configuration and state, which we'll have to save and load. So add abstract <code>Save</code> and <code>Load</code> methods too.</p>
						
						<pre translate="no">	<ins>public abstract void Save (GameDataWriter writer);</ins>

	<ins>public abstract void Load (GameDataReader reader);</ins></pre>
					</section>
					
					<section>
						<h3>Movement</h3>
						
						<p>Our first concrete shape behavior component will be about simple linear movement. It'll function exactly like the movement that we currently have, just implemented in a separate class. Create a <code>MovementShapeBehavior</code> script that extends <code>ShapeBehavior</code>. It needs a <code>Velocity</code> vector property that it uses in <code>GameUpdate</code> to adjust the shape's position, and it must save and load it too.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public class MovementShapeBehavior : ShapeBehavior {</ins>

	<ins>public Vector3 Velocity { get; set; }</ins>

	<ins>public override void GameUpdate (Shape shape) {</ins>
		<ins>shape.transform.localPosition += Velocity * Time.deltaTime;</ins>
	<ins>}</ins>

	<ins>public override void Save (GameDataWriter writer) {</ins>
		<ins>writer.Write(Velocity);</ins>
	<ins>}</ins>

	<ins>public override void Load (GameDataReader reader) {</ins>
		<ins>Velocity = reader.ReadVector3();</ins>
	<ins>}</ins>
<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Rotation</h3>
						
						<p>Do the same for rotation, creating a <code>RotationShapeBehavior</code> class that rotates with an <code>AngularVelocity</code> vector property.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public class RotationShapeBehavior : ShapeBehavior {</ins>

	<ins>public Vector3 AngularVelocity { get; set; }</ins>

	<ins>public override void GameUpdate (Shape shape) {</ins>
		<ins>shape.transform.Rotate(AngularVelocity * Time.deltaTime);</ins>
	<ins>}</ins>

	<ins>public override void Save (GameDataWriter writer) {</ins>
		<ins>writer.Write(AngularVelocity);</ins>
	<ins>}</ins>

	<ins>public override void Load (GameDataReader reader) {</ins>
		<ins>AngularVelocity = reader.ReadVector3();</ins>
	<ins>}</ins>
<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Adding Behavior When Needed</h3>
						
						<p>In <code>SpawnZone.SpawnShape</code>, add these behavior components to the shape and set their properties, instead of the properties of the shape itself.</p>
						
						<pre translate="no">	public virtual Shape SpawnShape () {
		&hellip;

		<ins>var rotation = shape.gameObject.AddComponent&lt;RotationShapeBehavior>();</ins>
		<ins>rotation</ins>.AngularVelocity =
			Random.onUnitSphere * spawnConfig.angularSpeed.RandomValueInRange;

		Vector3 direction;
		switch (spawnConfig.movementDirection) {
			&hellip;
		}
		<ins>var movement = shape.gameObject.AddComponent&lt;MovementShapeBehavior>();</ins>
		<ins>movement</ins>.Velocity = direction * spawnConfig.speed.RandomValueInRange;
		return shape;
	}</pre>
						
						<aside>
							<h3>Is it acceptable to use <code>var</code> here?</h3>
							<div>
								<p>There are no hard rules about when to use <code>var</code> instead of an explicit variable type, as long as the compiler can figure it out. My rule of thumb is that the type should be mentioned explicitly somewhere in the assignment. A constructor method invocation is the best example, but I also consider <code>AddComponent&lt;RotationShapeBehavior></code> explicit enough.</p>
							</div>
						</aside>
						
						<p>A benefit of using components for isolated bits of behavior is that we can omit them when they aren't needed. That way we can avoid some unnecessary work. In the case of movement and rotation, we only have to add their behavior if they would have a nonzero speed.</p>
						
						<pre translate="no">		<ins>float angularSpeed = spawnConfig.angularSpeed.RandomValueInRange;</ins>
		<ins>if (angularSpeed != 0f) {</ins>
			var rotation = shape.gameObject.AddBehavior&lt;RotationShapeBehavior>();
			rotation.AngularVelocity = Random.onUnitSphere * <ins>angularSpeed</ins>;
		<ins>}</ins>
		
		<ins>float speed = spawnConfig.speed.RandomValueInRange;</ins>
		<ins>if (speed != 0f) {</ins>
			Vector3 direction;
			switch (spawnConfig.movementDirection) {
				&hellip;
			}
			var movement = shape.gameObject.AddBehavior&lt;MovementShapeBehavior>();
			movement.Velocity = direction * <ins>speed</ins>;
		<ins>}</ins></pre>
						
						<p>If the spawn zone has a speed range from zero to some nonzero value, then it is extremely unlike that we'd end up with a speed of zero. But if the spawn zone's speed range is set to zero&mdash;because we didn't want any movement or rotation at all&mdash;then the behavior will always be omitted.</p>
						
						<figure>
							<img src="behavior-components/no-rotation.png" width="320" height="145">
							<figcaption>Shape with movement but without rotation.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Adding Behavior</h3>
						
						<p>We're now adding the required components to shapes, but they've stopped moving and rotating. That's because we're not invoking the required <code>GameUpdate</code> methods yet. That's the responsibility of <code>Shape</code>, and to do so it will need to keep track of its behavior components. Give it a list field for that purpose.</p>
						
						<pre translate="no"><ins>using System.Collections.Generic;</ins>
using UnityEngine;

public class Shape : PersistableObject {

	&hellip;

	<ins>List&lt;ShapeBehavior> behaviorList = new List&lt;ShapeBehavior>();</ins>
	
	&hellip;
}</pre>	
						
						<p>Next, we need a method to add a behavior instance to the shape. The most straightforward approach is a public <code>AddBehavior</code> method with the behavior as a parameter, which adds it to the list. That method has to be invoked either before or after adding the component to the shape's game object.</p>
						
						<pre translate="no">	<ins>public void AddBehavior (ShapeBehavior behavior) {</ins>
		<ins>behaviorList.Add(behavior);</ins>
	<ins>}</ins></pre>
						
						<p>We can make this more convenient by moving the <code>AddComponent</code> invocation inside the <code>AddBehavior</code> method, having it return the new behavior. To make that work, we have to turn <code>AddBehavior</code> into a generic method, just like <code>AddComponent</code>. That's done by attaching a type placeholder to the method name, between angle brackets. The placeholder name doesn't matter but is usually named <code>T</code> as a shorthand for template type.</p>
						
						<pre translate="no">	public <ins>T</ins> AddBehavior<ins>&lt;T> ()</ins> {
		<ins>T behavior = gameObject.AddComponent&lt;T>();</ins>
		behaviorList.Add(behavior);
		<ins>return behavior;</ins>
	}</pre>
						
						<p>However, it only works when <code>AddBehavior</code> is used with a type that extends <code>ShapeBehavior</code>. To enforce that constraint, write <code> where T : ShapeBehavior</code> after the method name.</p>
						
						<pre translate="no">	public T AddBehavior&lt;T> () <ins>where T : ShapeBehavior</ins> {
		&hellip;
	}</pre>
						
						<p>Now we can simply replace <code>AddComponent</code> with <code>AddBehavior</code> in <code>SpawnZone.SpawnShape</code>.</p>
						
						<pre translate="no">		var rotation = shape.<ins>AddBehavior</ins>&lt;RotationShapeBehavior>();
		&hellip;
		var movement = shape.<ins>AddBehavior</ins>&lt;MovementShapeBehavior>();</pre>
						
						<p>Finally, we can remove the old code from <code>Shape.GameUpdate</code> and instead invoke the <code>GameUpdate</code> method of all its behavior, with itself as the argument. That will make the shapes move and rotate again.</p>
						
						<pre translate="no">	public void GameUpdate () {
		<del>//transform.Rotate(AngularVelocity * Time.deltaTime);</del>
		<del>//transform.localPosition += Velocity * Time.deltaTime;</del>
		<ins>for (int i = 0; i &lt; behaviorList.Count; i++) {</ins>
			<ins>behaviorList[i].GameUpdate(this);</ins>
		<ins>}</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Removing Behavior</h3>
						
						<p>Adding behavior each time we spawn a shape works fine when instantiating new shapes, but leads to duplicate behavior components when shapes get recycled.</p>
						
						<figure>
							<img src="behavior-components/duplicate-components.png" width="320" height="230">
							<figcaption>Behavior duplicates.</figcaption>
						</figure>
						
						<p>The quickest way to fix this is to simply destroy all behavior and clear the list when a shape is recycled. That means that we'll be allocating memory even when reusing shapes, but we'll deal with that later.</p>
						
						<pre translate="no">	public void Recycle () {
		<ins>for (int i = 0; i &lt; behaviorList.Count; i++) {</ins>
			<ins>Destroy(behaviorList[i]);</ins>
		<ins>}</ins>
		<ins>behaviorList.Clear();</ins>
		OriginFactory.Reclaim(this);
	}</pre>
					</section>
					
					<section>
						<h3>Saving</h3>
						
						<p>When saving a shape, we now also have to save all its behavior. That means that we change our save file format, so increase <code>Game.saveVersion</code> to 6.</p>
						
						<pre translate="no">	const int saveVersion = <ins>6</ins>;</pre>
						
						<p>Just like with the list of shapes, we have to save the type of each behavior in the list. Once again, we can use an identifier number for that. But this time we're dealing with class types, not prefab array indices. We have a fixed amount of behavior types, two at the moment. Let's define a <code>ShapeBehaviorType</code> enumeration to identify movement and rotation, put in its own script file.</p>
						
						<pre translate="no"><ins>public enum ShapeBehaviorType {</ins>
	<ins>Movement,</ins>
	<ins>Rotation</ins>
<ins>}</ins></pre>
						
						<p>Next, add an abstract <code>BehaviorType</code> getter property to <code>ShapeBehavior</code>, so we can get a hold of the correct enumeration value.</p>
						
						<pre translate="no">	<ins>public abstract ShapeBehaviorType BehaviorType { get; }</ins></pre>
						
						<p>The implementation of the property is simple. <code>MovementShapeBehavior</code> always returns <code>ShapeBehaviorType.Movement</code>.</p>
						
						<pre translate="no">	<ins>public override ShapeBehaviorType BehaviorType {</ins>
		<ins>get {</ins>
			<ins>return ShapeBehaviorType.Movement;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>And <code>RotationShapeBehavior</code> always returns <code>ShapeBehaviorType.Rotation</code>.</p>
						
						<pre translate="no">	<ins>public override ShapeBehaviorType BehaviorType {</ins>
		<ins>get {</ins>
			<ins>return ShapeBehaviorType.Rotation;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Now we can write the behavior list in <code>Shape.Save</code>. For each behavior, first write its type, cast to an integer, then invoke its own <code>Save</code> method. That replaces the writing of the old movement and rotation data.</p>
						
						<pre translate="no">	public override void Save (GameDataWriter writer) {
		&hellip;
		<del>//writer.Write(AngularVelocity);</del>
		<del>//writer.Write(Velocity);</del>
		<ins>writer.Write(behaviorList.Count);</ins>
		<ins>for (int i = 0; i &lt; behaviorList.Count; i++) {</ins>
			<ins>writer.Write((int)behaviorList[i].BehaviorType);</ins>
			<ins>behaviorList[i].Save(writer);</ins>
		<ins>}</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Loading</h3>
						
						<p>When loading shape behavior, we now have to read an enumeration value and then add the correct behavior component to the shape. Add a private <code>AddBehavior</code> method to <code>Shape</code> for that, with a <code>ShapeBehaviorType</code> parameter. Have it use a <code>switch</code> statement to  add the correct behavior component. Also have it return <code>null</code> when we fail to add the correct type. If we ever end up with a null-reference exception after invoking this method, it means that we forgot to include a behavior type in the switch.</p>
						
						<pre translate="no">	<ins>ShapeBehavior AddBehavior (ShapeBehaviorType type) {</ins>
		<ins>switch (type) {</ins>
			<ins>case ShapeBehaviorType.Movement:</ins>
				<ins>return AddBehavior&lt;MovementShapeBehavior>();</ins>
			<ins>case ShapeBehaviorType.Rotation:</ins>
				<ins>return AddBehavior&lt;RotationShapeBehavior>();</ins>
		<ins>}</ins>
		<ins>Debug.LogError("Forgot to support " + type);</ins>
		<ins>return null;</ins>
	<ins>}</ins></pre>
						
						<p>Replace the old code for reading the movement and rotation data with reading the behavior list. For each behavior, read its identifier integer, cast it to <code>ShapeBehaviorType</code>, invoke <code>AddBehavior</code> with it, and then load the rest of the behavior's data.</p>
						
						<pre translate="no">	public override void Load (GameDataReader reader) {
		&hellip;
		<del>//AngularVelocity =</del>
		<del>//	reader.Version >= 4 ? reader.ReadVector3() : Vector3.zero;</del>
		<del>//Velocity = reader.Version >= 4 ? reader.ReadVector3() : Vector3.zero;</del>
		<ins>if (reader.Version >= 6) {</ins>
			<ins>int behaviorCount = reader.ReadInt();</ins>
			<ins>for (int i = 0; i &lt; behaviorCount; i++) {</ins>
				<ins>AddBehavior((ShapeBehaviorType)reader.ReadInt()).Load(reader);</ins>
			<ins>}</ins>
		<ins>}</ins>
	}</pre>
						
						<p>That works for file version 6 and newer, but file versions 4 and 5 still contain the old movement and rotation data. To remain backwards compatible, read that data when it exists and add the necessary behavior. We don't have to do this for even older versions, because those only contain motionless shapes.</p>
						
						<pre translate="no">		if (reader.Version >= 6) {
			&hellip;
		}
		<ins>else if (reader.Version >= 4) {</ins>
			<ins>AddBehavior&lt;RotationShapeBehavior>().AngularVelocity =</ins>
				<ins>reader.ReadVector3();</ins>
			<ins>AddBehavior&lt;MovementShapeBehavior>().Velocity = reader.ReadVector3();</ins>
		<ins>}</ins></pre>
						
						<p>The <code>AngularVelocity</code> and <code>Velocity</code> properties of <code>Shape</code> are no longer used at this point, so should be removed.</p>
						
						<pre translate="no">	<del>//public Vector3 AngularVelocity { get; set; }</del>

	<del>//public Vector3 Velocity { get; set; }</del></pre>
					</section>
				</section>
				
				<section>
					<h2>Recycling Behavior</h2>
					
					<p>Because we add shape behavior components each time we spawn a shape and later destroy the behavior, we end up allocating memory all the time. The whole point of recycling shapes was to minimize memory allocations, so we have to find a way to recycle shape behavior too.</p>
					
					<p>Unity components cannot be detached from their game object, thus they cannot be placed in a pool to be attached to a different game object later. If we want to keep using Unity components, then once we add a behavior to a shape it cannot be removed. It's possible to work with that restriction, for example by just not destroying unused components and checking whether they already exist before adding them when needed later. Or by making factories aware of shape behavior, requiring complex pooling. Those solutions are not ideal because we end up fighting against Unity's component architecture, instead of taking advantage of it. The simple solution is to just not use Unity components for shape behavior.</p>
					
					<section>
						<h3>No Longer Unity Components</h3>
						
						<p>To not have <code>ShapeBehavior</code> be a Unity component, simply have it not extend <code>MonoBehaviour</code>. It doesn't need to extend anything.</p>
						
						<pre translate="no"><del>//public abstract class ShapeBehavior : MonoBehaviour {</del>
<ins>public abstract class ShapeBehavior {</ins>
	&hellip;
}</pre>
						
						<p>Now we can no longer use <code>AddComponent</code> in <code>Shape.AddBehavior&lt;T></code>. Instead, we have to create a regular object instance, by invoking the type's default constructor method.</p>
						
						<pre translate="no">	public T AddBehavior&lt;T> () where T : ShapeBehavior {
		T behavior = <ins>new T()</ins>;
		behaviorList.Add(behavior);
		return behavior;
	}</pre>
						
						<p>Although classes implicitly have a public default constructor method when no explicit constructor method is defined, their existence isn't guaranteed. So we have to constrain our template type further by explicitly requiring the existence of a constructor method without parameters. That's done by adding <code>new()</code> to the list of constraints for <code>T</code>.</p>
						
						<pre translate="no">	public T AddBehavior&lt;T> () where T : ShapeBehavior<ins>, new()</ins> {
		&hellip;
	}</pre>
						
						<p>We can also no longer destroy behavior in <code>Shape.Recycle</code>. Instead, we'll only clear the list. The unused objects will be cleaned up by the garbage collector at some point. But the idea is that we'll recycle the behavior, so keep the loop even though it does nothing right now.</p>
						
						<pre translate="no">	public void Recycle () {
		for (int i = 0; i &lt; behaviorList.Count; i++) {
			<del>//Destroy(behaviorList[i]);</del>
		}
		behaviorList.Clear();
		OriginFactory.Reclaim(this);
	}</pre>
					</section>
					
					<section>
						<h3>Behavior Pools</h3>
						
						<p>To recycle behavior, we have to put it in pools. Each behavior has its own type, so should get its own pool. We'll create a generic <code>ShapeBehaviorPool&lt;T></code> class for this purpose. The type restriction is the same as before. As these pools exist per type, we don't have to bother with creating instances of them. Instead, we can make do with a static class. That means that the pools won't survive hot reloads, but that's fine.</p>
						
						<pre translate="no"><ins>using System.Collections.Generic;</ins>
<ins>using UnityEngine;</ins>

<ins>public static class ShapeBehaviorPool&lt;T> where T : ShapeBehavior, new() {}</ins></pre>
						
						<p>This time, we'll use a stack to keep track of the unused behavior, so add a static <code>Stack&lt;T></code> field to the class, immediately initializing it.</p>
						
						<pre translate="no">	<ins>static Stack&lt;T> stack = new Stack&lt;T>();</ins></pre>
						
						<aside>
							<h3>What's a stack?</h3>
							<div>
								<p>It's like a list, except you can only add to and remove from the top, via pushing and popping. Unity doesn't serialize stacks, but that's fine in this case.</p>
							</div>
						</aside>
						
						<p>Give the pool a <code>Get</code> and a <code>Reclaim</code> method. They work just like those of <code>ShapeFactory</code>, except that they're a lot simpler. When getting a behavior, pop it from the stack if it's not empty, otherwise return a new instance. When reclaiming, push the behavior on the stack.</p>
						
						<pre translate="no">	<ins>public static T Get () {</ins>
		<ins>if (stack.Count > 0) {</ins>
			<ins>return stack.Pop();</ins>
		<ins>}</ins>
		<ins>return new T();</ins>
	<ins>}</ins>

	<ins>public static void Reclaim (T behavior) {</ins>
		<ins>stack.Push(behavior);</ins>
	<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Returning to the Correct Pool</h3>
						
						<p>Add an abstract <code>Recycle</code> method to <code>ShapeBehavior</code> to make recycling possible.</p>
						
						<pre translate="no">	<ins>public abstract void Recycle ();</ins></pre>
						
						<p>In the case of <code>MovementShapeBehavior</code>, have the pool with the correct template type reclaim it.</p>
						
						<pre translate="no">	<ins>public override void Recycle () {</ins>
		<ins>ShapeBehaviorPool&lt;MovementShapeBehavior>.Reclaim(this);</ins>
	<ins>}</ins></pre>
						
						<p>Do the same for <code>RotationShapeBehavior</code>.</p>
						
						<pre translate="no">	<ins>public override void Recycle () {</ins>
		<ins>ShapeBehaviorPool&lt;RotationShapeBehavior>.Reclaim(this);</ins>
	<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Sealed Classes</h3>
						
						<p>Unlike shape prefabs, each shape behavior has its own type, thus all code is strongly-typed. It is not possible for a behavior to be added to the wrong pool. However, that is only true when each behavior only extends <code>ShapeBehavior</code>. Technically, it is possible to extend another behavior, for example some weird movement type that extends <code>MovementShapeBehavior</code>. Then it would be possible to add an instance of that behavior to the <code>ShapeBehaviorPool&lt;MovementShapeBehavior></code> pool, instead of its own type's pool. To prevent that, we can make it impossible to extend <code>MovementShapeBehavior</code>, by adding the <code>sealed</code> keyword to it.</p>
						
						<pre translate="no">public <ins>sealed</ins> class MovementShapeBehavior : ShapeBehavior { &hellip; }</pre>
						
						<p>Do the same for <code>RotationShapeBehavior</code>.</p>
						
						<pre translate="no">public <ins>sealed</ins> class RotationShapeBehavior : ShapeBehavior { &hellip; }</pre>
					</section>
					
					<section>
						<h3>Using the Pools</h3>
						
						<p>To use the pools, invoke <code>ShapeBehaviorPool&lt;T>.Get</code> in <code>Shape.AddBehavior&lt;T></code> instead of always creating a new object instance.</p>
						
						<pre translate="no">	public T AddBehavior&lt;T> () where T : ShapeBehavior, new() {
		T behavior = <ins>ShapeBehaviorPool&lt;T>.Get()</ins>;
		behaviorList.Add(behavior);
		return behavior;
	}</pre>
						
						<p>And to finally enable behavior reuse, recycle them in <code>Shape.Recycle</code>.</p>
						
						<pre translate="no">	public void Recycle () {
		for (int i = 0; i &lt; behaviorList.Count; i++) {
			<ins>behaviorList[i].Recycle();</ins>
		}
		behaviorList.Clear();
		OriginFactory.Reclaim(this);
	}</pre>
					</section>
					
					<section>
						<h3>Surviving a Hot Reload</h3>
						
						<p>A downside of not using Unity components is that our shape behavior no longer survives hot reloads. When the recompilation is finished, all behavior is gone. This isn't an issue for builds, but can be annoying while working in the editor.</p>
						
						<p>Making the behavior serializable is not enough, because Unity will try to deserialize a list of abstract <code>ShapeBehavior</code> instances per shape, because the list's type is <code>List&lt;ShapeBehavior></code>.</p>
						
						<p>What we can do is have <code>ShapeBehavior</code> extend <code>ScriptableObject</code>. That effectively turns our behavior instances into runtime-only assets, which Unity can serialize correctly.</p>
						
						<pre translate="no">public abstract class ShapeBehavior <ins>: ScriptableObject</ins> { &hellip; }</pre>
						
						<p>That appears to work, but Unity will complain about us directly invoking the constructor method to create new asset instances, instead of using <code>ScriptableObject.CreateInstance</code>. Adjust <code>ShapeBehaviorPool.Get</code> to do it the correct way.</p>
						
						<pre translate="no">	public static T Get () {
		if (stack.Count > 0) {
			return stack.Pop();
		}
		return <ins>ScriptableObject.CreateInstance&lt;T></ins>();
	}</pre>
						
						<p>Now behavior that is in use by shapes survives hot reloads. But the pools don't survive and references to reclaimed behavior are lost. That's isn't a big problem, but it is possible to recreate the pools.</p>
						
						<p>First, add a public boolean <code>IsReclaimed</code> property to <code>ShapeBehavior</code>.</p>
						
						<pre translate="no">	<ins>public bool IsReclaimed { get; set; }</ins></pre>
						
						<p>Second, set this property to true in <code>ShapeBehaviorPool.Reclaim</code> and to false in <code>Get</code> after popping.</p>
						
						<pre translate="no">	public static T Get () {
		if (stack.Count > 0) {
			<ins>T behavior = stack.Pop();</ins>
			<ins>behavior.IsReclaimed = false;</ins>
			return <ins>behavior</ins>;
		}
		return ScriptableObject.CreateInstance&lt;T>();
	}

	public static void Reclaim (T behavior) {
		<ins>behavior.IsReclaimed = true;</ins>
		stack.Push(behavior);
	}</pre>
						
						<p>Finally, add an <code>OnEnable</code> method to <code>ShapeBehavior</code> that checks whether it is reclaimed. If so, have it recycle itself. This method is invoked when the asset gets created via <code>ScriptableObject.CreateInstance</code> and after each hot reload, so the pools will be regenerated.</p>
						
						<pre translate="no">	<ins>void OnEnable () {</ins>
		<ins>if (IsReclaimed) {</ins>
			<ins>Recycle();</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Conditional Compilation</h3>
						
						<p>Extending <code>ScriptableObject</code> is only needed while working in the editor. The overhead of creating runtime assets is not needed in builds. We can use conditional compilation to only have <code>ShapeBehavior</code> extend <code>ScriptableObject</code> when our code is compiled for use in the editor. That's done by putting the <code>: ScriptableObject</code> code on a separate line, in between <code>#if UNITY_EDITOR</code> and <code>#endif</code> compiler directives.</p>
						
						<pre translate="no">public abstract class ShapeBehavior
<ins>#if UNITY_EDITOR</ins>
	: ScriptableObject
<ins>#endif</ins>
{
	&hellip;
}</pre>
						
						<aside>
							<h3>How does <code>#if UNITY_EDITOR</code> work?</h3>
							<div>
								<p>The <code>#if</code> directive is used by the compiler to decide whether to include or skip a section of code during compilation. That means that there are two ways in which the code can be compiled: either <code>ShapeBehavior</code> extends <code>ScriptableObject</code>, or it doesn't.</p>
								
								<p>The decision is made based on whether the symbol written after <code>#if</code> is defined. Symbols can be defined via the <code>#define</code> directive, but can also be passed to the compiler by the code editor or another application. In this case, Unity makes sure that the UNITY_EDITOR symbol is defined when it compiles our code for usage in the editor. The same approach can also be used to check the Unity version and for which target platform the code is compiled.</p>
							</div>
						</aside>
						
						<p>Likewise, we only need the <code>IsReclaimed</code> and <code>OnEnable</code> code in the editor, so make that bit conditional too.</p>
						
						<pre translate="no"><ins>#if UNITY_EDITOR</ins>
	public bool IsReclaimed { get; set; }

	void OnEnable () {
		if (IsReclaimed) {
			Recycle();
		}
	}
<ins>#endif</ins></pre>
						
						<p>The usage of <code>IsReclaimed</code> by <code>ShapeBehaviorPool</code> must also become conditional.</p>
						
						<pre translate="no">	public static T Get () {
		if (stack.Count > 0) {
			T behavior = stack.Pop();
<ins>#if UNITY_EDITOR</ins>
			behavior.IsReclaimed = false;
<ins>#endif</ins>
			return behavior;
		}
		return ScriptableObject.CreateInstance&lt;T>();
	}

	public static void Reclaim (T behavior) {
<ins>#if UNITY_EDITOR</ins>
		behavior.IsReclaimed = true;
<ins>#endif</ins>
		stack.Push(behavior);
	}</pre>
						
						<p>Finally, we must only use <code>ScriptableObject.CreateInstance</code> in the editor. Otherwise, we have to use the constructor method. That can be done with the help of an <code>#else</code> directive.</p>
						
						<pre translate="no">	public static T Get () {
		if (stack.Count > 0) {
			T behavior = stack.Pop();
#if UNITY_EDITOR
			behavior.IsReclaimed = false;
#endif
			return behavior;
		}
<ins>#if UNITY_EDITOR</ins>
		return ScriptableObject.CreateInstance&lt;T>();
<ins>#else</ins>
		<ins>return new T();</ins>
<ins>#endif</ins>
	}</pre>
					</section>
				</section>
				
				<section>
					<h2>Oscillation</h2>
					
					<p>Our new approach for shape behavior is pointless if all we're doing is moving and rotating shapes. It's only useful if we have a sizable selection of behavior that shapes could exhibit. So let's add third type of behavior. We'll add support for oscillating shapes, moving back and forth along a straight line, relative to its original position.</p>
					
					<section>
						<h3>Minimal Behavior</h3>
						
						<p>To support another behavior type, we first have to add an element for it to the <code>ShapeBehaviorType</code> enumeration. We must not change the order of existing elements, so append it to the list.</p>
						
						<pre translate="no">public enum ShapeBehaviorType {
	Movement,
	Rotation<ins>,</ins>
	<ins>Oscillation</ins>
}</pre>
						
						<p>Then we can create a minimal behavior class, in this case <code>OscillationShapeBehavior</code>, with minimal implementations of all required methods and properties. We'll add the code responsible for oscillation later.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public sealed class OscillationShapeBehavior : ShapeBehavior {</ins>

	<ins>public override ShapeBehaviorType BehaviorType {</ins>
		<ins>get {</ins>
			<ins>return ShapeBehaviorType.Oscillation;</ins>
		<ins>}</ins>
	<ins>}</ins>
	
	<ins>public override void GameUpdate (Shape shape) {}</ins>

	<ins>public override void Save (GameDataWriter writer) {}</ins>

	<ins>public override void Load (GameDataReader reader) {}</ins>

	<ins>public override void Recycle () {</ins>
		<ins>ShapeBehaviorPool&lt;OscillationShapeBehavior>.Reclaim(this);</ins>
	<ins>}</ins>
<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>From Enum to Instance</h3>
						
						<p>To support loading, we also have to add a case for oscillation to the non-generic <code>Shape.AddBehavior</code> method. But it's more convenient if we didn't have to edit <code>Shape</code> each time we add a behavior type. So let's move the conversion from enumeration to behavior instance to <code>ShapeBehaviorType</code>.</p>
						
						<p>While we cannot directly put methods inside an enumeration type, we can use extension methods to do it indirectly. An extension method can be defined in any class or struct, so we'll use a dedicated static <code>ShapeBehaviorTypeMethods</code> class, which we can put in the same file as the enumeration.</p>
						
						<pre translate="no">public enum ShapeBehaviorType {
	Movement,
	Rotation,
	Oscillation
}

<ins>public static class ShapeBehaviorTypeMethods {}</ins></pre>
						
						<aside>
							<h3>What's an extension method?</h3>
							<div>
								<p>An extension method is a static method inside a static class that behaves like an instance method of some type. That type could be anything, a class, an interface, a struct, a primitive value, or an enum. The first argument of an extension method defines the type and instance value that the method will operate on.</p>
								<p>Does this allow us to add methods to everything? Yes, just like you could write any static method that has any type as its argument. Is this a good idea? When used in moderation, it can be. It is a tool that has its uses, but wielding it with abandon will produce an unstructured mess.</p>
							</div>
						</aside>
						
						<p>Give this class a public static <code>GetInstance</code> method with a <code>ShapeBehaviorType</code> parameter. Then put the code from <code>Shape.AddShapeBehavior</code> in it, adjust it to use the pools, and add a new case for oscillation.</p>
						
						<pre translate="no">public static class ShapeBehaviorTypeMethods {

	<ins>public static ShapeBehavior GetInstance (ShapeBehaviorType type) {</ins>
		<ins>switch (type) {</ins>
			<ins>case ShapeBehaviorType.Movement:</ins>
				<ins>return ShapeBehaviorPool&lt;MovementShapeBehavior>.Get();</ins>
			 <ins>case ShapeBehaviorType.Rotation:</ins>
				<ins>return ShapeBehaviorPool&lt;RotationShapeBehavior>.Get();</ins>
			<ins>case ShapeBehaviorType.Oscillation:</ins>
				<ins>return ShapeBehaviorPool&lt;OscillationShapeBehavior>.Get();</ins>
		<ins>}</ins>
		<ins>UnityEngine.Debug.Log("Forgot to support " + type);</ins>
		<ins>return null;</ins>
	<ins>}</ins>
}</pre>
						
						<p>To turn it into an extension method for <code>ShapeBehaviorType</code>, add the <code>this</code> keyword before the <code>ShapeBehaviorType</code> parameter.</p>
						
						<pre translate="no">public static ShapeBehavior GetInstance (<ins>this</ins> ShapeBehaviorType type) { &hellip; }</pre>
						
						<p>Now it's possible to write code like <code>ShapeBehaviorType.Movement.GetInstance()</code> and get a <code>MovementShapeBehavior</code> instance out of it. Use this approach in <code>Shape.Load</code> to get a behavior instance, add it to the list, and then load it.</p>
						
						<pre translate="no">		if (reader.Version >= 6) {
			int behaviorCount = reader.ReadInt();
			for (int i = 0; i &lt; behaviorCount; i++) {
				<del>//AddBehavior((ShapeBehaviorType)reader.ReadInt()).Load(reader);</del>
				<ins>ShapeBehavior behavior =</ins>
					<ins>((ShapeBehaviorType)reader.ReadInt()).GetInstance();</ins>
				<ins>behaviorList.Add(behavior);</ins>
				<ins>behavior.Load(reader);</ins>
			}
		}</pre>
						
						<p>Delete the non-generic <code>AddBehavior</code> method, as we no longer need it.</p>
						
						<pre translate="no">	<del>//ShapeBehavior AddBehavior (ShapeBehaviorType type) { &hellip; }</del></pre>
					</section>

					<section>
						<h3>Oscillation Implementation</h3>
						
						<p>We'll implement the oscillation behavior by moving the shape with a sine wave along an offset vector. This vector defines the maximum offset in the positive direction. We also need a frequency to control the oscillation speed, defined in oscillations per second. Add properties for both to <code>OscillationShapeBehavior</code>.</p>
						
						<pre translate="no">	<ins>public Vector3 Offset { get; set; }</ins>
	
	<ins>public float Frequency { get; set; }</ins></pre>
						
						<p>The oscillation curve is simply the sine of 2&pi; multiplied by the frequency and current time. That's used to scale the configured offset, which is then used to set the shape's position.</p>
						
						<pre translate="no">	public override void GameUpdate (Shape shape) {
		<ins>float oscillation = Mathf.Sin(2f * Mathf.PI * Frequency * Time.time);</ins>
		<ins>shape.transform.localPosition = oscillation * Offset;</ins>
	}</pre>
						
						<p>But that would make all shapes oscillate around the origin, instead of their spawn position. Even worse, it wouldn't work in combination with the movement behavior. So we have to add the oscillation to the position instead of replacing it.</p>
						
						<pre translate="no">		shape.transform.localPosition <ins>+=</ins> oscillation * Offset;</pre>
						
						<p>However, if we add the oscillation offset to the position each update, then we end up accumulating offsets instead of using a new offset each update. To compensate for our previous oscillation, we have to remember it and subtract it before determining the final offset, and also set it to zero when recycling.</p>
						
						<pre translate="no">	<ins>float previousOscillation;</ins>

	public override void GameUpdate (Shape shape) {
		float oscillation = Mathf.Sin(2f * Mathf.PI * Frequency * Time.time);
		shape.transform.localPosition +=
			<ins>(oscillation - previousOscillation)</ins> * Offset;
		<ins>previousOscillation = oscillation;</ins>
	}

	&hellip;

	public override void Recycle () {
		<ins>previousOscillation = 0f;</ins>
		ShapeBehaviorPool&lt;OscillationShapeBehavior>.Reclaim(this);
	}</pre>
						
						<p>Now we also know what state has to be saved and loaded: both properties and the previous oscillation value.</p>
						
						<pre translate="no">	public override void Save (GameDataWriter writer) {
		<ins>writer.Write(Offset);</ins>
		<ins>writer.Write(Frequency);</ins>
		<ins>writer.Write(previousOscillation);</ins>
	}

	public override void Load (GameDataReader reader) {
		<ins>Offset = reader.ReadVector3();</ins>
		<ins>Frequency = reader.ReadFloat();</ins>
		<ins>previousOscillation = reader.ReadFloat();</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Oscillation Configuration</h3>
						
						<p>Like movement and rotation, we'll configure oscillation per spawn zone, by adding fields to <code>SpawnConfiguration</code>. Use <code>MovementDirection</code> for the direction and <code>FloatRange</code> to control the amplitude and frequency of the oscillation.</p>
						
						<pre translate="no">	public struct SpawnConfiguration {

		&hellip;

		<ins>public MovementDirection oscillationDirection;</ins>

		<ins>public FloatRange oscillationAmplitude;</ins>

		<ins>public FloatRange oscillationFrequency;</ins>
	}</pre>
						
						<figure>
							<img src="oscillation/spawn-zone-with-oscillation.png" width="320" height="254">
							<figcaption>Spawn zone with oscillation.</figcaption>
						</figure>
						
						<p>We now have two cases in <code>SpawnZone</code> where we need to convert <code>MovementDirection</code> to a vector, so move the relevant code to its own method.</p>
						
						<pre translate="no">	public virtual Shape SpawnShape () {
		&hellip;

		float speed = spawnConfig.speed.RandomValueInRange;
		if (speed != 0f) {
			<del>//Vector3 direction;</del>
			<del>//switch (spawnConfig.movementDirection) {</del>
			<del>//	&hellip;</del>
			<del>//}</del>
			var movement = shape.AddBehavior&lt;MovementShapeBehavior>();
			movement.Velocity =
				<ins>GetDirectionVector(spawnConfig.movementDirection, t)</ins> * speed;
		}
		
		return shape;
	}
	
	<ins>Vector3 GetDirectionVector (</ins>
		<ins>SpawnConfiguration.MovementDirection direction, Transform t</ins>
	<ins>) {</ins>
		<ins>switch (direction) {</ins>
			<ins>case SpawnConfiguration.MovementDirection.Upward:</ins>
				<ins>return transform.up;</ins>
			<ins>case SpawnConfiguration.MovementDirection.Outward:</ins>
				<ins>return (t.localPosition - transform.position).normalized;</ins>
			<ins>case SpawnConfiguration.MovementDirection.Random:</ins>
				<ins>return Random.onUnitSphere;</ins>
			<ins>default:</ins>
				<ins>return transform.forward;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Because the <code>SpawnShape</code> method is getting large, put the code to add an oscillation behavior in its own method too. In this case, we can skip adding the behavior if either the amplitude or the frequency ends up being zero.</p>
						
						<pre translate="no">	public virtual Shape SpawnShape () {
		&hellip;
		
		<ins>SetupOscillation(shape);</ins>
		return shape;
	}

	<ins>void SetupOscillation (Shape shape) {</ins>
		<ins>float amplitude = spawnConfig.oscillationAmplitude.RandomValueInRange;</ins>
		<ins>float frequency = spawnConfig.oscillationFrequency.RandomValueInRange;</ins>
		<ins>if (amplitude == 0f || frequency == 0f) {</ins>
			<ins>return;</ins>
		<ins>}</ins>
		<ins>var oscillation = shape.AddBehavior&lt;OscillationShapeBehavior>();</ins>
		<ins>oscillation.Offset = GetDirectionVector(</ins>
			<ins>spawnConfig.oscillationDirection, shape.transform</ins>
		<ins>) * amplitude;</ins>
		<ins>oscillation.Frequency = frequency;</ins>
	<ins>}</ins></pre>
						
						<figure>
							<div class="vid" style="width: 200px; height:200px;"><iframe src='https://gfycat.com/ifr/AmpleFatalDogwoodtwigborer?controls=0'></iframe></div>
							<figcaption>Oscillating in lockstep.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Oscillating Based on Shape Age</h3>
						
						<p>Because we're oscillating based on the current game time, all shapes oscillate in lockstep. Worse, because we don't save the game time oscillation isn't saved correctly. We can solve both problems by oscillating based on the shape's age instead, and saving the age.</p>
						
						<p>First, add an <code>Age</code> property to <code>Shape</code>. It's publicly accessible, but the shape controls its own age, so its setter should be private.</p>
						
						<pre translate="no">	<ins>public float Age { get; private set; }</ins></pre>
						
						<p>In <code>GameUpdate</code>, increase the age by the time delta. And set the age back to zero when recycling.</p>
						
						<pre translate="no">	public void GameUpdate () {
		<ins>Age += Time.deltaTime;</ins>
		for (int i = 0; i &lt; behaviorList.Count; i++) {
			behaviorList[i].GameUpdate(this);
		}
	}
	
	public void Recycle () {
		<ins>Age = 0f;</ins>
		&hellip;
	}</pre>
						
						<p>The age should be saved and loaded too. Write it directly before the behavior list.</p>
						
						<pre translate="no">	public override void Save (GameDataWriter writer) {
		&hellip;
		<ins>writer.Write(Age);</ins>
		writer.Write(behaviorList.Count);
		&hellip;
	}

	public override void Load (GameDataReader reader) {
		&hellip;
		if (reader.Version >= 6) {
			<ins>Age = reader.ReadFloat();</ins>
			int behaviorCount = reader.ReadInt();
			&hellip;
		}
		&hellip;
	}</pre>
						
						<p>Finally, adjust <code>OscillationShapeBehavior</code> so it uses the shape's age instead of the current time.</p>
						
						<pre translate="no">	public override void GameUpdate (Shape shape) {
		float oscillation = Mathf.Sin(2f * Mathf.PI * Frequency * <ins>shape.Age</ins>);
		&hellip;
	}</pre>
						
						<figure>
							<div class="vid" style="width: 200px; height:200px;"><iframe src='https://gfycat.com/ifr/RichSomberArrowcrab?controls=0'></iframe></div>
							<figcaption>Oscillating based on shape age.</figcaption>
						</figure>
						
						<p>We now have a framework for adding modular behavior to shapes. The current approach is overkill for just three simple behavior types, but we'll add more complex behavior in the next tutorial, <a href="../satellites/index.html">Satellites</a>.</p>
						
						<figure>
							<div class="vid" style="width: 320px; height:220px;"><iframe src='https://gfycat.com/ifr/PleasantFemaleAnhinga?controls=0'></iframe></div>
							<figcaption>Varied shape behavior.</figcaption>
						</figure>
					</section>
				
					<a href="https://bitbucket.org/catlikecodingunitytutorials/object-management-09-shape-behavior/" class="repository">repository</a>
					<a href="Shape-Behavior.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>