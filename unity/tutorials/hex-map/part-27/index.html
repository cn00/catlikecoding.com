<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/hex-map/part-27/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/hex-map/part-27/tutorial-image.jpg">
		<meta property="og:title" content="Hex Map 27">
		<meta property="og:description" content="A Unity Hex Map tutorial about adding support for wrapping maps. Part 27 of 27.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Hex Map 27</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/hex-map/part-27/#article",
				"headline": "Hex Map 27",
				"alternativeHeadline": "Wrapping",
				"datePublished": "2018-03-13",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Hex Map tutorial about adding support for wrapping maps. Part 27 of 27.",
				"image": "https://catlikecoding.com/unity/tutorials/hex-map/part-27/tutorial-image.jpg",
				"dependencies": "Unity 2017.3.0p3",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/hex-map/", "name": "Hex Map" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				Bezier: 1,
				Biome: 1,
				ClimateData: 1,
				EdgeVertices: 1,
				HemisphereMode: 1,
				HexCell: 1,
				HexCellPriorityQueue: 1,
				HexCellShaderData: 1,
				HexEdgeType: 1,
				HexCoordinates: 1,
				HexCoordinatesDrawer: 1,
				HexDirection: 1,
				HexDirectionExtensions: 1,
				HexFeatureCollection: 1,
				HexFeatureManager: 1,
				HexGameUI: 1,
				HexGrid: 1,
				HexGridChunk: 1,
				HexHash: 1,
				HexMapCamera: 1,
				HexMapEditor: 1,
				HexMapGenerator: 1,
				HexMesh: 1,
				HexMetrics: 1,
				HexUnit: 1,
				ListPool: 1,
				MapRegion: 1,
				NewMapMenu: 1,
				OptionalToggle: 1,
				SaveLoadItem: 1,
				SaveLoadMenu: 1,
				TextureArrayWizard: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Hex Map</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Hex Map 27</h1>
					<p>Wrapping</p>
					<ul>
						<li>Split maps into columns that can move.</li>
						<li>Keep the map centered on the camera.</li>
						<li>Wrap everything.</li>
					</ul>
				</header>

				<p>This is part 27 of a tutorial series about <a href="../index.html">hexagon maps</a>. The <a href="../part-26/index.html">previous part</a> completed the procedural terrain generator. In this final installment we add support for wrapping the map, by connecting the east and west edges.</p>
				
				<p>This tutorial is made with Unity 2017.3.0p3.</p>
				
				<figure>
					<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/tutorial-image.jpg" width="512" height="256">
					<figcaption>Wrapping makes the world go round.</figcaption>
				</figure>
				
				<section>
					<h2>Wrapping Maps</h2>
					
					<p>Our maps can be used to represent areas of varying sizes, but they're always constrained to a rectangular shape. We could make a map for a single island or an entire continent, but not an entire planet. Planets are spherical, without hard boundaries to block travel on their surface. Keep going in one direction, and at some point you'll come back to where you started.</p>
					
					<p>We cannot wrap a hexagonal grid around a sphere, such a tiling is impossible. The best approximations use an icosahedral topology, which requires twelve cells to be pentagons. However, wrapping the grid around a cylinder is possible without distortions or exceptions. This is simply a matter of connecting the east and west sides of the map. Besides the wrapping logic, everything else can remain the same.</p>
					
					<p>A cylinder is a poor approximation of a sphere, as it cannot represent the poles. But this hasn't stopped many games from using east&ndash;west wrapping to represent planetary maps. The polar regions are simply not part of the playable area.</p>
					
					<aside>
						<h3>What about wrapping north and south too?</h3>
						<div>
							<p>If you wrap both east&ndash;west and north&ndash; south, you end up with the topology of a torus. So that's not a valid representation of a spherical body, although there are games that use that wrapping method. This tutorial only covers east&ndash;west wrapping, but you could add north&ndash;south wrapping as well, using the same approaches. It just requires more work and other metrics.</p>
						</div>
					</aside>
					
					<p>There are two ways to approach cylindrical wrapping. The first approach is to actually make the map cylindrical, bending its surface and everything on it so the east and west sides touch each other. You're no longer playing on a flat surface, but a real cylinder. The second approach is to stick with a flat map and use teleportation or duplication to make the wrapping work. Most games use the second approach and so will we.</p>
					
					<section>
						<h3>Optional Wrapping</h3>
						
						<p>Whether you want a wrapping map depends on whether you're going for a local or planetary scale. We can support both by making wrapping optional. Add a new toggle to the <em translate="no">Create New Map</em> menu to make this possible, with wrapping as the default choice.</p>
						
						<figure>
							<img src="wrapping-maps/new-map-menu.png" width="192" height="234">
							<figcaption>New map menu with wrapping option.</figcaption>
						</figure>
						
						<p>Add a field to keep track of this choice in <code>NewMapMenu</code>, along with a method to change it. Have the new toggle invoke this method when its state changes.</p>
						
						<pre translate="no">	<ins>bool wrapping = true;</ins>

	&hellip;

	<ins>public void ToggleWrapping (bool toggle) {</ins>
		<ins>wrapping = toggle;</ins>
	<ins>}</ins></pre>
						
						<p>When a new map is requested, pass along whether it should wrap.</p>
						
						<pre translate="no">	void CreateMap (int x, int z) {
		if (generateMaps) {
			mapGenerator.GenerateMap(x, z<ins>, wrapping</ins>);
		}
		else {
			hexGrid.CreateMap(x, z<ins>, wrapping</ins>);
		}
		HexMapCamera.ValidatePosition();
		Close();
	}</pre>
						
						<p>Adjust <code>HexMapGenerator.GenerateMap</code> so it accepts this new argument, then passes it on to <code>HexGrid.CreateMap</code>.</p>
						
						<pre translate="no">	public void GenerateMap (int x, int z<ins>, bool wrapping</ins>) {
		&hellip;
		grid.CreateMap(x, z<ins>, wrapping</ins>);
		&hellip;
	}</pre>
						
						<p><code>HexGrid</code> should know whether it's currently wrapping, so give it a field for that and have <code>CreateMap</code> set it. Other classes will need to change their logic based on whether the grid wraps, so make the field public. This also makes it possible to set the default value via the inspector.</p>
						
						<pre translate="no">	public int cellCountX = 20, cellCountZ = 15;
	
	<ins>public bool wrapping;</ins>

	&hellip;

	public bool CreateMap (int x, int z<ins>, bool wrapping</ins>) {
		&hellip;

		cellCountX = x;
		cellCountZ = z;
		<ins>this.wrapping = wrapping;</ins>
		&hellip;
	}</pre>
						
						<p><code>HexGrid</code> invokes its own <code>CreateMap</code> in two places. We can just use its own field for the wrapping argument.</p>
						
						<pre translate="no">	void Awake () {
		&hellip;
		CreateMap(cellCountX, cellCountZ<ins>, wrapping</ins>);
	}
	
	&hellip;
	
	public void Load (BinaryReader reader, int header) {
		&hellip;
		if (x != cellCountX || z != cellCountZ) {
			if (!CreateMap(x, z<ins>, wrapping</ins>)) {
				return;
			}
		}

		&hellip;
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/wrapping-maps/grid-wrapping.png" width="320" height="108">
							<figcaption>Grid wrapping toggle, enabled by default.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Saving and Loading</h3>
						
						<p>Because wrapping is defined per map, it should be saved and loaded as well. This means we have to adjust our save file format, so increment the version constant in <code>SaveLoadMenu</code>.</p>
						
						<pre translate="no">	const int mapFileVersion = <ins>5</ins>;</pre>
						
						<p>When saving, have <code>HexGrid</code> simply write the wrapping boolean after the map dimensions.</p>
						
						<pre translate="no">	public void Save (BinaryWriter writer) {
		writer.Write(cellCountX);
		writer.Write(cellCountZ);
		<ins>writer.Write(wrapping);</ins>

		&hellip;
	}</pre>
						
						<p>When loading, only read it when we have to correct file version. If not, we have and older map so it doesn't wrap. Store this info in a local variable and compare it with the correct wrapping state. If it's different, we cannot reuse the existing map topology, just like we cannot if we loaded different dimensions.</p>
						
						<pre translate="no">	public void Load (BinaryReader reader, int header) {
		ClearPath();
		ClearUnits();
		int x = 20, z = 15;
		if (header >= 1) {
			x = reader.ReadInt32();
			z = reader.ReadInt32();
		}
		<ins>bool wrapping = header >= 5 ? reader.ReadBoolean() : false;</ins>
		if (x != cellCountX || z != cellCountZ <ins>|| this.wrapping != wrapping</ins>) {
			if (!CreateMap(x, z, wrapping)) {
				return;
			}
		}

		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Wrapping Metrics</h3>
						
						<p>A wrapping map requires quite some changes to logic, for example when calculating distances. So this can affect code that doesn't have a direct reference to the grid. Instead of passing this information as arguments all the time, let's add it to <code>HexMetrics</code>. Introduce a static integer that contains the wrap size, which matches the width of the map. If it's larger than zero, then we have a wrapping map. Add a convenient property to check this.</p>
						
						<pre translate="no">	<ins>public static int wrapSize;</ins>

	<ins>public static bool Wrapping {</ins>
		<ins>get {</ins>
			<ins>return wrapSize > 0;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>We have to set the wrap size each time <code>HexGrid.CreateMap</code> is invoked.</p>
						
						<pre translate="no">	public bool CreateMap (int x, int z, bool wrapping) {
		&hellip;
		this.wrapping = wrapping;
		<ins>HexMetrics.wrapSize = wrapping ? cellCountX : 0;</ins>
		&hellip;
	}</pre>
						
						<p>As this data doesn't survive recompilation while in play mode, set it in <code>OnEnable</code> as well.</p>
						
						<pre translate="no">	void OnEnable () {
		if (!HexMetrics.noiseSource) {
			HexMetrics.noiseSource = noiseSource;
			HexMetrics.InitializeHashGrid(seed);
			HexUnit.unitPrefab = unitPrefab;
			<ins>HexMetrics.wrapSize = wrapping ? cellCountX : 0;</ins>
			ResetVisibility();
		}
	}</pre>
					</section>
					
					<section>
						<h3>Cell Width</h3>
						
						<p>When working with wrapping maps, we're going to deal a lot with positions along the X dimension, measured in cell width. While we can use <code>HexMetrics.innerRadius * 2f</code> for that, it's convenient if we don't have to add the multiplication all the time. So let's add an additional <code>HexMetrics.innerDiameter</code> constant.</p>
						
						<pre translate="no">	public const float innerRadius = outerRadius * outerToInner;

	<ins>public const float innerDiameter = innerRadius * 2f;</ins></pre>
						
						<p>We can already use the diameter in three places. First, in <code>HexGrid.CreateCell</code>, when positioning the new cell.</p>
						
						<pre translate="no">	void CreateCell (int x, int z, int i) {
		Vector3 position;
		position.x = (x + z * 0.5f - z / 2) * <ins>HexMetrics.innerDiameter</ins>;
		&hellip;
	}</pre>
						
						<p>Second, in <code>HexMapCamera</code>, when clamping the camera's position.</p>
						
						<pre translate="no">	Vector3 ClampPosition (Vector3 position) {
		float xMax = (grid.cellCountX - 0.5f) * <ins>HexMetrics.innerDiameter</ins>;
		position.x = Mathf.Clamp(position.x, 0f, xMax);

		&hellip;
	}</pre>
						
						<p>And also in <code>HexCoordinates</code>, when converting from a position to coordinates.</p>
						
						<pre translate="no">	public static HexCoordinates FromPosition (Vector3 position) {
		float x = position.x / <ins>HexMetrics.innerDiameter</ins>;
		&hellip;
	}</pre>
					</section>
					
					<a href="https://catlikecoding.com/unity/tutorials/hex-map/part-27/wrapping-maps/wrapping-maps.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Centering the Map</h2>
					
					<p>When a map doesn't wrap, it has a well-defined east and west edge, and thus also a well-defined horizontal center. This isn't the case for a wrapping map. It doesn't have east and west edges, so also no center. Alternatively, we can say that the center is wherever the camera happens to be. This is useful, because we'd like the map to always be centered on our point of view. Then no matter where we are, we never see either an east or west edge of the map.</p>
					
					<section>
						<h3>Columns of Chunks</h3>
						
						<p>To keep the map visualization centered on the camera, we have to change where things are in response to the camera's movement. If it moves to the west, we have to take what's on the currently far east side and move that to the far west side. The same goes for the opposite direction.</p>
						
						<p>Ideally, whenever the camera moves to an adjacent column of cells, we immediately transplant the furthest cell column to the other side. However, we don't need to be so precise. Instead, we can transplant entire map chunks. This allows us to move parts of the map without having to change any meshes.</p>
						
						<p>As we'll move entire columns of chunks at the same time, let's group them by creating a column parent object per group. Add an array for these objects to <code>HexGrid</code> and initialize it in <code>CreateChunks</code>. We only use them as containers, so we only need to keep track of a reference to their <code>Transform</code> components. Just like the chunks, their initial positions are all at the local origin of the grid.</p>
						
						<pre translate="no">	<ins>Transform[] columns;</ins>
	
	&hellip;
	
	void CreateChunks () {
		<ins>columns = new Transform[chunkCountX];</ins>
		<ins>for (int x = 0; x &lt; chunkCountX; x++) {</ins>
			<ins>columns[x] = new GameObject("Column").transform;</ins>
			<ins>columns[x].SetParent(transform, false);</ins>
		<ins>}</ins>
		
		&hellip;
	}</pre>
						
						<p>Chunk should now become children of the appropriate column, instead of the grid.</p>
						
						<pre translate="no">	void CreateChunks () {
		&hellip;
		
		chunks = new HexGridChunk[chunkCountX * chunkCountZ];
		for (int z = 0, i = 0; z &lt; chunkCountZ; z++) {
			for (int x = 0; x &lt; chunkCountX; x++) {
				HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab);
				chunk.transform.SetParent(<ins>columns[x], false</ins>);
			}
		}
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/centering-the-map/columns.png" width="174" height="128">
							<figcaption>Chunks grouped into columns.</figcaption>
						</figure>
						
						<p>Because all chunks are now children of the columns, we can suffice with directly destroying all columns instead of the chunks in <code>CreateMap</code>. That will get rid of the chunk children as well.</p>
						
						<pre translate="no">	public bool CreateMap (int x, int z, bool wrapping) {
		&hellip;
		if (<ins>columns</ins> != null) {
			for (int i = 0; i &lt; <ins>columns</ins>.Length; i++) {
				Destroy(<ins>columns</ins>[i].gameObject);
			}
		}

		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Teleporting Columns</h3>
						
						<p>Add a new <code>CenterMap</code> method to <code>HexGrid</code>, with an X position as parameter. Convert the position to a column index by dividing it by the chunk width in units. This is the index of the column that the camera is currently in, which means that it should be the center column of the map.</p>
						
						<pre translate="no">	<ins>public void CenterMap (float xPosition) {</ins>
		<ins>int centerColumnIndex = (int)</ins>
			<ins>(xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX));</ins>
	<ins>}</ins></pre>
						
						<p>We only have to adjust the map visualization when the center column index changes. So let's keep track of it in a field. Use a default value of &minus;1 and when creating a map, so new maps will always get centered.</p>
						
						<pre translate="no">	<ins>int currentCenterColumnIndex = -1;</ins>
	
	&hellip;
	
	public bool CreateMap (int x, int z, bool wrapping) {
		&hellip;
		this.wrapping = wrapping;
		<ins>currentCenterColumnIndex = -1;</ins>
		&hellip;
	}
	
	&hellip;
	
	<ins>public void CenterMap (float xPosition) {</ins>
		int centerColumnIndex = (int)
			(xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX));
		
		<ins>if (centerColumnIndex == currentCenterColumnIndex) {</ins>
			<ins>return;</ins>
		<ins>}</ins>
		<ins>currentCenterColumnIndex = centerColumnIndex;</ins>
	}</pre>
						
						<p>Now that we know the center column index, we can determine the minimum and maximum indices too, by simply subtracting and adding half the amount of columns. As we're using integers, this works perfectly when we have an odd number of columns. In the case of an even number there cannot be a perfectly-centered column, so one of the indices will be one step too far away. This causes a single-column bias in the direction to the farthest map edge, but that isn't a problem.</p>
						
						<pre translate="no">		currentCenterColumnIndex = centerColumnIndex;

		<ins>int minColumnIndex = centerColumnIndex - chunkCountX / 2;</ins>
		<ins>int maxColumnIndex = centerColumnIndex + chunkCountX / 2;</ins></pre>
						
						<p>Note that these indices can be negative or greater that the natural maximum column index. The minimum is only zero if the camera ends up near the natural center of the map. Our job is to move columns around so they align with these relative indices. We do this by adjusting the local X coordinate of each column in a loop.</p>
						
						<pre translate="no">		int minColumnIndex = centerColumnIndex - chunkCountX / 2;
		int maxColumnIndex = centerColumnIndex + chunkCountX / 2;

		<ins>Vector3 position;</ins>
		<ins>position.y = position.z = 0f;</ins>
		<ins>for (int i = 0; i &lt; columns.Length; i++) {</ins>
			<ins>position.x = 0f;</ins>
			<ins>columns[i].localPosition = position;</ins>
		<ins>}</ins></pre>
						
						<p>For each column, check whether its index is smaller than the minimum index. If so, it's too far to the left of the center. It has to teleport to the other side of the map. This is done by making its X coordinate equal to the map width. Likewise, if the column's index is greater than the maximum index, then it's too far to the right of the center and has to be teleported in the other direction.</p>
						
						<pre translate="no">		for (int i = 0; i &lt; columns.Length; i++) {
			<ins>if (i &lt; minColumnIndex) {</ins>
				<ins>position.x = chunkCountX *</ins>
					<ins>(HexMetrics.innerDiameter * HexMetrics.chunkSizeX);</ins>
			<ins>}</ins>
			<ins>else if (i > maxColumnIndex) {</ins>
				<ins>position.x = chunkCountX *</ins>
					<ins>-(HexMetrics.innerDiameter * HexMetrics.chunkSizeX);</ins>
			<ins>}</ins>
			<ins>else {</ins>
				position.x = 0f;
			<ins>}</ins>
			columns[i].localPosition = position;
		}</pre>
					</section>
					
					<section>
						<h3>Moving the Camera</h3>
						
						<p>Change <code>HexMapCamera.AdjustPosition</code> so it invokes <code>WrapPosition</code> instead of <code>ClampPosition</code> when we're dealing with a wrapping map. Initially, simply make the new <code>WrapPosition</code> method a duplicate of <code>ClampPosition</code>, with the only difference that it invokes <code>CenterMap</code> at the end.</p>
						
						<pre translate="no">	void AdjustPosition (float xDelta, float zDelta) {
		&hellip;
		transform.localPosition =
			<ins>grid.wrapping ? WrapPosition(position) :</ins> ClampPosition(position);
	}

	&hellip;

	<ins>Vector3 WrapPosition (Vector3 position) {</ins>
		<ins>float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter;</ins>
		<ins>position.x = Mathf.Clamp(position.x, 0f, xMax);</ins>

		<ins>float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius);</ins>
		<ins>position.z = Mathf.Clamp(position.z, 0f, zMax);</ins>

		<ins>grid.CenterMap(position.x);</ins>
		<ins>return position;</ins>
	<ins>}</ins></pre>
						
						<p>To make sure that the map immediately begins centered, invoke <code>ValidatePosition</code> in <code>OnEnable</code>.</p>
						
						<pre translate="no">	void OnEnable () {
		instance = this;
		<ins>ValidatePosition();</ins>
	}</pre>
						
						<figure>
							<div class="vid" style="width: 295px; height:120px;"><iframe src='https://gfycat.com/ifr/GlumSomberConey'></iframe></div>
							<figcaption>Moving left and right while centering the map.</figcaption>
						</figure>
						
						<p>While we're still clamping the camera's movement, the map now tries to stay centered on the camera, teleporting chunk columns as needed. This is obvious when using a small map and a zoomed-out view, but on a large map the teleporting chunks are out of view of the camera. The original east&ndash;west edges of the map are only obvious because there is no triangulation between them yet.</p>
						
						<p>To wrap the camera too, remove the clamping of its X coordinate in <code>WrapPosition</code>. Instead, keep increasing X by the map width while it's below zero, and keep decreasing it while it's greater than the map width.</p>
						
						<pre translate="no">	Vector3 WrapPosition (Vector3 position) {
<del>//		float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter;</del>
<del>//		position.x = Mathf.Clamp(position.x, 0f, xMax);</del>
		<ins>float width = grid.cellCountX * HexMetrics.innerDiameter;</ins>
		<ins>while (position.x &lt; 0f) {</ins>
			<ins>position.x += width;</ins>
		<ins>}</ins>
		<ins>while (position.x > width) {</ins>
			<ins>position.x -= width;</ins>
		<ins>}</ins>

		float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius);
		position.z = Mathf.Clamp(position.z, 0f, zMax);

		grid.CenterMap(position.x);
		return position;
	}</pre>
						
						<figure>
							<div class="vid" style="width: 360px; height:120px;"><iframe src='https://gfycat.com/ifr/LinearMistyFlea'></iframe></div>
							<figcaption>Wrapping camera moving across the map.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Wrapping Shader Textures</h3>
						
						<p>Besides the triangulation gap, the camera wrapping should be unnoticeable in the game view. However, there is a visual change in half the terrain and water when that happens. That's because we use the world position to sample these textures. Suddenly teleporting a chunk changes the texture alignment.</p>
						
						<p>We can solve this problem by making sure that the textures tile in multiples of the chunk size. The chunk size is derived from constants in <code>HexMetrics</code>, so let's create a <em translate="no">HexMetrics.cginc</em> shader include file and put the relevant definitions in there. The base tiling scale is derived from the chunk size and outer cell radius. If you happen to use different metrics, you have to adjust this file as well.</p>
						
						<pre translate="no" class="shader"><ins>#define OUTER_TO_INNER 0.866025404</ins>
<ins>#define OUTER_RADIUS 10</ins>
<ins>#define CHUNK_SIZE_X 5</ins>
<ins>#define TILING_SCALE (1 / (CHUNK_SIZE_X * 2 * OUTER_RADIUS / OUTER_TO_INNER))</ins></pre>
						
						<p>This leads to a tiling scale of 0.00866025404. If we use an integer multiple of that, the texturing won't be affected by chunk teleportation. Also, the textures of the east and west edges map edge will align seamlessly, once we correctly triangulate their connection.</p>
						
						<p>We've used 0.02 for our UV scale in the <em translate="no">Terrain</em> shader. We can use twice the tiling scale instead, which would be 0.01732050808. It's a little smaller than it used to be, scaling up the texture a bit, but its not a visually obvious change.</p>
						
						<pre translate="no" class="shader">		<ins>#include "../HexMetrics.cginc"</ins>
		#include "../HexCellData.cginc"

		&hellip;

		float4 GetTerrainColor (Input IN, int index) {
			float3 uvw = float3(
				IN.worldPos.xz * <ins>(2 * TILING_SCALE)</ins>,
				IN.terrain[index]
			);
			&hellip;
		}</pre>
						
						<p>We used 0.025 for the noise UV in the <em translate="no">Roads</em> shader. We can use three times the tiling scale instead, which at 0.02598076212 is a close match.</p>
						
						<pre translate="no" class="shader">		<ins>#include "HexMetrics.cginc"</ins>
		#include "HexCellData.cginc"

		&hellip;

		void surf (Input IN, inout SurfaceOutputStandardSpecular o) {
			float4 noise =
				tex2D(_MainTex, IN.worldPos.xz * <ins>(3 * TILING_SCALE)</ins>);
			&hellip;
		}</pre>
						
						<p>Finally, in <em translate="no">Water.cginc</em> we've used 0.015 for the foam and 0.025 for the waves. Once again we can substitute double and triples the tiling scale.</p>
						
						<pre translate="no" class="shader"><ins>#include "HexMetrics.cginc"</ins>

float Foam (float shore, float2 worldXZ, sampler2D noiseTex) {
	shore = sqrt(shore) * 0.9;

	float2 noiseUV = worldXZ + _Time.y * 0.25;
	float4 noise = tex2D(noiseTex, noiseUV * <ins>(2 * TILING_SCALE)</ins>);

	&hellip;
}

&hellip;

float Waves (float2 worldXZ, sampler2D noiseTex) {
	float2 uv1 = worldXZ;
	uv1.y += _Time.y;
	float4 noise1 = tex2D(noiseTex, uv1 * <ins>(3 * TILING_SCALE)</ins>); 

	float2 uv2 = worldXZ;
	uv2.x += _Time.y;
	float4 noise2 = tex2D(noiseTex, uv2 * <ins>(3 * TILING_SCALE)</ins>);

	&hellip;
}</pre>
					</section>
					
					<a href="https://catlikecoding.com/unity/tutorials/hex-map/part-27/centering-the-map/centering-the-map.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Connecting East and West</h2>
					
					<p>At this point the only visual clue that we're wrapping the map is the small gap between the east-most and west-most columns. This gap exists because we're currently not triangulating edge and corner connections between the cells at opposite sides of the non-wrapping map.</p>
					
					<figure>
						<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/gap.png" width="170" height="270">
						<figcaption>Edge gap.</figcaption>
					</figure>
					
					<section>
						<h3>Wrapping Neighbors</h3>
						
						<p>To triangulate the east&ndash;west connection we have to make the cells on the opposite sides of the map neighbors of each other. We're currently not doing this, because in <code>HexGrid.CreateCell</code> we only establish the E&ndash;W relationship with the previous cell if its X index is greater than zero. To wrap this relationship, we also have to connect the last cell of a row with the first of the same row, when wrapping is enabled.</p>
						
						<pre translate="no">	void CreateCell (int x, int z, int i) {
		&hellip;

		if (x > 0) {
			cell.SetNeighbor(HexDirection.W, cells[i - 1]);
			<ins>if (wrapping &amp;&amp; x == cellCountX - 1) {</ins>
				<ins>cell.SetNeighbor(HexDirection.E, cells[i - x]);</ins>
			<ins>}</ins>
		}
		&hellip;
	}</pre>
						
						<p>With the E&ndash;W neighbor relationships established, we now get partial triangulation across the gap. The edge connection isn't perfect, because the perturbation doesn't tile correctly. We'll deal with that later.</p>
						
						<figure>
							<img src="connecting-east-and-west/e-w.png" width="170" height="270">
							<figcaption>E&ndash;W connections.</figcaption>
						</figure>
						
						<p>We also have to wrap the NE&ndash;SW relationships. We can do this by connecting the first cell of each even row with last cells of the previous row. That's simply the previous cell.</p>
						
						<pre translate="no">		if (z > 0) {
			if ((z &amp; 1) == 0) {
				cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX]);
				if (x > 0) {
					cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX - 1]);
				}
				<ins>else if (wrapping) {</ins>
					<ins>cell.SetNeighbor(HexDirection.SW, cells[i - 1]);</ins>
				<ins>}</ins>
			}
			else {
				&hellip;
			}
		}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/ne-sw.png" width="170" height="270">
							<figcaption>NE&ndash;SW connections.</figcaption>
						</figure>
						
						<p>Finally, the wrapping SE&ndash;NW connections are established at the end of each odd row beyond the first. Those cells are to be connected to the first cell of the previous row.</p>
						
						<pre translate="no">		if (z > 0) {
			if ((z &amp; 1) == 0) {
				&hellip;
			}
			else {
				cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX]);
				if (x &lt; cellCountX - 1) {
					cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX + 1]);
				}
				<ins>else if (wrapping) {</ins>
					<ins>cell.SetNeighbor(</ins>
						<ins>HexDirection.SE, cells[i - cellCountX * 2 + 1]</ins>
					<ins>);</ins>
				<ins>}</ins>
			}
		}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/se-nw.png" width="170" height="270">
							<figcaption>SE&ndash;NW connections.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Wrapping Noise</h3>
						
						<p>To make the gap perfect we have to make sure that the noise used to perturb the vertex positions matches on the east and west edges of the map. We can use the same trick that we used for the shaders, but the noise scale that we use for perturbation is 0.003. We'd have to drastically scale it up to make it tile, which would make the perturbation more erratic.</p>
						
						<p>An alternative approach is to not tile the noise, but to cross-fade the noise at the edge of the map. If we cross-fade across the width of a single cell, then the perturbation will transition smoothly, without discontinuities. The noise will be a bit smoothed out in this region, and from a distance the change would appear sudden, but that's not obvious when used for a little vertex perturbation.</p>
						
						<aside>
							<h3>What about the temperature jitter?</h3>
							<div>
								<p>We also use the same noise to jitter the temperature when generating maps. The sudden cross-fade can be much more obvious here, but only when using a strong jitter. As jitter is only there to add a little subtle variety, this limitation is acceptable. If you want strong jitter, you'd have to cross-fade over a larger distance.</p>
							</div>
						</aside>
						
						<p>If we're not wrapping the map, we can make do with taking a single sample in <code>HexMetrics.SampleNoise</code>. But when wrapping, we have to add the cross-fade. So store the sample in a variable before returning it.</p>
						
						<pre translate="no">	public static Vector4 SampleNoise (Vector3 position) {
		<ins>Vector4 sample =</ins> noiseSource.GetPixelBilinear(
			position.x * noiseScale,
			position.z * noiseScale
		);
		return <ins>sample</ins>;
	}</pre>
						
						<p>When wrapping, we need a second sample to blend with. We'll perform the transition at the east side of the map, so the second sample has to be taken at the west side.</p>
						
						<pre translate="no">		Vector4 sample = noiseSource.GetPixelBilinear(
			position.x * noiseScale,
			position.z * noiseScale
		);

		<ins>if (Wrapping &amp;&amp; position.x &lt; innerDiameter) {</ins>
			<ins>Vector4 sample2 = noiseSource.GetPixelBilinear(</ins>
				<ins>(position.x + wrapSize * innerDiameter) * noiseScale,</ins>
				<ins>position.z * noiseScale</ins>
			<ins>);</ins>
		<ins>}</ins></pre>
						
						<p>The cross-fade is done with a simple linear interpolation, from the west to the east side, across the width of a single cell.</p>
						
						<pre translate="no">		if (Wrapping &amp;&amp; position.x &lt; innerDiameter) {
			Vector4 sample2 = noiseSource.GetPixelBilinear(
				(position.x + wrapSize * innerDiameter) * noiseScale,
				position.z * noiseScale
			);
			<ins>sample = Vector4.Lerp(</ins>
				<ins>sample2, sample, position.x * (1f / innerDiameter)</ins>
			<ins>);</ins>
		}</pre>
						
						<figure>
							<img src="connecting-east-and-west/blending.png" width="170" height="270">
							<figcaption>Blending noise, imperfect</figcaption>
						</figure>
						
						<p>The result isn't an exact match. That's because part of the cells on the east side have negative X coordinates. To stay away from this area, let's shift the transition region half a cell-width to the west.</p>
						
						<pre translate="no">		if (Wrapping &amp;&amp; position.x &lt; innerDiameter <ins>* 1.5f</ins>) {
			Vector4 sample2 = noiseSource.GetPixelBilinear(
				(position.x + wrapSize * innerDiameter) * noiseScale,
				position.z * noiseScale
			);
			sample = Vector4.Lerp(
				sample2, sample, position.x * (1f / innerDiameter) <ins>- 0.5f</ins>
			);
		}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/blending-offset.png" width="170" height="270">
							<figcaption>Correct cross-fade.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Editing Cells</h3>
						
						<p>Now that it seems that we have correct triangulation, let's make sure that we can edit everywhere on the map and across the wrapping seam. As it turns out, coordinates are wrong on teleported chunks and larger brushes are cut off by the seam.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/incomplete-brush.jpg" width="230" height="220">
							<figcaption>Brush got cut off.</figcaption>
						</figure>
						
						<p>To fix this, we have to make <code>HexCoordinates</code> aware of the wrapping. We can do this by validating the X coordinate in the constructor method. We know that the axial X coordinate is derived from the X offset coordinate by subtracting half the Z coordinate. We can use this knowledge to convert back and check whether the offset coordinate is below zero. If so, we have a coordinate beyond the east side of the unwrapped map. As we teleport at most half the map in each direction, we can suffice by adding the wrap size to X once. And when the offset coordinate is greater than the wrap size, we have to subtract instead.</p>
						
						<pre translate="no">	public HexCoordinates (int x, int z) {
		<ins>if (HexMetrics.Wrapping) {</ins>
			<ins>int oX = x + z / 2;</ins>
			<ins>if (oX &lt; 0) {</ins>
				<ins>x += HexMetrics.wrapSize;</ins>
			<ins>}</ins>
			<ins>else if (oX >= HexMetrics.wrapSize) {</ins>
				<ins>x -= HexMetrics.wrapSize;</ins>
			<ins>}</ins>
		<ins>}</ins>
		this.x = x;
		this.z = z;
	}</pre>
						
						<aside>
							<h3>Sometimes I get errors when editing at the bottom or top of the map?</h3>
							<div>
								<p>This happens when&mdash;due to perturbation&mdash;the cursor ends up in a cell row that's outside the map. This is bug, which happens because we don't validate the coordinates in <code>HexGrid.GetCell</code> with a vector parameter. The fix is to rely on the <code>GetCell</code> method with coordinates as parameter, which performs the needed checks.</p>
								
								<pre translate="no">	public HexCell GetCell (Vector3 position) {
		position = transform.InverseTransformPoint(position);
		HexCoordinates coordinates = HexCoordinates.FromPosition(position);
<del>//		int index =</del>
<del>//			coordinates.X + coordinates.Z * cellCountX + coordinates.Z / 2;</del>
<del>//		return cells[index];</del>
		<ins>return GetCell(coordinates);</ins>
	}</pre>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Wrapping Shores</h3>
						
						<p>Triangulation goes well for the terrain, but it appears that water shore edges are missing along the east-west seam. They're actually not missing, but they aren't wrapping. They're flipped and stretch all the way to the other side of the map.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/missing-water-edge.jpg" width="240" height="230">
							<figcaption>Missing water edge.</figcaption>
						</figure>
						
						<p>This happens because we use the neighbor's position when triangulating the shore water. To fix this, we have to detect that we're dealing with a neighbor that's on the other side of the map. To make this easy, we'll add a property for a cell's column index to <code>HexCell</code>.</p>
						
						<pre translate="no">	<ins>public int ColumnIndex { get; set; }</ins></pre>
						
						<p>Assign this index in <code>HexGrid.CreateCell</code>. It's simply equal to the X offset coordinate divided by the chunk size.</p>
						
						<pre translate="no">	void CreateCell (int x, int z, int i) {
		&hellip;
		cell.Index = i;
		<ins>cell.ColumnIndex = x / HexMetrics.chunkSizeX;</ins>
		&hellip;
	}</pre>
						
						<p>Now we can detect that we're wrapping in <code>HexGridChunk.TriangulateWaterShore</code>, by comparing the column index of the current cell and its neighbor. If the neighbor's column index is more than one step smaller, then we're on the west side while the neighbor is on the east side. So we have to wrap the neighbor to the west. Conversely for the other direction.</p>
						
						<pre translate="no">		Vector3 center2 = neighbor.Position;
		<ins>if (neighbor.ColumnIndex &lt; cell.ColumnIndex - 1) {</ins>
			<ins>center2.x += HexMetrics.wrapSize * HexMetrics.innerDiameter;</ins>
		<ins>}</ins>
		<ins>else if (neighbor.ColumnIndex > cell.ColumnIndex + 1) {</ins>
			<ins>center2.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter;</ins>
		<ins>}</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/shore-edges.jpg" width="250" height="230">
							<figcaption>Shore edges, but not corners.</figcaption>
						</figure>
						
						<p>This takes care of the shore edges, but not yet the corners. We have to do the same with the next neighbor too.</p>
						
						<pre translate="no">		if (nextNeighbor != null) {
			<ins>Vector3 center3 = nextNeighbor.Position;</ins>
			<ins>if (nextNeighbor.ColumnIndex &lt; cell.ColumnIndex - 1) {</ins>
				<ins>center3.x += HexMetrics.wrapSize * HexMetrics.innerDiameter;</ins>
			<ins>}</ins>
			<ins>else if (nextNeighbor.ColumnIndex > cell.ColumnIndex + 1) {</ins>
				<ins>center3.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter;</ins>
			<ins>}</ins>
			Vector3 v3 = <ins>center3</ins> + (nextNeighbor.IsUnderwater ?
				HexMetrics.GetFirstWaterCorner(direction.Previous()) :
				HexMetrics.GetFirstSolidCorner(direction.Previous()));
			&hellip;
		}</pre>
						
						<figure>
							<img src="connecting-east-and-west/shore-complete.jpg" width="250" height="230">
							<figcaption>Correctly wrapped shore.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Map Generation</h3>
						
						<p>Whether the east and west sides of the map are connected also influences map generation. When the map wraps, the generation algorithm wraps as well. This will result in a different map, but the wrapping isn't obvious when using a nonzero <em translate="no">Map Border X</em>.</p>
						
						<figure>
							<img alt="without" src="connecting-east-and-west/generated-without-wrapping.jpg" width="350" height="200">
							<img alt="with" src="connecting-east-and-west/generated-with-wrapping.jpg" width="350" height="200">
							<figcaption>Default large map 1208905299, without and with wrapping.</figcaption>
						</figure>
						
						<p>When wrapping, it doesn't make sense to use <em translate="no">Map Border X</em>. But we can't just do away with it, because that would merge regions. When wrapping, we can just use <em translate="no">RegionBorder</em> instead.</p>
						
						<p>Adjust <code>HexMapGenerator.CreateRegions</code> by replacing the usage of <code>mapBorderX</code> with <code>borderX</code> in all cases. This new variable will be equal to either <code>regionBorder</code> or <code>mapBorderX</code>, depending on whether the map is wrapping. I've only shown changes to the first case below.</p>
						
						<pre translate="no">		<ins>int borderX = grid.wrapping ? regionBorder : mapBorderX;</ins>
		MapRegion region;
		switch (regionCount) {
		default:
			region.xMin = <ins>borderX</ins>;
			region.xMax = grid.cellCountX - <ins>borderX</ins>;
			region.zMin = mapBorderZ;
			region.zMax = grid.cellCountZ - mapBorderZ;
			regions.Add(region);
			break;
		<ins>&hellip;</ins>
		}</pre>
						
						<p>This keeps the regions apart, but that's only necessary when there are actually different regions on the east and west sides of the map. There are two cases for which this is not true. First, when there's only a single region. Second, when there are two regions that horizontally split the map. In those cases we can set <code>borderX</code> to zero, allowing landmasses to cross the east-west seam.</p>
						
						<pre translate="no">		switch (regionCount) {
		default:
			<ins>if (grid.wrapping) {</ins>
				<ins>borderX = 0;</ins>
			<ins>}</ins>
			region.xMin = borderX;
			region.xMax = grid.cellCountX - borderX;
			region.zMin = mapBorderZ;
			region.zMax = grid.cellCountZ - mapBorderZ;
			regions.Add(region);
			break;
		case 2:
			if (Random.value &lt; 0.5f) {
				&hellip;
			}
			else {
				<ins>if (grid.wrapping) {</ins>
					<ins>borderX = 0;</ins>
				<ins>}</ins>
				region.xMin = borderX;
				region.xMax = grid.cellCountX - borderX;
				region.zMin = mapBorderZ;
				region.zMax = grid.cellCountZ / 2 - regionBorder;
				regions.Add(region);
				region.zMin = grid.cellCountZ / 2 + regionBorder;
				region.zMax = grid.cellCountZ - mapBorderZ;
				regions.Add(region);
			}
			break;
		&hellip;
		}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/wrapping-region.jpg" width="350" height="200">
							<figcaption>Single wrapping region.</figcaption>
						</figure>
						
						<p>At first glance this might appear to work fine, but there's actually a discontinuity along the seam. This becomes more obvious when setting <em translate="no">Erosion Percentage</em> to zero.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/terrain-seam.jpg" width="350" height="200">
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/terrain-seam-detail.jpg" width="130" height="280">
							<figcaption>Using no erosion reveals a terrain seam.</figcaption>
						</figure>
						
						<p>The discontinuity happens because the seam blocks the growth of terrain chunks. The distance of cells to the chunk's center is used to determine which are added first, and cells on the other side of the map end up very far away, so they almost never get included. This is of course incorrect. We have to make <code>HexCoordinates.DistanceTo</code> aware of the wrapping map.</p>
						
						<p>We calculate the distance between <code>HexCoordinates</code> by adding the absolute distances along each of the three axes and halving the result. The Z distance is always correct, but the X and Y distances can be influenced by wrapping. So let's begin by separately calculating X+Y.</p>
						
						<pre translate="no">	public int DistanceTo (HexCoordinates other) {
<del>//		return</del>
<del>//			((x &lt; other.x ? other.x - x : x - other.x) +</del>
<del>//			(Y &lt; other.Y ? other.Y - Y : Y - other.Y) +</del>
<del>//			(z &lt; other.z ? other.z - z : z - other.z)) / 2;</del>
		
		<ins>int xy =</ins>
			<ins>(x &lt; other.x ? other.x - x : x - other.x) +</ins>
			<ins>(Y &lt; other.Y ? other.Y - Y : Y - other.Y);</ins>

		<ins>return (xy + (z &lt; other.z ? other.z - z : z - other.z)) / 2;</ins>
	}</pre>
						
						<p>Determining whether wrapping produces a smaller distance for arbitrary cells isn't straightforward, so let's simply calculate X+Y for when we wrap the other coordinate to the west side. If that ends up smaller than the original X+Y, use it instead.</p>
						
						<pre translate="no">		int xy =
			(x &lt; other.x ? other.x - x : x - other.x) +
			(Y &lt; other.Y ? other.Y - Y : Y - other.Y);

		<ins>if (HexMetrics.Wrapping) {</ins>
			<ins>other.x += HexMetrics.wrapSize;</ins>
			<ins>int xyWrapped =</ins>
				<ins>(x &lt; other.x ? other.x - x : x - other.x) +</ins>
				<ins>(Y &lt; other.Y ? other.Y - Y : Y - other.Y);</ins>
			<ins>if (xyWrapped &lt; xy) {</ins>
				<ins>xy = xyWrapped;</ins>
			<ins>}</ins>
		<ins>}</ins></pre>
						
						<p>If that doesn't lead to a shorter distance, then maybe wrapping in the other direction is shorter, so check that as well.</p>
						
						<pre translate="no">		if (HexMetrics.Wrapping) {
			other.x += HexMetrics.wrapSize;
			int xyWrapped =
				(x &lt; other.x ? other.x - x : x - other.x) +
				(Y &lt; other.Y ? other.Y - Y : Y - other.Y);
			if (xyWrapped &lt; xy) {
				xy = xyWrapped;
			}
			<ins>else {</ins>
				<ins>other.x -= 2 * HexMetrics.wrapSize;</ins>
				<ins>xyWrapped =</ins>
					<ins>(x &lt; other.x ? other.x - x : x - other.x) +</ins>
					<ins>(Y &lt; other.Y ? other.Y - Y : Y - other.Y);</ins>
				<ins>if (xyWrapped &lt; xy) {</ins>
					<ins>xy = xyWrapped;</ins>
				<ins>}</ins>
			<ins>}</ins>
		}</pre>
						
						<p>Now we always end up with the shortest distance on a wrapping map. Terrain chunks are no longer blocked by the seam, making it possible for landmasses to wrap.</p>
						
						<figure>
							<img alt="without" src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/wrapped-without-erosion.jpg" width="350" height="200">
							<img alt="with" src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/wrapped-with-erosion.jpg" width="350" height="200">
							<figcaption>Correctly wrapped terrain, without and with erosion.</figcaption>
						</figure>
					</section>
					
					<a href="connecting-east-and-west/connecting-east-and-west.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Traveling Around the World</h2>
					
					<p>Now that map generation and triangulation are covered, all that's left is to check units, exploration, and visibility.</p>
					
					<section>
						<h3>Explorable Seam</h3>
						
						<p>The first obstacle that we encounter when trying to move a unit around the world is the map's edge that cannot be explored.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/traveling-around-the-world/blocking-seam.jpg" width="250" height="240">
							<figcaption>Map seam cannot be explored.</figcaption>
						</figure>
						
						<p>The cells along the edge of the map are not explorable, to hide the sudden end of the map. But when a map wraps, only the north and south cells have to be marked as such, not the east and west cells. Adjust <code>HexGrid.CreateCell</code> to take this into account.</p>
						
						<pre translate="no">		<ins>if (wrapping) {</ins>
			<ins>cell.Explorable = z > 0 &amp;&amp; z &lt; cellCountZ - 1;</ins>
		<ins>}</ins>
		<ins>else {</ins>
			cell.Explorable =
				x > 0 &amp;&amp; z > 0 &amp;&amp; x &lt; cellCountX - 1 &amp;&amp; z &lt; cellCountZ - 1;
		<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Feature Visibility</h3>
						
						<p>Next, let's check whether visibility works correctly across the seam. It does for the terrain, but not for terrain features. It looks like wrapped features pick up the visibility of the last cell that isn't wrapped.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/traveling-around-the-world/feature-visibility-incorrect.jpg" width="330" height="210">
							<figcaption>Incorrect feature visibility.</figcaption>
						</figure>
						
						<p>This happens because the wrap mode of the texture used by <code>HexCellShaderData</code> is set to clamp. The solution is simply to set its clamp mode to repeat. But we only need to do this for the U coordinates, so set <code>wrapModeU</code> and <code>wrapModeV</code> separately in <code>Initialize</code>.</p>
						
						<pre translate="no">	public void Initialize (int x, int z) {
		if (cellTexture) {
			cellTexture.Resize(x, z);
		}
		else {
			cellTexture = new Texture2D(
				x, z, TextureFormat.RGBA32, false, true
			);
			cellTexture.filterMode = FilterMode.Point;
<del>//			cellTexture.wrapMode = TextureWrapMode.Clamp;</del>
			<ins>cellTexture.wrapModeU = TextureWrapMode.Repeat;</ins>
			<ins>cellTexture.wrapModeV = TextureWrapMode.Clamp;</ins>
			Shader.SetGlobalTexture("_HexCellData", cellTexture);
		}
		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Units and Columns</h3>
						
						<p>Another problem is that units currently do not wrap. They stay where they are when the column they're in is relocated.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-27/traveling-around-the-world/unit-on-wrong-size.jpg" width="370" height="170">
							<figcaption>Unit didn't wrap and is on the wrong side.</figcaption>
						</figure>
						
						<p>This can be solved by making the units children of the columns, just like the chunks. First, no longer make them a direct child of the grid in <code>HexGrid.AddUnit</code>.</p>
						
						<pre translate="no">	public void AddUnit (HexUnit unit, HexCell location, float orientation) {
		units.Add(unit);
		unit.Grid = this;
<del>//		unit.transform.SetParent(transform, false);</del>
		unit.Location = location;
		unit.Orientation = orientation;
	}</pre>
						
						<p>Because units move, they may end up in a different column, which means that we have to change their parent. To make this possible, add a public <code>MakeChildOfColumn</code> method to <code>HexGrid</code>, with the child's <code>Transform</code> component and the column index as parameters.</p>
						
						<pre translate="no">	<ins>public void MakeChildOfColumn (Transform child, int columnIndex) {</ins>
		<ins>child.SetParent(columns[columnIndex], false);</ins>
	<ins>}</ins></pre>
						
						<p>Invoke this method when the <code>HexUnit.Location</code> property is set.</p>
						
						<pre translate="no">	public HexCell Location {
		&hellip;
		set {
			&hellip;
			<ins>Grid.MakeChildOfColumn(transform, value.ColumnIndex);</ins>
		}
	}</pre>
						
						<p>That takes care of the creation of units. We also have to make sure they move to the correct column while traveling. This requires us to keep track of the current column index in <code>HexUnit.TravelPath</code>. At the start of this method, it's the column index of the cell at the start of the path, or the current one if traveling was interrupted by a recompile.</p>
						
						<pre translate="no">	IEnumerator TravelPath () {
		Vector3 a, b, c = pathToTravel[0].Position;
		yield return LookAt(pathToTravel[1].Position);

<del>//		Grid.DecreaseVisibility(</del>
<del>//			currentTravelLocation ? currentTravelLocation : pathToTravel[0],</del>
<del>//			VisionRange</del>
<del>//		);</del>
		<ins>if (!currentTravelLocation) {</ins>
			<ins>currentTravelLocation = pathToTravel[0];</ins>
		}
		<ins>Grid.DecreaseVisibility(currentTravelLocation, VisionRange);</ins>
		<ins>int currentColumn = currentTravelLocation.ColumnIndex;</ins>

		&hellip;
	}</pre>
						
						<p>During each iteration of the journey, check whether the next column index is different, and if so adjust the parent of the unit.</p>
						
						<pre translate="no">		int currentColumn = currentTravelLocation.ColumnIndex;

		float t = Time.deltaTime * travelSpeed;
		for (int i = 1; i &lt; pathToTravel.Count; i++) {
			&hellip;
			Grid.IncreaseVisibility(pathToTravel[i], VisionRange);

			<ins>int nextColumn = currentTravelLocation.ColumnIndex;</ins>
			<ins>if (currentColumn != nextColumn) {</ins>
				<ins>Grid.MakeChildOfColumn(transform, nextColumn);</ins>
				<ins>currentColumn = nextColumn;</ins>
			<ins>}</ins>

			&hellip;
		}</pre>
						
						<p>This makes units wrap just like chunks. However, when moving across the map seam the units don't wrap yet. Instead, they suddenly move in the wrong direction. This happens no matter where the seam is located, but is most dramatic when they race across the entire map.</p>
						
						<figure>
							<div class="vid" style="width: 370px; height:180px;"><iframe src='https://gfycat.com/ifr/DimBreakableIchthyostega'></iframe></div>
							<figcaption>Bouncing across the map.</figcaption>
						</figure>
						
						<p>Here we can use the same approach that we used for the water shores, except this time we wrap the curve that the unit is traveling along. When the next column is wrapped to the east, we teleport the curve to the east as well, likewise for the other direction. We have to adjust the <code>a</code> and <code>b</code> control points of the curve, which also takes care of the <code>c</code> control point.</p>
						
						<pre translate="no">		for (int i = 1; i &lt; pathToTravel.Count; i++) {
			currentTravelLocation = pathToTravel[i];
			a = c;
			b = pathToTravel[i - 1].Position;
<del>//			c = (b + currentTravelLocation.Position) * 0.5f;</del>
<del>//			Grid.IncreaseVisibility(pathToTravel[i], VisionRange);</del>

			int nextColumn = currentTravelLocation.ColumnIndex;
			if (currentColumn != nextColumn) {
				<ins>if (nextColumn &lt; currentColumn - 1) {</ins>
					<ins>a.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize;</ins>
					<ins>b.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize;</ins>
				<ins>}</ins>
				<ins>else if (nextColumn > currentColumn + 1) {</ins>
					<ins>a.x += HexMetrics.innerDiameter * HexMetrics.wrapSize;</ins>
					<ins>b.x += HexMetrics.innerDiameter * HexMetrics.wrapSize;</ins>
				<ins>}</ins>
				Grid.MakeChildOfColumn(transform, nextColumn);
				currentColumn = nextColumn;
			}

			<ins>c = (b + currentTravelLocation.Position) * 0.5f;</ins>
			<ins>Grid.IncreaseVisibility(pathToTravel[i], VisionRange);</ins>

			&hellip;
		}</pre>
						
						<figure>
							<div class="vid" style="width: 370px; height:180px;"><iframe src='https://gfycat.com/ifr/FlatBonyIchthyosaurs'></iframe></div>
							<figcaption>Wrapping movement.</figcaption>
						</figure>
						
						<p>The final thing that we have to tweak is the initial rotation of the unit, when it faces the first cell it's going to travel to. If that cell happens to be on the other side of the east&ndash;west seam, then the unit ends up looking in the wrong direction.</p>
						
						<p>When the map is wrapping, there are two ways to look at a point that's not directly north or south. You could look either eastward or westward. It makes sense to look in the direction that matches the closest distance to the point, as that's also the travel direction, so let's use that in <code>LookAt</code>.</p>
						
						<p>When wrapping, check the relative distance in the X dimension. If it's smaller than negative half of the map width, then we should look westward, which is done by wrapping the point to the west. Otherwise, if the distance is greater than half the map width, then we should wrap to the east.</p>
						
						<pre translate="no">	IEnumerator LookAt (Vector3 point) {
		<ins>if (HexMetrics.Wrapping) {</ins>
			<ins>float xDistance = point.x - transform.localPosition.x;</ins>
			<ins>if (xDistance &lt; -HexMetrics.innerRadius * HexMetrics.wrapSize) {</ins>
				<ins>point.x += HexMetrics.innerDiameter * HexMetrics.wrapSize;</ins>
			<ins>}</ins>
			<ins>else if (xDistance > HexMetrics.innerRadius * HexMetrics.wrapSize) {</ins>
				<ins>point.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize;</ins>
			<ins>}</ins>
		<ins>}</ins>

		&hellip;
	}</pre>
						
						<p>At this point we have a fully functional wrapping map. This also ends the Hex Map series. More topics could be covered, as mention in some earlier tutorials, but they're not specific to hex maps. I might cover them in future series of their own. Enjoy your maps!</p>
						
						<aside>
							<h3>I downloaded the final package and get rotation errors in play mode?</h3>
							<div>
								<p>That happens because the camera uses a custom <em translate="no">Rotation</em> axis. You need to add this axis. See <a href="../part-5/index.html">part 5, Larger Maps</a> for the details.</p>
							</div>
						</aside>
						
						<aside>
							<h3>I downloaded the final package and get graphics uglier than the screenshots?</h3>
							<div>
								<p>I've set my project to use linear color space. Gamme space makes it much brighter.</p>
							</div>
						</aside>
						
						<aside>
							<h3>I downloaded the final package and always generate the same map?</h3>
							<div>
								<p>The generator is set to always use the same fixed seed, 1208905299, which is the one used for most screenshots. Disable <em translate="no">Use Fixed Seed</em> to make it random.</p>
							</div>
						</aside>
						
					</section>
					
					<a href="https://catlikecoding.com/unity/tutorials/hex-map/part-27/traveling-around-the-world/traveling-around-the-world.unitypackage" download rel="nofollow">unitypackage</a>
					<a href="Hex-Map-27.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>