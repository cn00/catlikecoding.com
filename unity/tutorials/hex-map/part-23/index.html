<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/hex-map/part-23/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/hex-map/part-23/tutorial-image.jpg">
		<meta property="og:title" content="Hex Map 23">
		<meta property="og:description" content="A Unity Hex Map tutorial about procedurally generating land. Part 23 of 27.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Hex Map 23</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/hex-map/part-23/#article",
				"headline": "Hex Map 23",
				"alternativeHeadline": "Generating Land",
				"datePublished": "2017-11-14",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Hex Map tutorial about procedurally generating land. Part 23 of 27.",
				"image": "https://catlikecoding.com/unity/tutorials/hex-map/part-23/tutorial-image.jpg",
				"dependencies": "Unity 2017.1.0",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/hex-map/", "name": "Hex Map" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				Bezier: 1,
				EdgeVertices: 1,
				HexCell: 1,
				HexCellPriorityQueue: 1,
				HexCellShaderData: 1,
				HexEdgeType: 1,
				HexCoordinates: 1,
				HexCoordinatesDrawer: 1,
				HexDirection: 1,
				HexDirectionExtensions: 1,
				HexFeatureCollection: 1,
				HexFeatureManager: 1,
				HexGameUI: 1,
				HexGrid: 1,
				HexGridChunk: 1,
				HexHash: 1,
				HexMapCamera: 1,
				HexMapEditor: 1,
				HexMapGenerator: 1,
				HexMesh: 1,
				HexMetrics: 1,
				HexUnit: 1,
				ListPool: 1,
				NewMapMenu: 1,
				OptionalToggle: 1,
				SaveLoadItem: 1,
				SaveLoadMenu: 1,
				TextureArrayWizard: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Hex Map</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Hex Map 23</h1>
					<p>Generating Land</p>
					<ul>
						<li>Fill new maps with generated landscapes.</li>
						<li>Raise chunks of land above the water, and sink some.</li>
						<li>Control how much land appears, how high, and how erratic it is.</li>
						<li>Support multiple configuration options to create varied maps.</li>
						<li>Make it possible to generate the same map again.</li>
					</ul>
				</header>

				<p>This is part 23 of a tutorial series about <a href="../index.html">hexagon maps</a>. It is the first of a few tutorials that will cover how to generate maps procedurally.</p>
				
				<p>This tutorial is made with Unity 2017.1.0.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>One of many generated maps.</figcaption>
				</figure>
				
				<section>
					<h2>Generating Maps</h2>
					
					<p>While we can manually create any map we like, this can take a lot of time. It would be convenient if our app could help a designer get started by generating a map for them, which they could them modify as desired. A step further is to do away with manual design entirely, fully relying on the app itself to generate a finished map for us. That would make it possible to play a game with a new map every time, ensuring that each new game session will be different. Not knowing the layout of the map you'll play on beforehand is essential when exploration is a big part of a game that's meant to be played more than once. To make all this possible, we have to create an algorithm for generating maps.</p>
					
					<p>What kind of map-generating algorithm you need depends on the kind of maps that your app requires. There isn't a single best approach for this, but there will always be a trade-off between believability and playability.</p>
					
					<p>Believability is about the player of a game accepting that a map is possible and real. This doesn't mean that maps have to appear like they're part of our planet. They could be for another planet or a completely different reality. But if it's supposed to represent earthen terrain, it should at least somewhat look the part.</p>
					
					<p>Playability concerns whether maps support the gameplay experience that you're going for. It is often at odds with believability. For example, while mountain ranges might look great, they also logically severely limit the movement and vision of units. If that's not desired, you have to make do without mountains, which might lower believability and limits the expressiveness of your game. Alternatively, you could keep mountains but lessen their impact on gameplay, which might also lower believability.</p>
					
					<p>Besides that, there's also feasibility. For example, you could produce a very realistic-looking earth-like planet by simulating plate tectonics, erosion, rainfall, volcanic eruptions, meteor impacts, lunar influence, and so on. But that will take a long time to develop. Also, generating such a planet might take a while, and players won't appreciate having to wait minutes before they can start a new game. So while simulation can be a powerful tool, it has a cost.</p>
					
					<p>Games are full with trade-offs between believability, playability, and feasibility. Sometimes, these trade-offs go unnoticed, seem perfectly normal, or are arbitrary, inconsistent, or jarring, depending on the choices and priorities of whoever made the game. This isn't limited to map generation, but it's something that you have to be very aware of when developing a procedural map generator. You could end up spending a lot of time creating an algorithm that generates beautiful maps that are also useless for the game you're trying to make.</p>
					
					<p>In this tutorial series we're going for earth-like terrain. It should look interesting, with a lot of variety, no large homogenous areas. The scale of the terrain will be large, with maps covering one or more continents, oceanic regions, or even an entire planet. We want to have reasonable control over the geography, including the landmass, climate, how many regions there are, and how rough the terrain is. This tutorial will lay the foundation for the landmass.</p>
					
					<section>
						<h3>Starting in Edit Mode</h3>
						
						<p>As we're going to focus on the map and not gameplay, it's convenient to directly start our app in edit mode. That way we'll immediately see the maps. So adjust <code>HexMapEditor.Awake</code> to set the edit mode to true and enable the edit mode shader keyword. Also adjust the default state of the edit toggle in the GUI.</p>
						
						<pre translate="no">	void Awake () {
		terrainMaterial.DisableKeyword("GRID_ON");
		<ins>Shader.EnableKeyword("HEX_MAP_EDIT_MODE");</ins>
		SetEditMode(<ins>true</ins>);
	}</pre>
					</section>
					
					<section>
						<h3>Map Generator</h3>
						
						<p>Because procedural map generation requires quite a bit of code, we're not going to add that to <code>HexGrid</code> directly. Instead, we'll create a new <code>HexMapGenerator</code> component for it, keeping <code>HexGrid</code> unaware of it. This also makes it easier to switch to a different algorithm later, if you would like to.</p>
						
						<p>The generator requires a reference to the grid, so give it a public field for that. Besides that, add a public <code>GenerateMap</code> method that will do the algorithm's work. Give it the map dimensions as parameters, then have it use those to create a new empty map.</p>
						
						<pre translate="no"><ins>using System.Collections.Generic;</ins>
<ins>using UnityEngine;</ins>

<ins>public class HexMapGenerator : MonoBehaviour {</ins>

	<ins>public HexGrid grid;</ins>

	<ins>public void GenerateMap (int x, int z) {</ins>
		<ins>grid.CreateMap(x, z);</ins>
	<ins>}</ins>
<ins>}</ins></pre>
						
						<p>Add an object with the <code>HexMapGenerator</code> component to the scene and hook it up to the grid.</p>
						
						<figure>
							<img src="generating-maps/generator-object.png" width="320" height="123">
							<figcaption>Map generator object.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Adjusting the New Map Menu</h3>
						
						<p>We'll adjust <code>NewMapMenu</code> so it can also generate maps, besides creating empty ones. We'll control what it does via a boolean <code>generateMaps</code> field, which is set to <code>true</code> by default. Create a public method to set this field, like the we did for toggle options of <code>HexMapEditor</code>. Add a corresponding toggle to the menu UI and connect it to the method.</p>
						
						<pre translate="no">	<ins>bool generateMaps = true;</ins>

	<ins>public void ToggleMapGeneration (bool toggle) {</ins>
		<ins>generateMaps = toggle;</ins>
	<ins>}</ins></pre>
						
						<figure>
							<img src="generating-maps/new-map-menu.png" width="194" height="214">
							<figcaption>New map menu with toggle.</figcaption>
						</figure>
						
						<p>Give the menu a reference to the map generator. Then have it invoke the generator's <code>GenerateMap</code> method instead of directly going for the grid's <code>CreateMap</code>, when appropriate.</p>
						
						<pre translate="no">	<ins>public HexMapGenerator mapGenerator;</ins>

	&hellip;

	void CreateMap (int x, int z) {
		<ins>if (generateMaps) {</ins>
			<ins>mapGenerator.GenerateMap(x, z);</ins>
		<ins>}</ins>
		<ins>else {</ins>
			hexGrid.CreateMap(x, z);
		<ins>}</ins>
		HexMapCamera.ValidatePosition();
		Close();
	}</pre>
						
						<figure>
							<img src="generating-maps/new-map-menu-inspector.png" width="320" height="74">
							<figcaption>Hooked up to the generator.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Accessing the Cells</h3>
						
						<p>To do its work, the generator will need to access the grid's cells. <code>HexGrid</code> already has public <code>GetCell</code> methods, which require either a position vector or hex coordinates. The generator doesn't need to work with either, so let's also add two convenient <code>HexGrid.GetCell</code> method that work with either offset coordinates or a cell index.</p>
						
						<pre translate="no">	<ins>public HexCell GetCell (int xOffset, int zOffset) {</ins>
		<ins>return cells[xOffset + zOffset * cellCountX];</ins>
	<ins>}</ins>
	
	<ins>public HexCell GetCell (int cellIndex) {</ins>
		<ins>return cells[cellIndex];</ins>
	<ins>}</ins></pre>
						
						<p>Now <code>HexMapGenerator</code> can directly retrieve cells. For example, after a new map has been created, set the terrain of the middle cell column to grass, using offset coordinates. </p>
						
						<pre translate="no">	public void GenerateMap (int x, int z) {
		grid.CreateMap(x, z);
		<ins>for (int i = 0; i &lt; z; i++) {</ins>
			<ins>grid.GetCell(x / 2, i).TerrainTypeIndex = 1;</ins>
		<ins>}</ins>
	}</pre>
						
						<figure>
							<img src="generating-maps/generated-map.jpg" width="350" height="210">
							<figcaption>A grass column on a small map.</figcaption>
						</figure>
					</section>
					
					<a href="generating-maps/generating-maps.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Creating Land</h2>
					
					<p>When generating a map, we conceptually start without any land. You can imagine the entire world is covered with one big ocean. Land is created when part of the ocean floor is pushed upward so much it rises above the water. We have to decide how much land is created this way, where it appears, and in what shape.</p>
					
					<section>
						<h3>Raising Terrain</h3>
						
						<p>We start small, by raising a single chunk of land above the water. Create a <code>RaiseTerrain</code> method for this, with a parameter to control the size of the chunk. Invoke this method in <code>GenerateMap</code>, replacing the earlier test code. Let's start with a small chunk of land, consisting of seven cells.</p>
						
						<pre translate="no">	public void GenerateMap (int x, int z) {
		grid.CreateMap(x, z);
<del>//		for (int i = 0; i &lt; z; i++) {</del>
<del>//			grid.GetCell(x / 2, i).TerrainTypeIndex = 1;</del>
<del>//		}</del>
		<ins>RaiseTerrain(7);</ins>
	}

	<ins>void RaiseTerrain (int chunkSize) {}</ins></pre>
						
						<p>For now, we'll simply use the grass terrain type to indicate raised land, with the initial sand terrain representing the ocean. We'll make <code>RaiseTerrain</code> grab a random cell and adjust its terrain type, until we have the desired amount of land.</p>
						
						<p>To get a random cell, add a <code>GetRandomCell</code> method that determines a random cell index and retrieves the corresponding cell from the grid.</p>
						
						<pre translate="no">	void RaiseTerrain (int chunkSize) {
		<ins>for (int i = 0; i &lt; chunkSize; i++) {</ins>
			<ins>GetRandomCell().TerrainTypeIndex = 1;</ins>
		<ins>}</ins>
	}

	<ins>HexCell GetRandomCell () {</ins>
		<ins>return grid.GetCell(Random.Range(0, grid.cellCountX * grid.cellCountZ));</ins>
	<ins>}</ins></pre>
						
						<figure>
							<img src="creating-land/random-cells.jpg" width="350" height="210">
							<figcaption>Seven random land cells.</figcaption>
						</figure>
						
						<p>As we might end up needed lots of random cells&mdash;or loop through all cells multiple times&mdash;let's keep track of the amount of cells in <code>HexMapGenerator</code> itself.</p>
						
						<pre translate="no">	<ins>int cellCount;</ins>

	public void GenerateMap (int x, int z) {
		<ins>cellCount = x * z;</ins>
		&hellip;
	}

	&hellip;

	HexCell GetRandomCell () {
		return grid.GetCell(Random.Range(0, <ins>cellCount</ins>));
	}</pre>
					</section>
					
					<section>
						<h3>Creating a Single Chunk</h3>
						
						<p>While we're turning seven random cells into land, they can be anywhere. They're most likely don't form a single chunk of land. We might also end up picking the same cell multiple times, ending up with less than the desired amount of land. To solve both problems, only the first cell can be picked without constraint. After that, we must only pick cells that are adjacent to those that we have chosen earlier. These limitations are quite similar to those of pathfinding, so let's use the same approach here.</p>
						
						<p>Give <code>HexMapGenerator</code> its own priority queue and search frontier phase counter, just like <code>HexGrid</code>.</p>
						
						<pre translate="no">	<ins>HexCellPriorityQueue searchFrontier;</ins>

	<ins>int searchFrontierPhase;</ins></pre>
						
						<p>Make sure that the priority queue exists before we will need it.</p>
						
						<pre translate="no">	public void GenerateMap (int x, int z) {
		cellCount = x * z;
		grid.CreateMap(x, z);
		<ins>if (searchFrontier == null) {</ins>
			<ins>searchFrontier = new HexCellPriorityQueue();</ins>
		<ins>}</ins>
		RaiseTerrain(7);
	}</pre>
						
						<p>After a new map has been created, the search frontier of all cells is zero. But if we're going to search cells while generating a map, we're going to increase their search frontier in the process. If we do a lot of searching, they might end up ahead of the search frontier phase recorded by <code>HexGrid</code>. That could break the pathfinding of units. To prevent this, reset the search phase of all cells to zero at the end of the map generation process.</p>
						
						<pre translate="no">		RaiseTerrain(7);
		<ins>for (int i = 0; i &lt; cellCount; i++) {</ins>
			<ins>grid.GetCell(i).SearchPhase = 0;</ins>
		<ins>}</ins></pre>
						
						<p><code>RaiseTerrain</code> must now search for appropriate cells instead of picking them all at random. This process is quite similar to the way we search in <code>HexGrid</code>. However, we're never going to visit cells more than once, so we can suffice by increasing the search frontier phase by 1 instead of 2. Then initialize the frontier with the first cell, which is random. Make sure to set its distance and heuristic to zero besides setting its search phase, as usual.</p>
						
						<pre translate="no">	void RaiseTerrain (int chunkSize) {
<del>//		for (int i = 0; i &lt; chunkSize; i++) {</del>
<del>//			GetRandomCell().TerrainTypeIndex = 1;</del>
<del>//		}</del>
		<ins>searchFrontierPhase += 1;</ins>
		<ins>HexCell firstCell = GetRandomCell();</ins>
		<ins>firstCell.SearchPhase = searchFrontierPhase;</ins>
		<ins>firstCell.Distance = 0;</ins>
		<ins>firstCell.SearchHeuristic = 0;</ins>
		<ins>searchFrontier.Enqueue(firstCell);</ins>
	}</pre>
						
						<p>The search loop after that is also mostly familiar. Besides continuing until the frontier is empty, we should also stop when the chunk has reached the desired size, so keep track of that. Each iteration, dequeue the next cell, set its terrain type, increase the size, then go through that cell's neighbors. All neighbors are simply added to the frontier, if they hadn't already been added. We don't have to do any other comparisons or adjustments. Once we're done, make sure to clear the frontier.</p>
						
						<pre translate="no">		searchFrontier.Enqueue(firstCell);

		<ins>int size = 0;</ins>
		<ins>while (size &lt; chunkSize &amp;&amp; searchFrontier.Count > 0) {</ins>
			<ins>HexCell current = searchFrontier.Dequeue();</ins>
			<ins>current.TerrainTypeIndex = 1;</ins>
			<ins>size += 1;</ins>

			<ins>for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {</ins>
				<ins>HexCell neighbor = current.GetNeighbor(d);</ins>
				<ins>if (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) {</ins>
					<ins>neighbor.SearchPhase = searchFrontierPhase;</ins>
					<ins>neighbor.Distance = 0;</ins>
					<ins>neighbor.SearchHeuristic = 0;</ins>
					<ins>searchFrontier.Enqueue(neighbor);</ins>
				<ins>}</ins>
			<ins>}</ins>
		<ins>}</ins>
		<ins>searchFrontier.Clear();</ins></pre>
						
						<figure>
							<img src="creating-land/line-of-cells.jpg" width="350" height="210">
							<figcaption>A line of cells.</figcaption>
						</figure>
						
						<p>We now get a single chunk of the desired size. It will only end up smaller if there weren't enough cells available. Because of the way the frontier is filled, it always produces a line of cells moving northwest. It only changes direction when it reaches the edge of the map.</p>
					</section>
					
					<section>
						<h3>Keeping the Cells Together</h3>
						
						<p>Chunks of land are rarely shaped like a line, and even if they are the don't always have the same orientation. To change the shape of the chunk, we have to change the priorities of the cells. We can use the first random cell as the center of the chunk. Then the distance of all other cells is relative to that point. This will give higher priority to cells that are closer to the center, which should cause the chunk to grow around its center instead of in a line.</p>
						
						<pre translate="no">		searchFrontier.Enqueue(firstCell);
		<ins>HexCoordinates center = firstCell.coordinates;</ins>

		int size = 0;
		while (size &lt; chunkSize &amp;&amp; searchFrontier.Count > 0) {
			HexCell current = searchFrontier.Dequeue();
			current.TerrainTypeIndex = 1;
			size += 1;

			for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {
				HexCell neighbor = current.GetNeighbor(d);
				if (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) {
					neighbor.SearchPhase = searchFrontierPhase;
					neighbor.Distance = <ins>neighbor.coordinates.DistanceTo(center);</ins>
					neighbor.SearchHeuristic = 0;
					searchFrontier.Enqueue(neighbor);
				}
			}
		}</pre>
						
						<figure>
							<img src="creating-land/clumped-cells.jpg" width="350" height="210">
							<figcaption>Clumped cells.</figcaption>
						</figure>
						
						<p>Indeed, our seven cells are now always neatly packed in a compact hexagonal area, unless the center cell happens to lie on the edge of the map. Let's try it with chunk size 30 as well.</p>
						
						<pre translate="no">		RaiseTerrain(<ins>30</ins>);</pre>
						
						<figure>
							<img src="creating-land/30-cells.jpg" width="350" height="210">
							<figcaption>A mass of 30 cells.</figcaption>
						</figure>
						
						<p>Again, we always get the same shape, although it's not the right amount of cells to form a neat hexagon. Because the chunk's radius is larger, it's also more likely to be close enough to a map edge to be forced into a different shape.</p>
					</section>
					
					<section>
						<h3>Randomizing the Land Shape</h3>
						
						<p>We don't want all chunks to look the same, so let's mess up the cell priorities a bit. Each time we're adding a neighbor cell to the frontier, if the next <code>Random.value</code> number is less than some threshold, set that cell's heuristic to 1 instead of 0. Let's use 0.5 as the threshold, which means most likely half of the cells will be affected.</p>
						
						<pre translate="no">					neighbor.Distance = neighbor.coordinates.DistanceTo(center);
					neighbor.SearchHeuristic = <ins>Random.value &lt; 0.5f ? 1: 0</ins>;
					searchFrontier.Enqueue(neighbor);</pre>
						
						<figure>
							<img src="creating-land/randomized-chunk.jpg" width="350" height="210">
							<figcaption>Jittered chunk.</figcaption>
						</figure>
						
						<p>By increasing a cell's search heuristic we ensure that it will be visited later than expected. This causes other cells that are one step further away from the center to be visited earlier, unless their heuristic has been increased too. This means that if we increased the heuristic of all cells by the same amount, there would be no effect. So a threshold of 1 would have no effect, just like a threshold of 0. And a threshold of 0.8 would be equivalent to 0.2. Thus a probability of 0.5 makes the search process the most jittery.</p>
						
						<p>Which jitter probability is best depends on what kind of terrain you're aiming for, so let's make it configurable. Add a public float <code>jitterProbability</code> field to the generator, with a <code>Range</code> attribute constrained to 0&ndash;0.5. Give it a default value equal to the average of its range, so 0.25. This allows us to configure our generator via the Unity inspector window.</p>
						
						<pre translate="no">	<ins>[Range(0f, 0.5f)]</ins>
	<ins>public float jitterProbability = 0.25f;</ins></pre>
						
						<figure>
							<img src="creating-land/jitter-probability.png" width="320" height="74">
							<figcaption>Jitter probability.</figcaption>
						</figure>
						
						<aside>
							<h3>What about making it configurable via the in-game UI as well?</h3>
							<div>
								<p>That is possible, and most games do this. I'm not going to add in-game UI for it in this tutorial, but that's not stopping you. However, we'll end up with quite a few configuration options for our generator. So keep this in mind when designing your UI. You could decide to wait until you know all the options. At that point, you might also decide to use different constraints, different terminology, and limit which options are exposed to the player.</p>
							</div>
						</aside>
						
						<p>Now use this probability instead of the fixed value to decide whether the heuristic should be set to 1.</p>
						
						<pre translate="no">					neighbor.SearchHeuristic =
						Random.value &lt; <ins>jitterProbability</ins> ? 1: 0;</pre>
						
						<p>We use the heuristic values 0 and 1. While you could use larger heuristic values as well, this will greatly exacerbate the deformation of the chunk, likely turning it into a bunch of ribbons.</p>
					</section>
					
					<section>
						<h3>Raising Multiple Chunks</h3>
						
						<p>We're not limited to generating a single chunk of land. For example, put the invocation of <code>RaiseTerrain</code> inside a loop so we get five chunks.</p>
						
						<pre translate="no">		<ins>for (int i = 0; i &lt; 5; i++) {</ins>
			RaiseTerrain(30);
		<ins>}</ins></pre>
						
						<figure>
							<img src="creating-land/multiple-chunks.jpg" width="350" height="210">
							<figcaption>Five chunks.</figcaption>
						</figure>
						
						<p>Although we're now generating five chunks of size 30 each, we're not guaranteed to get 150 cell's worth of land. As each chunk is created in isolation, they're not aware of each other, so they can overlap. This is fine, because it can produce more varied landscapes that a bunch of isolated chunks.</p>
						
						<p>To make the land even more varied, we can also vary the size of each chunk. Add two integer fields to control the minimum and maximum chunk sizes that are allowed. Give them each a reasonably large range, like 20&ndash;200. I've set the default minimum to 30 and the default maximum to 100.</p>
						
						<pre translate="no">	<ins>[Range(20, 200)]</ins>
	<ins>public int chunkSizeMin = 30;</ins>

	<ins>[Range(20, 200)]</ins>
	<ins>public int chunkSizeMax = 100;</ins></pre>
						
						<figure>
							<img src="creating-land/chunk-size.png" width="320" height="110">
							<figcaption>Chunk size range.</figcaption>
						</figure>
						
						<p>Use these field to randomly determine the chunk size when invoking <code>RaiseTerrain</code>.</p>
						
						<pre translate="no">			RaiseTerrain(<ins>Random.Range(chunkSizeMin, chunkSizeMax + 1)</ins>);</pre>
						
						<figure>
							<img src="creating-land/random-chunk-size.jpg" width="350" height="210">
							<figcaption>Five chunks with random sizes, on a medium map.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Making Enough Land</h3>
						
						<p>At this point we do not have much control over how much land gets generated. While we could add a configuration option for the amount of chunks, the chunk sizes are still random and they could overlap a little or a lot. Thus, the amount of chunks doesn't guarantee how much of the map ends up as land. So let's add an option to directly control the land percentage, expressed an an integer. As 100% land or water isn't interesting, set its range to 5&ndash;95, with a default of 50.</p>
						
						<pre translate="no">	<ins>[Range(5, 95)]</ins>
	<ins>public int landPercentage = 50;</ins></pre>
						
						<figure>
							<img src="creating-land/land-percentage.png" width="320" height="128">
							<figcaption>Land percentage.</figcaption>
						</figure>
						
						<p>To make sure that we end up with the desired amount of land, we simply have to keep raising chunks of terrain until we have enough. This requires us to keep track of our progress, which makes the land generation more complex. So let's replace our current loop that raises some chunks with the invocation of a new <code>CreateLand</code> method. The first thing that method does is calculate how many cells have to become land. That amount is our land budget.</p>
						
						<pre translate="no">	public void GenerateMap (int x, int z) {
		&hellip;
<del>//		for (int i = 0; i &lt; 5; i++) {</del>
<del>//			RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + 1));</del>
<del>//		}</del>
		<ins>CreateLand();</ins>
		for (int i = 0; i &lt; cellCount; i++) {
			grid.GetCell(i).SearchPhase = 0;
		}
	}

	<ins>void CreateLand () {</ins>
		<ins>int landBudget = Mathf.RoundToInt(cellCount * landPercentage * 0.01f);</ins>
	<ins>}</ins></pre>
						
						<p><code>CreateLand</code> is going to invoke <code>RaiseTerrain</code> as long as there's still land budget to be spent. To prevent going over budget, adjust <code>RaiseTerrain</code> so it takes the budget as an additional parameter. Once it's done, it should return the remaining budget.</p>
						
						<pre translate="no"><del>//	void RaiseTerrain (int chunkSize) {</del>
	<ins>int RaiseTerrain (int chunkSize, int budget) {</ins>
		&hellip;
		<ins>return budget;</ins>
	}</pre>
						
						<p>Each time a cell is taken out of the frontier and turned into land, the budget should be decremented. If the entire budget is spent after that, we have to abort the search and cut the chunk short. Make sure to only do this if the current cell isn't land yet.</p>
						
						<pre translate="no">		while (size &lt; chunkSize &amp;&amp; searchFrontier.Count > 0) {
			HexCell current = searchFrontier.Dequeue();
			<ins>if (current.TerrainTypeIndex == 0) {</ins>
				current.TerrainTypeIndex = 1;
				<ins>if (--budget == 0) {</ins>
					<ins>break;</ins>
				<ins>}</ins>
			<ins>}</ins>
			size += 1;
			
			&hellip;
		}</pre>
						
						<p>Now <code>CreateLand</code> can keep raising land as long as it has budget.</p>
						
						<pre translate="no">	void CreateLand () {
		int landBudget = Mathf.RoundToInt(cellCount * landPercentage * 0.01f);
		<ins>while (landBudget > 0) {</ins>
			<ins>landBudget = RaiseTerrain(</ins>
				<ins>Random.Range(chunkSizeMin, chunkSizeMax + 1), landBudget</ins>
			<ins>);</ins>
		<ins>}</ins>
	}</pre>
						
						<figure>
							<img src="creating-land/50-percent-land.jpg" width="350" height="210">
							<figcaption>Exactly half the map is land.</figcaption>
						</figure>
					</section>
					
					<a href="creating-land/creating-land.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Sculpting with Elevation</h2>
					
					<p>Land isn't just a flat slab solely defined by its coastline. It can also have varied elevation, containing hills, mountains, valleys, lakes, and so on. Large elevation differences exist because of the interactions between slowly-moving tectonic plates. While we're not going to simulate this, our chunks of land are somewhat like these plates. Our chunks don't move, but they do overlap. This is something that we can make use of.</p>
					
					<section>
						<h3>Pushing Land Upward</h3>
						
						<p>Each chunk represents a portion of land that has been pushed up from the ocean floor. So let's always increment the elevation of the current cell that we're processing in <code>RaiseTerrain</code> and see what happens.</p>
						
						<pre translate="no">			HexCell current = searchFrontier.Dequeue();
			<ins>current.Elevation += 1;</ins>
			if (current.TerrainTypeIndex == 0) {
				&hellip;
			}</pre>
						
						<figure>
							<img src="sculpting-with-elevation/elevation.jpg" width="350" height="210">
							<figcaption>Land with elevation.</figcaption>
						</figure>
						
						<p>We're getting some elevation, but it's hard to see clearly. We can make it obvious by using a different terrain type for each elevation level, like geological stratification. This is just for the purpose of making it obvious, so we can simply use the elevation level as the terrain index.</p>
						
						<aside>
							<h3>What happens when elevation goes above the amount of terrain types?</h3>
							<div>The shader will use the last texture in the texture array. In our case snow is the last terrain type, so we'll get a snow line.</div>
						</aside>
						
						<p>Instead of updating a cell's terrain type each time its elevation changes, let's create a separate <code>SetTerrainType</code> method to set all terrain types once.</p>
						
						<pre translate="no">	<ins>void SetTerrainType () {</ins>
		<ins>for (int i = 0; i &lt; cellCount; i++) {</ins>
			<ins>HexCell cell = grid.GetCell(i);</ins>
			<ins>cell.TerrainTypeIndex = cell.Elevation;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Invoke this method after the land has been created.</p>
						
						<pre translate="no">	public void GenerateMap (int x, int z) {
		&hellip;
		CreateLand();
		<ins>SetTerrainType();</ins>
		&hellip;
	}</pre>
						
						<p>Now <code>RaiseTerrain</code> no longer has to worry about terrain type and can focus on elevation. This requires a change in its logic. When the current cell's new elevation is 1, it has just become land, so the budget decrements, which could end the chunk's growth.</p>
						
						<pre translate="no">			HexCell current = searchFrontier.Dequeue();
			current.Elevation += 1;
			<ins>if (current.Elevation == 1 &amp;&amp; --budget == 0) {</ins>
				<ins>break;</ins>
			<ins>}</ins>
			
<del>//			if (current.TerrainTypeIndex == 0) {</del>
<del>//				current.TerrainTypeIndex = 1;</del>
<del>//				if (--budget == 0) {</del>
<del>//					break;</del>
<del>//				}</del>
<del>//			}</del></pre>
						
						<figure>
							<img src="sculpting-with-elevation/stratification.jpg" width="350" height="210">
							<figcaption>Stratification.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Adding Water</h3>
						
						<p>Let's make it explicit which cells are land or water, by setting the water level of all cells to 1. Do this in <code>GenerateMap</code>, before creating the land.</p>
						
						<pre translate="no">	public void GenerateMap (int x, int z) {
		cellCount = x * z;
		grid.CreateMap(x, z);
		if (searchFrontier == null) {
			searchFrontier = new HexCellPriorityQueue();
		}
		<ins>for (int i = 0; i &lt; cellCount; i++) {</ins>
			<ins>grid.GetCell(i).WaterLevel = 1;</ins>
		<ins>}</ins>
		CreateLand();
		&hellip;
	}</pre>
						
						<p>Now we can use all terrain types to represent land layers. All underwater cells remain sand, as well as the lowest land cells. This is done by subtracting the water level from the elevation and using that as the terrain type index.</p>
						
						<pre translate="no">	void SetTerrainType () {
		for (int i = 0; i &lt; cellCount; i++) {
			HexCell cell = grid.GetCell(i);
			<ins>if (!cell.IsUnderwater) {</ins>
				cell.TerrainTypeIndex = cell.Elevation <ins>- cell.WaterLevel</ins>;
			<ins>}</ins>
		}
	}</pre>
						
						<figure>
							<img src="sculpting-with-elevation/water.jpg" width="350" height="210">
							<figcaption>Land and water.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Raising the Water Level</h3>
						
						<p>We're not limited to a fixed water level of 1. Let's make it configurable via a public field with range 1&ndash;5 and a default of 3. Use this level to initialize the cells.</p>
						
						<pre translate="no">	<ins>[Range(1, 5)]</ins>
	<ins>public int waterLevel = 3;</ins>
	
	&hellip;
	
	public void GenerateMap (int x, int z) {
		&hellip;
		for (int i = 0; i &lt; cellCount; i++) {
			grid.GetCell(i).WaterLevel = <ins>waterLevel</ins>;
		}
		&hellip;
	}</pre>
						
						<figure>
							<img alt="inspector" src="sculpting-with-elevation/water-level.png" width="320" height="146"><br>
							<img alt="scene" src="sculpting-with-elevation/too-much-water.jpg" width="350" height="210">
							<figcaption>Water level 3.</figcaption>
						</figure>
						
						<p>When the water level is 3, we end up with much less land than expected. This happens because <code>RaiseTerrain</code> still assumes that the water level is 1. Let's fix this.</p>
						
						<pre translate="no">			HexCell current = searchFrontier.Dequeue();
			current.Elevation += 1;
			if (current.Elevation == <ins>waterLevel</ins> &amp;&amp; --budget == 0) {
				break;
			}</pre>
						
						<p>The effect of using a higher water level is that cells don't immediately become land. When the water level is 2, the first chunk is still fully underwater. The ocean floor has risen, but it's still submerged. Only when at least two chunks overlap is land formed. The higher the water level, the more chunks need to be stacked to produce land. The result of this is that higher water levels make the land more erratic. Also, when more chunks are needed it's more likely that they end up stacked on top of already existing land, which makes mountain ranges more common and flat land more rare, just like using smaller chunks does.</p>
						
						<figure>
							<img alt="2" src="sculpting-with-elevation/water-level-2.jpg" width="350" height="210">
							<img alt="3" src="sculpting-with-elevation/water-level-3.jpg" width="350" height="210">
							<img alt="4" src="sculpting-with-elevation/water-level-4.jpg" width="350" height="210">
							<img alt="5" src="sculpting-with-elevation/water-level-5.jpg" width="350" height="210">
							<figcaption>Water levels 2&ndash;5, always with 50% land.</figcaption>
						</figure>
					</section>
					
					<a href="sculpting-with-elevation/sculpting-with-elevation.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Vertical Movement</h2>
					
					<p>Up to this point we've only raised chunks upward one elevation level at a time, but it doesn't have to be limited to this.</p>
					
					<section>
						<h3>High-Rise Chunks</h3>
						
						<p>Although each chunk increases the elevation of its cells by one level, cliffs can occur. This happens when the edges of two chunks touch. That can produce isolated cliffs, but longer strings of cliffs are rare. We can make those a lot more common by increasing the elevation of chunks by more than one step. But we should only do this for a fraction of the chunks. If all chunks were high-rises, the terrain would become very hard to navigate. So let's make it configurable with a probability field, with default value 0.25.</p>
						
						<pre translate="no">	<ins>[Range(0f, 1f)]</ins>
	<ins>public float highRiseProbability = 0.25f;</ins></pre>
						
						<figure>
							<img src="vertical-movement/high-rise-probability.png" width="320" height="164">
							<figcaption>High-rise probability.</figcaption>
						</figure>
						
						<p>While we could use any elevation increase for high-rising chunks, it gets out of hand fast. An elevation difference of 2 already creates cliffs, so that's sufficient. Because this makes it possible to skip the elevation that equals the water level, we have to change how we determine that a cell has turned into land. If it used to be below the water level but is now at the same level or above it, then we made a new land cell.</p>
						
						<pre translate="no">		<ins>int rise = Random.value &lt; highRiseProbability ? 2 : 1;</ins>
		int size = 0;
		while (size &lt; chunkSize &amp;&amp; searchFrontier.Count > 0) {
			HexCell current = searchFrontier.Dequeue();
			<ins>int originalElevation = current.Elevation;</ins>
			current.Elevation = <ins>originalElevation + rise</ins>;
			if (
				<ins>originalElevation &lt; waterLevel &amp;&amp;</ins>
				current.Elevation <ins>>=</ins> waterLevel &amp;&amp; --budget == 0
			) {
				break;
			}
			size += 1;
			
			&hellip;
		}</pre>
						
						<figure>
							<img alt="25" src="vertical-movement/high-rise-25.jpg" width="350" height="210">
							<img alt=50 src="vertical-movement/high-rise-50.jpg" width="350" height="210">
							<img alt="75" src="vertical-movement/high-rise-75.jpg" width="350" height="210">
							<img alt="100" src="vertical-movement/high-rise-100.jpg" width="350" height="210">
							<figcaption>High-rise probability 0.25, 0.50, 0.75, and 1.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Sinking Land</h3>
						
						<p>Land doesn't always go up, sometimes it goes down as well. When land sinks low enough, it submerges and is lost. We're currently not doing this. Because we only push chunks upward, the land tends to look like a collection of fairly round areas mashed together. If we sometimes push a chunk downward instead, we can end up with more varied shapes.</p>
						
						<figure>
							<img src="vertical-movement/large-map.jpg" width="350" height="210">
							<figcaption>Large map, without sunken land.</figcaption>
						</figure>
						
						<p>Controlling how often we sink land can be done with another probability field. Because sinking can destroy land, we should always make it less likely to sink than to raise. Otherwise it might take a very long time to reach the desired land percentage, if we ever get there. So let's use a maximum sink probability of 0.4, with a default of 0.2.</p>
						
						<pre translate="no">	<ins>[Range(0f, 0.4f)]</ins>
	<ins>public float sinkProbability = 0.2f;</ins></pre>
						
						<figure>
							<img src="vertical-movement/sink-probability.png" width="320" height="182">
							<figcaption>Sink probability.</figcaption>
						</figure>
						
						<p>Sinking a chunk is similar to raising one, with a few differences. So duplicate the <code>RaiseTerrain</code> method and change its name to <code>SinkTerrain</code>. Instead of determining an amount to rise, we need an amount to sink by, which can use the same logic. Meanwhile, the comparisons to check for whether we passed through the water surface have to be reversed. Also, we're not limited by the the budget when sinking terrain. Instead, each land cell that is lost reclaims spent budget, so we should increment it and keep going.</p>
						
						<pre translate="no">	int <ins>SinkTerrain</ins> (int chunkSize, int budget) {
		&hellip;

		int <ins>sink</ins> = Random.value &lt; highRiseProbability ? 2 : 1;
		int size = 0;
		while (size &lt; chunkSize &amp;&amp; searchFrontier.Count > 0) {
			HexCell current = searchFrontier.Dequeue();
			int originalElevation = current.Elevation;
			current.Elevation = originalElevation <ins>- sink</ins>;
			if (
				originalElevation <ins>>=</ins> waterLevel &amp;&amp;
				current.Elevation <ins>&lt;</ins> waterLevel
<del>//				&amp;&amp; --budget == 0</del>
			) {
<del>//				break;</del>
				<ins>budget += 1;</ins>
			}
			size += 1;

			&hellip;
		}
		searchFrontier.Clear();
		return budget;
	}</pre>
						
						
						<p>Each iteration inside the <code>CreateLand</code> loop we should now either raise or sink a chunk of land, depending on the sink probability.</p>
						
						<pre translate="no">	void CreateLand () {
		int landBudget = Mathf.RoundToInt(cellCount * landPercentage * 0.01f);
		while (landBudget > 0) {
			<ins>int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1);</ins>
			<ins>if (Random.value &lt; sinkProbability) {</ins>
				<ins>landBudget = SinkTerrain(chunkSize, landBudget);</ins>
			<ins>}</ins>
			<ins>else {</ins>
				landBudget = RaiseTerrain(<ins>chunkSize</ins>, landBudget);
			<ins>}</ins>
		}
	}</pre>
						
						<aside>
							<h3>Shouldn't that be <code>chubkSize + 1</code> instead?</h3>
							<div>
								<p>Yes, that's a bug. It doesn't make a big difference, so I decided to keep it like that so all the screenshots of generated maps are still the same.</p>
							</div>
						</aside>
						
						<figure>
							<img alt="10" src="vertical-movement/sink-10.jpg" width="350" height="210">
							<img alt=20 src="vertical-movement/sink-20.jpg" width="350" height="210">
							<img alt="30" src="vertical-movement/sink-30.jpg" width="350" height="210">
							<img alt="40" src="vertical-movement/sink-40.jpg" width="350" height="210">
							<figcaption>Sink probability 0.1, 0.2, 0.3, and 0.4.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Limiting Elevation</h3>
						
						<p>At this point we're potentially stacking many chunks, sometimes multiple high-rises, part of which can sink and later rise again. This can produce very high and sometimes also very low elevations, especially when a high land percentage is desired.</p>
						
						<figure>
							<img src="vertical-movement/extreme-elevation.jpg" width="470" height="190">
							<figcaption>Extreme elevation with 90% land.</figcaption>
						</figure>
						
						<p>To keep elevation in check, let's add a configurable minimum and maximum. A reasonable minimum could be somewhere between &minus;4 and 0, while an acceptable maximum can fall in the 6&ndash;10 range. Set the default values to &minus;2 and 8. These lie outside the allowed range when manually editing a map, so you might want to adjust the slider of the editor UI, or not.</p>
						
						<pre translate="no">	<ins>[Range(-4, 0)]</ins>
	<ins>public int elevationMinimum = -2;</ins>

	<ins>[Range(6, 10)]</ins>
	<ins>public int elevationMaximum = 8;</ins></pre>
						
						<figure>
							<img src="vertical-movement/elevation-limits.png" width="320" height="218">
							<figcaption>Elevation minimum and maximum.</figcaption>
						</figure>
						
						<p>In <code>RaiseTerrain</code>, we should now ensure that we do not go above the maximum allowed elevation. We'll do this by checking whether the new elevation of the current cells would end up too high. If so, we skip it, not adjusting its elevation and also not adding its neighbors. This will cause chunks to avoid areas that are already at their highest, growing around them.</p>
						
						<pre translate="no">			HexCell current = searchFrontier.Dequeue();
			int originalElevation = current.Elevation;
			<ins>int newElevation = originalElevation + rise;</ins>
			<ins>if (newElevation > elevationMaximum) {</ins>
				<ins>continue;</ins>
			<ins>}</ins>
			current.Elevation = <ins>newElevation</ins>;
			if (
				originalElevation &lt; waterLevel &amp;&amp;
				<ins>newElevation</ins> >= waterLevel &amp;&amp; --budget == 0
			) {
				break;
			}
			size += 1;</pre>
						
						<p>Do the same in <code>SinkTerrain</code>, but for the minimum elevation.</p>
						
						<pre translate="no">			HexCell current = searchFrontier.Dequeue();
			int originalElevation = current.Elevation;
			<ins>int newElevation = current.Elevation - sink;</ins>
			<ins>if (newElevation &lt; elevationMinimum) {</ins>
				<ins>continue;</ins>
			<ins>}</ins>
			current.Elevation = <ins>newElevation</ins>;
			if (
				originalElevation >= waterLevel &amp;&amp;
				<ins>newElevation</ins> &lt; waterLevel
			) {
				budget += 1;
			}
			size += 1;</pre>
						
						<figure>
							<img src="vertical-movement/limited-elevation.jpg" width="470" height="190">
							<figcaption>Limited elevation with 90% land.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Storing Negative Elevation</h3>
						
						<p>Currently, our saving and loading code cannot deal with negative elevations. That's because we're storing elevation as a byte. A negative number will convert into a large positive one when saved. So saving and then loading a generated map can result in some very high cells appearing that were originally submerged.</p>
						
						<p>We could support negative elevation by storing it as an integer instead of a byte. However, we still don't need to support many elevation levels. We could also offset the value we store, adding 127. That makes it possible to correctly store elevations in the &minus;127&ndash;128 range with a single byte. Let's do that. Adjust <code>HexCell.Save</code> accordingly.</p>
						
						<pre translate="no">	public void Save (BinaryWriter writer) {
		writer.Write((byte)terrainTypeIndex);
		writer.Write((byte)<ins>(</ins>elevation <ins>+ 127)</ins>);
		&hellip;
	}</pre>
						
						<p>As we've changed how we store map data, increment <code>SaveLoadMenu.mapFileVersion</code> to 4.</p>
						
						<pre translate="no">	const int mapFileVersion = <ins>4</ins>;</pre>
						
						<p>Finally, adjust <code>HexCell.Load</code> so it subtracts 127 from the elevation loaded from version 4 files.</p>
						
						<pre translate="no">	public void Load (BinaryReader reader, int header) {
		terrainTypeIndex = reader.ReadByte();
		ShaderData.RefreshTerrain(this);
		elevation = reader.ReadByte();
		<ins>if (header >= 4) {</ins>
			<ins>elevation -= 127;</ins>
		<ins>}</ins>
		&hellip;
	}</pre>
					</section>
					
					<a href="vertical-movement/vertical-movement.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Recreating the Same Map</h2>
					
					<p>By now we can already create a wide variety of maps. Each time we generate a new one, the result will be random. We can only control the characteristics of the maps via the configuration options, not its exact shape. But sometimes we want to recreate the exact same map again. For example, to share a nice map with someone else. Or to start again after editing it manually. It's also useful during development. So let's make this possible.</p>

					<section>
						<h3>Using a Seed</h3>
						
						<p>We're using <code>Random.Range</code> and <code>Random.value</code> to make the map generation process unpredictable. To get the same pseudorandom sequence again, we have to use the same seed value. We've already used this approach before, in <code>HexMetrics.InitializeHashGrid</code>. It first stores the current state of the number generator, initialized it with a specific seed, then later restores it back to its old state. We can use the same approach for <code>HexMapGenerator.GenerateMap</code>. Again, we remember the old state and restore it once we're done, so we do not influence anything else that uses <code>Random</code>.</p>

						<pre translate="no">	public void GenerateMap (int x, int z) {
		<ins>Random.State originalRandomState = Random.state;</ins>
		&hellip;
		<ins>Random.state = originalRandomState;</ins>
	}</pre>
						
						<p>Next, we're going to expose the seed that we used to generate  the last map. This is done via a public integer field.</p>
						
						<pre translate="no">	<ins>public int seed;</ins></pre>
						
						<figure>
							<img src="recreating-the-same-map/seed.png" width="320" height="90">
							<figcaption>Displaying the seed.</figcaption>
						</figure>
						
						<p>Now we need a seed value to initialize <code>Random</code>. To create random maps we have to use a random seed. The most straightforward approach might appear to use <code>Random.Range</code> to generate an arbitrary seed value. To not affect the original random state, we have to do this after storing it.</p>
						
						<pre translate="no">	public void GenerateMap (int x, int z) {
		Random.State originalRandomState = Random.state;
		<ins>seed = Random.Range(0, int.MaxValue);</ins>
		<ins>Random.InitState(seed);</ins>
		
		&hellip;
	}</pre>
						
						<p>As we restore the random state after we're done, if we immediately generate another map we'll end up with the same seed value. Also, we don't know how the original random state has been initialized. So while it can serve as an arbitrary starting point, we need something more to randomize it per invocation.</p>
						
						<p>There are various ways to initialize random number generators. In this case, can just combine a few arbitrary values that change a lot so it's very unlikely to generate the same map again. For example, let's use the lower 32 bits of the system time expressed in ticks, plus the current run time of our app. Combine these values with the bitwise exclusive-OR operation, so we don't end up with an obviously increasing number.</p>
						
						<pre translate="no">		seed = Random.Range(0, int.MaxValue);
		<ins>seed ^= (int)System.DateTime.Now.Ticks;</ins>
		<ins>seed ^= (int)Time.unscaledTime;</ins>
		Random.InitState(seed);</pre>
						
						<p>The resulting number can be negative, which doesn't look nice for a publicly-exposed seed. We can force it to be positive by bitwise masking it with the maximum integer value, which sets the sign bit to zero.</p>
						
						<pre translate="no">		seed ^= (int)Time.unscaledTime;
		<ins>seed &amp;= int.MaxValue;</ins>
		Random.InitState(seed);</pre>
					</section>
					
					<section>
						<h3>Reusing the Seed</h3>
						
						<p>We're still generating random maps, but we can now see which seed value is used for each. To recreate the same map again, we have to instruct the generator to reuse its seed value, instead of making a new one. We'll do this by adding a toggle via a boolean field.</p>
						
						<pre translate="no">	<ins>public bool useFixedSeed;</ins></pre>
						
						<figure>
							<img src="recreating-the-same-map/fixed-seed.png" width="320" height="91">
							<figcaption>Option to use a fixed seed.</figcaption>
						</figure>
						
						<p>When a fixed seed should be used, we simply skip generating a new seed in <code>GenerateMap</code>. If we don't edit the seed field manually, this results in the exact same map being generated again.</p>
						
						<pre translate="no">		Random.State originalRandomState = Random.state;
		<ins>if (!useFixedSeed) {</ins>
			seed = Random.Range(0, int.MaxValue);
			seed ^= (int)System.DateTime.Now.Ticks;
			seed ^= (int)Time.time;
			seed &amp;= int.MaxValue;
		<ins>}</ins>
		Random.InitState(seed);</pre>
						
						<p>Now it's possible to copy the seed value of a map that you like and store it somewhere, to later generate it again. Keep in mind that you only get the same map if you use the exact same generator settings. So the same map size, but also all the other configuration options. Even a small change to one of the probabilities can produce a completely different map. So besides the seed, you also have to remember all settings.</p>
						
						<figure>
							<img alt="0" src="recreating-the-same-map/map-0.jpg" width="350" height="210">
							<img alt="929396788" src="recreating-the-same-map/map-929396788.jpg" width="350" height="210">
							<figcaption>Large maps with seeds 0 and 929396788, default settings.</figcaption>
						</figure>
						
						<p>The next tutorial is <a href="../part-24/index.html">Regions and Erosion</a>.</p>
					</section>
					
					<a href="recreating-the-same-map/recreating-the-same-map.unitypackage" download rel="nofollow">unitypackage</a>
					<a href="Hex-Map-23.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>