<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/hex-map/part-18/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/hex-map/part-18/tutorial-image.jpg">
		<meta property="og:title" content="Hex Map 18">
		<meta property="og:description" content="A Unity Hex Map tutorial about adding support for units. Part 18 of 27.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Hex Map 18</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/hex-map/part-18/#article",
				"headline": "Hex Map 18",
				"alternativeHeadline": "Units",
				"datePublished": "2017-06-23",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Hex Map tutorial about adding support for units. Part 18 of 27.",
				"image": "https://catlikecoding.com/unity/tutorials/hex-map/part-18/tutorial-image.jpg",
				"dependencies": "Unity 5.6.0",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/hex-map/", "name": "Hex Map" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				EdgeVertices: 1,
				HexCell: 1,
				HexCellPriorityQueue: 1,
				HexEdgeType: 1,
				HexCoordinates: 1,
				HexCoordinatesDrawer: 1,
				HexDirection: 1,
				HexDirectionExtensions: 1,
				HexFeatureCollection: 1,
				HexFeatureManager: 1,
				HexGameUI: 1,
				HexGrid: 1,
				HexGridChunk: 1,
				HexHash: 1,
				HexMapCamera: 1,
				HexMapEditor: 1,
				HexMesh: 1,
				HexMetrics: 1,
				HexUnit: 1,
				ListPool: 1,
				NewMapMenu: 1,
				OptionalToggle: 1,
				SaveLoadItem: 1,
				SaveLoadMenu: 1,
				TextureArrayWizard: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Hex Map</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Hex Map 18</h1>
					<p>Units</p>
					<ul>
						<li>Place units on the map.</li>
						<li>Save and load units.</li>
						<li>Find paths for units.</li>
						<li>Move units around.</li>
					</ul>
				</header>

				<p>This is part 18 of a tutorial series about <a href="../index.html">hexagon maps</a>. Now that we've figured out how to do pathfinding, let's put some units on the map.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Units have arrived.</figcaption>
				</figure>
				
				<section>
					<h2>Creating Units</h2>
					
					<p>So far, we've only dealt with cells and their immobile features. Units are different, because they are mobile. A unit can represent anything at any scale, from one person or vehicle to an entire army. In this tutorial, we'll limit ourselves to a single generic unit type. Once we have that covered we'll move on to supporting a mix of unit types.</p>
					
					<section>
						<h3>Unit Prefab</h3>
						
						<p>To work with units, create a new <code>HexUnit</code> component type. Start with an empty <code>MonoBehaviour</code> for now, we'll add functionality to it later.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public class HexUnit : MonoBehaviour {</ins>
<ins>}</ins></pre>
						
						<p>Create an empty game object with this component, which should become a prefab. This is the root object for a unit.</p>
						
						<figure>
							<img src="creating-units/prefab.png" width="320" height="160">
							<figcaption>Unit prefab.</figcaption>
						</figure>
						
						<p>Add a 3D model to represent the unit as a child object. I simply used a scaled cube, which I gave a blue material. The root object defines the ground level for the unit, so offset the child accordingly.</p>
						
						<figure>
							<img alt="hierarchy" src="creating-units/hierarchy.png" width="100" height="34"><br>
							<img alt="cube" src="creating-units/cube.png" width="320" height="228">
							<figcaption>Cube child.</figcaption>
						</figure>
						
						<p>Giving the unit a collider will make it easier to select them later. The collider of the default cube works fine. Just make sure that the collider fits inside a single cell.</p>
					</section>
					
					<section>
						<h3>Instantiating Units</h3>
						
						<p>As we have no gameplay yet, spawning units is done in edit mode. So it's the responsibility of <code>HexMapEditor</code> to create them. It needs the prefab to do this, so add a <code>HexUnit unitPrefab</code> field for it and hook it up.</p>
						
						<pre translate="no">	<ins>public HexUnit unitPrefab;</ins></pre>
						
						<figure>
							<img src="creating-units/editor.png" width="320" height="92">
							<figcaption>Connecting the prefab.</figcaption>
						</figure>
						
						<p>When creating units, we're going to place them on the cell that's underneath the cursor. <code>HandleInput</code> has code to find this cell when editing the terrain. We now need it for units as well, so let's move the relevant code to its own method.</p>
						
						<pre translate="no">	<ins>HexCell GetCellUnderCursor () {</ins>
		<ins>Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition);</ins>
		<ins>RaycastHit hit;</ins>
		<ins>if (Physics.Raycast(inputRay, out hit)) {</ins>
			<ins>return hexGrid.GetCell(hit.point);</ins>
		<ins>}</ins>
		<ins>return null;</ins>
	<ins>}</ins></pre>
						
						<p>Now we can use this method in <code>HandleInput</code>, simplifying it.</p>
						
						<pre translate="no">	void HandleInput () {
<del>//		Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition);</del>
<del>//		RaycastHit hit;</del>
<del>//		if (Physics.Raycast(inputRay, out hit)) {</del>
<del>//			HexCell currentCell = hexGrid.GetCell(hit.point);</del>

		<ins>HexCell currentCell = GetCellUnderCursor();</ins>
		<ins>if (currentCell) {</ins>
			&hellip;
		}
		else {
			previousCell = null;
		}
	}</pre>
						
						<p>Next, add a new <code>CreateUnit</code> method that uses <code>GetCellUnderCursor</code> as well. If there's a cell, instantiate a new unit.</p>
						
						<pre translate="no">	<ins>void CreateUnit () {</ins>
		<ins>HexCell cell = GetCellUnderCursor();</ins>
		<ins>if (cell) {</ins>
			<ins>Instantiate(unitPrefab);</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>To keep the hierarchy clean, let's use the grid as the parent for all unit game objects.</p>
						
						<pre translate="no">	void CreateUnit () {
		HexCell cell = GetCellUnderCursor();
		if (cell) {
			<ins>HexUnit unit =</ins> Instantiate(unitPrefab);
			<ins>unit.transform.SetParent(hexGrid.transform, false);</ins>
		}
	}</pre>
						
						<p>The simplest way to add support for creating units to <code>HexMapEditor</code> is via a key press. Adjust the <code>Update</code> method so it invokes <code>CreateUnit</code> when the U key is pressed. Like <code>HandleInput</code>, this should only happen if the cursor is not on top of a GUI element. First check whether we should edit the map, and if not check whether we should add a unit. If so, invoke <code>CreateUnit</code>.</p>
						
						<pre translate="no">	void Update () {
<del>//		if (</del>
<del>//			Input.GetMouseButton(0) &amp;&amp;</del>
<del>//			!EventSystem.current.IsPointerOverGameObject()</del>
<del>//		) {</del>
<del>//			HandleInput();</del>
<del>//		}</del>
<del>//		else {</del>
<del>//			previousCell = null;</del>
<del>//		}</del>

		<ins>if (!EventSystem.current.IsPointerOverGameObject()) {</ins>
			<ins>if (Input.GetMouseButton(0)) {</ins>
				<ins>HandleInput();</ins>
				<ins>return;</ins>
			<ins>}</ins>
			<ins>if (Input.GetKeyDown(KeyCode.U)) {</ins>
				<ins>CreateUnit();</ins>
				<ins>return;</ins>
			<ins>}</ins>
		<ins>}</ins>
		<ins>previousCell = null;</ins>
	}</pre>
						
						<figure>
							<img src="creating-units/instance.png" width="230" height="220">
							<figcaption>Instantiated unit.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Positioning Units</h3>
						
						<p>It is now possible to create units, but they all end up at the origin of the map. The next step it to put them in the right place. This requires that units are aware of their location. So add a <code>Location</code> property to <code>HexUnit</code> to identify the cell that they are occupying. When setting it, adjust the unit's position so it matches the cell's.</p>
						
						<pre translate="no">	<ins>public HexCell Location {</ins>
		<ins>get {</ins>
			<ins>return location;</ins>
		<ins>}</ins>
		<ins>set {</ins>
			<ins>location = value;</ins>
			<ins>transform.localPosition = value.Position;</ins>
		<ins>}</ins>
	<ins>}</ins>

	<ins>HexCell location;</ins></pre>
						
						<p>Now <code>HexMapEditor.CreateUnit</code> has to assign the cell under the cursor to the unit's location. Then the units will end up where they're expected.</p>
						
						<pre translate="no">	void CreateUnit () {
		HexCell cell = GetCellUnderCursor();
		if (cell) {
			HexUnit unit = Instantiate(unitPrefab);
			unit.transform.SetParent(hexGrid.transform, false);
			<ins>unit.Location = cell;</ins>
		}
	}</pre>
						
						<figure>
							<img src="creating-units/positioned.png" width="360" height="240">
							<figcaption>Positioned units.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Unit Orientation</h3>
						
						<p>Currently, all unit have the same orientation, which looks quite rigid. To liven things up, add an <code>Orientation</code> property to <code>HexUnit</code>. This is a float which represents the unit's rotation around the Y axis, in degrees. When setting it, adjust the unit's actual game object rotation accordingly.</p>
						
						<pre translate="no">	<ins>public float Orientation {</ins>
		<ins>get {</ins>
			<ins>return orientation;</ins>
		<ins>}</ins>
		<ins>set {</ins>
			<ins>orientation = value;</ins>
			<ins>transform.localRotation = Quaternion.Euler(0f, value, 0f);</ins>
		<ins>}</ins>
	<ins>}</ins>

	<ins>float orientation;</ins></pre>
						
						<p>In <code>HexMapEditor.CreateUnit</code>, assign a random rotation, between 0 and 360 degrees.</p>
						
						<pre translate="no">	void CreateUnit () {
		HexCell cell = GetCellUnderCursor();
		if (cell) {
			HexUnit unit = Instantiate(unitPrefab);
			unit.transform.SetParent(hexGrid.transform, false);
			unit.Location = cell;
			<ins>unit.Orientation = Random.Range(0f, 360f);</ins>
		}
	}</pre>
						
						<figure>
							<img src="creating-units/orientation.png" width="360" height="240">
							<figcaption>Varied unit orientations.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>One Unit Per Cell</h3>
						
						<p>The units look good, except when multiple are created in the same location. Then we get overlapping cubes, which looks bad.</p>
						
						<figure>
							<img src="creating-units/overlapping.png" width="250" height="220">
							<figcaption>Overlapping units.</figcaption>
						</figure>
						
						<p>Some games allow multiple units in the same location, while other do not allow this. As a single unit per cell is easier to work with, we'll go for this option. That means that we should only create a new unit if the current cell is not occupied. To make it possible to know this, add a default <code>Unit</code> property to <code>HexCell</code>.</p>
						
						<pre translate="no">	<ins>public HexUnit Unit { get; set; }</ins></pre>
						
						<p>Use this property in <code>HexUnit.Location</code> to make the cell aware that there is a unit standing on it.</p>
						
						<pre translate="no">	public HexCell Location {
		get {
			return location;
		}
		set {
			location = value;
			<ins>value.Unit = this;</ins>
			transform.localPosition = value.Position;
		}
	}</pre>
						
						<p>Now <code>HexMapEditor.CreateUnit</code> can check whether the current cell is available.</p>
						
						<pre translate="no">	void CreateUnit () {
		HexCell cell = GetCellUnderCursor();
		if (cell <ins>&amp;&amp; !cell.Unit</ins>) {
			HexUnit unit = Instantiate(unitPrefab);
			unit.Location = cell;
			unit.Orientation = Random.Range(0f, 360f);
		}
	}</pre>
					</section>
					
					<section>
						<h3>Editing Occupied Cells</h3>
						
						<p>While units are correctly positioned initially, it can go wrong when their locations are edited later. If a cell's elevation is changed, the unit occupying it will end up either hovering above it, or sinking into it.</p>
						
						<figure>
							<img src="creating-units/misplaced.png" width="300" height="200">
							<figcaption>Floating and sunken units.</figcaption>
						</figure>
						
						<p>The solution is to validate the unit's location after a change has been made. Add a method for this to <code>HexUnit</code>. Currently, we only care about the unit's position, so just set it again.</p>
						
						<pre translate="no">	<ins>public void ValidateLocation () {</ins>
		<ins>transform.localPosition = location.Position;</ins>
	<ins>}</ins></pre>
						
						<p>We should validate the unit's location whenever we refresh a cell, which is when either the <code>Refresh</code> or <code>RefreshSelfOnly</code> methods of <code>HexCell</code> are invoked. Of course this is only required when there's actually a unit in the cell.</p>
						
						<pre translate="no">	void Refresh () {
		if (chunk) {
			chunk.Refresh();
			&hellip;
			<ins>if (Unit) {</ins>
				<ins>Unit.ValidateLocation();</ins>
			<ins>}</ins>
		}
	}

	void RefreshSelfOnly () {
		chunk.Refresh();
		<ins>if (Unit) {</ins>
			<ins>Unit.ValidateLocation();</ins>
		<ins>}</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Removing Units</h3>
						
						<p>Besides creating units, it is also useful to be able to destroy them. So add a <code>DestroyUnit</code> method to <code>HexMapEditor</code>. It has to check whether there's a unit in the cell under the cursor, and if so destroy that unit's game object.</p>
						
						<pre translate="no">	<ins>void DestroyUnit () {</ins>
		<ins>HexCell cell = GetCellUnderCursor();</ins>
		<ins>if (cell &amp;&amp; cell.Unit) {</ins>
			<ins>Destroy(cell.Unit.gameObject);</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Note that we're going through the cell to reach the unit. Hovering over the cell that contains a unit is enough to interact with it. So units don't need to have a collider for this to work. However, giving them a collider makes it easier to point at them, because it blocks the rays that would otherwise end up hitting a cell behind the unit.</p>
						
						<p>Let's use left shift plus the U key to trigger the destruction of a unit in <code>Update</code>, instead of creating one.</p>
						
						<pre translate="no">			if (Input.GetKeyDown(KeyCode.U)) {
				<ins>if (Input.GetKey(KeyCode.LeftShift)) {</ins>
					<ins>DestroyUnit();</ins>
				<ins>}</ins>
				<ins>else {</ins>
					CreateUnit();
				<ins>}</ins>
				return;
			}</pre>
						
						<p>In case we're going to create and destroy many units, let's be tidy and clean up property when getting rid of a unit. This means explicitly clearing the cell's unit reference. Add a <code>Die</code> method to <code>HexUnit</code> to take care of this, plus the destruction of its own game object.</p>
						
						<pre translate="no">	<ins>public void Die () {</ins>
		<ins>location.Unit = null;</ins>
		<ins>Destroy(gameObject);</ins>
	<ins>}</ins></pre>
						
						<p>Invoke this method in <code>HexMapEditor.DestroyUnit</code> instead of destroying the unit directly.</p>
						
						<pre translate="no">	void DestroyUnit () {
		HexCell cell = GetCellUnderCursor();
		if (cell &amp;&amp; cell.Unit) {
<del>//			Destroy(cell.Unit.gameObject);</del>
			<ins>cell.Unit.Die();</ins>
		}
	}</pre>
					</section>
					
					<a href="creating-units/creating-units.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Saving and Loading Units</h2>
					
					<p>Now that we can have units on the map, we must include them in the saving and loading process. There are two ways we could approach this. The first is to write a unit's data when its cell is written, so cell and unit data will be mixed. The other way is to keep cell and unit data separate. While the first approach might appear more straightforward to implement, the second one gives us more structured data. Keeping the data separate will make it easier to work with in the future.</p>
					
					<section>
						<h3>Keeping Track of Units</h3>
						
						<p>To save all units together, we have to keep track of them. We'll do this by adding a unit list to <code>HexGrid</code>. This list should contain all the units on the map.</p>
						
						<pre translate="no">	<ins>List&lt;HexUnit> units = new List&lt;HexUnit>();</ins></pre>
						
						<p>Whenever a new map is created or loaded, we have to get rid of all units currently on the map. To facilitate this, create a <code>ClearUnits</code> method that kills everything in the list and empties it.</p>
						
						<pre translate="no">	<ins>void ClearUnits () {</ins>
		<ins>for (int i = 0; i &lt; units.Count; i++) {</ins>
			<ins>units[i].Die();</ins>
		<ins>}</ins>
		<ins>units.Clear();</ins>
	}</pre>
						
						<p>Invoke this method in <code>CreateMap</code> and <code>Load</code>. Let's do so after the path is cleared.</p>
						
						<pre translate="no">	public bool CreateMap (int x, int z) {
		&hellip;

		ClearPath();
		<ins>ClearUnits();</ins>
		&hellip;
	}
	
	&hellip;
	
	public void Load (BinaryReader reader, int header) {
		ClearPath();
		<ins>ClearUnits();</ins>
		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Adding Units to the Grid</h3>
						
						<p>We now have to add new units to the list when we create them. Let's define an <code>AddUnit</code> method for that, which also takes care of positioning the unit and settings its parent.</p>
						
						<pre translate="no">	<ins>public void AddUnit (HexUnit unit, HexCell location, float orientation) {</ins>
		<ins>units.Add(unit);</ins>
		<ins>unit.transform.SetParent(transform, false);</ins>
		<ins>unit.Location = location;</ins>
		<ins>unit.Orientation = orientation;</ins>
	<ins>}</ins></pre>
						
						<p><code>HexMapEditor.CreatUnit</code> can now suffice with invoking <code>AddUnit</code> with a newly instantiated unit, its location, and a random orientation.</p>
						
						<pre translate="no">	void CreateUnit () {
		HexCell cell = GetCellUnderCursor();
		if (cell &amp;&amp; !cell.Unit) {
<del>//			HexUnit unit = Instantiate(unitPrefab);</del>
<del>//			unit.transform.SetParent(hexGrid.transform, false);</del>
<del>//			unit.Location = cell;</del>
<del>//			unit.Orientation = Random.Range(0f, 360f);</del>
			<ins>hexGrid.AddUnit(</ins>
				<ins>Instantiate(unitPrefab), cell, Random.Range(0f, 360f)</ins>
			<ins>);</ins>
		}
	}</pre>
					</section>
					
					<section>
						<h3>Removing Units from the Grid</h3>
						
						<p>Add a method for removing a unit to <code>HexGrid</code> as well. Simply remove the unit from the list and tell it to die.</p>
						
						<pre translate="no">	<ins>public void RemoveUnit (HexUnit unit) {</ins>
		<ins>units.Remove(unit);</ins>
		<ins>unit.Die();</ins>
	<ins>}</ins></pre>
						
						<p>Invoke this method in <code>HexMapEditor.DestroyUnit</code>, instead of directly killing the unit.</p>
						
						<pre translate="no">	void DestroyUnit () {
		HexCell cell = GetCellUnderCursor();
		if (cell &amp;&amp; cell.Unit) {
<del>//			cell.Unit.Die();</del>
			<ins>hexGrid.RemoveUnit(cell.Unit);</ins>
		}
	}</pre>
					</section>
					
					<section>
						<h3>Saving Units</h3>
						
						<p>As we are going to store all units together, we have to remember which cells they are occupying. The most robust way to do this is by storing the coordinates of their locations. To make this possible, add a <code>Save</code> method to <code>HexCoordinates</code>, which writes its X and Z fields.</p>
						
						<pre translate="no">using UnityEngine;
<ins>using System.IO;</ins>

[System.Serializable]
public struct HexCoordinates {

	&hellip;
	
	<ins>public void Save (BinaryWriter writer) {</ins>
		<ins>writer.Write(x);</ins>
		<ins>writer.Write(z);</ins>
	<ins>}</ins>
}</pre>
						
						<p>The <code>Save</code> method for <code>HexUnit</code> can now write the unit's coordinates, and its orientation. That is all unit data that we have at this point.</p>
						
						<pre translate="no">using UnityEngine;
<ins>using System.IO;</ins>

public class HexUnit : MonoBehaviour {

	&hellip;

	<ins>public void Save (BinaryWriter writer) {</ins>
		<ins>location.coordinates.Save(writer);</ins>
		<ins>writer.Write(orientation);</ins>
	<ins>}</ins>
}</pre>
						
						<p>As <code>HexGrid</code> keeps track of the units, its <code>Save</code> method will take care of writing the unit data. First write how many units there are, then loop through the units.</p>
						
						<pre translate="no">	public void Save (BinaryWriter writer) {
		writer.Write(cellCountX);
		writer.Write(cellCountZ);

		for (int i = 0; i &lt; cells.Length; i++) {
			cells[i].Save(writer);
		}

		<ins>writer.Write(units.Count);</ins>
		<ins>for (int i = 0; i &lt; units.Count; i++) {</ins>
			<ins>units[i].Save(writer);</ins>
		<ins>}</ins>
	}</pre>
						
						<p>We have changed what we save, so increase the version number in <code>SaveLoadMenu.Save</code> to 2. The old loading code could still work fine, because it will simply not read the unit data. However, the version increase is needed to communicate that there is unit data in the file.</p>
						
						<pre translate="no">	void Save (string path) {
		using (
			BinaryWriter writer =
			new BinaryWriter(File.Open(path, FileMode.Create))
		) {
			writer.Write(<ins>2</ins>);
			hexGrid.Save(writer);
		}
	}</pre>
					</section>
					
					<section>
						<h3>Loading Units</h3>
						
						<p>Because <code>HexCoordinates</code> is a struct, it doesn't make much sense to add a regular <code>Load</code> method to it. Instead, make it a static method that reads and returns the stored coordinates.</p>
						
						<pre translate="no">	<ins>public static HexCoordinates Load (BinaryReader reader) {</ins>
		<ins>HexCoordinates c;</ins>
		<ins>c.x = reader.ReadInt32();</ins>
		<ins>c.z = reader.ReadInt32();</ins>
		<ins>return c;</ins>
	<ins>}</ins></pre>
						
						<p>Because the amount of units is variable, we do not have pre-existing units to load data into. We could create new unit instances before we load their data, but that would require <code>HexGrid</code> to instantiate new units while loading. It's better to leave that up to <code>HexUnit</code>. So we'll use a static <code>HexUnit.Load</code> method as well. Let's begin by just reading the unit data. To read the float for the orientation, use the <code>BinaryReader.ReadSingle</code> method.</p>
						
						<aside>
							<h3>Why is it single?</h3>
							<div>
								<p>The <code>float</code> type represents single-precision floating-point numbers, which are four bytes long. There are also double-precision numbers, defined as <code>double</code>, which have a length of eight bytes. Those are rarely used in Unity.</p>
							</div>
						</aside>
						
						<pre translate="no">	<ins>public static void Load (BinaryReader reader) {</ins>
		<ins>HexCoordinates coordinates = HexCoordinates.Load(reader);</ins>
		<ins>float orientation = reader.ReadSingle();</ins>
	<ins>}</ins></pre>
						
						<p>The next step is to instantiate a new unit. However, we need a reference to the unit prefab for this. To keep it simple for now, let's add a static field for it to <code>HexUnit</code>.</p>
						
						<pre translate="no">	<ins>public static HexUnit unitPrefab;</ins></pre>
						
						<p>To set this reference, let's abuse <code>HexGrid</code> once more, like we're doing for the noise texture. We'll move on to a better approach when we'll support multiple unit types.</p>
						
						<pre translate="no">	<ins>public HexUnit unitPrefab;</ins>

	&hellip;

	void Awake () {
		HexMetrics.noiseSource = noiseSource;
		HexMetrics.InitializeHashGrid(seed);
		<ins>HexUnit.unitPrefab = unitPrefab;</ins>
		CreateMap(cellCountX, cellCountZ);
	}

	&hellip;

	void OnEnable () {
		if (!HexMetrics.noiseSource) {
			HexMetrics.noiseSource = noiseSource;
			HexMetrics.InitializeHashGrid(seed);
			<ins>HexUnit.unitPrefab = unitPrefab;</ins>
		}
	}</pre>
						
						<figure>
							<img src="saving-and-loading-units/inspector.png" width="320" height="182">
							<figcaption>Passing through the unit prefab.</figcaption>
						</figure>
						
						<p>After hooking up the field, we no longer need a direct reference in <code>HexMapEditor</code>. It can use <code>HexUnit.unitPrefab</code> instead.</p>
						
						<pre translate="no"><del>//	public HexUnit unitPrefab;</del>

	&hellip;

	void CreateUnit () {
		HexCell cell = GetCellUnderCursor();
		if (cell &amp;&amp; !cell.Unit) {
			hexGrid.AddUnit(
				Instantiate(<ins>HexUnit.unitPrefab</ins>), cell, Random.Range(0f, 360f)
			);
		}
	}</pre>
						
						<p>Now we can instantiate a new unit in <code>HexUnit.Load</code>. Instead or returning it, we can use the loaded coordinates and orientation to add it to the grid. Add a <code>HexGrid</code> parameter to make this possible.</p>
						
						<pre translate="no">	public static void Load (BinaryReader reader<ins>, HexGrid grid</ins>) {
		HexCoordinates coordinates = HexCoordinates.Load(reader);
		float orientation = reader.ReadSingle();
		<ins>grid.AddUnit(</ins>
			<ins>Instantiate(unitPrefab), grid.GetCell(coordinates), orientation</ins>
		<ins>);</ins>
	}
</pre>
						
						<p>At the end of <code>HexGrid.Load</code>, read the unit count and use it to load all the stored units, passing itself as an additional argument.</p>
						
						<pre translate="no">	public void Load (BinaryReader reader, int header) {
		&hellip;

		<ins>int unitCount = reader.ReadInt32();</ins>
		<ins>for (int i = 0; i &lt; unitCount; i++) {</ins>
			<ins>HexUnit.Load(reader, this);</ins>
		<ins>}</ins>
	}</pre>
						
						<p>Of course this only works for save files that are at least version 2, otherwise there are no units to load.</p>
						
						<pre translate="no">		<ins>if (header >= 2) {</ins>
			int unitCount = reader.ReadInt32();
			for (int i = 0; i &lt; unitCount; i++) {
				HexUnit.Load(reader, this);
			}
		<ins>}</ins></pre>
						
						<p>We can now correctly load version 2 files, so increase the supported version number to 2 in <code>SaveLoadMenu.Load</code>.</p>
						
						<pre translate="no">	void Load (string path) {
		if (!File.Exists(path)) {
			Debug.LogError("File does not exist " + path);
			return;
		}
		using (BinaryReader reader = new BinaryReader(File.OpenRead(path))) {
			int header = reader.ReadInt32();
			if (header &lt;= <ins>2</ins>) {
				hexGrid.Load(reader, header);
				HexMapCamera.ValidatePosition();
			}
			else {
				Debug.LogWarning("Unknown map format " + header);
			}
		}
	}</pre>
					</section>
					
					<a href="saving-and-loading-units/saving-and-loading-units.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Moving Units</h2>
					
					<p>Units are mobile, so we should be able to move them around the map. We already have code for pathfinding, but so far we've only tested it for arbitrary locations. We have to remove the old testing UI and make a new UI for controlling units.</p>
					
					<section>
						<h3>Cleaning Up the Map Editor</h3>
						
						<p>Moving units along paths is part of actual gameplay. It doesn't belong in the map editor. So get rid of all the code related to pathfinding in <code>HexMapEditor</code>.</p>
						
						<pre translate="no"><del>//	HexCell previousCell, searchFromCell, searchToCell;</del>
	<ins>HexCell previousCell;</ins>
	
	&hellip;
	
		void HandleInput () {
		HexCell currentCell = GetCellUnderCursor();
		if (currentCell) {
			if (previousCell &amp;&amp; previousCell != currentCell) {
				ValidateDrag(currentCell);
			}
			else {
				isDrag = false;
			}
			if (editMode) {
				EditCells(currentCell);
			}
<del>//			else if (</del>
<del>//				Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell</del>
<del>//			) {</del>
<del>//				if (searchFromCell != currentCell) {</del>
<del>//					if (searchFromCell) {</del>
<del>//						searchFromCell.DisableHighlight();</del>
<del>//					}</del>
<del>//					searchFromCell = currentCell;</del>
<del>//					searchFromCell.EnableHighlight(Color.blue);</del>
<del>//					if (searchToCell) {</del>
<del>//						hexGrid.FindPath(searchFromCell, searchToCell, 24);</del>
<del>//					}</del>
<del>//				}</del>
<del>//			}</del>
<del>//			else if (searchFromCell &amp;&amp; searchFromCell != currentCell) {</del>
<del>//				if (searchToCell != currentCell) {</del>
<del>//					searchToCell = currentCell;</del>
<del>//					hexGrid.FindPath(searchFromCell, searchToCell, 24);</del>
<del>//				}</del>
<del>//			}</del>
			previousCell = currentCell;
		}
		else {
			previousCell = null;
		}
	}</pre>
						
						<p>With this code eliminated, we have no reason to keep the editor active when we're not in edit mode. So instead of using a field to keep track of the mode, we can simply enable or disable the <code>HexMapEditor</code> component. The editor also doesn't need to care about the UI labels anymore.</p>
						
						<pre translate="no"><del>//	bool editMode;</del>
	
	&hellip;
	
	public void SetEditMode (bool toggle) {
<del>//		editMode = toggle;</del>
<del>//		hexGrid.ShowUI(!toggle);</del>
		<ins>enabled = toggle;</ins>
	}
	
	&hellip;
	
	void HandleInput () {
		HexCell currentCell = GetCellUnderCursor();
		if (currentCell) {
			if (previousCell &amp;&amp; previousCell != currentCell) {
				ValidateDrag(currentCell);
			}
			else {
				isDrag = false;
			}
<del>//			if (editMode) {</del>
			EditCells(currentCell);
<del>//			}</del>
			previousCell = currentCell;
		}
		else {
			previousCell = null;
		}
	}</pre>
						
						<p>Because we're not in map editing mode by default, disable the editor when it awakens.</p>
						
						<pre translate="no">	void Awake () {
		terrainMaterial.DisableKeyword("GRID_ON");
		<ins>SetEditMode(false);</ins>
	}</pre>
						
						<p>Using a raycast to find the current cell under the cursor is something that we need to do both for map editing and controlling units. And maybe later for other things too. Let's move the raycasting logic in <code>HexGrid</code>, in a new <code>GetCell</code> method with a ray parameter.</p>
						
						<pre translate="no">	<ins>public HexCell GetCell (Ray ray) {</ins>
		<ins>RaycastHit hit;</ins>
		<ins>if (Physics.Raycast(ray, out hit)) {</ins>
			<ins>return GetCell(hit.point);</ins>
		<ins>}</ins>
		<ins>return null;</ins>
	<ins>}</ins></pre>
						
						<p><code>HexMapEditor.GetCellUniderCursor</code> can simply invoke this method with the cursor ray.</p>
						
						<pre translate="no">	HexCell GetCellUnderCursor () {
		<ins>return</ins>
			<ins>hexGrid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition));</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Game UI</h3>
						
						<p>We'll use a new component to take care of the game-mode UI. At this time that only involves selecting and moving units. Create a new <code>HexGameUI</code> component type for it. It only needs a reference to the grid to do its job.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>
<ins>using UnityEngine.EventSystems;</ins>

<ins>public class HexGameUI : MonoBehaviour {</ins>

	<ins>public HexGrid grid;</ins>
<ins>}</ins></pre>
						
						<p>Add this component to a new game object in the UI hierarchy. It doesn't need to have its own object, but that makes it obvious that we have a separate UI for the game.</p>
						
						<figure>
							<img alt="inspector" src="moving-units/inspector.png" width="320" height="122">
							<img alt="hierarchy" src="moving-units/hierarchy.png" width="130" height="100">
							<figcaption>Game UI object.</figcaption>
						</figure>
						
						<p>Give <code>HexGameUI</code> a <code>SetEditMode</code> method, just like <code>HexMapEditor</code>. The game UI should be enabled when we're not in edit mode. Also, this is the place to toggle the labels, because the game UI will work with paths.</p>
						
						<pre translate="no">	<ins>public void SetEditMode (bool toggle) {</ins>
		<ins>enabled = !toggle;</ins>
		<ins>grid.ShowUI(!toggle);</ins>
	<ins>}</ins></pre>
						
						<p>Add the game UI's method to the event list of the edit mode toggle. This means that both methods will be invoked when the player changes the mode.</p>
						
						<figure>
							<img src="moving-units/event-methods.png" width="320" height="130">
							<figcaption>Multiple event methods.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Keeping Track of the Current Cell</h3>
						
						<p>Depending on what's happening, <code>HexGameUI</code> needs to know which cell is currently underneath the cursor. So give it a <code>currentCell</code> field.</p>
						
						<pre translate="no">	<ins>HexCell currentCell;</ins></pre>
						
						<p>Create an <code>UpdateCurrentCell</code> method, which uses <code>HexGrid.GetCell</code> with the cursor ray, to update the field.</p>
						
						<pre translate="no">	<ins>void UpdateCurrentCell () {</ins>
		<ins>currentCell =</ins>
			<ins>grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition));</ins>
	<ins>}</ins></pre>
						
						<p>When updating the current cell, we might like to know whether it has changed. Have <code>UpdateCurrentCell</code> return whether that's the case.</p>
						
						<pre translate="no">	<ins>bool</ins> UpdateCurrentCell () {
		<ins>HexCell cell</ins> =
			grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition));
		<ins>if (cell != currentCell) {</ins>
			<ins>currentCell = cell;</ins>
			<ins>return true;</ins>
		<ins>}</ins>
		<ins>return false;</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Selecting a Unit</h3>
						
						<p>Before we can move a unit, we have to select one first, and keep track of it. So add a <code>selectedUnit</code> field.</p>
						
						<pre translate="no">	<ins>HexUnit selectedUnit;</ins></pre>
						
						<p>When we attempt a selection, we should begin by updating the current cell. If there is a current cell, the unit occupying that cell becomes the selected unit. If the cell doesn't have a unit, then we end up with no unit selected. Create a <code>DoSelection</code> method for this.</p>
						
						<pre translate="no">	<ins>void DoSelection () {</ins>
		<ins>UpdateCurrentCell();</ins>
		<ins>if (currentCell) {</ins>
			<ins>selectedUnit = currentCell.Unit;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>We'll support selecting units with a regular mouse click. So add an <code>Update</code> method that performs the selection when mouse button 0 is activated. Of course we only bother with this when the cursor is not on top of a GUI element.</p>
						
						<pre translate="no">	<ins>void Update () {</ins>
		<ins>if (!EventSystem.current.IsPointerOverGameObject()) {</ins>
			<ins>if (Input.GetMouseButtonDown(0)) {</ins>
				<ins>DoSelection();</ins>
			<ins>}</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>At this point we can select a single unit at a time with a mouse click. And clicking on an empty cell will deselect whatever unit we had selected. But we don't get any visual feedback about this yet.</p>
					</section>
					
					<section>
						<h3>Unit Pathfinding</h3>
						
						<p>When a unit is selected, we can use its location as the starting point for pathfinding. We won't require another button press to activate this. Instead, we'll automatically find and show the path between the unit's location and the current cell. Do this always in <code>Update</code>, except when a selection is performed, by invoking a <code>DoPathfinding</code> method if we have a unit.</p>
						
						<pre translate="no">	void Update () {
		if (!EventSystem.current.IsPointerOverGameObject()) {
			if (Input.GetMouseButtonDown(0)) {
				DoSelection();
			}
			<ins>else if (selectedUnit) {</ins>
				<ins>DoPathfinding();</ins>
			<ins>}</ins>
		}
	}</pre>
						
						<p><code>DoPathfinding</code> simply updates the current cell and invokes <code>HexGrid.FindPath</code> if there's a destination. We'll again use a fixed speed of 24.</p>
						
						<pre translate="no">	<ins>void DoPathfinding () {</ins>
		<ins>UpdateCurrentCell();</ins>
		<ins>grid.FindPath(selectedUnit.Location, currentCell, 24);</ins>
	<ins>}</ins></pre>
						
						<p>Note that we don't have to find a new path every update, only when the current cell has changed.</p>
						
						<pre translate="no">	void DoPathfinding () {
		<ins>if (</ins>UpdateCurrentCell()<ins>) {</ins>
			grid.FindPath(selectedUnit.Location, currentCell, 24);
		<ins>}</ins>
	}</pre>
						
						<figure>
							<img src="moving-units/pathfinding.png" width="400" height="130">
							<figcaption>Pathfinding for a unit.</figcaption>
						</figure>
						
						<p>We now see paths appear when moving the cursor around while a unit is selected, which also makes it obvious which unit is selected. However, the paths aren't always properly cleared. First, let's clear the old path if the cursor ends up outside the map.</p>
						
						<pre translate="no">	void DoPathfinding () {
		if (UpdateCurrentCell()) {
			<ins>if (currentCell) {</ins>
				grid.FindPath(selectedUnit.Location, currentCell, 24);
			<ins>}</ins>
			<ins>else {</ins>
				<ins>grid.ClearPath();</ins>
			<ins>}</ins>
		}
	}</pre>
						
						<p>Of course this requires <code>HexGrid.ClearPath</code> to be public, so make that adjustment.</p>
						
						<pre translate="no">	<ins>public</ins> void ClearPath () {
		&hellip;
	}</pre>
						
						<p>Second, clear the old path when a selection is made.</p>
						
						<pre translate="no">	void DoSelection () {
		<ins>grid.ClearPath();</ins>
		UpdateCurrentCell();
		if (currentCell) {
			selectedUnit = currentCell.Unit;
		}
	}</pre>
						
						<p>Finally, clear the path when the edit mode is changed.</p>
						
						<pre translate="no">	public void SetEditMode (bool toggle) {
		enabled = !toggle;
		grid.ShowUI(!toggle);
		<ins>grid.ClearPath();</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Only Search for Valid Destinations</h3>
						
						<p>We don't always find a path, because sometimes there's no way to reach the destination cell. That is fine. But sometimes the destination cell itself is invalid. For example, we've decided that paths cannot include underwater cells. But this might depend on the unit. So let's add a method to <code>HexUnit</code> which tells us whether a cell is a valid destination. Underwater cells aren't.</p>
						
						<pre translate="no">	<ins>public bool IsValidDestination (HexCell cell) {</ins>
		<ins>return !cell.IsUnderwater;</ins>
	<ins>}</ins></pre>
						
						<p>Also, we support only one unit per cell. So the destination cell is also invalid if it is occupied.</p>
						
						<pre translate="no">	public bool IsValidDestination (HexCell cell) {
		return !cell.IsUnderwater <ins>&amp;&amp; !cell.Unit</ins>;
	}</pre>
						
						<p>Use this method in <code>HexGameUI.DoPathfinding</code> to ignore invalid destinations.</p>
						
						<pre translate="no">	void DoPathfinding () {
		if (UpdateCurrentCell()) {
			if (currentCell <ins>&amp;&amp; selectedUnit.IsValidDestination(currentCell)</ins>) {
				grid.FindPath(selectedUnit.Location, currentCell, 24);
			}
			else {
				grid.ClearPath();
			}
		}
	}</pre>
					</section>
					
					<section>
						<h3>Moving to the Destination</h3>
						
						<p>If we have a valid path, then it should be possible to move the unit to the destination. <code>HexGrid</code> knows whether this this the case. Have it expose this information via a new read-only <code>HasPath</code> property.</p>
						
						<pre translate="no">	<ins>public bool HasPath {</ins>
		<ins>get {</ins>
			<ins>return currentPathExists;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>To move the unit, add a <code>DoMove</code> method to <code>HexGameUI</code>. This method will be invoked when a move command is issued and we have a unit selected. So it should check whether we have a path, and if so change the unit's location. For now, we'll directly teleport the unit to the destination. We'll make it actually traverse the path in a later tutorial.</p>
						
						<pre translate="no">	<ins>void DoMove () {</ins>
		<ins>if (grid.HasPath) {</ins>
			<ins>selectedUnit.Location = currentCell;</ins>
			<ins>grid.ClearPath();</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Let's use a right mouse click &ndash; mouse button 1 &ndash; to order a move. Check for this when we have a selection. The alternative is to perform pathfinding.</p>
						
						<pre translate="no">	void Update () {
		if (!EventSystem.current.IsPointerOverGameObject()) {
			if (Input.GetMouseButtonDown(0)) {
				DoSelection();
			}
			else if (selectedUnit) {
				<ins>if (Input.GetMouseButtonDown(1)) {</ins>
					<ins>DoMove();</ins>
				<ins>}</ins>
				<ins>else {</ins>
					DoPathfinding();
				<ins>}</ins>
			}
		}
	}</pre>
						
						<p>Now we can move units around! But they sometimes refuse to find a path to certain cells. Specifically, cells that used to have a unit in them. This happens because <code>HexUnit</code> doesn't update its old location when a new one is set. To fix this, clear the unit reference of its old location.</p>
						
						<pre translate="no">	public HexCell Location {
		get {
			return location;
		}
		set {
			<ins>if (location) {</ins>
				<ins>location.Unit = null;</ins>
			<ins>}</ins>
			location = value;
			value.Unit = this;
			transform.localPosition = value.Position;
		}
	}</pre>
					</section>
					
					<section>
						<h3>Avoiding Units</h3>
						
						<p>Pathfind now works correctly and units can be teleported across the map. Although they cannot move to cells that already have a unit in them, units that happen to stand on the path are ignored.</p>
						
						<figure>
							<img src="moving-units/ignoring-units.png" width="330" height="190">
							<figcaption>Ignoring units on the path.</figcaption>
						</figure>
						
						<p>It is typical for units of the same faction to be able to move through each other, but we don't have unit factions yet. So let's treat all units as unaffiliated, blocking each other's paths. We can do this by skipping occupied cells in <code>HexGrid.Search</code>.</p>
						
						<pre translate="no">				if (
					neighbor == null ||
					neighbor.SearchPhase > searchFrontierPhase
				) {
					continue;
				}
				if (neighbor.IsUnderwater <ins>|| neighbor.Unit</ins>) {
					continue;
				}</pre>
						
						<figure>
							<img src="moving-units/avoiding-units.png" width="330" height="190">
							<figcaption>Avoiding Units.</figcaption>
						</figure>
						
						<p>The next tutorial is <a href="../part-19/index.html">Animating Movement</a>.</p>
					</section>
					
					<a href="moving-units/moving-units.unitypackage" download rel="nofollow">unitypackage</a>
					<a href="Hex-Map-18.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../../../jquery2.js"></script>
		<script src="../../tutorials.js"></script>
	</body>
</html>