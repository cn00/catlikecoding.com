<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/hex-map/part-20/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/hex-map/part-20/tutorial-image.jpg">
		<meta property="og:title" content="Hex Map 20">
		<meta property="og:description" content="A Unity Hex Map tutorial about adding support for fog of war. Part 20 of 27.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Hex Map 20</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/hex-map/part-20/#article",
				"headline": "Hex Map 20",
				"alternativeHeadline": "Fog of War",
				"datePublished": "2017-08-24",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Hex Map tutorial about adding support for fog of war. Part 20 of 27.",
				"image": "https://catlikecoding.com/unity/tutorials/hex-map/part-20/tutorial-image.jpg",
				"dependencies": "Unity 2017.1.0",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/hex-map/", "name": "Hex Map" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				Bezier: 1,
				EdgeVertices: 1,
				HexCell: 1,
				HexCellPriorityQueue: 1,
				HexCellShaderData: 1,
				HexEdgeType: 1,
				HexCoordinates: 1,
				HexCoordinatesDrawer: 1,
				HexDirection: 1,
				HexDirectionExtensions: 1,
				HexFeatureCollection: 1,
				HexFeatureManager: 1,
				HexGameUI: 1,
				HexGrid: 1,
				HexGridChunk: 1,
				HexHash: 1,
				HexMapCamera: 1,
				HexMapEditor: 1,
				HexMesh: 1,
				HexMetrics: 1,
				HexUnit: 1,
				ListPool: 1,
				NewMapMenu: 1,
				OptionalToggle: 1,
				SaveLoadItem: 1,
				SaveLoadMenu: 1,
				TextureArrayWizard: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Hex Map</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Hex Map 20</h1>
					<p>Fog of War</p>
					<ul>
						<li>Store cell data in a texture.</li>
						<li>Change terrain types without triangulating.</li>
						<li>Keep track of visibility.</li>
						<li>Darken everything that is not visible.</li>
					</ul>
				</header>

				<p>This is part 20 of a tutorial series about <a href="../index.html">hexagon maps</a>. This installment is about adding a fog-of-war effect to our map.</p>
				
				<p>From now on, this tutorial series is made with Unity 2017.1.0.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Now you can see what you can and cannot see.</figcaption>
				</figure>
				
				<section>
					<h2>Cell Shader Data</h2>
					
					<p>Many strategy games use what's known as fog of war. This means that your vision is limited. You can only see things that are close to your units or zone of control. While you might know the layout of the land, you're not sure what's going on there while you can't see it. Typically, terrain that you cannot currently see is rendered darker than normal. To implement this, we need to keep track of a cell's visibility and make sure that it is rendered appropriately.</p>
					
					<p>The most straightforward way to change the appearance of hidden cells is by adding a visibility indicator to the mesh data. However, that would require us to trigger a new triangulation of the terrain whenever visibility changes. As visibility changes happen all the time during play, it is not a good idea to do it this way.</p>
					
					<p>An often-described technique is to render a semitransparent surface on top of the terrain, which partially masks the cells that you cannot see. This can work well for fairly flat terrains, in combination with a restricted view angle. Because our terrain can contain wildly varying elevations and features and we can look at it from any angle, it would require a highly-detailed form-fitting mesh. That would be more expensive than the straightforward approach.</p>
					
					<p>Another approach is to make the cell data available to the shader while rendering, separate from the terrain mesh. This allows us to triangulate once. The cell data can be made available via a texture. Adjusting a texture is much simpler an faster that triangulating the terrain. Doing a few more texture samples is also faster than rendering a separate semitransparent overlay.</p>
					
					<aside>
						<h3>What about using shader arrays?</h3>
						<div>
							<p>It is also possible to pass cell data to the shader via a vector array. However, shader arrays have a size limitation measured in thousands of bytes, while textures can have millions of pixels. To support large maps, go with a texture.</p>
						</div>
					</aside>
					
					<section>
						<h3>Managing the Cell Data</h3>
						
						<p>We need a way to manage the texture that contains the cell data. Let's create a new <code>HexCellShaderData</code> component to take care of that.</p>
						
						<pre translate="no"><ins>using UnityEngine;</ins>

<ins>public class HexCellShaderData : MonoBehaviour {</ins>
	
	<ins>Texture2D cellTexture;</ins>
<ins>}</ins></pre>
						
						<p>Whenever a new map is created or loaded, we have to create a new texture with the correct size. So give it an initialization method which creates the texture. We'll use an RGBA texture, without mipmaps, and in linear color space. We don't want to blend cell data, so use point filtering. Also, the data shouldn't wrap. Each pixel of the texture will hold the data of one cell.</p>
						
						<pre translate="no">	<ins>public void Initialize (int x, int z) {</ins>
		<ins>cellTexture = new Texture2D(</ins>
			<ins>x, z, TextureFormat.RGBA32, false, true</ins>
		<ins>);</ins>
		<ins>cellTexture.filterMode = FilterMode.Point;</ins>
		<ins>cellTexture.wrapMode = TextureWrapMode.Clamp;</ins>
	<ins>}</ins></pre>
						
						<aside>
							<h3>Does the texture size have to match the map size?</h3>
							<div>
								<p>No, it just has to have enough pixels to contain all the cells. Exactly matching the map size will likely result in a non-power-of-two (NPOT) texture, which isn't the most efficient texture format. While you could tweak it to work with power-of-two textures, this is a minor optimization which makes accessing cell data less obvious.</p>
							</div>
						</aside>
						
						<p>We don't actually have to create a new texture every time a new map is created. We can suffice with resizing our texture if it already exists. We don't even have to check whether we already have the correct size, as <code>Texture2D.Resize</code> is smart enough to do this for us.</p>
						
						<pre translate="no">	public void Initialize (int x, int z) {
		<ins>if (cellTexture) {</ins>
			<ins>cellTexture.Resize(x, z);</ins>
		<ins>}</ins>
		<ins>else {</ins>
			cellTexture = new Texture2D(
				x, z, TextureFormat.RGBA32, false, true
			);
			cellTexture.filterMode = FilterMode.Point;
			cellTexture.wrapMode = TextureWrapMode.Clamp;
		<ins>}</ins>
	}</pre>
						
						<p>Instead of applying cell data one pixel at a time, we'll use a color buffer and apply all cell data in one go. We'll use a <code>Color32</code> array for this. Create a new array instance at the end of <code>Initialize</code> when needed. If we already have an array of the correct size, reset its contents.</p>
						
						<pre translate="no">	Texture2D cellTexture;
	<ins>Color32[] cellTextureData;</ins>
	
	public void Initialize () {
		&hellip;
		
		<ins>if (cellTextureData == null || cellTextureData.Length != x * z) {</ins>
			<ins>cellTextureData = new Color32[x * z];</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>for (int i = 0; i &lt; cellTextureData.Length; i++) {</ins>
				<ins>cellTextureData[i] = new Color32(0, 0, 0, 0);</ins>
			<ins>}</ins>
		<ins>}</ins>
	}</pre>
						
						<aside>
							<h3>What's <code>Color32</code>?</h3>
							<div>
								<p>Default uncompressed RGBA textures contain pixels that are four bytes in size. Each of the four color channels get one byte, so they have 256 possible values. When using Unity's <code>Color</code> struct, its floating-point components in the range 0&ndash;1 are converted to bytes in the range 0&ndash;255. The GPU performs the reverse conversion when sampling.</p>
								
								<p>The <code>Color32</code> struct works directly with bytes. So they take less space and don't require a conversion, which makes them more efficient to use. As we're storing cell data instead of colors, it also makes more sense to work directly with the raw texture data instead of going through <code>Color</code>.</p>
							</div>
						</aside>
						
						<p>It is the responsibility of <code>HexGrid</code> to create and initialize the cell shader data. So give it a <code>cellShaderData</code> field and create the component inside <code>Awake</code>.</p>
						
						<pre translate="no">	<ins>HexCellShaderData cellShaderData;</ins>

	void Awake () {
		HexMetrics.noiseSource = noiseSource;
		HexMetrics.InitializeHashGrid(seed);
		HexUnit.unitPrefab = unitPrefab;
		<ins>cellShaderData = gameObject.AddComponent&lt;HexCellShaderData>();</ins>
		CreateMap(cellCountX, cellCountZ);
	}</pre>
						
						<p>Whenever a new map is created, <code>cellShaderData</code> has to be initialized as well.</p>
						
						<pre translate="no">	public bool CreateMap (int x, int z) {
		&hellip;

		cellCountX = x;
		cellCountZ = z;
		chunkCountX = cellCountX / HexMetrics.chunkSizeX;
		chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ;
		<ins>cellShaderData.Initialize(cellCountX, cellCountZ);</ins>
		CreateChunks();
		CreateCells();
		return true;
	}</pre>
					</section>
					
					<section>
						<h3>Adjusting Cell Data</h3>
						
						<p>Up to this point, whenever a cell's properties were changed one or more chunks had to be refreshed. But from now on cell data might also need to be refreshed. This means that cells must also have a reference to the cell shader data. Add a property for this to <code>HexCell</code>.</p>
						
						<pre translate="no">	<ins>public HexCellShaderData ShaderData { get; set; }</ins></pre>
						
						<p>In <code>HexGrid.CreateCell</code>, assign its shader data component to this property.</p>
						
						<pre translate="no">	void CreateCell (int x, int z, int i) {
		&hellip;

		HexCell cell = cells[i] = Instantiate&lt;HexCell>(cellPrefab);
		cell.transform.localPosition = position;
		cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z);
		<ins>cell.ShaderData = cellShaderData;</ins>
		
		&hellip;
	}</pre>
						
						<p>Now we can have cells update their shader data. At this point we do not keep track of visibility yet, but we can also use the shader data for something else. A cell's terrain type dictates which texture is used when rendering it. It doesn't influence the cell's geometry. So we could store the terrain type index in the cell data instead of in the mesh data. This would eliminate the need for triangulation when a cell's terrain type is changed.</p>
						
						<p>Add a <code>RefreshTerrain</code> method to <code>HexCellShaderData</code> to facilitate this for a specific cell. Let's leave it an empty method for now.</p>
						
						<pre translate="no">	<ins>public void RefreshTerrain (HexCell cell) {</ins>
	<ins>}</ins></pre>
						
						<p>Change <code>HexCell.TerrainTypeIndex</code> so it invokes this method, instead of scheduling a chunk refresh.</p>
						
						<pre translate="no">	public int TerrainTypeIndex {
		get {
			return terrainTypeIndex;
		}
		set {
			if (terrainTypeIndex != value) {
				terrainTypeIndex = value;
<del>//				Refresh();</del>
				<ins>ShaderData.RefreshTerrain(this);</ins>
			}
		}
	}</pre>
						
						<p>Also invoke it in <code>HexCell.Load</code> after retrieving the cell's terrain type.</p>
						
						<pre translate="no">	public void Load (BinaryReader reader) {
		terrainTypeIndex = reader.ReadByte();
		<ins>ShaderData.RefreshTerrain(this);</ins>
		elevation = reader.ReadByte();
		RefreshPosition();
		&hellip;
	}</pre>
					</section>
					
					<section>
						<h3>Cell Index</h3>
						
						<p>To adjust the cell data, we need to know the cell's index. The simplest way to do this is by adding an <code>Index</code> property to <code>HexCell</code>. This represents the cell's index in the map's cell list, which matches it's index in the cell shader data.</p>
						
						<pre translate="no">	<ins>public int Index { get; set; }</ins></pre>
						
						<p>We already have this index available in <code>HexGrid.CreateCell</code>, so simply assign it to the newly created cell.</p>
						
						<pre translate="no">	void CreateCell (int x, int z, int i) {
		&hellip;
		cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z);
		<ins>cell.Index = i;</ins>
		cell.ShaderData = cellShaderData;

		&hellip;
	}</pre>
						
						<p>Now <code>HexCellShaderData.RefreshTerrain</code> can use this index to set the cell's data. Let's store the terrain type index in its pixel's alpha component, by simply converting the type to a byte. This allows us to support up to 256 terrain types, which is plenty.</p>
						
						<pre translate="no">	<ins>public void RefreshTerrain (HexCell cell) {</ins>
		<ins>cellTextureData[cell.Index].a = (byte)cell.TerrainTypeIndex;</ins>
	}</pre>
						
						<p>To actually apply the data to the texture and push it to the GPU, we have to invoke <code>Texture2D.SetPixels32</code> followed by <code>Texture2D.Apply</code>. Like we do with chunks, we're going to delay this to <code>LateUpdate</code> so we do it at most once per frame, no matter how many cells were changed.</p>
						
						<pre translate="no">	public void RefreshTerrain (HexCell cell) {
		cellTextureData[cell.Index].a = (byte)cell.TerrainTypeIndex;
		<ins>enabled = true;</ins>
	}
	
	<ins>void LateUpdate () {</ins>
		<ins>cellTexture.SetPixels32(cellTextureData);</ins>
		<ins>cellTexture.Apply();</ins>
		<ins>enabled = false;</ins>
	<ins>}</ins></pre>
						
						<p>To make sure that the data is updated after creating a new map, also enable the component after initialization.</p>
						
						<pre translate="no">	public void Initialize (int x, int z) {
		&hellip;
		<ins>enabled = true;</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Triangulating Cell Indices</h3>
						
						<p>Because we're now storing the terrain type index in the cell data, we no longer have to include it while triangulating. But to use the cell data, the shader has to know which cell indices to use. So we have to store the cell indices in the mesh data, replacing the terrain type indices. Also, we still need the mesh color channel to blend between cells when using the cell data.</p>
						
						<p>Remove the outdated <code>useColors</code> and <code>useTerrainTypes</code> public fields from <code>HexMesh</code>. Replace them with a single <code>useCellData</code> field.</p>
						
						<pre translate="no"><del>//	public bool useCollider, useColors, useUVCoordinates, useUV2Coordinates;</del>
<del>//	public bool useTerrainTypes;</del>
	<ins>public bool useCollider, useCellData, useUVCoordinates, useUV2Coordinates;</ins>
</pre>
						
						<p>Refactor-rename the <code>terrainTypes</code> list to <code>cellIndices</code>. Let's also refactor-rename <code>colors</code> to <code>cellWeights</code>, which is a more appropriate name.</p>
						
						<pre translate="no"><del>//	[NonSerialized] List&lt;Vector3> vertices, terrainTypes;</del>
<del>//	[NonSerialized] List&lt;Color> colors;</del>
	<ins>[NonSerialized] List&lt;Vector3> vertices, cellIndices;</ins>
	<ins>[NonSerialized] List&lt;Color> cellWeights;</ins>
	[NonSerialized] List&lt;Vector2> uvs, uv2s;
	[NonSerialized] List&lt;int> triangles;
</pre>
						
						<p>Adjust <code>Clear</code> so it grabs the two lists together when using cell data, instead of independent of one another.</p>
						
						<pre translate="no">	public void Clear () {
		hexMesh.Clear();
		vertices = ListPool&lt;Vector3>.Get();
		<ins>if (useCellData) {</ins>
			<ins>cellWeights = ListPool&lt;Color>.Get();</ins>
			<ins>cellIndices = ListPool&lt;Vector3>.Get();</ins>
		<ins>}</ins>
<del>//		if (useColors) {</del>
<del>//			colors = ListPool&lt;Color>.Get();</del>
<del>//		}</del>
		if (useUVCoordinates) {
			uvs = ListPool&lt;Vector2>.Get();
		}
		if (useUV2Coordinates) {
			uv2s = ListPool&lt;Vector2>.Get();
		}
<del>//		if (useTerrainTypes) {</del>
<del>//			terrainTypes = ListPool&lt;Vector3>.Get();</del>
<del>//		}</del>
		triangles = ListPool&lt;int>.Get();
	}</pre>
						
						<p>Perform the same grouping in <code>Apply</code>.</p>
						
						<pre translate="no">	public void Apply () {
		hexMesh.SetVertices(vertices);
		ListPool&lt;Vector3>.Add(vertices);
		<ins>if (useCellData) {</ins>
			<ins>hexMesh.SetColors(cellWeights);</ins>
			<ins>ListPool&lt;Color>.Add(cellWeights);</ins>
			<ins>hexMesh.SetUVs(2, cellIndices);</ins>
			<ins>ListPool&lt;Vector3>.Add(cellIndices);</ins>
		<ins>}</ins>
<del>//		if (useColors) {</del>
<del>//			hexMesh.SetColors(colors);</del>
<del>//			ListPool&lt;Color>.Add(colors);</del>
<del>//		}</del>
		if (useUVCoordinates) {
			hexMesh.SetUVs(0, uvs);
			ListPool&lt;Vector2>.Add(uvs);
		}
		if (useUV2Coordinates) {
			hexMesh.SetUVs(1, uv2s);
			ListPool&lt;Vector2>.Add(uv2s);
		}
<del>//		if (useTerrainTypes) {</del>
<del>//			hexMesh.SetUVs(2, terrainTypes);</del>
<del>//			ListPool&lt;Vector3>.Add(terrainTypes);</del>
<del>//		}</del>
		hexMesh.SetTriangles(triangles, 0);
		ListPool&lt;int>.Add(triangles);
		hexMesh.RecalculateNormals();
		if (useCollider) {
			meshCollider.sharedMesh = hexMesh;
		}
	}</pre>
						
						<p>Delete all the <code>AddTriangleColor</code> and <code>AddTriangleTerrainTypes</code> methods. Replace them with corresponding <code>AddTriangleCellData</code> methods that add the indices and weights in one go.</p>
						
						<pre translate="no">	<ins>public void AddTriangleCellData (</ins>
		<ins>Vector3 indices, Color weights1, Color weights2, Color weights3</ins>
	<ins>) {</ins>
		<ins>cellIndices.Add(indices);</ins>
		<ins>cellIndices.Add(indices);</ins>
		<ins>cellIndices.Add(indices);</ins>
		<ins>cellWeights.Add(weights1);</ins>
		<ins>cellWeights.Add(weights2);</ins>
		<ins>cellWeights.Add(weights3);</ins>
	<ins>}</ins>
		
	<ins>public void AddTriangleCellData (Vector3 indices, Color weights) {</ins>
		<ins>AddTriangleCellData(indices, weights, weights, weights);</ins>
	<ins>}</ins></pre>
						
						<p>Apply the same treatment to the respective <code>AddQuad</code> methods.</p>
						
						<pre translate="no">	<ins>public void AddQuadCellData (</ins>
		<ins>Vector3 indices,</ins>
		<ins>Color weights1, Color weights2, Color weights3, Color weights4</ins>
	<ins>) {</ins>
		<ins>cellIndices.Add(indices);</ins>
		<ins>cellIndices.Add(indices);</ins>
		<ins>cellIndices.Add(indices);</ins>
		<ins>cellIndices.Add(indices);</ins>
		<ins>cellWeights.Add(weights1);</ins>
		<ins>cellWeights.Add(weights2);</ins>
		<ins>cellWeights.Add(weights3);</ins>
		<ins>cellWeights.Add(weights4);</ins>
	<ins>}</ins>

	<ins>public void AddQuadCellData (</ins>
		<ins>Vector3 indices, Color weights1, Color weights2</ins>
	<ins>) {</ins>
		<ins>AddQuadCellData(indices, weights1, weights1, weights2, weights2);</ins>
	<ins>}</ins>

	<ins>public void AddQuadCellData (Vector3 indices, Color weights) {</ins>
		<ins>AddQuadCellData(indices, weights, weights, weights, weights);</ins>
	<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Refactoring HexGridChunk</h3>
						
						<p>At this point we get a lot of compiler errors in <code>HexGridChunk</code> that we have to fix. But first refactor-rename the static colors to weights, to stay consistent.</p>
						
						<pre translate="no">	static Color <ins>weights1</ins> = new Color(1f, 0f, 0f);
	static Color <ins>weights2</ins> = new Color(0f, 1f, 0f);
	static Color <ins>weights3</ins> = new Color(0f, 0f, 1f);
</pre>
						
						<p>Let's begin by fixing <code>TriangulateEdgeFan</code>. It used to require a type but now needs a cell index. Replace the <code>AddTriangleColor</code> and <code>AddTriangleTerrainTypes</code> code with the corresponding <code>AddTriangleCellData</code> code.</p>
						
						<pre translate="no">	void TriangulateEdgeFan (Vector3 center, EdgeVertices edge, float <ins>index</ins>) {
		terrain.AddTriangle(center, edge.v1, edge.v2);
		terrain.AddTriangle(center, edge.v2, edge.v3);
		terrain.AddTriangle(center, edge.v3, edge.v4);
		terrain.AddTriangle(center, edge.v4, edge.v5);

		<ins>Vector3 indices;</ins>
		<ins>indices.x = indices.y = indices.z = index;</ins>
		<ins>terrain.AddTriangleCellData(indices, weights1);</ins>
		<ins>terrain.AddTriangleCellData(indices, weights1);</ins>
		<ins>terrain.AddTriangleCellData(indices, weights1);</ins>
		<ins>terrain.AddTriangleCellData(indices, weights1);</ins>

<del>//		terrain.AddTriangleColor(weights1);</del>
<del>//		terrain.AddTriangleColor(weights1);</del>
<del>//		terrain.AddTriangleColor(weights1);</del>
<del>//		terrain.AddTriangleColor(weights1);</del>

<del>//		Vector3 types;</del>
<del>//		types.x = types.y = types.z = type;</del>
<del>//		terrain.AddTriangleTerrainTypes(types);</del>
<del>//		terrain.AddTriangleTerrainTypes(types);</del>
<del>//		terrain.AddTriangleTerrainTypes(types);</del>
<del>//		terrain.AddTriangleTerrainTypes(types);</del>
	}</pre>
						
						<p>This method is invoked in a few placed. Go through them and make sure that it's supplied with the cell index instead of the terrain type.</p>
						
						<pre translate="no">		TriangulateEdgeFan(center, e, cell.<ins>Index</ins>);</pre>
						
						<p>Next is <code>TriangulateEdgeStrip</code>. It's a bit more involved, but apply the same treatment. Also refactor-rename the <code>c1</code> and <code>c2</code> parameter names to <code>w1</code> and <code>w2</code>.</p>
						
						<pre translate="no">	void TriangulateEdgeStrip (
		EdgeVertices e1, Color <ins>w1</ins>, float <ins>index1</ins>,
		EdgeVertices e2, Color <ins>w2</ins>, float <ins>index2</ins>,
		bool hasRoad = false
	) {
		terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2);
		terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3);
		terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4);
		terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);

		<ins>Vector3 indices;</ins>
		<ins>indices.x = indices.z = index1;</ins>
		<ins>indices.y = index2;</ins>
		<ins>terrain.AddQuadCellData(indices, w1, w2);</ins>
		<ins>terrain.AddQuadCellData(indices, w1, w2);</ins>
		<ins>terrain.AddQuadCellData(indices, w1, w2);</ins>
		<ins>terrain.AddQuadCellData(indices, w1, w2);</ins>

<del>//		terrain.AddQuadColor(c1, c2);</del>
<del>//		terrain.AddQuadColor(c1, c2);</del>
<del>//		terrain.AddQuadColor(c1, c2);</del>
<del>//		terrain.AddQuadColor(c1, c2);</del>

<del>//		Vector3 types;</del>
<del>//		types.x = types.z = type1;</del>
<del>//		types.y = type2;</del>
<del>//		terrain.AddQuadTerrainTypes(types);</del>
<del>//		terrain.AddQuadTerrainTypes(types);</del>
<del>//		terrain.AddQuadTerrainTypes(types);</del>
<del>//		terrain.AddQuadTerrainTypes(types);</del>

		if (hasRoad) {
			TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4);
		}
	}</pre>
						
						<p>Change the invocations of this method so they're supplied with the cell index. Also keep the variable names consistent.</p>
						
						<pre translate="no">		TriangulateEdgeStrip(
			m, weights1, cell.<ins>Index</ins>,
			e, weights1, cell.<ins>Index</ins>
		);
		
	&hellip;
		
			TriangulateEdgeStrip(
				e1, weights1, cell.<ins>Index</ins>,
				e2, weights2, neighbor.<ins>Index</ins>, hasRoad
			);
	
	&hellip;
	
	void TriangulateEdgeTerraces (
		EdgeVertices begin, HexCell beginCell,
		EdgeVertices end, HexCell endCell,
		bool hasRoad
	) {
		EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, 1);
		Color <ins>w2</ins> = HexMetrics.TerraceLerp(weights1, weights2, 1);
		float <ins>i1</ins> = beginCell.<ins>Index</ins>;
		float <ins>i2</ins> = endCell.<ins>Index</ins>;

		TriangulateEdgeStrip(begin, weights1, <ins>i1</ins>, e2, <ins>w2</ins>, <ins>i2</ins>, hasRoad);

		for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) {
			EdgeVertices e1 = e2;
			Color <ins>w1</ins> = <ins>w2</ins>;
			e2 = EdgeVertices.TerraceLerp(begin, end, i);
			w2 = HexMetrics.TerraceLerp(weights1, weights2, i);
			TriangulateEdgeStrip(e1, <ins>w1</ins>, <ins>i1</ins>, e2, <ins>w2</ins>, <ins>i2</ins>, hasRoad);
		}

		TriangulateEdgeStrip(e2, <ins>w2</ins>, <ins>i1</ins>, end, weights2, <ins>i2</ins>, hasRoad);
	}</pre>
						
						<p>Now we move on to the corner methods. These changes are straightforward, but go through a lot of code. First is <code>TriangulateCorner</code>.</p>
						
						<pre translate="no">	void TriangulateCorner (
		Vector3 bottom, HexCell bottomCell,
		Vector3 left, HexCell leftCell,
		Vector3 right, HexCell rightCell
	) {
		&hellip;
		else {
			terrain.AddTriangle(bottom, left, right);
			<ins>Vector3 indices;</ins>
			<ins>indices.x = bottomCell.Index;</ins>
			<ins>indices.y = leftCell.Index;</ins>
			<ins>indices.z = rightCell.Index;</ins>
			<ins>terrain.AddTriangleCellData(indices, weights1, weights2, weights3);</ins>
<del>//			terrain.AddTriangleColor(weights1, weights2, weights3);</del>
<del>//			Vector3 types;</del>
<del>//			types.x = bottomCell.TerrainTypeIndex;</del>
<del>//			types.y = leftCell.TerrainTypeIndex;</del>
<del>//			types.z = rightCell.TerrainTypeIndex;</del>
<del>//			terrain.AddTriangleTerrainTypes(types);</del>
		}

		features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell);
	}</pre>
						
						<p><code>TriangulateCornerTerraces</code> is next.</p>
						
						<pre translate="no">	void TriangulateCornerTerraces (
		Vector3 begin, HexCell beginCell,
		Vector3 left, HexCell leftCell,
		Vector3 right, HexCell rightCell
	) {
		Vector3 v3 = HexMetrics.TerraceLerp(begin, left, 1);
		Vector3 v4 = HexMetrics.TerraceLerp(begin, right, 1);
		Color <ins>w3</ins> = HexMetrics.TerraceLerp(weights1, weights2, 1);
		Color <ins>w4</ins> = HexMetrics.TerraceLerp(weights1, weights3, 1);
		Vector3 <ins>indices</ins>;
		<ins>indices</ins>.x = beginCell.<ins>Index</ins>;
		<ins>indices</ins>.y = leftCell.<ins>Index</ins>;
		<ins>indices</ins>.z = rightCell.<ins>Index</ins>;

		terrain.AddTriangle(begin, v3, v4);
		<ins>terrain.AddTriangleCellData(indices, weights1, w3, w4);</ins>
<del>//		terrain.AddTriangleColor(weights1, w3, w4);</del>
<del>//		terrain.AddTriangleTerrainTypes(indices);</del>

		for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) {
			Vector3 v1 = v3;
			Vector3 v2 = v4;
			Color <ins>w1</ins> = <ins>w3</ins>;
			Color <ins>w2</ins> = <ins>w4</ins>;
			v3 = HexMetrics.TerraceLerp(begin, left, i);
			v4 = HexMetrics.TerraceLerp(begin, right, i);
			w3 = HexMetrics.TerraceLerp(weights1, weights2, i);
			w4 = HexMetrics.TerraceLerp(weights1, weights3, i);
			terrain.AddQuad(v1, v2, v3, v4);
			<ins>terrain.AddQuadCellData(indices, w1, w2, w3, w4);</ins>
<del>//			terrain.AddQuadColor(w1, w2, w3, w4);</del>
<del>//			terrain.AddQuadTerrainTypes(indices);</del>
		}

		terrain.AddQuad(v3, v4, left, right);
		<ins>terrain.AddQuadCellData(indices, w3, w4, weights2, weights3);</ins>
<del>//		terrain.AddQuadColor(w3, w4, weights2, weights3);</del>
<del>//		terrain.AddQuadTerrainTypes(indices);</del>
	}</pre>
						
						<p>Followed by <code>TriangulateCornerTerracesCliff</code>.</p>
						
						<pre translate="no">	void TriangulateCornerTerracesCliff (
		Vector3 begin, HexCell beginCell,
		Vector3 left, HexCell leftCell,
		Vector3 right, HexCell rightCell
	) {
		float b = 1f / (rightCell.Elevation - beginCell.Elevation);
		if (b &lt; 0) {
			b = -b;
		}
		Vector3 boundary = Vector3.Lerp(
			HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b
		);
		Color <ins>boundaryWeights</ins> = Color.Lerp(weights1, weights3, b);
		Vector3 <ins>indices</ins>;
		<ins>indices</ins>.x = beginCell.<ins>Index</ins>;
		<ins>indices</ins>.y = leftCell.<ins>Index</ins>;
		<ins>indices</ins>.z = rightCell.<ins>Index</ins>;

		TriangulateBoundaryTriangle(
			begin, weights1, left, weights2, boundary, <ins>boundaryWeights</ins>, <ins>indices</ins>
		);

		if (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) {
			TriangulateBoundaryTriangle(
				left, weights2, right, weights3,
				boundary, <ins>boundaryWeights</ins>, <ins>indices</ins>
			);
		}
		else {
			terrain.AddTriangleUnperturbed(
				HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary
			);
			<ins>terrain.AddTriangleCellData(</ins>
				<ins>indices, weights2, weights3, boundaryWeights</ins>
			<ins>);</ins>
<del>//			terrain.AddTriangleColor(weights2, weights3, boundaryColor);</del>
<del>//			terrain.AddTriangleTerrainTypes(indices);</del>
		}
	}</pre>
						
						<p>And the slightly different <code>TriangulateCornerCliffTerraces</code>.</p>
						
						<pre translate="no">	void TriangulateCornerCliffTerraces (
		Vector3 begin, HexCell beginCell,
		Vector3 left, HexCell leftCell,
		Vector3 right, HexCell rightCell
	) {
		float b = 1f / (leftCell.Elevation - beginCell.Elevation);
		if (b &lt; 0) {
			b = -b;
		}
		Vector3 boundary = Vector3.Lerp(
			HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b
		);
		Color <ins>boundaryWeights</ins> = Color.Lerp(weights1, weights2, b);
		Vector3 <ins>indices</ins>;
		<ins>indices</ins>.x = beginCell.<ins>Index</ins>;
		<ins>indices</ins>.y = leftCell.<ins>Index</ins>;
		<ins>indices</ins>.z = rightCell.<ins>Index</ins>;

		TriangulateBoundaryTriangle(
			right, weights3, begin, weights1, boundary, <ins>boundaryWeights</ins>, <ins>indices</ins>
		);

		if (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) {
			TriangulateBoundaryTriangle(
				left, weights2, right, weights3,
				boundary, <ins>boundaryWeights</ins>, <ins>indices</ins>
			);
		}
		else {
			terrain.AddTriangleUnperturbed(
				HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary
			);
			<ins>terrain.AddTriangleCellData(</ins>
				<ins>indices, weights2, weights3, boundaryWeights</ins>
			<ins>);</ins>
<del>//			terrain.AddTriangleColor(weights2, weights3, boundaryWeights);</del>
<del>//			terrain.AddTriangleTerrainTypes(indices);</del>
		}
	}</pre>
						
						<p>The previous two methods rely on <code>TriangulateBoundaryTriangle</code>, which requires an update as well.</p>
						
						<pre translate="no">	void TriangulateBoundaryTriangle (
		Vector3 begin, Color <ins>beginWeights</ins>,
		Vector3 left, Color <ins>leftWeights</ins>,
		Vector3 boundary, Color <ins>boundaryWeights</ins>, Vector3 <ins>indices</ins>
	) {
		Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, 1));
		Color <ins>w2</ins> = HexMetrics.TerraceLerp(<ins>beginWeights</ins>, <ins>leftWeights</ins>, 1);

		terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary);
		<ins>terrain.AddTriangleCellData(indices, beginWeights, w2, boundaryWeights);</ins>
<del>//		terrain.AddTriangleColor(beginColor, c2, boundaryColor);</del>
<del>//		terrain.AddTriangleTerrainTypes(types);</del>

		for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) {
			Vector3 v1 = v2;
			Color <ins>w1</ins> = <ins>w2</ins>;
			v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i));
			<ins>w2</ins> = HexMetrics.TerraceLerp(<ins>beginWeights</ins>, <ins>leftWeights</ins>, i);
			terrain.AddTriangleUnperturbed(v1, v2, boundary);
			<ins>terrain.AddTriangleCellData(indices, w1, w2, boundaryWeights);</ins>
<del>//			terrain.AddTriangleColor(c1, c2, boundaryColor);</del>
<del>//			terrain.AddTriangleTerrainTypes(types);</del>
		}

		terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary);
		<ins>terrain.AddTriangleCellData(indices, w2, leftWeights, boundaryWeights);</ins>
<del>//		terrain.AddTriangleColor(c2, leftColor, boundaryColor);</del>
<del>//		terrain.AddTriangleTerrainTypes(types);</del>
	}</pre>
						
						<p>The final method that requires changes is <code>TriangulateWithRiver</code>.</p>
						
						<pre translate="no">	void TriangulateWithRiver (
		HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e
	) {
		&hellip;

		terrain.AddTriangle(centerL, m.v1, m.v2);
		terrain.AddQuad(centerL, center, m.v2, m.v3);
		terrain.AddQuad(center, centerR, m.v3, m.v4);
		terrain.AddTriangle(centerR, m.v4, m.v5);

		<ins>Vector3 indices;</ins>
		<ins>indices.x = indices.y = indices.z = cell.Index;</ins>
		<ins>terrain.AddTriangleCellData(indices, weights1);</ins>
		<ins>terrain.AddQuadCellData(indices, weights1);</ins>
		<ins>terrain.AddQuadCellData(indices, weights1);</ins>
		<ins>terrain.AddTriangleCellData(indices, weights1);</ins>

<del>//		terrain.AddTriangleColor(weights1);</del>
<del>//		terrain.AddQuadColor(weights1);</del>
<del>//		terrain.AddQuadColor(weights1);</del>
<del>//		terrain.AddTriangleColor(weights1);</del>

<del>//		Vector3 types;</del>
<del>//		types.x = types.y = types.z = cell.TerrainTypeIndex;</del>
<del>//		terrain.AddTriangleTerrainTypes(types);</del>
<del>//		terrain.AddQuadTerrainTypes(types);</del>
<del>//		terrain.AddQuadTerrainTypes(types);</del>
<del>//		terrain.AddTriangleTerrainTypes(types);</del>

		&hellip;
	}</pre>
						
						<p>To make this work, we have to indicate that we use cell data for the terrain child of the chunk prefab.</p>
						
						<figure>
							<img src="cell-shader-data/using-cell-data.png" width="320" height="116">
							<figcaption>Terrain uses cell data.</figcaption>
						</figure>
						
						<p>At this point, our mesh contains cell indices instead of terrain type indices. Because the terrain shader still interprets them as terrain indices, you'll see that the first cell is rendered with the first texture, and so on until the last terrain texture is reached.</p>
						
						<figure>
							<img src="cell-shader-data/index-terrain.png" width="420" height="260">
							<figcaption>Treating cell indices as terrain texture indices.</figcaption>
						</figure>
						
						<aside>
							<h3>I can't get the refactored code to work. What am I doing wrong?</h3>
							<div>
								<p>As a lot of triangulation code has been changed in one go, there's been plenty of opportunity for a mistake or oversight. If you can't find the error, don't forget that you can download the package of this section and extract the relevant files. You can import them in a separate project and compare with your own code.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Passing Cell Data to the Shader</h3>
						
						<p>In order to use the cell data, the terrain shader needs access to it. We could do this via a shader property, which would require <code>HexCellShaderData</code> to set the terrain material's property. An alternative is to make the cell data texture globally available to all shaders. This is convenient, as we'll be needing it in multiple shaders, so let's use that approach.</p>
						
						<p>After the cell texture has been created, invoke the static <code>Shader.SetGlobalTexture</code> method to make it globally known as <em translate="no">_HexCellData</em>.</p>
						
						<pre translate="no">	public void Initialize (int x, int z) {
		&hellip;
		else {
			cellTexture = new Texture2D(
				x, z, TextureFormat.RGBA32, false, true
			);
			cellTexture.filterMode = FilterMode.Point;
			cellTexture.wrapMode = TextureWrapMode.Clamp;
			<ins>Shader.SetGlobalTexture("_HexCellData", cellTexture);</ins>
		}

		&hellip;
	}</pre>
						
						<p>When using a shader property, Unity also makes a texture's size available to the shader via a <em translate="no">textureName_TexelSize</em> variable. This is a four-component vector which contains the multiplicative inverses of the width and height, and the actual width and height. But when setting a texture globally, this is not done. So let's do it ourselves, via <code>Shader.SetGlobalVector</code> after the texture has been created or resized.</p>
						
						<pre translate="no">		else {
			cellTexture = new Texture2D(
				x, z, TextureFormat.RGBA32, false, true
			);
			cellTexture.filterMode = FilterMode.Point;
			cellTexture.wrapMode = TextureWrapMode.Clamp;
			Shader.SetGlobalTexture("_HexCellData", cellTexture);
		}
		<ins>Shader.SetGlobalVector(</ins>
			<ins>"_HexCellData_TexelSize",</ins>
			<ins>new Vector4(1f / x, 1f / z, x, z)</ins>
		<ins>);</ins></pre>
					</section>
					
					<section>
						<h3>Accessing Shader Data</h3>
						
						<p>Create a new shader include file named <em translate="no">HexCellData</em> in the material folder. Inside it, define variables for the cell data texture and size info. Also provide a function for retrieving the cell data, given the mesh data of a vertex.</p>
						
						<pre translate="no" class="shader"><ins>sampler2D _HexCellData;</ins>
<ins>float4 _HexCellData_TexelSize;</ins>

<ins>float4 GetCellData (appdata_full v) {</ins>
<ins>}</ins></pre>
						
						<figure>
							<img src="cell-shader-data/include-file.png" width="120" height="290">
							<figcaption>New include file.</figcaption>
						</figure>
						
						<p>The cell indices are stored in <code class="shader">v.texcoord2</code>, just like the terrain types were. Let's start with the first index, <code class="shader">v.texcoord2.x</code>. Unfortunately, we cannot directly use an index to sample the cell data texture. We have to convert it to UV coordinates.</p>
						
						<p>The first step of constructing the U coordinate is to divide the cell index by the texture width. We can do this by multiplying with <code class="shader">_HexCellData_TexelSize.x</code>.</p>
						
						<pre translate="no" class="shader">float4 GetCellData (appdata_full v) {
	<ins>float2 uv;</ins>
	<ins>uv.x = v.texcoord2.x * _HexCellData_TexelSize.x;</ins>
}</pre>
						
						<p>The result is a number of the form Z.U, where Z is the row index and U is the U coordinate of the cell. We can extract the row by flooring the number, then subtract that from the number to get the U coordinate.</p>
						
						<pre translate="no" class="shader">float4 GetCellData (appdata_full v) {
	float2 uv;
	uv.x = v.texcoord2.x * _HexCellData_TexelSize.x;
	<ins>float row = floor(uv.x);</ins>
	<ins>uv.x -= row;</ins>
}</pre>
						
						<p>The V coordinate is found by dividing the row by the texture height.</p>
						
						<pre translate="no" class="shader">float4 GetCellData (appdata_full v) {
	float2 uv;
	uv.x = v.texcoord2.x * _HexCellData_TexelSize.x;
	float row = floor(uv.x);
	uv.x -= row;
	<ins>uv.y = row * _HexCellData_TexelSize.y;</ins>
}</pre>
						
						<p>Because we're sampling a texture, we want to use UV coordinates that align with the centers of pixels. That ensures that we sample the correct pixels. So add &frac12; before dividing by the texture sizes.</p>
						
						<pre translate="no" class="shader">float4 GetCellData (appdata_full v) {
	float2 uv;
	uv.x = <ins>(</ins>v.texcoord2.x <ins>+ 0.5)</ins> * _HexCellData_TexelSize.x;
	float row = floor(uv.x);
	uv.x -= row;
	uv.y = <ins>(</ins>row <ins>+ 0.5)</ins> * _HexCellData_TexelSize.y;
}</pre>
						
						<p>This gives us the proper UV coordinates for the first cell index stored in the vertex data. But we can have up to three different indices per vertex. So let's make <code>GetCellData</code> work for any index. Give it an integer <code class="shader">index</code> parameter, which we use to access the cell index vector's component.</p>
						
						<pre translate="no" class="shader">float4 GetCellData (appdata_full v<ins>, int index</ins>) {
	float2 uv;
	uv.x = (v.texcoord2<ins>[index]</ins> + 0.5) * _HexCellData_TexelSize.x;
	float row = floor(uv.x);
	uv.x -= row;
	uv.y = (row + 0.5) * _HexCellData_TexelSize.y;
}</pre>
						
						<p>Now that we have the desired cell data coordinates, we can sample <code class="shader">_HexCellData</code>. Because we're sampling the texture in the vertex program, we have to explicitly tell the shader which mipmap to use. This is done via the <code class="shader">tex2Dlod</code> function, which requires four texture coordinates. Because the cell data doesn't have mipmaps, set the extra coordinates to zero.</p>
						
						<pre translate="no" class="shader">float4 GetCellData (appdata_full v, int index) {
	float2 uv;
	uv.x = (v.texcoord2[index] + 0.5) * _HexCellData_TexelSize.x;
	float row = floor(uv.x);
	uv.x -= row;
	uv.y = (row + 0.5) * _HexCellData_TexelSize.y;
	<ins>float4 data = tex2Dlod(_HexCellData, float4(uv, 0, 0));</ins>
}</pre>
						
						<p>The fourth data component contains the terrain type index, which we directly stored as a byte. However, the GPU automatically converted it into a floating-point value in the 0&ndash;1 range. To convert it back to its proper value, multiply it with 255. After that, we can return the data.</p>
						
						<pre translate="no" class="shader">	float4 data = tex2Dlod(_HexCellData, float4(uv, 0, 0));
	<ins>data.w *= 255;</ins>
	<ins>return data;</ins></pre>
						
						<p>To use this functionality, include <em translate="no">HexCellData</em> in the <em translate="no">Terrain</em> shader. Because I've placed this shader in <em translate="no">Materials / Terrain</em>, I have to use the relative path <em translate="no">../HexCellData.cginc</em>.</p>
						
						<pre translate="no" class="shader">		<ins>#include "../HexCellData.cginc"</ins>

		UNITY_DECLARE_TEX2DARRAY(_MainTex);</pre>
						
						<p>In the vertex program, retrieve the cell data for all three cell indices stored in the vertex data. Then assign their terrain indices to <code class="shader">data.terrain</code>.</p>
						
						<pre translate="no" class="shader">		void vert (inout appdata_full v, out Input data) {
			UNITY_INITIALIZE_OUTPUT(Input, data);
<del>//			data.terrain = v.texcoord2.xyz;</del>

			<ins>float4 cell0 = GetCellData(v, 0);</ins>
			<ins>float4 cell1 = GetCellData(v, 1);</ins>
			<ins>float4 cell2 = GetCellData(v, 2);</ins>

			<ins>data.terrain.x = cell0.w;</ins>
			<ins>data.terrain.y = cell1.w;</ins>
			<ins>data.terrain.z = cell2.w;</ins>
		}</pre>
						
						<p>At this point, our map should again show the correct terrain. The big difference is that editing only the terrain types no longer triggers new triangulations. If some other cell data is changed while editing, a triangulation will occur as usual.</p>
					</section>
					
					<a href="cell-shader-data/cell-shader-data.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Visibility</h2>
					
					<p>With our cell data framework in place, we can move on to adding support for visibility. This will involve the shader, cells themselves, and whoever decides what is visible. Note that the triangulation process is completely unaware of this.</p>
					
					<section>
						<h3>Shader</h3>
						
						<p>Let's begin by making the <em translate="no">Terrain</em> shader aware of visibility. It will extract the visibility data in the vertex program and pass it to the fragment program via the <code class="shader">Input</code> structure. Because we're passing through three separate terrain indices, let's also pass through three visibility values.</p>
						
						<pre translate="no" class="shader">		struct Input {
			float4 color : COLOR;
			float3 worldPos;
			float3 terrain;
			<ins>float3 visibility;</ins>
		};</pre>
						
						<p>We'll use the first component of the cell data to store the visibility.</p>
						
						<pre translate="no" class="shader">		void vert (inout appdata_full v, out Input data) {
			UNITY_INITIALIZE_OUTPUT(Input, data);

			float4 cell0 = GetCellData(v, 0);
			float4 cell1 = GetCellData(v, 1);
			float4 cell2 = GetCellData(v, 2);

			data.terrain.x = cell0.w;
			data.terrain.y = cell1.w;
			data.terrain.z = cell2.w;

			<ins>data.visibility.x = cell0.x;</ins>
			<ins>data.visibility.y = cell1.x;</ins>
			<ins>data.visibility.z = cell2.x;</ins>
		}</pre>
						
						<p>A visibility of 0 means that a cell is currently not visible. If the cell were visible, it would be set to 1 instead. So we can darken the terrain by multiplying the result of <code class="shader">GetTerrainColor</code> by the appropriate visibility factor. That way, we modulate the terrain color of each blended cell independently.</p>
						
						<pre translate="no" class="shader">		float4 GetTerrainColor (Input IN, int index) {
			float3 uvw = float3(IN.worldPos.xz * 0.02, IN.terrain[index]);
			float4 c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw);
			return c * <ins>(</ins>IN.color[index] <ins>* IN.visibility[index])</ins>;
		}</pre>
						
						<figure>
							<img src="visibility/black-cells.png" width="420" height="254">
							<figcaption>Cells have become black.</figcaption>
						</figure>
						
						<aside>
							<h3>Coulnd't we combine visibility in the vertex program instead?</h3>
							<div>
								<p>That is also possible, requiring only a single visibility factor to be passed to the fragment program. By passing a factor per cell to be blended, the three terrain samples are blended in isolation. The result is that visible cells contribute more to the blend region. Using a single factor requires the terrain to be blended first, after which the final interpolated visibility is applied. Both approaches work, but they're visually different.</p>
							</div>
						</aside>
						
						<p>Complete darkness is a bit too much for cells that aren't currently visible. To still be able to see the terrain, we should increase the factor used for hidden cells. Let's change the 0&ndash;1 choice to &frac14;&ndash;1, which can be done with the <code class="shader">lerp</code> function at the end of the vertex program.</p>
						
						<pre translate="no" class="shader">		void vert (inout appdata_full v, out Input data) {
			&hellip;

			data.visibility.x = cell0.x;
			data.visibility.y = cell1.x;
			data.visibility.z = cell2.x;
			<ins>data.visibility = lerp(0.25, 1, data.visibility);</ins>
		}</pre>
						
						<figure>
							<img src="visibility/darkened-cells.png" width="420" height="254">
							<figcaption>Darkened cells.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Keeping Track of Cell Visibility</h3>
						
						<p>To make visibility work, cells have to keep track of their visibility. But how does a cell determine whether it is visible? We can do this by having it keep track of how many entities can see it. Whenever something acquires sight of a cell, it should inform that cell about it. And when something loses sight of a cell, it has to inform that cell as well. The cell simply keeps track of the view count, no matter what or where these entities are. If the cell has a least a visibility score of 1, then it is visible, otherwise it isn't. Add a variable, two methods, and a property to <code>HexCell</code> to support this behavior.</p>
						
						<pre translate="no">	<ins>public bool IsVisible {</ins>
		<ins>get {</ins>
			<ins>return visibility > 0;</ins>
		<ins>}</ins>
	<ins>}</ins>

	&hellip;

	<ins>int visibility;</ins>

	&hellip;

	<ins>public void IncreaseVisibility () {</ins>
		<ins>visibility += 1;</ins>
	<ins>}</ins>

	<ins>public void DecreaseVisibility () {</ins>
		<ins>visibility -= 1;</ins>
	<ins>}</ins></pre>
						
						<p>Next, add a <code>RefreshVisibility</code> method to <code>HexCellShaderData</code> that does the same as <code>RefreshTerrain</code>, but for visibility. Store the data in the R component of the cell data. Because we're working with bytes that get converted to 0&ndash;1 values in the shader, use <code>(byte)255</code> to represent visible.</p>
						
						<pre translate="no">	<ins>public void RefreshVisibility (HexCell cell) {</ins>
		<ins>cellTextureData[cell.Index].r = cell.IsVisible ? (byte)255 : (byte)0;</ins>
		<ins>enabled = true;</ins>
	<ins>}</ins></pre>
						
						<p>Invoke this method both when a cell's visibility is increased and decreased, when changing between a score of 0 and 1.</p>
						
						<pre translate="no">	public void IncreaseVisibility () {
		visibility += 1;
		<ins>if (visibility == 1) {</ins>
			<ins>ShaderData.RefreshVisibility(this);</ins>
		<ins>}</ins>
	}

	public void DecreaseVisibility () {
		visibility -= 1;
		<ins>if (visibility == 0) {</ins>
			<ins>ShaderData.RefreshVisibility(this);</ins>
		<ins>}</ins>
	}</pre>
					</section>
					
					<section>
						<h3>Giving Sight to Units</h3>
						
						<p>Let's make it possible for units to see the cell they're occupying. This is done by invoking <code>IncreaseVisibility</code> on the unit's new location when <code>HexUnit.Location</code> is set. Also invoke <code>DecreaseVisibility</code> on the old location, if any.</p>
						
						<pre translate="no">	public HexCell Location {
		get {
			return location;
		}
		set {
			if (location) {
				<ins>location.DecreaseVisibility();</ins>
				location.Unit = null;
			}
			location = value;
			value.Unit = this;
			<ins>value.IncreaseVisibility();</ins>
			transform.localPosition = value.Position;
		}
	}
</pre>
						
						<figure>
							<img src="visibility/units-see-where-they-are.png" width="420" height="254">
							<figcaption>Units can see where they are.</figcaption>
						</figure>
						
						<p>For the first time, we can see visibility in action! Units make their location visible when added to the map. Their sight also teleports to their new location when they travel. But their sight remains active after they are removed from the map. To fix this, decrease the visibility of their location when they die.</p>
						
						<pre translate="no">	public void Die () {
		<ins>if (location) {</ins>
			<ins>location.DecreaseVisibility();</ins>
		<ins>}</ins>
		location.Unit = null;
		Destroy(gameObject);
	}</pre>
					</section>
					
					<section>
						<h3>Vision Range</h3>
						
						<p>Only seeing the cell you're in is rather limiting. At least, you should be able to see the adjacent cells as well. In general, units can see all cells up to some distance, which could vary per unit.</p>
						
						<p>Let's add a method to <code>HexGrid</code> to find all cells that are visible from one cell, given a vision range. We can create this method by duplicating and modifying <code>Search</code>. Change its parameters and have it return a list of cells, for which it can use the list pool.</p>
						
						<p>Each iteration, the current cell is added to the list. There is no longer a destination cell, so the search never ends when it reaches that cell. Also get rid of the turn and movement cost logic. Make sure that the <code>PathFrom</code> properties are no longer set, as we don't need them and we don't want to interfere with the grid's path.</p>
						
						<p>Each step, the distance simply increases by 1. If it exceeds the range, skip that cell. And we don't need a search heuristic, so initialize it to 0. So we're effectively back at Dijkstra's algorithm.</p>
						
						<pre translate="no">	<ins>List&lt;HexCell> GetVisibleCells (HexCell fromCell, int range)</ins> {
		<ins>List&lt;HexCell> visibleCells = ListPool&lt;HexCell>.Get();</ins>

		searchFrontierPhase += 2;
		if (searchFrontier == null) {
			searchFrontier = new HexCellPriorityQueue();
		}
		else {
			searchFrontier.Clear();
		}

		fromCell.SearchPhase = searchFrontierPhase;
		fromCell.Distance = 0;
		searchFrontier.Enqueue(fromCell);
		while (searchFrontier.Count > 0) {
			HexCell current = searchFrontier.Dequeue();
			current.SearchPhase += 1;
			<ins>visibleCells.Add(current);</ins>
<del>//			if (current == toCell) {</del>
<del>//				return true;</del>
<del>//			}</del>

<del>//			int currentTurn = (current.Distance - 1) / speed;</del>

			for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {
				HexCell neighbor = current.GetNeighbor(d);
				if (
					neighbor == null ||
					neighbor.SearchPhase > searchFrontierPhase
				) {
					continue;
				}
<del>//				&hellip;</del>
<del>//				int moveCost;</del>
<del>//				&hellip;</del>

				int distance = current.Distance + <ins>1</ins>;
				<ins>if (distance > range) {</ins>
					<ins>continue;</ins>
				<ins>}</ins>
<del>//				int turn = (distance - 1) / speed;</del>
<del>//				if (turn > currentTurn) {</del>
<del>//					distance = turn * speed + moveCost;</del>
<del>//				}</del>

				if (neighbor.SearchPhase &lt; searchFrontierPhase) {
					neighbor.SearchPhase = searchFrontierPhase;
					neighbor.Distance = distance;
<del>//					neighbor.PathFrom = current;</del>
					neighbor.SearchHeuristic = <ins>0</ins>;
					searchFrontier.Enqueue(neighbor);
				}
				else if (distance &lt; neighbor.Distance) {
					int oldPriority = neighbor.SearchPriority;
					neighbor.Distance = distance;
<del>//					neighbor.PathFrom = current;</del>
					searchFrontier.Change(neighbor, oldPriority);
				}
			}
		}
		return <ins>visibleCells</ins>;
	}</pre>
						
						<aside>
							<h3>Couldn't we use a simper algorithm to find all cells in range?</h3>
							<div>
								<p>We could, but this approach allows us to support more complex vision algorithms, which we'll do in a future tutorial.</p>
							</div>
						</aside>
						
						<p>Now also give <code>HexGrid</code> an <code>IncreaseVisibility</code> and <code>DecreaseVisibility</code> method. They take a cell and range, fetch the relevant cell list, and either increase or decrease their visibility appropriately. After that's done, they should put the list back in its pool.</p>
						
						<pre translate="no">	<ins>public void IncreaseVisibility (HexCell fromCell, int range) {</ins>
		<ins>List&lt;HexCell> cells = GetVisibleCells(fromCell, range);</ins>
		<ins>for (int i = 0; i &lt; cells.Count; i++) {</ins>
			<ins>cells[i].IncreaseVisibility();</ins>
		<ins>}</ins>
		<ins>ListPool&lt;HexCell>.Add(cells);</ins>
	<ins>}</ins>

	<ins>public void DecreaseVisibility (HexCell fromCell, int range) {</ins>
		<ins>List&lt;HexCell> cells = GetVisibleCells(fromCell, range);</ins>
		<ins>for (int i = 0; i &lt; cells.Count; i++) {</ins>
			<ins>cells[i].DecreaseVisibility();</ins>
		<ins>}</ins>
		<ins>ListPool&lt;HexCell>.Add(cells);</ins>
	<ins>}</ins></pre>
						
						<p><code>HexUnit</code> requires access to the grid to be able to use these methods, so add a <code>Grid</code> property to it.</p>
						
						<pre translate="no">	<ins>public HexGrid Grid { get; set; }</ins></pre>
						
						<p>Assign the grid to this property when a unit is added to it, in <code>HexGrid.AddUnit</code>.</p>
						
						<pre translate="no">	public void AddUnit (HexUnit unit, HexCell location, float orientation) {
		units.Add(unit);
		<ins>unit.Grid = this;</ins>
		unit.transform.SetParent(transform, false);
		unit.Location = location;
		unit.Orientation = orientation;
	}</pre>
						
						<p>A vision range of three cells is plenty to start with. Add a constant for this to <code>HexUnit</code>, which could always become variable in the future. Then make sure that the unit invokes the <code>IncreaseVisibility</code> and <code>DecreaseVisibility</code> methods of the grid, instead of directly going to its location, passing along its range as well.</p>
						
						<pre translate="no">	<ins>const int visionRange = 3;</ins>

	&hellip;

	public HexCell Location {
		get {
			return location;
		}
		set {
			if (location) {
<del>//				location.DecreaseVisibility();</del>
				<ins>Grid.DecreaseVisibility(location, visionRange);</ins>
				location.Unit = null;
			}
			location = value;
			value.Unit = this;
<del>//			value.IncreaseVisibility();</del>
			<ins>Grid.IncreaseVisibility(value, visionRange);</ins>
			transform.localPosition = value.Position;
		}
	}

	&hellip;

	public void Die () {
		if (location) {
<del>//			location.DecreaseVisibility();</del>
			<ins>Grid.DecreaseVisibility(location, visionRange);</ins>
		}
		location.Unit = null;
		Destroy(gameObject);
	}</pre>
						
						<figure>
							<img src="visibility/vsion-range.png" width="420" height="254">
							<figcaption>Units with vision range, which can overlap.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Vision While Traveling</h3>
						
						<p>Currently, a unit's vision directly teleports to its destination when it is ordered to move. It would look better if the unit and its vision moved together. The first step of making this work is no longer setting the <code>Location</code> property in <code>HexUnit.Travel</code>. Instead, directly change the <code>location</code> field, avoiding the property's code. So manually clean up the old location and configure the new location. Leave the vision unchanged.</p>
						
						<pre translate="no">	public void Travel (List&lt;HexCell> path) {
<del>//		Location = path[path.Count - 1];</del>
		<ins>location.Unit = null;</ins>
		<ins>location = path[path.Count - 1];</ins>
		<ins>location.Unit = this;</ins>
		pathToTravel = path;
		StopAllCoroutines();
		StartCoroutine(TravelPath());
	}</pre>
						
						<p>Inside the <code>TravelPath</code> coroutine, decrease visibility from the first cell only after <code>LookAt</code> has finished. After that, before moving to a new cell, increase visibility from that cell. After that's done, decrease visibility from it again. Finally, increase visibility from the last cell.</p>
						
						<pre translate="no">	IEnumerator TravelPath () {
		Vector3 a, b, c = pathToTravel[0].Position;
<del>//		transform.localPosition = c;</del>
		yield return LookAt(pathToTravel[1].Position);
		<ins>Grid.DecreaseVisibility(pathToTravel[0], visionRange);</ins>

		float t = Time.deltaTime * travelSpeed;
		for (int i = 1; i &lt; pathToTravel.Count; i++) {
			a = c;
			b = pathToTravel[i - 1].Position;
			c = (b + pathToTravel[i].Position) * 0.5f;
			<ins>Grid.IncreaseVisibility(pathToTravel[i], visionRange);</ins>
			for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) {
				&hellip;
			}
			<ins>Grid.DecreaseVisibility(pathToTravel[i], visionRange);</ins>
			t -= 1f;
		}

		a = c;
		b = <ins>location.Position</ins>; // We can simply use the destination here.
		c = b;
		<ins>Grid.IncreaseVisibility(location, visionRange);</ins>
		for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) {
			&hellip;
		}

		&hellip;
	}</pre>
						
						<figure>
							<div class="vid" style="width: 320px; height:195px;"><iframe src='https://gfycat.com/ifr/SkinnyIcyHairstreakbutterfly'></iframe></div>
							<figcaption>Vision while traveling.</figcaption>
						</figure>
						
						<p>This works, except when a new move order is issued while the unit is still traveling. That triggers a teleportation, which should apply to vision as well. To support this, we have to keep track of the unit's current location while traveling.</p>
						
						<pre translate="no">	HexCell location<ins>, currentTravelLocation</ins>;</pre>
						
						<p>Update this location every time a new cell is entered while traveling, until the final cell is entered. Then it should be cleared.</p>
						
						<pre translate="no">	IEnumerator TravelPath () {
		&hellip;
		
		for (int i = 1; i &lt; pathToTravel.Count; i++) {
			<ins>currentTravelLocation = pathToTravel[i];</ins>
			a = c;
			b = pathToTravel[i - 1].Position;
			c = (b + <ins>currentTravelLocation</ins>.Position) * 0.5f;
			Grid.IncreaseVisibility(pathToTravel[i], visionRange);
			for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) {
				transform.localPosition = Bezier.GetPoint(a, b, c, t);
				Vector3 d = Bezier.GetDerivative(a, b, c, t);
				d.y = 0f;
				transform.localRotation = Quaternion.LookRotation(d);
				yield return null;
			}
			Grid.DecreaseVisibility(pathToTravel[i], visionRange);
			t -= 1f;
		}
		<ins>currentTravelLocation = null;</ins>
		
		&hellip;
	}</pre>
						
						<p>Now we can check whether an old intermediate travel location is know, after finishing rotation in <code>TravelPath</code>. If so, we should decrease visibility from that cell, instead of the start of the path.</p>
						
						<pre translate="no">	IEnumerator TravelPath () {
		Vector3 a, b, c = pathToTravel[0].Position;
		yield return LookAt(pathToTravel[1].Position);
		Grid.DecreaseVisibility(
			<ins>currentTravelLocation ? currentTravelLocation :</ins> pathToTravel[0],
			visionRange
		);

		&hellip;
	}</pre>
						
						<p>We also have to fix visibility after a recompile happened while a unit was traveling. If an intermediate location is still known, decrease visibility from it and increase visibility from the destination, then clear the intermediate location.</p>
						
						<pre translate="no">	void OnEnable () {
		if (location) {
			transform.localPosition = location.Position;
			<ins>if (currentTravelLocation) {</ins>
				<ins>Grid.IncreaseVisibility(location, visionRange);</ins>
				<ins>Grid.DecreaseVisibility(currentTravelLocation, visionRange);</ins>
				<ins>currentTravelLocation = null;</ins>
			<ins>}</ins>
		}
	}</pre>
					</section>
					
					<a href="visibility/visibility.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Visibility of Roads and Water</h2>
					
					<p>Although the terrain changes color based on visibility, roads and water are not affected. They appear too bright for cells that are out of sight. To apply visibility to roads and water, we have to add cell indices and blend weights to their mesh data as well. So check <em translate="no">Use Cell Data</em> for the <em translate="no">Rivers</em>, <em translate="no">Roads</em>, <em translate="no">Water</em>, <em translate="no">Water Shore</em>, and <em translate="no">Estuaries</em> children of the chunk prefab.</p>
					
					<section>
						<h3>Roads</h3>
						
						<p>We start with roads. The <code>HexGridChunk.TriangulateRoadEdge</code> method is used to create a small part of the road at the center of a cell, so it needs a single cell index. Add a parameter for it and generate the cell data for the triangle.</p>
						
						<pre translate="no">	void TriangulateRoadEdge (
		Vector3 center, Vector3 mL, Vector3 mR<ins>, float index</ins>
	) {
		roads.AddTriangle(center, mL, mR);
		roads.AddTriangleUV(
			new Vector2(1f, 0f), new Vector2(0f, 0f), new Vector2(0f, 0f)
		);
		<ins>Vector3 indices;</ins>
		<ins>indices.x = indices.y = indices.z = index;</ins>
		<ins>roads.AddTriangleCellData(indices, weights1);</ins>
	}</pre>
						
						<p>The other basic road-creation method is <code>TriangulateRoadSegment</code>. It's used both inside and between cells, so it needs to work with two different indices. An indices vector parameter is convenient for this. As road segments can be part of terraces, the weights have to be provided via parameters as well.</p>
						
						<pre translate="no">	void TriangulateRoadSegment (
		Vector3 v1, Vector3 v2, Vector3 v3,
		Vector3 v4, Vector3 v5, Vector3 v6<ins>,</ins>
		<ins>Color w1, Color w2, Vector3 indices</ins>
	) {
		roads.AddQuad(v1, v2, v4, v5);
		roads.AddQuad(v2, v3, v5, v6);
		roads.AddQuadUV(0f, 1f, 0f, 0f);
		roads.AddQuadUV(1f, 0f, 0f, 0f);
		<ins>roads.AddQuadCellData(indices, w1, w2);</ins>
		<ins>roads.AddQuadCellData(indices, w1, w2);</ins>
	}</pre>
						
						<p>Next up is <code>TriangulateRoad</code>, which creates roads inside cells. It also needs an index parameter. It passes this data on to the road methods it invokes, and adds it to the triangles it creates itself.</p>
						
						<pre translate="no">	void TriangulateRoad (
		Vector3 center, Vector3 mL, Vector3 mR,
		EdgeVertices e, bool hasRoadThroughCellEdge<ins>, float index</ins>
	) {
		if (hasRoadThroughCellEdge) {
			<ins>Vector3 indices;</ins>
			<ins>indices.x = indices.y = indices.z = index;</ins>
			Vector3 mC = Vector3.Lerp(mL, mR, 0.5f);
			TriangulateRoadSegment(
				mL, mC, mR, e.v2, e.v3, e.v4<ins>,</ins>
				<ins>weights1, weights1, indices</ins>
			);
			roads.AddTriangle(center, mL, mC);
			roads.AddTriangle(center, mC, mR);
			roads.AddTriangleUV(
				new Vector2(1f, 0f), new Vector2(0f, 0f), new Vector2(1f, 0f)
			);
			roads.AddTriangleUV(
				new Vector2(1f, 0f), new Vector2(1f, 0f), new Vector2(0f, 0f)
			);
			<ins>roads.AddTriangleCellData(indices, weights1);</ins>
			<ins>roads.AddTriangleCellData(indices, weights1);</ins>
		}
		else {
			TriangulateRoadEdge(center, mL, mR<ins>, index</ins>);
		}
	}</pre>
						
						<p>What's left is to add the required method arguments to <code>TriangulateRoad</code>, <code>TriangulateRoadEdge</code>, and <code>TriangulateRoadSegment</code> until all compiler errors are fixed.</p>
						
						<pre translate="no">	void TriangulateWithoutRiver (
		HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e
	) {
		TriangulateEdgeFan(center, e, cell.Index);

		if (cell.HasRoads) {
			Vector2 interpolators = GetRoadInterpolators(direction, cell);
			TriangulateRoad(
				center,
				Vector3.Lerp(center, e.v1, interpolators.x),
				Vector3.Lerp(center, e.v5, interpolators.y),
				e, cell.HasRoadThroughEdge(direction)<ins>, cell.Index</ins>
			);
		}
	}
	
	&hellip;
	
	void TriangulateRoadAdjacentToRiver (
		HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e
	) {
		&hellip;
		TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge<ins>, cell.Index</ins>);
		if (previousHasRiver) {
			TriangulateRoadEdge(roadCenter, center, mL<ins>, cell.Index</ins>);
		}
		if (nextHasRiver) {
			TriangulateRoadEdge(roadCenter, mR, center<ins>, cell.Index</ins>);
		}
	}
	
	&hellip;
	
	void TriangulateEdgeStrip (
		&hellip;
	) {
		&hellip;

		if (hasRoad) {
			TriangulateRoadSegment(
				e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4<ins>, w1, w2, indices</ins>
			);
		}
	}</pre>
						
						<p>Now that the mesh data is correct, we move on to the <em translate="no">Road</em> shader. It needs a vertex program and has to include <em translate="no">HexCellData</em>.</p>
						
						<pre translate="no" class="shader">		#pragma surface surf Standard fullforwardshadows decal:blend <ins>vertex:vert</ins>
		#pragma target 3.0

		<ins>#include "HexCellData.cginc"</ins></pre>
						
						<p>Because we're not blending multiple materials, we can suffice with passing a single visibility factor to the fragment program.</p>
						
						<pre translate="no" class="shader">		struct Input {
			float2 uv_MainTex;
			float3 worldPos;
			<ins>float visibility;</ins>
		};</pre>
						
						<p>The new vertex program only has to retrieve the data of two cells. We blend their visibility immediately, tweak it, and add it to the output data.</p>
						
						<pre translate="no" class="shader">		<ins>void vert (inout appdata_full v, out Input data) {</ins>
			<ins>UNITY_INITIALIZE_OUTPUT(Input, data);</ins>

			<ins>float4 cell0 = GetCellData(v, 0);</ins>
			<ins>float4 cell1 = GetCellData(v, 1);</ins>

			<ins>data.visibility = cell0.x * v.color.x + cell1.x * v.color.y;</ins>
			<ins>data.visibility = lerp(0.25, 1, data.visibility);</ins>
		<ins>}</ins></pre>
						
						<p>In the fragment program, all we have to do is factor the visibility into the color.</p>
						
						<pre translate="no" class="shader">		void surf (Input IN, inout SurfaceOutputStandard o) {
			float4 noise = tex2D(_MainTex, IN.worldPos.xz * 0.025);
			fixed4 c = _Color * <ins>(</ins>(noise.y * 0.75 + 0.25) <ins>* IN.visibility)</ins>;
			&hellip;
		}</pre>
						
						<figure>
							<img src="visibility-of-roads-and-water/road-visibility.png" width="420" height="254">
							<figcaption>Roads with visibility.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Open Water</h3>
						
						<p>It might look like water is already affected by visibility, but that's just the submerged terrain surface underneath it. Let's start with applying visibility to the open water. This requires adjustment of <code>HexGridChunk.TriangulateOpenWater</code>.</p>
						
						<pre translate="no">	void TriangulateOpenWater (
		HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center
	) {
		&hellip;

		water.AddTriangle(center, c1, c2);
		<ins>Vector3 indices;</ins>
		<ins>indices.x = indices.y = indices.z = cell.Index;</ins>
		<ins>water.AddTriangleCellData(indices, weights1);</ins>

		if (direction &lt;= HexDirection.SE &amp;&amp; neighbor != null) {
			&hellip;

			water.AddQuad(c1, c2, e1, e2);
			<ins>indices.y = neighbor.Index;</ins>
			<ins>water.AddQuadCellData(indices, weights1, weights2);</ins>

			if (direction &lt;= HexDirection.E) {
				&hellip;
				water.AddTriangle(
					c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next())
				);
				<ins>indices.z = nextNeighbor.Index;</ins>
				<ins>water.AddTriangleCellData(</ins>
					<ins>indices, weights1, weights2, weights3</ins>
				<ins>);</ins>
			}
		}
	}</pre>
						
						<p>We also have to add cell data to the triangle fans next to water shores.</p>
						
						<pre translate="no">	void TriangulateWaterShore (
		HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center
	) {
		&hellip;
		water.AddTriangle(center, e1.v1, e1.v2);
		water.AddTriangle(center, e1.v2, e1.v3);
		water.AddTriangle(center, e1.v3, e1.v4);
		water.AddTriangle(center, e1.v4, e1.v5);
		<ins>Vector3 indices;</ins>
		<ins>indices.x = indices.y = indices.z = cell.Index;</ins>
		<ins>water.AddTriangleCellData(indices, weights1);</ins>
		<ins>water.AddTriangleCellData(indices, weights1);</ins>
		<ins>water.AddTriangleCellData(indices, weights1);</ins>
		<ins>water.AddTriangleCellData(indices, weights1);</ins>
		
		&hellip;
	}</pre>
						
						<p>The <em translate="no">Water</em> shader has to be changed the same way as the <em translate="no">Road</em> shader, except that it needs to combine visibility of three cells instead of just two.</p>
						
						<pre translate="no" class="shader">		#pragma surface surf Standard alpha <ins>vertex:vert</ins>
		#pragma target 3.0

		#include "Water.cginc"
		<ins>#include "HexCellData.cginc"</ins>

		sampler2D _MainTex;

		struct Input {
			float2 uv_MainTex;
			float3 worldPos;
			<ins>float visibility;</ins>
		};

		&hellip;

		<ins>void vert (inout appdata_full v, out Input data) {</ins>
			<ins>UNITY_INITIALIZE_OUTPUT(Input, data);</ins>

			<ins>float4 cell0 = GetCellData(v, 0);</ins>
			<ins>float4 cell1 = GetCellData(v, 1);</ins>
			<ins>float4 cell2 = GetCellData(v, 2);</ins>

			<ins>data.visibility =</ins>
				<ins>cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z;</ins>
			<ins>data.visibility = lerp(0.25, 1, data.visibility);</ins>
		<ins>}</ins>

		void surf (Input IN, inout SurfaceOutputStandard o) {
			float waves = Waves(IN.worldPos.xz, _MainTex);

			fixed4 c = saturate(_Color + waves);
			o.Albedo = c.rgb <ins>* IN.visibility</ins>;
			&hellip;
		}</pre>
						
						<figure>
							<img src="visibility-of-roads-and-water/water-visibility.png" width="420" height="254">
							<figcaption>Open water with visibility.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Water Shores and Estuaries</h3>
						
						<p>To support water shores, we have to adjust <code>HexGridChunk.TriangulateWaterShore</code> once again. We already created an indices vector, but only used a single cell index for the open water. The shores also need the neighbor index, so change that.</p>
						
						<pre translate="no">		Vector3 indices;
<del>//		indices.x = indices.y = indices.z = cell.Index;</del>
		<ins>indices.x = indices.z = cell.Index;</ins>
		<ins>indices.y = neighbor.Index;</ins></pre>
						
						<p>Add the cell data to the shore quads and triangle. Also pass along the indices when invoking <code>TriangulateEstuary</code>.</p>
						
						<pre translate="no">		if (cell.HasRiverThroughEdge(direction)) {
			TriangulateEstuary(
				e1, e2, cell.IncomingRiver == direction<ins>, indices</ins>
			);
		}
		else {
			&hellip;
			waterShore.AddQuadUV(0f, 0f, 0f, 1f);
			<ins>waterShore.AddQuadCellData(indices, weights1, weights2);</ins>
			<ins>waterShore.AddQuadCellData(indices, weights1, weights2);</ins>
			<ins>waterShore.AddQuadCellData(indices, weights1, weights2);</ins>
			<ins>waterShore.AddQuadCellData(indices, weights1, weights2);</ins>
		}

		HexCell nextNeighbor = cell.GetNeighbor(direction.Next());
		if (nextNeighbor != null) {
			&hellip;
			waterShore.AddTriangleUV(
				&hellip;
			);
			<ins>indices.z = nextNeighbor.Index;</ins>
			<ins>waterShore.AddTriangleCellData(</ins>
				<ins>indices, weights1, weights2, weights3</ins>
			<ins>);</ins>
		}</pre>
						
						<p>Add the required parameter to <code>TriangulateEstuary</code> and take care of the cell data for the shore and the estuary. Remember that the estuaries are made with a trapezoid, flanked by two shore triangles. Ensure the weights are provided in the correct order.</p>
						
						<pre translate="no">	void TriangulateEstuary (
		EdgeVertices e1, EdgeVertices e2, bool incomingRiver<ins>, Vector3 indices</ins>
	) {
		waterShore.AddTriangle(e2.v1, e1.v2, e1.v1);
		waterShore.AddTriangle(e2.v5, e1.v5, e1.v4);
		waterShore.AddTriangleUV(
			new Vector2(0f, 1f), new Vector2(0f, 0f), new Vector2(0f, 0f)
		);
		waterShore.AddTriangleUV(
			new Vector2(0f, 1f), new Vector2(0f, 0f), new Vector2(0f, 0f)
		);
		<ins>waterShore.AddTriangleCellData(indices, weights2, weights1, weights1);</ins>
		<ins>waterShore.AddTriangleCellData(indices, weights2, weights1, weights1);</ins>

		estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3);
		estuaries.AddTriangle(e1.v3, e2.v2, e2.v4);
		estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5);

		estuaries.AddQuadUV(
			new Vector2(0f, 1f), new Vector2(0f, 0f),
			new Vector2(1f, 1f), new Vector2(0f, 0f)
		);
		estuaries.AddTriangleUV(
			new Vector2(0f, 0f), new Vector2(1f, 1f), new Vector2(1f, 1f)
		);
		estuaries.AddQuadUV(
			new Vector2(0f, 0f), new Vector2(0f, 0f),
			new Vector2(1f, 1f), new Vector2(0f, 1f)
		);
		<ins>estuaries.AddQuadCellData(</ins>
			<ins>indices, weights2, weights1, weights2, weights1</ins>
		<ins>);</ins>
		<ins>estuaries.AddTriangleCellData(indices, weights1, weights2, weights2);</ins>
		<ins>estuaries.AddQuadCellData(indices, weights1, weights2);</ins>
		
		&hellip;
	}</pre>
						
						<p>The <em translate="no">WaterShore</em> shader requires the same changes as the <em translate="no">Water</em> shader, blending the visibility of three cells.</p>
						
						<pre translate="no" class="shader">		#pragma surface surf Standard alpha <ins>vertex:vert</ins>
		#pragma target 3.0

		#include "Water.cginc"
		<ins>#include "HexCellData.cginc"</ins>

		sampler2D _MainTex;

		struct Input {
			float2 uv_MainTex;
			float3 worldPos;
			<ins>float visibility;</ins>
		};

		&hellip;

		<ins>void vert (inout appdata_full v, out Input data) {</ins>
			<ins>UNITY_INITIALIZE_OUTPUT(Input, data);</ins>

			<ins>float4 cell0 = GetCellData(v, 0);</ins>
			<ins>float4 cell1 = GetCellData(v, 1);</ins>
			<ins>float4 cell2 = GetCellData(v, 2);</ins>

			<ins>data.visibility =</ins>
				<ins>cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z;</ins>
			<ins>data.visibility = lerp(0.25, 1, data.visibility);</ins>
		<ins>}</ins>

		void surf (Input IN, inout SurfaceOutputStandard o) {
			&hellip;

			fixed4 c = saturate(_Color + max(foam, waves));
			o.Albedo = c.rgb <ins>* IN.visibility</ins>;
			&hellip;
		}</pre>
						
						<p>The <em translate="no">Estuary</em> shader blends the visibility of two cells, like the <em translate="no">Road</em> shader. It already has a vertex program because we needed it to pass through the river UV coordinates.</p>
						
						<pre translate="no" class="shader">		#include "Water.cginc"
		<ins>#include "HexCellData.cginc"</ins>

		sampler2D _MainTex;

		struct Input {
			float2 uv_MainTex;
			float2 riverUV;
			float3 worldPos;
			<ins>float visibility;</ins>
		};

		half _Glossiness;
		half _Metallic;
		fixed4 _Color;

		void vert (inout appdata_full v, out Input o) {
			UNITY_INITIALIZE_OUTPUT(Input, o);
			o.riverUV = v.texcoord1.xy;

			<ins>float4 cell0 = GetCellData(v, 0);</ins>
			<ins>float4 cell1 = GetCellData(v, 1);</ins>

			<ins>o.visibility = cell0.x * v.color.x + cell1.x * v.color.y;</ins>
			<ins>o.visibility = lerp(0.25, 1, o.visibility);</ins>
		}

		void surf (Input IN, inout SurfaceOutputStandard o) {
			&hellip;

			fixed4 c = saturate(_Color + water);
			o.Albedo = c.rgb <ins>* IN.visibility</ins>;
			&hellip;
		}</pre>
						
						<figure>
							<img src="visibility-of-roads-and-water/shore-visibility.png" width="420" height="254">
							<figcaption>Water shores and estuaries with visibility.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Rivers</h3>
						
						<p>The last water regions to deal with are the rivers. Add an indices vector parameter to <code>HexGridChunk.TriangulateRiverQuad</code> and add it to the mesh so it can support the visibility of two cells.</p>
						
						<pre translate="no">	void TriangulateRiverQuad (
		Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4,
		float y, float v, bool reversed<ins>, Vector3 indices</ins>
	) {
		TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed<ins>, indices</ins>);
	}

	void TriangulateRiverQuad (
		Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4,
		float y1, float y2, float v, bool reversed<ins>, Vector3 indices</ins>
	) {
		&hellip;
		<ins>rivers.AddQuadCellData(indices, weights1, weights2);</ins>
	}</pre>
						
						<p><code>TriangulateWithRiverBeginOrEnd</code> creates the end points of rivers with a quad and a triangle in the center of a cell. Add the required cell data for that.</p>
						
						<pre translate="no">	void TriangulateWithRiverBeginOrEnd (
		HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e
	) {
		&hellip;

		if (!cell.IsUnderwater) {
			bool reversed = cell.HasIncomingRiver;
			<ins>Vector3 indices;</ins>
			<ins>indices.x = indices.y = indices.z = cell.Index;</ins>
			TriangulateRiverQuad(
				m.v2, m.v4, e.v2, e.v4,
				cell.RiverSurfaceY, 0.6f, reversed<ins>, indices</ins>
			);
			center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY;
			rivers.AddTriangle(center, m.v2, m.v4);
			&hellip;
			<ins>rivers.AddTriangleCellData(indices, weights1);</ins>
		}
	}</pre>
						
						<p>We already have the cell indices in <code>TriangulateWithRiver</code>, so simply pass them along when invoking <code>TriangulateRiverQuad</code>.</p>
						
						<pre translate="no">	void TriangulateWithRiver (
		HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e
	) {
		&hellip;

		if (!cell.IsUnderwater) {
			bool reversed = cell.IncomingRiver == direction;
			TriangulateRiverQuad(
				centerL, centerR, m.v2, m.v4,
				cell.RiverSurfaceY, 0.4f, reversed<ins>, indices</ins>
			);
			TriangulateRiverQuad(
				m.v2, m.v4, e.v2, e.v4,
				cell.RiverSurfaceY, 0.6f, reversed<ins>, indices</ins>
			);
		}
	}</pre>
						
						<p>Also add support for indices to waterfalls that crash into deeper water.</p>
						
						<pre translate="no">	void TriangulateWaterfallInWater (
		Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4,
		float y1, float y2, float waterY<ins>, Vector3 indices</ins>
	) {
		&hellip;
		<ins>rivers.AddQuadCellData(indices, weights1, weights2);</ins>
	}</pre>
						
						<p>Finally, update <code>TriangulateConnection</code> so it provides the needed indices to the river and waterfall methods.</p>
						
						<pre translate="no">	void TriangulateConnection (
		HexDirection direction, HexCell cell, EdgeVertices e1
	) {
		&hellip;

		if (hasRiver) {
			e2.v3.y = neighbor.StreamBedY;
			<ins>Vector3 indices;</ins>
			<ins>indices.x = indices.z = cell.Index;</ins>
			<ins>indices.y = neighbor.Index;</ins>

			if (!cell.IsUnderwater) {
				if (!neighbor.IsUnderwater) {
					TriangulateRiverQuad(
						e1.v2, e1.v4, e2.v2, e2.v4,
						cell.RiverSurfaceY, neighbor.RiverSurfaceY, 0.8f,
						cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction<ins>,</ins>
						<ins>indices</ins>
					);
				}
				else if (cell.Elevation > neighbor.WaterLevel) {
					TriangulateWaterfallInWater(
						e1.v2, e1.v4, e2.v2, e2.v4,
						cell.RiverSurfaceY, neighbor.RiverSurfaceY,
						neighbor.WaterSurfaceY<ins>, indices</ins>
					);
				}
			}
			else if (
				!neighbor.IsUnderwater &amp;&amp;
				neighbor.Elevation > cell.WaterLevel
			) {
				TriangulateWaterfallInWater(
					e2.v4, e2.v2, e1.v4, e1.v2,
					neighbor.RiverSurfaceY, cell.RiverSurfaceY,
					cell.WaterSurfaceY<ins>, indices</ins>
				);
			}
		}

		&hellip;
	}</pre>
						
						<p>The <em translate="no">River</em> shader requires the same changes as the <em translate="no">Road</em> shader.</p>
						
						<pre translate="no" class="shader">		#pragma surface surf Standard alpha <ins>vertex:vert</ins>
		#pragma target 3.0

		#include "Water.cginc"
		<ins>#include "HexCellData.cginc"</ins>

		sampler2D _MainTex;

		struct Input {
			float2 uv_MainTex;
			<ins>float visibility;</ins>
		};

		&hellip;

		<ins>void vert (inout appdata_full v, out Input data) {</ins>
			<ins>UNITY_INITIALIZE_OUTPUT(Input, data);</ins>

			<ins>float4 cell0 = GetCellData(v, 0);</ins>
			<ins>float4 cell1 = GetCellData(v, 1);</ins>

			<ins>data.visibility = cell0.x * v.color.x + cell1.x * v.color.y;</ins>
			<ins>data.visibility = lerp(0.25, 1, data.visibility);</ins>
		<ins>}</ins>

		void surf (Input IN, inout SurfaceOutputStandard o) {
			float river = River(IN.uv_MainTex, _MainTex);
			
			fixed4 c = saturate(_Color + river);
			o.Albedo = c.rgb <ins>* IN.visibility</ins>;
			&hellip;
		}</pre>
						
						<figure>
							<img src="visibility-of-roads-and-water/rivers-visibility.png" width="420" height="254">
							<figcaption>Rivers with visibility.</figcaption>
						</figure>
					</section>
					
					<a href="visibility-of-roads-and-water/visibility-of-roads-and-water.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Features and Visibility</h2>
					
					<p>Visibility now works for the procedurally-generated terrain, but the terrain features are still unaffected by it. Buildings, farms, and trees are made by instantiating prefabs, not with procedural geometry. So we cannot add cell indices and blend weights to their vertices. As these features belong to a single cell each, we have to figure out which cell they belong to. If we can do that, we can access the relevant cell data and apply the visibility.</p>
					
					<p>We can already convert world XZ positions into cell indices. We use that to edit the terrain and manipulate units. However, the relevant code isn't trivial. It relies on integer operations and requires logic to deal with edge cases. That's isn't practical in a shader. Instead, we can bake most of the logic in a texture and use that.</p>
					
					<p>We already use a texture with a hexagonal pattern to project the grid on top of the terrain. That texture defines a 2&times;2 cell region. So it's easy to figure out which region we're in. We can then use a texture that contains X and Z offsets for the cells in that region and use that to pinpoint the cell we're in.</p>
					
					<p>Here is such a texture. The X offset is stored in its red channel and the Z offset is stored in its green channel. As it covers a 2&times;2 cell region, we need offsets between 0 and 2. This cannot be stored in a color channel, so the offsets are halved. We don't need crisp cell edges, so a small texture suffices.</p>
					
					<figure>
						<img src="features/hex-grid-coordinates.png" width="32" height="32">
						<figcaption>Grid coordinates texture.</figcaption>
					</figure>
					
					<p>Add the texture to the project. Make sure its <em translate="no">Wrap Mode</em> is set to <em translate="no">Repeat</em>, just like the other grid texture. We don't want any blending, so set its <em translate="no">Blend Mode</em> to <em translate="no">Point</em>. Also disable <em translate="no">Compression</em> so the data doesn't get messed up. Disable <em translate="no">sRGB</em> mode, to ensure that no color space conversions are performed when rendering in linear mode. Finally, we don't need mipmaps.</p>
					
					<figure>
						<img src="features/texture-import-inspector.png" width="320" height="390">
						<figcaption>Texture import settings.</figcaption>
					</figure>
					
					<section>
						<h3>Feature Shader With Visibility</h3>
						
						<p>Create a new <em translate="no">Feature</em> shader to add visibility support to features. It's a straightforward surface shader, with a vertex program. Include <em translate="no">HexCellData</em> and pass the visibility factor to the fragment program and factor it into the color, as usual. What's different is that we cannot use <code class="shader">GetCellData</code>, because the required mesh data is missing. Instead, we'll use the world position. But for now, leave visibility at 1.</p>
						
						<pre translate="no" class="shader">Shader "Custom/Feature" {
	Properties {
		_Color ("Color", Color) = (1,1,1,1)
		_MainTex ("Albedo (RGB)", 2D) = "white" {}
		_Glossiness ("Smoothness", Range(0,1)) = 0.5
		_Metallic ("Metallic", Range(0,1)) = 0.0
		<ins>[NoTilingOffset] _GridCoordinates ("Grid Coordinates", 2D) = "white" {}</ins>
	}
	SubShader {
		Tags { "RenderType"="Opaque" }
		LOD 200
		
		CGPROGRAM
		#pragma surface surf Standard fullforwardshadows vertex:vert
		#pragma target 3.0

		<ins>#include "../HexCellData.cginc"</ins>

		sampler2D _MainTex<ins>, _GridCoordinates</ins>;

		half _Glossiness;
		half _Metallic;
		fixed4 _Color;

		struct Input {
			float2 uv_MainTex;
			<ins>float visibility;</ins>
		};

		void vert (inout appdata_full v, out Input data) {
			UNITY_INITIALIZE_OUTPUT(Input, data);
			<ins>float3 pos = mul(unity_ObjectToWorld, v.vertex);</ins>

			<ins>data.visibility = 1;</ins>
		}

		void surf (Input IN, inout SurfaceOutputStandard o) {
			fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
			o.Albedo = c.rgb <ins>* IN.visibility</ins>;
			o.Metallic = _Metallic;
			o.Smoothness = _Glossiness;
			o.Alpha = c.a;
		}
		ENDCG
	}
	FallBack "Diffuse"
}</pre>
						
						<p>Change all feature materials so they use the new shader and assign the grid-coordinates texture to them.</p>
						
						<figure>
							<img src="features/urban-material.png" width="320" height="244">
							<figcaption>Urban material with grid texture.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Accessing the Cell Data</h3>
						
						<p>To sample the grid-coordinates texture in the vertex program, we again need to use <code class="shader">tex2Dlod</code> with a four-component texture coordinates vector. The first two coordinates are the world XZ position. The other two are zero, as before.</p>
						
						<pre translate="no" class="shader">		void vert (inout appdata_full v, out Input data) {
			UNITY_INITIALIZE_OUTPUT(Input, data);
			float3 pos = mul(unity_ObjectToWorld, v.vertex);

			<ins>float4 gridUV = float4(pos.xz, 0, 0);</ins>

			data.visibility = 1;
		}</pre>
						
						<p>Like in the <em translate="no">Terrain</em> shader, stretch the UV coordinates so the texture has the proper aspect ratio, matching the actual hexagonal grid.</p>
						
						<pre translate="no" class="shader">			float4 gridUV = float4(pos.xz, 0, 0);
			<ins>gridUV.x *= 1 / (4 * 8.66025404);</ins>
			<ins>gridUV.y *= 1 / (2 * 15.0);</ins></pre>
						
						<p>We can find which 2&times;2 cell patch we're in by taking the floor of the UV coordinates. This forms the basis of our cell coordinates.</p>
						
						<pre translate="no" class="shader">			float4 gridUV = float4(pos.xz, 0, 0);
			gridUV.x *= 1 / (4 * 8.66025404);
			gridUV.y *= 1 / (2 * 15.0);
			<ins>float2 cellDataCoordinates = floor(gridUV.xy);</ins></pre>
						
						<p>To find the coordinates of the cell we're in, add the offsets stored in the texture.</p>
						
						<pre translate="no" class="shader">			float2 cellDataCoordinates =
				floor(gridUV.xy) <ins>+ tex2Dlod(_GridCoordinates, gridUV).rg;</ins></pre>
						
						<p>Because the grid patch is 2&times;2 and the offsets are halved, we have to double the result to arrive at the final coordinates.</p>
						
						<pre translate="no" class="shader">			float2 cellDataCoordinates =
				floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg;
			<ins>cellDataCoordinates *= 2;</ins></pre>
						
						<p>We now have XZ cell grid coordinates, which have to be converted into cell data UV coordinates. This is done by simply shifting to the pixel centers followed by dividing by the texture sizes. Let's add a function for that to the <em translate="no">HexCellData</em> include file, also taking care of the sampling.</p>
						
						<pre translate="no" class="shader"><ins>float4 GetCellData (float2 cellDataCoordinates) {</ins>
	<ins>float2 uv = cellDataCoordinates + 0.5;</ins>
	<ins>uv.x *= _HexCellData_TexelSize.x;</ins>
	<ins>uv.y *= _HexCellData_TexelSize.y;</ins>
	<ins>return tex2Dlod(_HexCellData, float4(uv, 0, 0));</ins>
<ins>}</ins></pre>
						
						<p>Now we can use this function in the vertex program of the <em translate="no">Feature</em> shader.</p>
						
						<pre translate="no" class="shader">			cellDataCoordinates *= 2;

			<ins>data.visibility = GetCellData(cellDataCoordinates).x;</ins>
			data.visibility = <ins>lerp(0.25, 1, data.visibility)</ins>;</pre>
						
						<figure>
							<img src="features/features-visibility.png" width="420" height="254">
							<figcaption>Features with visibility.</figcaption>
						</figure>
						
						<p>Finally everything is affected by visibility, except units as they're always visible. Because we're determining the visibility of features per vertex, a feature that crosses a cell boundary will end up blending between the visibility of the cells it covers. The idea is that features are small enough that they always stay inside their cell, even when taking position perturbation into account. But some might end up with a few vertices in another cell. So our approach is cheap, but not perfect. This is most obvious for walls, which can end up oscillating between the visibility of the cells they sit between.</p>
						
						<figure>
							<img src="features/walls-visibility.png" width="420" height="160">
							<figcaption>Walls with varying visibility.</figcaption>
						</figure>
						
						<p>As the wall segments are procedurally generated, we could add cell data to their mesh and switch to the approach that we use for the terrain. Unfortunately, the wall towers are prefabs, so we'll still have those inconsistencies. In general, the current approach looks good enough for the simple geometry that we're using in this tutorial.</p>
						
						<p>The next tutorial is <a href="../part-21/index.html">Exploration</a>.</p>
					</section>
					
					<a href="features/features.unitypackage" download rel="nofollow">unitypackage</a>
					<a href="Hex-Map-20.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../../../jquery2.js"></script>
		<script src="../../tutorials.js"></script>
	</body>
</html>