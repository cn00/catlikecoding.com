<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/hex-map/part-8/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/hex-map/part-8/tutorial-image.jpg">
		<meta property="og:title" content="Hex Map 8">
		<meta property="og:description" content="A Unity Hex Map tutorial about adding support for open water. Part 8 of 27.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Hex Map 8</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/hex-map/part-8/#article",
				"headline": "Hex Map 8",
				"alternativeHeadline": "Water",
				"datePublished": "2016-08-23",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Hex Map tutorial about adding support for open water. Part 8 of 27.",
				"image": "https://catlikecoding.com/unity/tutorials/hex-map/part-8/tutorial-image.jpg",
				"dependencies": "Unity 5.3.1",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/hex-map/", "name": "Hex Map" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				EdgeVertices: 1,
				HexCell: 1,
				HexEdgeType: 1,
				HexCoordinates: 1,
				HexCoordinatesDrawer: 1,
				HexDirection: 1,
				HexDirectionExtensions: 1,
				HexGrid: 1,
				HexGridChunk: 1,
				HexMapCamera: 1,
				HexMapEditor: 1,
				HexMesh: 1,
				HexMetrics: 1,
				ListPool: 1,
				OptionalToggle: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Hex Map</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Hex Map 8</h1>
					<p>Water</p>
					<ul>
						<li>Add water to cells.</li>
						<li>Triangulate a water surface.</li>
						<li>Create shore water with foam.</li>
						<li>Make water and rivers play nice.</li>
					</ul>
				</header>

				<p>This tutorial is the eighth part of a series about <a href="../index.html">hexagon maps</a>. We have already added support for rivers. Now we're going to completely submerge cells.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>The water level is rising.</figcaption>
				</figure>
				
				<section>
					<h2>Water Level</h2>
					
					<p>The most straightforward way to support water is to define a uniform water level. All cells that have an elevation lower than that level are submerged. But it's more flexible to support water at different elevations, so let's make the water level variable. This requires each <code>HexCell</code> to keep track of its water level.</p>
					
					<pre translate="no">	<ins>public int WaterLevel {</ins>
		<ins>get {</ins>
			<ins>return waterLevel;</ins>
		<ins>}</ins>
		<ins>set {</ins>
			<ins>if (waterLevel == value) {</ins>
				<ins>return;</ins>
			<ins>}</ins>
			<ins>waterLevel = value;</ins>
			<ins>Refresh();</ins>
		<ins>}</ins>
	<ins>}</ins>
	
	<ins>int waterLevel;</ins></pre>
					
					<p>If you want to, you could enforce that certain terrain features cannot exist while underwater. But I'm not going to at this point. Things like underwater roads are fine. It might represent an area that has been recently submerged.</p>
					
					<section>
						<h3>Submerging Cells</h3>
						
						<p>Now that we have water levels, the most important question is whether a cell is underwater or not. A cell is submerged if its water level is higher than its elevation. Add a property to retrieve this information.</p>
						
						<pre translate="no">	<ins>public bool IsUnderwater {</ins>
		<ins>get {</ins>
			<ins>return waterLevel > elevation;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>This means that when the water level and elevation are equal, the cell rises above the water. So the actual water surface is somewhere below that elevation. Just like the surfaces of rivers, so let's use the same offset, <code>HexMetrics.riverSurfaceElevationOffset</code>. Change its name to be more generic.</p>
						
						<pre translate="no"><del>//	public const float riverSurfaceElevationOffset = -0.5f;</del>
	<ins>public const float waterElevationOffset = -0.5f;</ins></pre>
						
						<p>Adjust <code>HexCell.RiverSurfaceY</code> so it uses the new name. Then add a similar property for the water surface of a submerged cell.</p>
						
						<pre translate="no">	public float RiverSurfaceY {
		get {
			return
				(elevation + <ins>HexMetrics.waterElevationOffset</ins>) *
				HexMetrics.elevationStep;
		}
	}
	
	<ins>public float WaterSurfaceY {</ins>
		<ins>get {</ins>
			<ins>return</ins>
				<ins>(waterLevel + HexMetrics.waterElevationOffset) *</ins>
				<ins>HexMetrics.elevationStep;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
					</section>
					
					<section>
						<h3>Editing Water</h3>
						
						<p>Editing the water level of a cell works just like editing its elevation. So <code>HexMapEditor</code> has to keep track of the active water level, and whether it should be applied to cells.</p>
						
						<pre translate="no">	int activeElevation;
	<ins>int activeWaterLevel;</ins>

	&hellip;
	
	bool applyElevation = true;
	<ins>bool applyWaterLevel = true;</ins>
	
	</pre>
						
						<p>Add the methods to connect these settings with the UI.</p>
						
						<pre translate="no">	<ins>public void SetApplyWaterLevel (bool toggle) {</ins>
		<ins>applyWaterLevel = toggle;</ins>
	<ins>}</ins>
	
	<ins>public void SetWaterLevel (float level) {</ins>
		<ins>activeWaterLevel = (int)level;</ins>
	<ins>}</ins></pre>
						
						<p>And include the water level in <code>EditCell</code>.</p>
						
						<pre translate="no">	void EditCell (HexCell cell) {
		if (cell) {
			if (applyColor) {
				cell.Color = activeColor;
			}
			if (applyElevation) {
				cell.Elevation = activeElevation;
			}
			<ins>if (applyWaterLevel) {</ins>
				<ins>cell.WaterLevel = activeWaterLevel;</ins>
			<ins>}</ins>
			&hellip;
		}
	}</pre>
						
						<p>To add the water level to the UI, duplicate the elevation label and slider and adjust them. Don't forget to hook their events to the correct methods.</p>
						
						<figure>
							<img src="water-level/ui.png" width="108" height="374">
							<figcaption>Water level slider.</figcaption>
						</figure>
					</section>
					
					<a href="water-level/water-level.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Triangulating Water</h2>
					
					<p>We need a new mesh to triangulate the water, with a new material. First, create a <em translate="no">Water</em> shader by duplicating the <em translate="no">River</em> shader. Change it so it just uses the color property.</p>
					
					<pre translate="no" class="shader">Shader "Custom/<ins>Water</ins>" {
	Properties {
		_Color ("Color", Color) = (1,1,1,1)
		_MainTex ("Albedo (RGB)", 2D) = "white" {}
		_Glossiness ("Smoothness", Range(0,1)) = 0.5
		_Metallic ("Metallic", Range(0,1)) = 0.0
	}
	SubShader {
		Tags { "RenderType"="Transparent" "Queue"="Transparent" }
		LOD 200
		
		CGPROGRAM
		#pragma surface surf Standard alpha
		#pragma target 3.0

		sampler2D _MainTex;

		struct Input {
			float2 uv_MainTex;
		};

		half _Glossiness;
		half _Metallic;
		fixed4 _Color;

		void surf (Input IN, inout SurfaceOutputStandard o) {
			fixed4 c = <ins>_Color</ins>;
			o.Albedo = c.rgb;
			o.Metallic = _Metallic;
			o.Smoothness = _Glossiness;
			o.Alpha = c.a;
		}
		ENDCG
	}
	FallBack "Diffuse"
}</pre>
					
					<p>Create a new material with this shader, by duplicating the <em translate="no">River</em> material and changing its shader. Keep the noise texture, as we'll use it later.</p>
					
					<figure>
						<img src="triangulating-water/material.png" width="320" height="178">
						<figcaption>Water material.</figcaption>
					</figure>
					
					<p>Add a new child object to the prefab by duplicating the <em translate="no">Rivers</em> child object. It doesn't need UV coordinates, and should use the <em translate="no">Water</em> material. As usual, do this by creating a prefab instance, changing that one, then applying the changes to the prefab. Afterwards, get rid of the instance.</p>
					
					<figure>
						<img alt="hierarchy" src="triangulating-water/hierarchy.png" width="140" height="96">
						<img alt="inspector" src="triangulating-water/child-object.png" width="320" height="368">
						<figcaption>Water child object.</figcaption>
					</figure>
					
					<p>Next, add support for a water mesh to <code>HexGridChunk</code>.</p>
					
					<pre translate="no">	public HexMesh terrain, rivers, roads<ins>, water</ins>;

	public void Triangulate () {
		terrain.Clear();
		rivers.Clear();
		roads.Clear();
		<ins>water.Clear();</ins>
		for (int i = 0; i &lt; cells.Length; i++) {
			Triangulate(cells[i]);
		}
		terrain.Apply();
		rivers.Apply();
		roads.Apply();
		<ins>water.Apply();</ins>
	}</pre>
					
					<p>And make sure to connect it with the actual prefab child object.</p>
					
					<figure>
						<img src="triangulating-water/component.png" width="320" height="112">
						<figcaption>Water object connected.</figcaption>
					</figure>
					
					<section>
						<h3>Water Hexagons</h3>
						
						<p>As the water forms a second layer, let's give it its own triangulation method, per direction. We only need to invoke it when a cell is submerged.</p>
						
						<pre translate="no">	void Triangulate (HexDirection direction, HexCell cell) {
		&hellip;

		<ins>if (cell.IsUnderwater) {</ins>
			<ins>TriangulateWater(direction, cell, center);</ins>
		<ins>}</ins>
	}

	<ins>void TriangulateWater (</ins>
		<ins>HexDirection direction, HexCell cell, Vector3 center</ins>
	<ins>) {</ins>
	<ins>}</ins></pre>
						
						<p>Just as with rivers, the height of the water surface doesn't vary between cells with the same water level. As such, it looks like we don't need complex edges. A simple triangle will do.</p>
						
						<pre translate="no">	void TriangulateWater (
		HexDirection direction, HexCell cell, Vector3 center
	) {
		<ins>center.y = cell.WaterSurfaceY;</ins>
		<ins>Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction);</ins>
		<ins>Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction);</ins>

		<ins>water.AddTriangle(center, c1, c2);</ins>
	}</pre>
						
						<figure>
							<img src="triangulating-water/water-centers.png" width="390" height="240">
							<figcaption>Water hexagons.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Water Connections</h3>
						
						<p>We can connect adjacent water cells with a single quad.</p>
						
						<pre translate="no">		water.AddTriangle(center, c1, c2);

		<ins>if (direction &lt;= HexDirection.SE) {</ins>
			<ins>HexCell neighbor = cell.GetNeighbor(direction);</ins>
			<ins>if (neighbor == null || !neighbor.IsUnderwater) {</ins>
				<ins>return;</ins>
			<ins>}</ins>

			<ins>Vector3 bridge = HexMetrics.GetBridge(direction);</ins>
			<ins>Vector3 e1 = c1 + bridge;</ins>
			<ins>Vector3 e2 = c2 + bridge;</ins>

			<ins>water.AddQuad(c1, c2, e1, e2);</ins>
		<ins>}</ins></pre>
						
						<figure>
							<img src="triangulating-water/water-edge-connections.png" width="390" height="240">
							<figcaption>Water edge connections.</figcaption>
						</figure>
						
						<p>And fill the corners with a single triangle.</p>
						
						<pre translate="no">		if (direction &lt;= HexDirection.SE) {
			&hellip;

			water.AddQuad(c1, c2, e1, e2);

			<ins>if (direction &lt;= HexDirection.E) {</ins>
				<ins>HexCell nextNeighbor = cell.GetNeighbor(direction.Next());</ins>
				<ins>if (nextNeighbor == null || !nextNeighbor.IsUnderwater) {</ins>
					<ins>return;</ins>
				<ins>}</ins>
				<ins>water.AddTriangle(</ins>
					<ins>c2, e2, c2 + HexMetrics.GetBridge(direction.Next())</ins>
				<ins>);</ins>
			<ins>}</ins>
		}</pre>
						
						<figure>
							<img src="triangulating-water/water-corner-connections.png" width="390" height="240">
							<figcaption>Water corner connections.</figcaption>
						</figure>
						
						<p>We now have water cells that connect when they are adjacent. They leave a gap between themselves and dry cells with a higher elevation, but we'll deal with that later.</p>
					</section>
					
					<section>
						<h3>Consistent Water Levels</h3>
						
						<p>We have made the assumption that adjacent submerged cells have the same water level. Things look good when this is indeed the case, but it goes wrong when we violate this assumption.</p>
						
						<figure>
							<img src="triangulating-water/inconsistent-water-level.png" width="390" height="240">
							<figcaption>Inconsistent water levels.</figcaption>
						</figure>
						
						<p>We could try to force our water levels to stay at the same level. For example, when adjusting the water level of a submerged cell, we could propagate changes to adjacent cells to keep the water level synchronized. However, this process has to keep going until it encounters cells that end up not submerged. Those cells define the boundary of the water body.</p>
						
						<p>The danger of this approach is that it can quickly go out of control. An unlucky edit could submerge the entire map. Then all chunks will need to be triangulating at the same time, causing a big lag spike.</p>
						
						<p>So let's not do that now. It can be a feature of a more advanced editor. For now, it's up to the user to stay consistent.</p>
					</section>
					
					<a href="triangulating-water/triangulating-water.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Animating Water</h2>
					
					<p>Instead of using a uniform color, let's create something that looks somewhat like waves. As with our other shaders, we're not aiming for great visuals at this time. Just a suggestion of waves will do.</p>
					
					<figure>
						<img src="animating-water/flat-color.png" width="400" height="220">
						<figcaption>Perfectly flat water.</figcaption>
					</figure>
					
					<p>Let's do the same thing that we did with rivers. Sample some noise using the wold position, and add it to the uniform color. To animate it, add the time to the V coordinate.</p>
					
					<pre translate="no" class="shader">		struct Input {
			float2 uv_MainTex;
			<ins>float3 worldPos;</ins>
		};

		&hellip;

		void surf (Input IN, inout SurfaceOutputStandard o) {
			<ins>float2 uv = IN.worldPos.xz;</ins>
			<ins>uv.y += _Time.y;</ins>
			<ins>float4 noise = tex2D(_MainTex, uv * 0.025);</ins>
			<ins>float waves = noise.z;</ins>

			fixed4 c = <ins>saturate(</ins>_Color <ins>+ waves)</ins>;
			o.Albedo = c.rgb;
			o.Metallic = _Metallic;
			o.Smoothness = _Glossiness;
			o.Alpha = c.a;
		}</pre>
					
					<figure>
						<div class="vid" style="width: 320px; height:176px;"><iframe src='https://gfycat.com/ifr/AcceptableDarlingCoypu'></iframe></div>
						<figcaption>Scrolling water, time &times;10.</figcaption>
					</figure>
					
					<section>
						<h3>Two Directions</h3>
						
						<p>That doesn't look like waves at all. Let's make it more complex by adding a second noise sample, adding the time to the U coordinate this time. Use a different noise channel so you end up with two different patterns. The final waves will be these two samples added together.</p>

						<pre translate="no" class="shader">			float2 <ins>uv1</ins> = IN.worldPos.xz;
			<ins>uv1</ins>.y += _Time.y;
			float4 <ins>noise1</ins> = tex2D(_MainTex, <ins>uv1</ins> * 0.025);

			<ins>float2 uv2 = IN.worldPos.xz;</ins>
			<ins>uv2.x += _Time.y;</ins>
			<ins>float4 noise2 = tex2D(_MainTex, uv2 * 0.025);</ins>

			float waves = <ins>noise1</ins>.z <ins>+ noise2.x</ins>;</pre>
						
						<p>Summing both samples can produces results in the 0&ndash;2 range, so we have to scale that back to 0&ndash;1. Instead of just halving the waves, we can use the <code class="shader">smoothstep</code> function to create a more interesting result. We'll map &frac34;&ndash;2 to 0&ndash;1, so part of the water surface ends up without visible waves.</p>

						<pre translate="no" class="shader">			float waves = noise1.z + noise2.x;
			<ins>waves = smoothstep(0.75, 2, waves);</ins></pre>

						<figure>
							<div class="vid" style="width: 320px; height:176px;"><iframe src='https://gfycat.com/ifr/FaroffImpassionedIberianlynx'></iframe></div>
							<figcaption>Two directions, time &times;10.</figcaption>
						</figure>
					</section>

					<section>
						<h3>Blend Waves</h3>
						
						<p>It is still quite obvious that we have two scrolling noise patterns that don't actually change. It will be more convincing if the patterns changed. We can do this by interpolating between different channels of the noise samples. But we shouldn't do this uniformly, because then the entire water surface would change at the same time. That would be very obvious. Instead, we'll use a blend wave.</p>

						<p>We produce a blend wave by creating a sine wave that runs diagonally across the water surface. We do that by adding the X and Z world coordinates together and using that as input of the <code class="shader">sin</code> function. Scale them down so that we get reasonably large bands. Also add the time so it animates.</p>

						<pre translate="no" class="shader">			<ins>float blendWave =</ins>
				<ins>sin((IN.worldPos.x + IN.worldPos.z) * 0.1 + _Time.y);</ins></pre>
						
						<p>Sine waves undulate between -1 and 1, but we need a 0&ndash;1 range. We can get there by squaring the wave. To see the result in isolation, use it as the output, instead of the adjusted color.</p>
						
						<pre translate="no" class="shader">			sin((IN.worldPos.x + IN.worldPos.z) * 0.1 + _Time.y);
			<ins>blendWave *= blendWave;</ins>

			float waves = noise1.z + noise2.x;
			waves = smoothstep(0.75, 2, waves);

			fixed4 c = <ins>blendWave</ins>; <del>//saturate(_Color + waves);</del></pre>

						<figure>
							<img src="animating-water/blend-wave.png" width="400" height="220">
							<figcaption>Blend waves.</figcaption>
						</figure>

						<p>To make the blend wave a bit less obvious, add some noise to it, from both samples.</p>

						<pre translate="no" class="shader">			float blendWave = sin(
				(IN.worldPos.x + IN.worldPos.z) * 0.1 +
				<ins>(noise1.y + noise2.z) +</ins> _Time.y
			);
			blendWave *= blendWave;</pre>

						<figure>
							<img src="animating-water/blend-wave-perturbed.png" width="400" height="220">
							<figcaption>Perturbed blend waves.</figcaption>
						</figure>

						<p>Finally, use the blend wave to interpolate between two channels, for both of our noise samples. Use four different channels for maximum variety.</p>

						<pre translate="no" class="shader">			float waves =
				<ins>lerp(</ins>noise1.z<ins>, noise1.w, blendWave)</ins> +
				<ins>lerp(</ins>noise2.x<ins>, noise2.y, blendWave)</ins>;
			waves = smoothstep(0.75, 2, waves);

			fixed4 c = <ins>saturate(_Color + waves)</ins>;</pre>

						<figure>
							<div class="vid" style="width: 320px; height:176px;"><iframe src='https://gfycat.com/ifr/UnlawfulPolishedAmurminnow'></iframe></div>
							<figcaption>Wave blending, time &times;2.</figcaption>
						</figure>
					</section>
					
					<a href="animating-water/animating-water.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Shore Water</h2>
					
					<p>We are done with open water, but still have to fill the gap in the water along the shore. Because we have to match the contours of the land, the shore water requires a separate approach. Let's split <code>TriangulateWater</code> into two methods, one for open water and one for shore water. To determine whether we have a shore, we have to look at the neighbor cell. So retrieving the neighbor stays in <code>TriangulateWater</code>. If there is a neighbor and it is not underwater, then we're dealing with shore water.</p>
					
					<pre translate="no">	void TriangulateWater (
		HexDirection direction, HexCell cell, Vector3 center
	) {
		center.y = cell.WaterSurfaceY;

		<ins>HexCell neighbor = cell.GetNeighbor(direction);</ins>
		<ins>if (neighbor != null &amp;&amp; !neighbor.IsUnderwater) {</ins>
			<ins>TriangulateWaterShore(direction, cell, neighbor, center);</ins>
		<ins>}</ins>
		<ins>else {</ins>
			<ins>TriangulateOpenWater(direction, cell, neighbor, center);</ins>
		<ins>}</ins>
	}

	<ins>void TriangulateOpenWater (</ins>
		<ins>HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center</ins>
	<ins>) {</ins>
		Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction);
		Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction);

		water.AddTriangle(center, c1, c2);

		if (direction &lt;= HexDirection.SE <ins>&amp;&amp; neighbor != null</ins>) {
<del>//			HexCell neighbor = cell.GetNeighbor(direction);</del>
<del>//			if (neighbor == null || !neighbor.IsUnderwater) {</del>
<del>//				return;</del>
<del>//			}</del>
			
			Vector3 bridge = HexMetrics.GetBridge(direction);
			&hellip;
		}
	<ins>}</ins>

	<ins>void TriangulateWaterShore (</ins>
		<ins>HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center</ins>
	<ins>) {</ins>
		
	<ins>}</ins></pre>
					
					<figure>
						<img src="shore-water/shore-gaps.png" width="360" height="274">
						<figcaption>No triangulation along the shore.</figcaption>
					</figure>
					
					<p>Because the shore is perturbed, we should perturb the water triangles along the shore as well. So we need edge vertices and a triangle fan.</p>
					
					<pre translate="no">	void TriangulateWaterShore (
		HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center
	) {
		<ins>EdgeVertices e1 = new EdgeVertices(</ins>
			<ins>center + HexMetrics.GetFirstSolidCorner(direction),</ins>
			<ins>center + HexMetrics.GetSecondSolidCorner(direction)</ins>
		<ins>);</ins>
		<ins>water.AddTriangle(center, e1.v1, e1.v2);</ins>
		<ins>water.AddTriangle(center, e1.v2, e1.v3);</ins>
		<ins>water.AddTriangle(center, e1.v3, e1.v4);</ins>
		<ins>water.AddTriangle(center, e1.v4, e1.v5);</ins>
	}</pre>
					
					<figure>
						<img src="shore-water/shore-fans.png" width="360" height="274">
						<figcaption>Triangle fans along the shore.</figcaption>
					</figure>
					
					<p>Next comes the edge strip, just like for regular terrain. However, we do not have to limit ourselves to only some directions. That's because we're only invoking <code>TriangulateWaterShore</code> when we are facing a shore, which always requires a strip.</p>
					
					<pre translate="no">		water.AddTriangle(center, e1.v4, e1.v5);
		
		<ins>Vector3 bridge = HexMetrics.GetBridge(direction);</ins>
		<ins>EdgeVertices e2 = new EdgeVertices(</ins>
			<ins>e1.v1 + bridge,</ins>
			<ins>e1.v5 + bridge</ins>
		<ins>);</ins>
		<ins>water.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2);</ins>
		<ins>water.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3);</ins>
		<ins>water.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4);</ins>
		<ins>water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);</ins></pre>
					
					<figure>
						<img src="shore-water/shore-edge.png" width="360" height="274">
						<figcaption>Edge strips along the shore.</figcaption>
					</figure>
					
					<p>Likewise, we also have to add a corner triangle every time.</p>
					
					<pre translate="no">		water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);

		<ins>HexCell nextNeighbor = cell.GetNeighbor(direction.Next());</ins>
		<ins>if (nextNeighbor != null) {</ins>
			<ins>water.AddTriangle(</ins>
				<ins>e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next())</ins>
			<ins>);</ins>
		<ins>}</ins></pre>
					
					<figure>
						<img src="shore-water/shore-corners.png" width="360" height="274">
						<figcaption>Edge corners along the shore.</figcaption>
					</figure>
					
					<p>We now have complete shore water. Part of it always ends up below the terrain mesh, so there are no gaps.</p>
					
					<section>
						<h3>Shore UV</h3>
						
						<p>We could leave it like this, but it's more interesting if the shore water had some extra visuals. A foam effect, which gets stronger the closer you get to the shore. To support this, the shader has to know how close a fragment is to the shore. We could provide this information via UV coordinates.</p>
						
						<p>Our open water doesn't have UV coordinates, and it doesn't need any foam. That's only needed for the water near the shore. So the requirements of both types of water are quite different. It makes sense to give each type its own mesh. So add support for another mesh object to <code>HexGridChunk</code>.</p>
						
						<pre translate="no">	public HexMesh terrain, rivers, roads, water<ins>, waterShore</ins>;
	
	public void Triangulate () {
		terrain.Clear();
		rivers.Clear();
		roads.Clear();
		water.Clear();
		<ins>waterShore.Clear();</ins>
		for (int i = 0; i &lt; cells.Length; i++) {
			Triangulate(cells[i]);
		}
		terrain.Apply();
		rivers.Apply();
		roads.Apply();
		water.Apply();
		<ins>waterShore.Apply();</ins>
	}</pre>
						
						<p><code>TriangulateWaterShore</code> will use this new mesh.</p>
						
						<pre translate="no">	void TriangulateWaterShore (
		HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center
	) {
		&hellip;
		<ins>waterShore</ins>.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2);
		<ins>waterShore</ins>.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3);
		<ins>waterShore</ins>.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4);
		<ins>waterShore</ins>.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);

		HexCell nextNeighbor = cell.GetNeighbor(direction.Next());
		if (nextNeighbor != null) {
			<ins>waterShore</ins>.AddTriangle(
				e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next())
			);
		}
	}</pre>
						
						<p>Duplicate the water object, connect it with the prefab, and configure it to use UV coordinates. Also create a shader and material for the shore water, by duplicating the existing water shader and material.</p>
						
						<figure>
							<img src="shore-water/water-shore-object.png" width="320" height="240">
							<figcaption>Water shore object and material, with UV.</figcaption>
						</figure>
						
						<p>Adjust the <em translate="no">Water Shore</em> shader so it shows the UV coordinates instead of water.</p>
						
						<pre translate="no" class="shader">			fixed4 c = <ins>fixed4(IN.uv_MainTex, 1, 1)</ins>;</pre>
						
						<p>As we're not setting the coordinates yet, it will produce a solid color. This makes it easy to see that the water shore indeed uses a separate mesh and material.</p>
						
						<figure>
							<img src="shore-water/shore-mesh.png" width="360" height="274">
							<figcaption>Separate mesh for the water shore.</figcaption>
						</figure>
						
						<p>Let's put the information about the shore in the V coordinate. Set it to 0 on the water side and to 1 on the land side. As we don't need to communicate anything else, all U coordinates can just be 0.</p>
						
						<pre translate="no">		waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2);
		waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3);
		waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4);
		waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);
		<ins>waterShore.AddQuadUV(0f, 0f, 0f, 1f);</ins>
		<ins>waterShore.AddQuadUV(0f, 0f, 0f, 1f);</ins>
		<ins>waterShore.AddQuadUV(0f, 0f, 0f, 1f);</ins>
		<ins>waterShore.AddQuadUV(0f, 0f, 0f, 1f);</ins>

		HexCell nextNeighbor = cell.GetNeighbor(direction.Next());
		if (nextNeighbor != null) {
			waterShore.AddTriangle(
				e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next())
			);
			<ins>waterShore.AddTriangleUV(</ins>
				<ins>new Vector2(0f, 0f),</ins>
				<ins>new Vector2(0f, 1f),</ins>
				<ins>new Vector2(0f, 0f)</ins>
			<ins>);</ins>
		}</pre>
						
						<figure>
							<img src="shore-water/shore-transition-wrong.png" width="320" height="240">
							<figcaption>Shore transitions, incorrect.</figcaption>
						</figure>
						
						<p>The above code works for edges, but goes wrong for some of the corners. If the next neighbor is underwater, the current approach is correct. But when the next neighbor is not underwater, then the third vertex of the triangle is below land.</p>
						
						<pre translate="no">			waterShore.AddTriangleUV(
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(0f, <ins>nextNeighbor.IsUnderwater ? 0f : 1f</ins>)
			);</pre>
						
						<figure>
							<img src="shore-water/shore-transition-correct.png" width="320" height="240">
							<figcaption>Shore transitions, correct.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Shore Foam</h3>
						
						<p>Now that the shore transitions are correct, we can use them to create some foam effects. The simplest approach is to add the shore value to the uniform color.</p>
						
						<pre translate="no" class="shader">		void surf (Input IN, inout SurfaceOutputStandard o) {
			<ins>float shore = IN.uv_MainTex.y;</ins>
			
			<ins>float foam = shore;</ins>

			fixed4 c = <ins>saturate(_Color + foam)</ins>;
			o.Albedo = c.rgb;
			o.Metallic = _Metallic;
			o.Smoothness = _Glossiness;
			o.Alpha = c.a;
		}</pre>
						
						<figure>
							<img src="shore-water/foam-linear.png" width="310" height="180">
							<figcaption>Linear foam.</figcaption>
						</figure>
						
						<p>To make it more interesting, factor a squared sine wave into it.</p>
						
						<pre translate="no" class="shader">			float foam = <ins>sin(</ins>shore <ins>* 10)</ins>;
			<ins>foam *= foam * shore;</ins></pre>
						
						<figure>
							<img src="shore-water/foam-sine.png" width="310" height="180">
							<figcaption>Fading squared sine foam.</figcaption>
						</figure>
						
						<p>Let's make the foam front grow bigger as it approaches the shore. This can be done by taking the square root of the shore value before using it.</p>
						
						<pre translate="no" class="shader">			float shore = IN.uv_MainTex.y;
			<ins>shore = sqrt(shore);</ins></pre>
						
						<figure>
							<img src="shore-water/foam-sqrt.png" width="310" height="180">
							<figcaption>Foam becomes stronger near the shore.</figcaption>
						</figure>
						
						<p>Add some distortion to make it look more natural. Make the distortion grow weaker the closer it gets to the shore. That way it will better match the coastline.</p>
						
						<pre translate="no" class="shader">			<ins>float2 noiseUV = IN.worldPos.xz;</ins>
			<ins>float4 noise = tex2D(_MainTex, noiseUV * 0.015);</ins>

			<ins>float distortion = noise.x * (1 - shore);</ins>
			float foam = sin(<ins>(</ins>shore <ins>+ distortion)</ins> * 10);
			foam *= foam * shore;</pre>
						
						<figure>
							<img src="shore-water/foam-distorted.png" width="310" height="180">
							<figcaption>Perturbed foam.</figcaption>
						</figure>
						
						<p>And of course animate it all, both the sine wave and the distortion.</p>
						
						<pre translate="no" class="shader">			float2 noiseUV = IN.worldPos.xz <ins>+ _Time.y * 0.25</ins>;
			float4 noise = tex2D(_MainTex, noiseUV * 0.015);

			float distortion = noise.x * (1 - shore);
			float foam = sin((shore + distortion) * 10 <ins>- _Time.y</ins>);
			foam *= foam * shore;</pre>
						
						<figure>
							<div class="vid" style="width: 320px; height:186px;"><iframe src='https://gfycat.com/ifr/SpryWideeyedBrownbear'></iframe></div>
							<figcaption>Animated foam.</figcaption>
						</figure>
						
						<p>Besides advancing foam, there is also receding foam. Let's add a second sine wave that moves in the opposite direction to simulate that. Make it a little weaker and give it a time offset. The final foam is the maximum of these two sine waves.</p>
						
						<pre translate="no" class="shader">			float <ins>distortion1</ins> = noise.x * (1 - shore);
			float <ins>foam1</ins> = sin((shore + <ins>distortion1</ins>) * 10 - _Time.y);
			<ins>foam1</ins> *= <ins>foam1</ins>;

			<ins>float distortion2 = noise.y * (1 - shore);</ins>
			<ins>float foam2 = sin((shore + distortion2) * 10 + _Time.y + 2);</ins>
			<ins>foam2 *= foam2 * 0.7;</ins>

			<ins>float foam = max(foam1, foam2) * shore;</ins></pre>
						
						<figure>
							<div class="vid" style="width: 320px; height:186px;"><iframe src='https://gfycat.com/ifr/SerpentineAlarmedBlackpanther'></iframe></div>
							<figcaption>Advancing and receding foam.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Bleding Waves and Foam</h3>
						
						<p>There is a harsh transition between the open and shore water, because the waves from the open water are not included in the water shore. To fix this, we have to include those waves in the <em translate="no">Water Shore</em> shader as well.</p>
						
						<p>Instead of copying the wave code, let's put it in a <em translate="no">Water.cginc</em> include file. In fact, put both the code for foam and wave in it, each as a separate function.</p>
						
						<aside>
							<h3>How do shader include files work?</h3>
							<div>
								<p>Creating your own shader include file is covered in <a href="../../rendering/part-5/index.html">Rendering 5, Multiple Lights</a>.</p>
							</div>
						</aside>
						
						<pre translate="no" class="shader"><ins>float Foam (float shore, float2 worldXZ, sampler2D noiseTex) {</ins>
<del>//	float shore = IN.uv_MainTex.y;</del>
	shore = sqrt(shore);

	float2 noiseUV = <ins>worldXZ</ins> + _Time.y * 0.25;
	float4 noise = tex2D(<ins>noiseTex</ins>, noiseUV * 0.015);

	float distortion1 = noise.x * (1 - shore);
	float foam1 = sin((shore + distortion1) * 10 - _Time.y);
	foam1 *= foam1;

	float distortion2 = noise.y * (1 - shore);
	float foam2 = sin((shore + distortion2) * 10 + _Time.y + 2);
	foam2 *= foam2 * 0.7;

	<ins>return</ins> max(foam1, foam2) * shore;
<ins>}</ins>

<ins>float Waves (float2 worldXZ, sampler2D noiseTex) {</ins>
	float2 uv1 = <ins>worldXZ</ins>;
	uv1.y += _Time.y;
	float4 noise1 = tex2D(<ins>noiseTex</ins>, uv1 * 0.025);

	float2 uv2 = <ins>worldXZ</ins>;
	uv2.x += _Time.y;
	float4 noise2 = tex2D(<ins>noiseTex</ins>, uv2 * 0.025);

	float blendWave = sin(
		(<ins>worldXZ</ins>.x + <ins>worldXZ.y</ins>) * 0.1 +
		(noise1.y + noise2.z) + _Time.y
	);
	blendWave *= blendWave;

	float waves =
		lerp(noise1.z, noise1.w, blendWave) +
		lerp(noise2.x, noise2.y, blendWave);
	<ins>return</ins> smoothstep(0.75, 2, waves);
<ins>}</ins></pre>
						
						<p>Adjust the <em translate="no">Water</em> shader so it uses our new include file.</p>
						
						<pre translate="no" class="shader">		<ins>#include "Water.cginc"</ins>

		sampler2D _MainTex;

		&hellip;

		void surf (Input IN, inout SurfaceOutputStandard o) {
			<ins>float waves = Waves(IN.worldPos.xz, _MainTex);</ins>

			fixed4 c = saturate(_Color + waves);
			o.Albedo = c.rgb;
			o.Metallic = _Metallic;
			o.Smoothness = _Glossiness;
			o.Alpha = c.a;
		}</pre>
						
						<p>In the <em translate="no">Water Shore</em> shader, compute both the foam and waves values. Then fade the waves as they approach the shore. The final result the maximum of the foam and waves.</p>
						
						<pre translate="no" class="shader">		<ins>#include "Water.cginc"</ins>

		sampler2D _MainTex;

		&hellip;

		void surf (Input IN, inout SurfaceOutputStandard o) {
			<ins>float shore = IN.uv_MainTex.y;</ins>
			<ins>float foam = Foam(shore, IN.worldPos.xz, _MainTex);</ins>
			<ins>float waves = Waves(IN.worldPos.xz, _MainTex);</ins>
			<ins>waves *= 1 - shore;</ins>

			fixed4 c = saturate(_Color + <ins>max(foam, waves)</ins>);
			o.Albedo = c.rgb;
			o.Metallic = _Metallic;
			o.Smoothness = _Glossiness;
			o.Alpha = c.a;
		}</pre>
						
						<figure>
							<div class="vid" style="width: 320px; height:186px;"><iframe src='https://gfycat.com/ifr/ImpoliteNearAbyssiniangroundhornbill'></iframe></div>
							<figcaption>Blending foam and waves.</figcaption>
						</figure>
					</section>
					
					<a href="shore-water/shore-water.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>More Shore Water</h2>
					
					<p>Part of the water shore mesh ends up hidden below the terrain mesh. This is fine when only a small part is hidden. Unfortunately, steep cliffs end up hiding most of the shore water, and thus also the foam.</p>
					
					<figure>
						<img src="more-shore-water/problem.png" width="250" height="210">
						<figcaption>Mostly hidden shore water.</figcaption>
					</figure>
					
					<p>We can combat this by increasing the size of the water shore strip. This can be done by decreasing the radius of the water hexagons. To do so, <code>HexMetrics</code> needs a water factor to accompany its solid factor, plus methods to get the water corners.</p>
					
					<p>The solid factor is 0.8. To double the size of the water connections, we have to set the water factor to 0.6.</p>
					
					<pre translate="no">	<ins>public const float waterFactor = 0.6f;</ins>
	
	<ins>public static Vector3 GetFirstWaterCorner (HexDirection direction) {</ins>
		<ins>return corners[(int)direction] * waterFactor;</ins>
	<ins>}</ins>

	<ins>public static Vector3 GetSecondWaterCorner (HexDirection direction) {</ins>
		<ins>return corners[(int)direction + 1] * waterFactor;</ins>
	<ins>}</ins></pre>
					
					<p>Use these new methods in <code>HexGridChunk</code> to find the water corners.</p>
					
					<pre translate="no">	void TriangulateOpenWater (
		HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center
	) {
		Vector3 c1 = center + HexMetrics.<ins>GetFirstWaterCorner</ins>(direction);
		Vector3 c2 = center + HexMetrics.<ins>GetSecondWaterCorner</ins>(direction);

		&hellip;
	}
	
	void TriangulateWaterShore (
		HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center
	) {
		EdgeVertices e1 = new EdgeVertices(
			center + HexMetrics.<ins>GetFirstWaterCorner</ins>(direction),
			center + HexMetrics.<ins>GetSecondWaterCorner</ins>(direction)
		);
		&hellip;
	}</pre>
					
					<figure>
						<img src="more-shore-water/water-corners.png" width="360" height="280">
						<figcaption>Using water corners.</figcaption>
					</figure>
					
					<p>The distance between the water hexagons has indeed doubled. Now <code>HexMetrics</code> must also provide a water bridge method.</p>
					
					<pre translate="no">	<ins>public const float waterBlendFactor = 1f - waterFactor;</ins>
	
	<ins>public static Vector3 GetWaterBridge (HexDirection direction) {</ins>
		<ins>return (corners[(int)direction] + corners[(int)direction + 1]) *</ins>
			<ins>waterBlendFactor;</ins>
	<ins>}</ins></pre>
					
					<p>Adjust <code>HexGridChunk</code> to use the new method.</p>
					
					<pre translate="no">	void TriangulateOpenWater (
		HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center
	) {
		&hellip;

		if (direction &lt;= HexDirection.SE &amp;&amp; neighbor != null) {
			Vector3 bridge = HexMetrics.<ins>GetWaterBridge</ins>(direction);
			&hellip;

			if (direction &lt;= HexDirection.E) {
				&hellip;
				water.AddTriangle(
					c2, e2, c2 + HexMetrics.<ins>GetWaterBridge</ins>(direction.Next())
				);
			}
		}
	}

	void TriangulateWaterShore (
		HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center
	) {
		&hellip;
		
		Vector3 bridge = HexMetrics.<ins>GetWaterBridge</ins>(direction);
		&hellip;

		HexCell nextNeighbor = cell.GetNeighbor(direction.Next());
		if (nextNeighbor != null) {
			waterShore.AddTriangle(
				e1.v5, e2.v5, e1.v5 +
					HexMetrics.<ins>GetWaterBridge</ins>(direction.Next())
			);
			&hellip;
		}
	}</pre>
					
					<figure>
						<img src="more-shore-water/water-bridges.png" width="360" height="280">
						<figcaption>Long water bridges.</figcaption>
					</figure>
					
					<section>
						<h3>Between Water and Solid Edges</h3>
						
						<p>While this gives us more space for the foam, there is now also a much larger part of it hidden below the terrain. Ideally, we could use the water edge on the water side, and the solid edge on the land side.</p>
						
						<p>We cannot use a simple bridge to find the opposite solid edge, when starting with water corners. Instead, we can work backwards from the center of the neighbor. Adjust <code>TriangulateWaterShore</code> so it uses this new approach.</p>
						
						<pre translate="no"><del>//		Vector3 bridge = HexMetrics.GetWaterBridge(direction);</del>
		<ins>Vector3 center2 = neighbor.Position;</ins>
		<ins>center2.y = center.y;</ins>
		EdgeVertices e2 = new EdgeVertices(
			<ins>center2</ins> + <ins>HexMetrics.GetSecondSolidCorner(direction.Opposite())</ins>,
			<ins>center2</ins> + <ins>HexMetrics.GetFirstSolidCorner(direction.Opposite())</ins>
		);
		&hellip;

		HexCell nextNeighbor = cell.GetNeighbor(direction.Next());
		if (nextNeighbor != null) {
			<ins>Vector3 center3 = nextNeighbor.Position;</ins>
			<ins>center3.y = center.y;</ins>
			waterShore.AddTriangle(
				e1.v5, e2.v5, <ins>center3</ins> +
					<ins>HexMetrics.GetFirstSolidCorner(direction.Previous())</ins>
			);
			&hellip;
		}</pre>
						
						<figure>
							<img src="more-shore-water/corners-wrong.png" width="360" height="280">
							<figcaption>Incorrect edge corners.</figcaption>
						</figure>
						
						<p>This works, except that once again we have two cases to consider for the corner triangles.</p>
						
						<pre translate="no">		HexCell nextNeighbor = cell.GetNeighbor(direction.Next());
		if (nextNeighbor != null) {
<del>//			Vector3 center3 = nextNeighbor.Position;</del>
<del>//			center3.y = center.y;</del>
			<ins>Vector3 v3 = nextNeighbor.Position + (nextNeighbor.IsUnderwater ?</ins>
				<ins>HexMetrics.GetFirstWaterCorner(direction.Previous()) :</ins>
				<ins>HexMetrics.GetFirstSolidCorner(direction.Previous()));</ins>
			<ins>v3.y = center.y;</ins>
			waterShore.AddTriangle(e1.v5, e2.v5, <ins>v3</ins>);
			waterShore.AddTriangleUV(
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(0f, nextNeighbor.IsUnderwater ? 0f : 1f)
			);
		}</pre>
						
						<figure>
							<img src="more-shore-water/corners-correct.png" width="360" height="280">
							<figcaption>Correct edge corners.</figcaption>
						</figure>
						
						<p>This works nice, except that the foam can get quite pronounced when most of it is visible. To compensate, you can make the effect a little weaker by scaling down the shore value in the shader.</p>
						
						<pre translate="no" class="shader">	shore = sqrt(shore) <ins>* 0.9</ins>;</pre>
						
						<figure>
							<div class="vid" style="width: 320px; height:186px;"><iframe src='https://gfycat.com/ifr/FragrantGrandioseKangaroo'></iframe></div>
							<figcaption>Final foam.</figcaption>
						</figure>
					</section>
					
					<a href="more-shore-water/more-shore-water.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Underwater Rivers</h2>
					
					<p>Our water is complete, at least when there aren't any rivers flowing into it. As water and rivers are currently oblivious to each other, the rivers will flow through and underneath the water.</p>
					
					<figure>
						<img src="underwater-rivers/rivers-and-water.png" width="360" height="240">
						<figcaption>Rivers flowing into the water.</figcaption>
					</figure>
					
					<p>The order in which semitransparent objects are rendered depends on their distance from the camera. The nearest objects are rendered last, which ensures they end up on top. As you move the camera around, this means that sometimes rivers, and sometimes water ends up on top of the other. Let's begin by making the rendering order consistent. Rivers should be drawn on top of the water, so waterfalls are correctly displayed. We can enforce this by changing the queue of the <em translate="no">River</em> shader.</p>
					
					<pre translate="no" class="shader">		Tags { "RenderType"="Transparent" "Queue"="Transparent<ins>+1</ins>" }</pre>
					
					<figure>
						<img src="underwater-rivers/rivers-on-top.png" width="360" height="240">
						<figcaption>Drawing rivers last.</figcaption>
					</figure>
					
					<section>
						<h3>Hiding Underwater Rivers</h3>
						
						<p>While it is fine for a stream bed to exist underwater, and water might actually flow through it, we shouldn't be able to see this water. Especially not rendered on top of the actual water surface. We can get rid of the underwater river's water by making sure to only add river segments when the current cell in not underwater.</p>
						
						<pre translate="no">	void TriangulateWithRiverBeginOrEnd (
		HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e
	) {
		&hellip;

		<ins>if (!cell.IsUnderwater) {</ins>
			bool reversed = cell.HasIncomingRiver;
			&hellip;
		<ins>}</ins>
	}
	
	void TriangulateWithRiver (
		HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e
	) {
		&hellip;

		<ins>if (!cell.IsUnderwater) {</ins>
			bool reversed = cell.IncomingRiver == direction;
			&hellip;
		<ins>}</ins>
	}</pre>
						
						<p>For <code>TriangulateConnection</code>, let's start by only adding the river segment when neither the current nor the neighbor cell is underwater.</p>
						
						<pre translate="no">		if (cell.HasRiverThroughEdge(direction)) {
			e2.v3.y = neighbor.StreamBedY;

			<ins>if (!cell.IsUnderwater &amp;&amp; !neighbor.IsUnderwater) {</ins>
				TriangulateRiverQuad(
					e1.v2, e1.v4, e2.v2, e2.v4,
					cell.RiverSurfaceY, neighbor.RiverSurfaceY, 0.8f,
					cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction
				);
			<ins>}</ins>
		}</pre>
						
						<figure>
							<img src="underwater-rivers/no-underwater-rivers.png" width="360" height="240">
							<figcaption>No more underwater rivers.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Waterfalls</h3>
						
						<p>The underwater rivers are gone, but now we get gaps in the rivers where they meet the water surface. Rivers on the same level as the water get small gaps or overlaps. But most obvious are the lacking waterfalls for rivers that come from a higher elevation. Let's deal with those first.</p>
						
						<p>The river segment of a waterfall used to pass through the water surface. It ended up partially above, and partially below the water. We have to keep the part above the water level, discarding the rest. That requires some work, so let's create a separate method for that.</p>
						
						<p>The new method requires four vertices, two river levels, and the water level. We'll align it so we're looking in the direction of the flow, down the waterfall. So the first two vertices and the left and right side at the top, followed by those for the bottom.</p>
						
						<pre translate="no">	<ins>void TriangulateWaterfallInWater (</ins>
		<ins>Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4,</ins>
		<ins>float y1, float y2, float waterY</ins>
	<ins>) {</ins>
		<ins>v1.y = v2.y = y1;</ins>
		<ins>v3.y = v4.y = y2;</ins>
		<ins>rivers.AddQuad(v1, v2, v3, v4);</ins>
		<ins>rivers.AddQuadUV(0f, 1f, 0.8f, 1f);</ins>
	<ins>}</ins></pre>
						
						<p>Invoke this method in <code>TriangulateConnection</code>, when the neighbor ends up underwater and we have a waterfall.</p>
						
						<pre translate="no">			if (!cell.IsUnderwater<ins>) {</ins>
				<ins>if (</ins>!neighbor.IsUnderwater) {
					TriangulateRiverQuad(
						e1.v2, e1.v4, e2.v2, e2.v4,
						cell.RiverSurfaceY, neighbor.RiverSurfaceY, 0.8f,
						cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction
					);
				<ins>}</ins>
				<ins>else if (cell.Elevation > neighbor.WaterLevel) {</ins>
					<ins>TriangulateWaterfallInWater(</ins>
						<ins>e1.v2, e1.v4, e2.v2, e2.v4,</ins>
						<ins>cell.RiverSurfaceY, neighbor.RiverSurfaceY,</ins>
						<ins>neighbor.WaterSurfaceY</ins>
					<ins>);</ins>
				<ins>}</ins>
			}</pre>
						
						<p>We also have to deal with waterfalls in the opposite direction, when the current cell is underwater and the neighbor isn't.</p>
						
						<pre translate="no">			if (!cell.IsUnderwater) {
				&hellip;
			}
			<ins>else if (</ins>
				<ins>!neighbor.IsUnderwater &amp;&amp;</ins>
				<ins>neighbor.Elevation > cell.WaterLevel</ins>
			<ins>) {</ins>
				<ins>TriangulateWaterfallInWater(</ins>
					<ins>e2.v4, e2.v2, e1.v4, e1.v2,</ins>
					<ins>neighbor.RiverSurfaceY, cell.RiverSurfaceY,</ins>
					<ins>cell.WaterSurfaceY</ins>
				<ins>);</ins>
			<ins>}</ins></pre>
						
						<p>This again produces the original river quad. Next, we have to adjust <code>TriangulateWaterfallInWater</code> so it pulls the bottom vertices up to the water level. Unfortunately, we cannot suffice with only adjusting their Y coordinates. That would pull the waterfall away from the cliff, which can lead to gaps. Instead, we have to pull the bottom vertices towards the top vertices, via interpolation.</p>
						
						<figure>
							<img src="underwater-rivers/interpolation.png" width="155" height="150">
							<figcaption>Interpolating.</figcaption>
						</figure>
						
						<p>To move the bottom vertices upward, divide their distance below the water surface by the height of the waterfall. That gives us the interpolator value.</p>
						
						<pre translate="no">		v1.y = v2.y = y1;
		v3.y = v4.y = y2;
		<ins>float t = (waterY - y2) / (y1 - y2);</ins>
		<ins>v3 = Vector3.Lerp(v3, v1, t);</ins>
		<ins>v4 = Vector3.Lerp(v4, v2, t);</ins>
		rivers.AddQuad(v1, v2, v3, v4);
		rivers.AddQuadUV(0f, 1f, 0.8f, 1f);</pre>
						
						<p>The result is a shorter waterfall that still has the same orientation. However, because the positions of the bottom vertices have changed, they will be perturbed differently than the original vertices. This means that the end result still does not match the original waterfall. To solve this, we have to manually perturb the vertices before interpolating, and then add an unperturbed quad.</p>
						
						<pre translate="no">		v1.y = v2.y = y1;
		v3.y = v4.y = y2;
		<ins>v1 = HexMetrics.Perturb(v1);</ins>
		<ins>v2 = HexMetrics.Perturb(v2);</ins>
		<ins>v3 = HexMetrics.Perturb(v3);</ins>
		<ins>v4 = HexMetrics.Perturb(v4);</ins>
		float t = (waterY - y2) / (y1 - y2);
		v3 = Vector3.Lerp(v3, v1, t);
		v4 = Vector3.Lerp(v4, v2, t);
		rivers.<ins>AddQuadUnperturbed</ins>(v1, v2, v3, v4);
		rivers.AddQuadUV(0f, 1f, 0.8f, 1f);</pre>
						
						<p>While we already have an unperturbed variant method for adding triangles, we actually don't have one for quads yet. So add the required <code>HexMesh.AddQuadUnperturbed</code> method.</p>
						
						<pre translate="no">	public void <ins>AddQuadUnperturbed</ins> (
		Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4
	) {
		int vertexIndex = vertices.Count;
		vertices.Add(<ins>v1</ins>);
		vertices.Add(<ins>v2</ins>);
		vertices.Add(<ins>v3</ins>);
		vertices.Add(<ins>v4</ins>);
		triangles.Add(vertexIndex);
		triangles.Add(vertexIndex + 2);
		triangles.Add(vertexIndex + 1);
		triangles.Add(vertexIndex + 1);
		triangles.Add(vertexIndex + 2);
		triangles.Add(vertexIndex + 3);
	}</pre>
						
						<figure>
							<img src="underwater-rivers/waterfalls.png" width="360" height="240">
							<figcaption>Waterfalls end at the water surface.</figcaption>
						</figure>
					</section>
					
					<a href="underwater-rivers/underwater-rivers.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Estuaries</h2>

					<p>When rivers flow at the same height as the water surface, the river mesh touches the shore mesh. If this were a river flowing into a sea or ocean, this is where the river stream meets the tide. As such, we'll refer to these regions as estuaries.</p>
					
					<figure>
						<img src="estuaries/river-meets-foam.png" width="300" height="150">
						<figcaption>River meets shore, without vertex perturbation.</figcaption>
					</figure>
					
					<p>There are currently two problems with estuaries. First, river quads connect the 2<sup>nd</sup> and 4<sup>th</sup> edge vertices, skipping the 3<sup>rd</sup>. As the water shore does use the 3<sup>rd</sup> vertex, it can end up creating a gap or an overlap. We can solve this by adjusting the geometry of the estuaries.</p>
					
					<p>The second problem is that there is a harsh transition between the foam and river materials. To solve this, we need yet another material, which blends between the river and water shore effects.</p>
					
					<p>This means that estuaries require special treatment, so let's create a separate method for them. It should be invoked in <code>TriangulateWaterShore</code>, when there is a river flowing through the current direction.</p>
					
					<pre translate="no">	void TriangulateWaterShore (
		HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center
	) {
		&hellip;

		<ins>if (cell.HasRiverThroughEdge(direction)) {</ins>
			<ins>TriangulateEstuary(e1, e2);</ins>
		<ins>}</ins>
		<ins>else {</ins>
			waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2);
			waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3);
			waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4);
			waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);
			waterShore.AddQuadUV(0f, 0f, 0f, 1f);
			waterShore.AddQuadUV(0f, 0f, 0f, 1f);
			waterShore.AddQuadUV(0f, 0f, 0f, 1f);
			waterShore.AddQuadUV(0f, 0f, 0f, 1f);
		<ins>}</ins>

		&hellip;
	}

	<ins>void TriangulateEstuary (EdgeVertices e1, EdgeVertices e2) {</ins>
	<ins>}</ins></pre>
					
					<p>The region that blends both effects doesn't need to fill the entire edge strip. We can suffice with a trapezoid shape. So we can use two water shore triangles at the sides.</p>
					
					<pre translate="no">	void TriangulateEstuary (EdgeVertices e1, EdgeVertices e2) {
		<ins>waterShore.AddTriangle(e2.v1, e1.v2, e1.v1);</ins>
		<ins>waterShore.AddTriangle(e2.v5, e1.v5, e1.v4);</ins>
		<ins>waterShore.AddTriangleUV(</ins>
			<ins>new Vector2(0f, 1f), new Vector2(0f, 0f), new Vector2(0f, 0f)</ins>
		<ins>);</ins>
		<ins>waterShore.AddTriangleUV(</ins>
			<ins>new Vector2(0f, 1f), new Vector2(0f, 0f), new Vector2(0f, 0f)</ins>
		<ins>);</ins>
	}</pre>
					
					<figure>
						<img src="estuaries/hole.png" width="300" height="150">
						<figcaption>Trapezoidal hole for the blend region.</figcaption>
					</figure>
					
					<section>
						<h3>UV2 Coordinates</h3>
						
						<p>To create the river effect, we need UV coordinates. But to create the foam effect, we also need UV coordinates. So when blending both, we end up requiring two sets of UV coordinates. Fortunately, Unity's meshes can support up to four UV sets. We just have to add support for a second set to <code>HexMesh</code>.</p>
						
						<pre translate="no">	public bool useCollider, useColors, useUVCoordinates<ins>, useUV2Coordinates</ins>;

	[NonSerialized] List&lt;Vector2> uvs<ins>, uv2s</ins>;
	
	public void Clear () {
		&hellip;
		if (useUVCoordinates) {
			uvs = ListPool&lt;Vector2>.Get();
		}
		<ins>if (useUV2Coordinates) {</ins>
			<ins>uv2s = ListPool&lt;Vector2>.Get();</ins>
		<ins>}</ins>
		triangles = ListPool&lt;int>.Get();
	}

	public void Apply () {
		&hellip;
		if (useUVCoordinates) {
			hexMesh.SetUVs(0, uvs);
			ListPool&lt;Vector2>.Add(uvs);
		}
		<ins>if (useUV2Coordinates) {</ins>
			<ins>hexMesh.SetUVs(1, uv2s);</ins>
			<ins>ListPool&lt;Vector2>.Add(uv2s);</ins>
		<ins>}</ins>
		&hellip;
	}</pre>
						
						<p>To add to the second UV set, duplicate the UV methods and adjust them as you would expect.</p>
						
						<pre translate="no">	public void <ins>AddTriangleUV2</ins> (Vector2 uv1, Vector2 uv2, Vector3 uv3) {
		<ins>uv2s</ins>.Add(uv1);
		<ins>uv2s</ins>.Add(uv2);
		<ins>uv2s</ins>.Add(uv3);
	}
	
	public void <ins>AddQuadUV2</ins> (Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4) {
		<ins>uv2s</ins>.Add(uv1);
		<ins>uv2s</ins>.Add(uv2);
		<ins>uv2s</ins>.Add(uv3);
		<ins>uv2s</ins>.Add(uv4);
	}

	public void <ins>AddQuadUV2</ins> (float uMin, float uMax, float vMin, float vMax) {
		<ins>uv2s</ins>.Add(new Vector2(uMin, vMin));
		<ins>uv2s</ins>.Add(new Vector2(uMax, vMin));
		<ins>uv2s</ins>.Add(new Vector2(uMin, vMax));
		<ins>uv2s</ins>.Add(new Vector2(uMax, vMax));
	}</pre>
					</section>
					
					<section>
						<h3>River Shader Function</h3>
						
						<p>Because we're going to use the river effect in two shaders, move the code from the <em translate="no">River</em> shader to a new function in the <em translate="no">Water</em> include file.</p>
						
						<pre translate="no" class="shader"><ins>float River (float2 riverUV, sampler2D noiseTex) {</ins>
	float2 uv = <ins>riverUV</ins>;
	uv.x = uv.x * 0.0625 + _Time.y * 0.005;
	uv.y -= _Time.y * 0.25;
	float4 noise = tex2D(<ins>noiseTex</ins>, uv);

	float2 uv2 = <ins>riverUV</ins>;
	uv2.x = uv2.x * 0.0625 - _Time.y * 0.0052;
	uv2.y -= _Time.y * 0.23;
	float4 noise2 = tex2D(<ins>noiseTex</ins>, uv2);
	
	<ins>return noise.x * noise2.w;</ins>
<ins>}</ins></pre>
						
						<p>Adjust the <em translate="no">River</em> shader to use this new function.</p>
						
						<pre translate="no" class="shader">		<ins>#include "Water.cginc"</ins>

		sampler2D _MainTex;

		&hellip;

		void surf (Input IN, inout SurfaceOutputStandard o) {
			<ins>float river = River(IN.uv_MainTex, _MainTex);</ins>
			
			fixed4 c = saturate(_Color + <ins>river</ins>);
			&hellip;
		}</pre>
					</section>
					
					<section>
						<h3>Estuary Objects</h3>
						
						<p>Add support for an estuary mesh object to <code>HexGridChunk</code>.</p>
						
						<pre translate="no">	public HexMesh terrain, rivers, roads, water, waterShore<ins>, estuaries</ins>;
	
	public void Triangulate () {
		terrain.Clear();
		rivers.Clear();
		roads.Clear();
		water.Clear();
		waterShore.Clear();
		<ins>estuaries.Clear();</ins>
		for (int i = 0; i &lt; cells.Length; i++) {
			Triangulate(cells[i]);
		}
		terrain.Apply();
		rivers.Apply();
		roads.Apply();
		water.Apply();
		waterShore.Apply();
		<ins>estuaries.Apply();</ins>
	}</pre>
						
						<p>Create an estuary shader, material, and object, by duplicating and adjusting those for the water shore. Connect it with the chunk, and make sure that it uses both UV and UV2 coordinates.</p>
						
						<figure>
							<img src="estuaries/inspector.png" width="320" height="258">
							<figcaption>Estuarties object.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Triangulating the Estuary</h3>
						
						<p>We can solve the gap or overlap problem by placing a triangle between the river's end and the middle of the water's edge. Because our estuary shader is a duplicate of the water shore shader, set the UV coordinates to match the foam effect.</p>
						
						<pre translate="no">	void TriangulateEstuary (EdgeVertices e1, EdgeVertices e2) {
		&hellip;

		<ins>estuaries.AddTriangle(e1.v3, e2.v2, e2.v4);</ins>
		<ins>estuaries.AddTriangleUV(</ins>
			<ins>new Vector2(0f, 0f), new Vector2(0f, 1f), new Vector2(0f, 1f)</ins>
		<ins>);</ins>
	}</pre>
						
						<figure>
							<img src="estuaries/middle-triangle.png" width="320" height="258">
							<figcaption>Middle triangle.</figcaption>
						</figure>
						
						<p>We can fill the entire trapezoid by adding a quad on both sides of the middle triangle.</p>
						
						<pre translate="no">		<ins>estuaries.AddQuad(e1.v2, e1.v3, e2.v1, e2.v2);</ins>
		estuaries.AddTriangle(e1.v3, e2.v2, e2.v4);
		<ins>estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5);</ins>
		
		<ins>estuaries.AddQuadUV(0f, 0f, 0f, 1f);</ins>
		estuaries.AddTriangleUV(
			new Vector2(0f, 0f), new Vector2(0f, 1f), new Vector2(0f, 1f)
		);
		<ins>estuaries.AddQuadUV(0f, 0f, 0f, 1f);</ins></pre>
						
						<figure>
							<img src="estuaries/trapezoid.png" width="320" height="258">
							<figcaption>Complete trapezoid.</figcaption>
						</figure>
						
						<p>Let's rotate the orientation of the quad on the left side, so it has a shorter diagonal connection, and we end up with symmetrical geometry.</p>
						
						<pre translate="no">		estuaries.AddQuad(<ins>e2.v1</ins>, <ins>e1.v2</ins>, <ins>e2.v2</ins>, <ins>e1.v3</ins>);
		estuaries.AddTriangle(e1.v3, e2.v2, e2.v4);
		estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5);
		
		<ins>estuaries.AddQuadUV(</ins>
			<ins>new Vector2(0f, 1f), new Vector2(0f, 0f),</ins>
			<ins>new Vector2(0f, 1f), new Vector2(0f, 0f)</ins>
		<ins>);</ins>
<del>//		estuaries.AddQuadUV(0f, 0f, 0f, 1f);</del></pre>
						
						<figure>
							<img src="estuaries/rotated-quad.png" width="320" height="258">
							<figcaption>Rotated quad, symmetrical geometry</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>River Flow</h3>
						
						<p>To support the river effect, we need to add UV2 coordinates. The bottom of the middle triangle sits in the middle of the river, so its U coordinate should be 0.5. As the river flows towards the water, its left point gets U coordinate 1, and its right point gets U coordinate 0. Set the Y coordinates to 0 and 1, matching the flow direction.</p>
						
						<pre translate="no">		<ins>estuaries.AddTriangleUV2(</ins>
			<ins>new Vector2(0.5f, 1f), new Vector2(1f, 0f), new Vector2(0f, 0f)</ins>
		<ins>);</ins></pre>
						
						<p>The quads of either side of the triangle should match this orientation. Keep the same U coordinates for the points that are beyond the width of the river.</p>
						
						<pre translate="no">		<ins>estuaries.AddQuadUV2(</ins>
			<ins>new Vector2(1f, 0f), new Vector2(1f, 1f),</ins>
			<ins>new Vector2(1f, 0f), new Vector2(0.5f, 1f)</ins>
		<ins>);</ins>
		estuaries.AddTriangleUV2(
			new Vector2(0.5f, 1f), new Vector2(1f, 0f), new Vector2(0f, 0f)
		);
		<ins>estuaries.AddQuadUV2(</ins>
			<ins>new Vector2(0.5f, 1f), new Vector2(0f, 1f),</ins>
			<ins>new Vector2(0f, 0f), new Vector2(0f, 0f)</ins>
		<ins>);</ins></pre>
						
						<figure>
							<img src="estuaries/trapezoid-uv2.png" width="290" height="200">
							<figcaption>Trapezoid UV2.</figcaption>
						</figure>
						
						<p>To check whether we set the UV2 coordinates correctly, have the <em translate="no">Estuary</em> shader visualize them. We can access these coordinates by adding <code class="shader">float2 uv2_MainTex</code> to its input structure.</p>
						
						<pre translate="no" class="shader">		struct Input {
			float2 uv_MainTex;
			<ins>float2 uv2_MainTex;</ins>
			float3 worldPos;
		};

		&hellip;

		void surf (Input IN, inout SurfaceOutputStandard o) {
			float shore = IN.uv_MainTex.y;
			float foam = Foam(shore, IN.worldPos.xz, _MainTex);
			float waves = Waves(IN.worldPos.xz, _MainTex);
			waves *= 1 - shore;

			fixed4 c = <ins>fixed4(IN.uv2_MainTex, 1, 1)</ins>;
			&hellip;
		}</pre>
						
						<figure>
							<img src="estuaries/uv2.png" width="320" height="258">
							<figcaption>UV2 coordinates.</figcaption>
						</figure>
						
						<p>That looks good. We can use this to create the river effect.</p>
						
						<pre translate="no" class="shader">		void surf (Input IN, inout SurfaceOutputStandard o) {
			&hellip;

			<ins>float river = River(IN.uv2_MainTex, _MainTex);</ins>

			fixed4 c = <ins>saturate(_Color + river)</ins>;
			&hellip;
		}</pre>
						
						<figure>
							<img src="estuaries/river.png" width="320" height="258">
							<figcaption>Using UV2 to create the river effect.</figcaption>
						</figure>
						
						<p>We designed rivers so that when triangulating connections between cells, the river's V coordinates go from 0.8 to 1. So we should use this range here as well, instead of going from 0 to 1. However, the shore connection is 50% larger than regular cell connections. So to best match the river flow, we have to go from 0.8 to 1.1.</p>
						
						<pre translate="no">		estuaries.AddQuadUV2(
			new Vector2(1f, <ins>0.8f</ins>), new Vector2(1f, <ins>1.1f</ins>),
			new Vector2(1f, <ins>0.8f</ins>), new Vector2(0.5f, <ins>1.1f</ins>)
		);
		estuaries.AddTriangleUV2(
			new Vector2(0.5f, <ins>1.1f</ins>),
			new Vector2(1f, <ins>0.8f</ins>),
			new Vector2(0f, <ins>0.8f</ins>)
		);
		estuaries.AddQuadUV2(
			new Vector2(0.5f, <ins>1.1f</ins>), new Vector2(0f, <ins>1.1f</ins>),
			new Vector2(0f, <ins>0.8f</ins>), new Vector2(0f, <ins>0.8f</ins>)
		);</pre>
						
						<figure>
							<img alt="diagram" src="estuaries/uv-synchronized.png" width="290" height="200"><br>
							<img alt="scene" src="estuaries/river-synchronized.png" width="320" height="258">
							<figcaption>Synchronized river and estuary flow.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Adjusting the Flow</h3>
						
						<p>Right now, the river flow continues along a straight line. But when water flows into a larger area, it will spread out. The flow will curve. We can simulate this by warping the UV2 coordinates.</p>
						
						<p>Instead of keeping the top U coordinates constant beyond the width of the river, shift them by 0.5. The leftmost point becomes 1.5, and the rightmost becomes &minus;0.5.</p>
						
						<p>At the same time, widen the flow by shifting the U coordinates of the left and right points at the bottom. Change the left one from 1 to 0.7, and change the right one from 0 to 0.3.</p>
						
						<pre translate="no">		estuaries.AddQuadUV2(
			new Vector2(<ins>1.5f</ins>, 0.8f), new Vector2(<ins>0.7f</ins>, 1.1f),
			new Vector2(1f, 0.8f), new Vector2(0.5f, 1.1f)
		);
		&hellip;
		estuaries.AddQuadUV2(
			new Vector2(0.5f, 1.1f), new Vector2(<ins>0.3f</ins>, 1.1f),
			new Vector2(0f, 0.8f), new Vector2(<ins>-0.5f</ins>, 0.8f)
		);</pre>
						
						<figure>
							<img alt="diagram" src="estuaries/uv-widening.png" width="290" height="200"><br>
							<img alt="scene" src="estuaries/river-widening.png" width="320" height="258">
							<figcaption>Widening river flow.</figcaption>
						</figure>
						
						<p>To complete the curving effect, adjust the V coordinates of the same four points. As the water flows away from the river exit, increase the V coordinates of the top points to 1. And to produce a better curve, increase the V coordinates of the bottom two points to 1.15.</p>
						
						<pre translate="no">		estuaries.AddQuadUV2(
			new Vector2(1.5f, <ins>1f</ins>), new Vector2(0.7f, <ins>1.15f</ins>),
			new Vector2(1f, 0.8f), new Vector2(0.5f, 1.1f)
		);
		estuaries.AddTriangleUV2(
			new Vector2(0.5f, 1.1f),
			new Vector2(1f, 0.8f),
			new Vector2(0f, 0.8f)
		);
		estuaries.AddQuadUV2(
			new Vector2(0.5f, 1.1f), new Vector2(0.3f, <ins>1.15f</ins>),
			new Vector2(0f, 0.8f), new Vector2(-0.5f, <ins>1f</ins>)
		);</pre>
						
						<figure>
							<img alt="diagram" src="estuaries/uv-curving.png" width="290" height="200"><br>
							<img alt="scene" src="estuaries/river-curving.png" width="320" height="258">
							<figcaption>Curving river flow.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Blending River and Shore</h3>
						
						<p>All that is left is to blend the shore and river effects. We'll use linear interpolation for this, with the shore value as the interpolator.</p>
						
						<pre translate="no" class="shader">			<ins>float shoreWater = max(foam, waves);</ins>

			float river = River(IN.uv2_MainTex, _MainTex);

			<ins>float water = lerp(shoreWater, river, IN.uv_MainTex.y);</ins>

			fixed4 c = saturate(_Color + <ins>water</ins>);</pre>
						
						<p>While this should work, you might get a compile error. The compiler is complaining about a redefinition of <code class="shader">_MainTex_ST</code>. This is due to a bug in Unity's surface shader compiler, caused by using <code class="shader">uv_MainTex</code> and <code class="shader">uv2_MainTex</code> at the same time. We have to find a workaround.</p>
						
						<p>Instead of relying on <code class="shader">uv2_MainTex</code>, we'll have to manually pass along the secondary UV coordinates. To do so, rename <code class="shader">uv2_MainTex</code> to <code class="shader">riverUV</code>. Then add a vertex function to the shader which assigns the coordinates to it.</p>
						
						<pre translate="no" class="shader">		#pragma surface surf Standard alpha <ins>vertex:vert</ins>
		&hellip;
		
		struct Input {
			float2 uv_MainTex;
			float2 <ins>riverUV</ins>;
			float3 worldPos;
		};

		&hellip;

		<ins>void vert (inout appdata_full v, out Input o) {</ins>
			<ins>UNITY_INITIALIZE_OUTPUT(Input, o);</ins>
			<ins>o.riverUV = v.texcoord1.xy;</ins>
		<ins>}</ins>

		void surf (Input IN, inout SurfaceOutputStandard o) {
			&hellip;

			float river = River(IN.<ins>riverUV</ins>, _MainTex);

			&hellip;
		}</pre>
						
						<figure>
							<img src="estuaries/shore-lerp.png" width="320" height="258">
							<figcaption>Interpolating based on shore.</figcaption>
						</figure>
						
						<p>The interpolations works, except for the leftmost and rightmost vertices at the top. The river should have faded away at those points. So we cannot use the shore value. We have to use another value, which is set to 0 at those two vertices. Fortunately, we still have the U coordinate of the first UV set available, so we can store this value there.</p>
						
						<pre translate="no">		estuaries.AddQuadUV(
			new Vector2(0f, 1f), new Vector2(0f, 0f),
			new Vector2(<ins>1f</ins>, 1f), new Vector2(0f, 0f)
		);
		estuaries.AddTriangleUV(
			new Vector2(0f, 0f), new Vector2(<ins>1f</ins>, 1f), new Vector2(<ins>1f</ins>, 1f)
		);
		<ins>estuaries.AddQuadUV(</ins>
			<ins>new Vector2(0f, 0f), new Vector2(0f, 0f),</ins>
			<ins>new Vector2(1f, 1f), new Vector2(0f, 1f)</ins>
		<ins>);</ins>
<del>//		estuaries.AddQuadUV(0f, 0f, 0f, 1f);</del></pre>
						
						<p>Then switch to the U channel to interpolate in the shader.</p>
						
						<pre translate="no" class="shader">			float water = lerp(shoreWater, river, IN.uv_MainTex.<ins>x</ins>);</pre>
						
						<figure>
							<img src="estuaries/blended.png" width="320" height="258">
							<figcaption>Correct blend.</figcaption>
						</figure>
						
						<p>Our estuaries now contain a nice blend between the widening river, shore water, and foam. Although it doesn't produce an exact match with waterfalls, this effect looks fine in combination with waterfalls as well.</p>
						
						<figure>
							<div class="vid" style="width: 320px; height:186px;"><iframe src='https://gfycat.com/ifr/PointlessSafeGermanspaniel'></iframe></div>
							<figcaption>Estuaries in motion.</figcaption>
						</figure>
					</section>
					
					<a href="estuaries/estuaries.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Rivers Flowing out of Water Bodies</h2>
					
					<p>While we have rivers flowing into bodies of water, we current do not support rivers flowing in the other direction. As many lakes have rivers flowing out of them, this is something that we should add.</p>
					
					<p>When a river flows out of a body of water, it's actually flowing towards a higher elevation. This is currently invalid. We have to make an exception, and allow this when the water level matches the elevation of the destination cell. Let's add a private method to <code>HexCell</code> that checks whether a neighbor is a valid destination for an outgoing river, using our new criteria.</p>
					
					<pre translate="no">	<ins>bool IsValidRiverDestination (HexCell neighbor) {</ins>
		<ins>return neighbor &amp;&amp; (</ins>
			<ins>elevation >= neighbor.elevation || waterLevel == neighbor.elevation</ins>
		<ins>);</ins>
	<ins>}</ins></pre>
					
					<p>Use this new method to determine whether setting an outgoing river is allowed.</p>
					
					<pre translate="no">	public void SetOutgoingRiver (HexDirection direction) {
		if (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) {
			return;
		}

		HexCell neighbor = GetNeighbor(direction);
<del>//		if (!neighbor || elevation &lt; neighbor.elevation) {</del>
		<ins>if (!IsValidRiverDestination(neighbor)) {</ins>
			return;
		}

		RemoveOutgoingRiver();
		&hellip;
	}</pre>
					
					<p>We also have to validate the rivers when changing either the elevation or water level. Create a private method that takes care of this.</p>
					
					<pre translate="no">	<ins>void ValidateRivers () {</ins>
		<ins>if (</ins>
			<ins>hasOutgoingRiver &amp;&amp;</ins>
			<ins>!IsValidRiverDestination(GetNeighbor(outgoingRiver))</ins>
		<ins>) {</ins>
			<ins>RemoveOutgoingRiver();</ins>
		<ins>}</ins>
		<ins>if (</ins>
			<ins>hasIncomingRiver &amp;&amp;</ins>
			<ins>!GetNeighbor(incomingRiver).IsValidRiverDestination(this)</ins>
		<ins>) {</ins>
			<ins>RemoveIncomingRiver();</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
					
					<p>Take advantage of this new method in both the <code>Elevation</code> and <code>WaterLevel</code> properties.</p>
					
					<pre translate="no">	public int Elevation {
		&hellip;
		set {
			&hellip;

<del>//			if (</del>
<del>//				hasOutgoingRiver &amp;&amp;</del>
<del>//				elevation &lt; GetNeighbor(outgoingRiver).elevation</del>
<del>//			) {</del>
<del>//				RemoveOutgoingRiver();</del>
<del>//			}</del>
<del>//			if (</del>
<del>//				hasIncomingRiver &amp;&amp;</del>
<del>//				elevation > GetNeighbor(incomingRiver).elevation</del>
<del>//			) {</del>
<del>//				RemoveIncomingRiver();</del>
<del>//			}</del>
			<ins>ValidateRivers();</ins>

			&hellip;
		}
	}

	public int WaterLevel {
		&hellip;
		set {
			if (waterLevel == value) {
				return;
			}
			waterLevel = value;
			<ins>ValidateRivers();</ins>
			Refresh();
		}
	}</pre>
					
					<figure>
						<img src="rivers-flowing-out-of-water-bodies/both-in-and-out.png" width="400" height="240">
						<figcaption>Flowing both in and out of lakes.</figcaption>
					</figure>
					
					<section>
						<h3>Reversing the Flow</h3>
						
						<p>We created <code>HexGridChunk.TriangulateEstuary</code> while assuming that rivers only flow into bodies of water. As a result, the river flow always goes in the same direction. We have to reverse the flow when we're dealing with a river that flows away from the water. This requires that <code>TriangulateEstuary</code> knows about the flow direction. So give it a boolean parameter that defines whether we're dealing with an incoming river.</p>
						
						<pre translate="no">	void TriangulateEstuary (
		EdgeVertices e1, EdgeVertices e2<ins>, bool incomingRiver</ins>
	) {
	&hellip;
}</pre>
						
						<p>Pass along this information when <code>TriangulateWaterShore</code> invokes the method.</p>
						
						<pre translate="no">		if (cell.HasRiverThroughEdge(direction)) {
			TriangulateEstuary(e1, e2<ins>, cell.IncomingRiver == direction</ins>);
		}</pre>
						
						<p>Now we have to reverse the river flow, by changing the UV2 coordinates. The U coordinates have to be mirrored for outgoing rivers. &minus;0.5 becomes 1.5, 0 becomes 1, 1 becomes 0, and 1.5 becomes &minus;0.5.</p>
						
						<p>The V coordinates a less straightforward. Reviewing how we dealt with reversed river connections, 0.8 should become 0, and 1 should become &minus;0.2. This means that 1.1 becomes &minus;0.3, and 1.15 becomes &minus;0.35.</p>
						
						<p>As the UV2 coordinates are so different for each case, let's use separate code for them.</p>
						
						<pre translate="no">	void TriangulateEstuary (
		EdgeVertices e1, EdgeVertices e2, bool incomingRiver
	) {
		&hellip;

		<ins>if (incomingRiver) {</ins>
			estuaries.AddQuadUV2(
				new Vector2(1.5f, 1f), new Vector2(0.7f, 1.15f),
				new Vector2(1f, 0.8f), new Vector2(0.5f, 1.1f)
			);
			estuaries.AddTriangleUV2(
				new Vector2(0.5f, 1.1f),
				new Vector2(1f, 0.8f),
				new Vector2(0f, 0.8f)
			);
			estuaries.AddQuadUV2(
				new Vector2(0.5f, 1.1f), new Vector2(0.3f, 1.15f),
				new Vector2(0f, 0.8f), new Vector2(-0.5f, 1f)
			);
		<ins>}</ins>
		<ins>else {</ins>
			<ins>estuaries.AddQuadUV2(</ins>
				<ins>new Vector2(-0.5f, -0.2f), new Vector2(0.3f, -0.35f),</ins>
				<ins>new Vector2(0f, 0f), new Vector2(0.5f, -0.3f)</ins>
			<ins>);</ins>
			<ins>estuaries.AddTriangleUV2(</ins>
				<ins>new Vector2(0.5f, -0.3f),</ins>
				<ins>new Vector2(0f, 0f),</ins>
				<ins>new Vector2(1f, 0f)</ins>
			<ins>);</ins>
			<ins>estuaries.AddQuadUV2(</ins>
				<ins>new Vector2(0.5f, -0.3f), new Vector2(0.7f, -0.35f),</ins>
				<ins>new Vector2(1f, 0f), new Vector2(1.5f, -0.2f)</ins>
			<ins>);</ins>
		<ins>}</ins>
	}</pre>
						
						<figure>
							<div class="vid" style="width: 320px; height:192px;"><iframe src='https://gfycat.com/ifr/PotableWideeyedIrishwolfhound'></iframe></div>
							<figcaption>Correct river flow.</figcaption>
						</figure>
						
						<p>The next tutorial is <a href="../part-9/index.html">Terrain Features</a>.</p>
					</section>
					
					<a href="rivers-flowing-out-of-water-bodies/rivers-flowing-out-of-water-bodies.unitypackage" download rel="nofollow">unitypackage</a>
					<a href="Hex-Map-8.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../../../jquery2.js"></script>
		<script src="../../tutorials.js"></script>
	</body>
</html>