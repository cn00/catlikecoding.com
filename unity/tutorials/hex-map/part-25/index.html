<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/hex-map/part-25/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/hex-map/part-25/tutorial-image.jpg">
		<meta property="og:title" content="Hex Map 25">
		<meta property="og:description" content="A Unity Hex Map tutorial about simulating a partial water cycle. Part 25 of 27.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Hex Map 25</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/hex-map/part-25/#article",
				"headline": "Hex Map 25",
				"alternativeHeadline": "Water Cycle",
				"datePublished": "2018-01-22",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Hex Map tutorial about simulating a partial water cycle. Part 25 of 27.",
				"image": "https://catlikecoding.com/unity/tutorials/hex-map/part-25/tutorial-image.jpg",
				"dependencies": "Unity 2017.3.0",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/hex-map/", "name": "Hex Map" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				Bezier: 1,
				ClimateData: 1,
				EdgeVertices: 1,
				HexCell: 1,
				HexCellPriorityQueue: 1,
				HexCellShaderData: 1,
				HexEdgeType: 1,
				HexCoordinates: 1,
				HexCoordinatesDrawer: 1,
				HexDirection: 1,
				HexDirectionExtensions: 1,
				HexFeatureCollection: 1,
				HexFeatureManager: 1,
				HexGameUI: 1,
				HexGrid: 1,
				HexGridChunk: 1,
				HexHash: 1,
				HexMapCamera: 1,
				HexMapEditor: 1,
				HexMapGenerator: 1,
				HexMesh: 1,
				HexMetrics: 1,
				HexUnit: 1,
				ListPool: 1,
				MapRegion: 1,
				NewMapMenu: 1,
				OptionalToggle: 1,
				SaveLoadItem: 1,
				SaveLoadMenu: 1,
				TextureArrayWizard: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Hex Map</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Hex Map 25</h1>
					<p>Water Cycle</p>
					<ul>
						<li>Display raw map data.</li>
						<li>Evolve cell climates.</li>
						<li>Create a partial water cycle simulation.</li>
					</ul>
				</header>

				<p>This is part 25 of a tutorial series about <a href="../index.html">hexagon maps</a>. The <a href="../part-24/index.html">previous part</a> was about regions and erosion. This time we'll add moisture to the land.</p>
				
				<p>This tutorial is made with Unity 2017.3.0.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Using the water cycle to determine biomes.</figcaption>
				</figure>
				
				<section>
					<h2>Clouds</h2>
					
					<p>Up to this point our map generation algorithm only adjusts the elevation of cells. The biggest difference between cells is whether they are submerged or not. While we also set different terrain types, that's just a simple visualization of elevation. A better way to assign terrain types would be by taking the local climate into consideration.</p>
					
					<p>The climate of earth is a very complex system. Fortunately, we don't have to create a realistic climate simulation. All we need is something that looks natural enough. The most important aspect of the climate is the water cycle, because flora and fauna need liquid water to survive. Temperature is very important too, but we'll focus on water this time, effectively keeping the global temperature constant, while varying wetness.</p>
					
					<p>The water cycle describes how water moves through the environment. Put simply, waterbodies evaporate, which leads to clouds, which produce rain, which flows back to the waterbodies. There's much more to it than that, but simulating those steps might already be enough to produce a seemingly natural distribution of water across our map.</p>
					
					<section>
						<h3>Visualizing Data</h3>
						
						<p>Before we get to the actual simulation, it would be useful if we could directly see the relevant data. For this purpose, we'll adjust our <em translate="no">Terrain</em> shader. Give it a toggle property so we can switch it into data-visualization mode, displaying raw map data instead of the usual terrain textures. This is done via a float property with a toggle attribute, specifying a keyword. That will make it show up as a checkbox in the material inspector, which controls whether the keyword is set. The actual name of the property doesn't matter, only the keyword, for which we'll use <em translate="no">SHOW_MAP_DATA</em>.</p>
						
						<pre translate="no" class="shader">	Properties {
		_Color ("Color", Color) = (1,1,1,1)
		_MainTex ("Terrain Texture Array", 2DArray) = "white" {}
		_GridTex ("Grid Texture", 2D) = "white" {}
		_Glossiness ("Smoothness", Range(0,1)) = 0.5
		_Specular ("Specular", Color) = (0.2, 0.2, 0.2)
		_BackgroundColor ("Background Color", Color) = (0,0,0)
		<ins>[Toggle(SHOW_MAP_DATA)] _ShowMapData ("Show Map Data", Float) = 0</ins>
	}</pre>
						
						<figure>
							<img src="clouds/show-map-data-toggle.png" width="320" height="76">
							<figcaption>Toggle for showing map data.</figcaption>
						</figure>
						
						<p>Add a shader feature to enable support for the keyword.</p>
						
						<pre translate="no" class="shader">		#pragma multi_compile _ GRID_ON
		#pragma multi_compile _ HEX_MAP_EDIT_MODE

		<ins>#pragma shader_feature SHOW_MAP_DATA</ins></pre>
						
						<p>We'll make it possible to display a single float value, just like the other terrain data. To make this possible, add a <code class="shader">mapData</code> field to the <code class="shader">Input</code> structure, when the keyword is defined.</p>
						
						<pre translate="no" class="shader">		struct Input {
			float4 color : COLOR;
			float3 worldPos;
			float3 terrain;
			float4 visibility;

			<ins>#if defined(SHOW_MAP_DATA)</ins>
				<ins>float mapData;</ins>
			<ins>#endif</ins>
		};</pre>
						
						<p>In the vertex program, we'll use the Z channel of the cell data to fill <code class="shader">mapData</code>, interpolated between cells as usual.</p>
						
						<pre translate="no" class="shader">		void vert (inout appdata_full v, out Input data) {
			&hellip;

			<ins>#if defined(SHOW_MAP_DATA)</ins>
				<ins>data.mapData = cell0.z * v.color.x + cell1.z * v.color.y +</ins>
					<ins>cell2.z * v.color.z;</ins>
			<ins>#endif</ins>
		}</pre>
						
						<p>When map data should be shown, directly use it as the fragment's albedo, instead of the normal color. Multiply it with the grid, so the grid can still be enable when visualizing data.</p>
						
						<pre translate="no" class="shader">		void surf (Input IN, inout SurfaceOutputStandardSpecular o) {
			&hellip;
			o.Albedo = c.rgb * grid * _Color * explored;
			<ins>#if defined(SHOW_MAP_DATA)</ins>
				<ins>o.Albedo = IN.mapData * grid;</ins>
			<ins>#endif</ins>
			&hellip;
		}</pre>
						
						<p>To actually get any data to the shader, we have to add a method to <code>HexCellShaderData</code> to put something in the blue channel of its texture data. The data is a single float value, clamped to the 0&ndash;1 range.</p>
						
						<pre translate="no">	<ins>public void SetMapData (HexCell cell, float data) {</ins>
		<ins>cellTextureData[cell.Index].b =</ins>
			<ins>data &lt; 0f ? (byte)0 : (data &lt; 1f ? (byte)(data * 255f) : (byte)255);</ins>
		<ins>enabled = true;</ins>
	<ins>}</ins></pre>
						
						<p>However, this approach interferes with our exploration system. A value ot 255 for the blue data component is used to indicate that a cell's visibility is in transition. To keep this working, we have to use the byte value 254 as the maximum. Note that unit movement will wipe out the map data, but that's fine as we only use it for debugging map generation.</p>
						
						<pre translate="no">		cellTextureData[cell.Index].b =
			data &lt; 0f ? (byte)0 : (data &lt; 1f ? (byte)(data * <ins>254f</ins>) : (byte)<ins>254</ins>);</pre>
						
						<p>Add a method with the same name to <code>HexCell</code> as well, which passes the request on to its shader data.</p>
						
						<pre translate="no">	<ins>public void SetMapData (float data) {</ins>
		<ins>ShaderData.SetMapData(this, data);</ins>
	<ins>}</ins></pre>
						
						<p>To test whether this works, adjust <code>HexMapGenerator.SetTerrainType</code> so it sets each cell's map data. Let's visualize elevation, converted from an integer to a float in the 0&ndash;1 range. This is done by subtracting the elevation minimum from the cell's elevation, then dividing that by the elevation maximum minus the minimum. Ensure that it is a float division.</p>
						
						<pre translate="no">	void SetTerrainType () {
		for (int i = 0; i &lt; cellCount; i++) {
			&hellip;
			<ins>cell.SetMapData(</ins>
				<ins>(cell.Elevation - elevationMinimum) /</ins>
				<ins>(float)(elevationMaximum - elevationMinimum)</ins>
			<ins>);</ins>
		}
	}</pre>
						
						<p>You should now be able to switch between the normal terrain and data visualization, by toggling the <em translate="no">Show Map Data</em> checkbox of the <em translate="no">Terrain</em> material asset.</p>
						
						<figure>
							<img alt="normal" src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/clouds/map-1208905299.jpg" width="350" height="200">
							<img alt="map data" src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/clouds/showing-elevation.jpg" width="350" height="200">
							<figcaption>Map 1208905299, normal terrain and elevation visualization.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Creating a Climate</h3>
						
						<p>To simulate a climate, we have to keep track of the climate's data. As our map consists of discrete cells, each cell has its own local climate. Create a <code>ClimateData</code> struct to contain all the relevant data. While we could add this data to the cells themselves, we're only going to use it when generating the map. So we'll store it separately instead. This means that we can define this struct inside <code>HexMapGenerator</code>, just like <code>MapRegion</code>. We'll begin by only tracking clouds, which we can do with a single float field.</p>
						
						<pre translate="no">	<ins>struct ClimateData {</ins>
		<ins>public float clouds;</ins>
	<ins>}</ins></pre>
						
						<p>Add a list to keep track of the climate data for all cells.</p>
						
						<pre translate="no">	<ins>List&lt;ClimateData> climate = new List&lt;ClimateData>();</ins></pre>
						
						<p>Now we need a method to create the map's climate. It should start with clearing the climate list, then adding one item for each cell. The initial climate data is simply zero, which we get via the default constructor of <code>ClimateData</code>.</p>
						
						<pre translate="no">	<ins>void CreateClimate () {</ins>
		<ins>climate.Clear();</ins>
		<ins>ClimateData initialData = new ClimateData();</ins>
		<ins>for (int i = 0; i &lt; cellCount; i++) {</ins>
			<ins>climate.Add(initialData);</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>The climate has to be created after the land has been eroded and before the terrain types are set. In reality, erosion is mostly caused by the movement of air and water, which is part of the climate, but we're not going to simulate that.</p>
						
						<pre translate="no">	public void GenerateMap (int x, int z) {
		&hellip;
		CreateRegions();
		CreateLand();
		ErodeLand();
		<ins>CreateClimate();</ins>
		SetTerrainType();
		&hellip;
	}</pre>
						
						<p>Change <code>SetTerrainType</code> so we can see the cloud data instead of the cell elevation. Initially, that will look like a black map.</p>
						
						<pre translate="no">	void SetTerrainType () {
		for (int i = 0; i &lt; cellCount; i++) {
			&hellip;
			cell.SetMapData(<ins>climate[i].clouds</ins>);
		}
	}</pre>
					</section>
					
					<section>
						<h3>Evolving Climate</h3>
						
						<p>The first step of our climate simulation is evaporation. How much water should evaporate? Let's control that with a slider. A value of 0 means no evaporation at all, while 1 means maximum evaporation. We'll use 0.5 as the default.</p>
						
						<pre translate="no">	<ins>[Range(0f, 1f)]</ins>
	<ins>public float evaporation = 0.5f;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/clouds/evaporation-slider.png" width="320" height="56">
							<figcaption>Evaporation slider.</figcaption>
						</figure>
						
						<p>Let's create another method specifically to evolve the climate of a single cell. Give it the cell's index as a parameter and use it to retrieve the relevant cell and its climate data. If the cell is underwater, then we're dealing with a waterbody, which should evaporate. We'll immediately turn the vapor into clouds &ndash; ignoring dew points and condensation &ndash; so directly add the evaporation to the cell's clouds value. Once we're done, copy the climate data back to the list.</p>
						
						<pre translate="no">	<ins>void EvolveClimate (int cellIndex) {</ins>
		<ins>HexCell cell = grid.GetCell(cellIndex);</ins>
		<ins>ClimateData cellClimate = climate[cellIndex];</ins>
		
		<ins>if (cell.IsUnderwater) {</ins>
			<ins>cellClimate.clouds += evaporation;</ins>
		<ins>}</ins>

		<ins>climate[cellIndex] = cellClimate;</ins>
	<ins>}</ins></pre>
						
						<p>Invoke this method in <code>CreateClimate</code>, for every cell.</p>
						
						<pre translate="no">	void CreateClimate () {
		&hellip;

		<ins>for (int i = 0; i &lt; cellCount; i++) {</ins>
			<ins>EvolveClimate(i);</ins>
		<ins>}</ins>
	}</pre>
						
						<p>Doing this just once isn't sufficient. To create a complex simulation, we have to evolve the cell climates multiple times. The more often we do this, the more refined the result will be. We'll simply pick a fixed amount, let's use 40 cycles.</p>
						
						<pre translate="no">		<ins>for (int cycle = 0; cycle &lt; 40; cycle++) {</ins>
			for (int i = 0; i &lt; cellCount; i++) {
				EvolveClimate(i);
			}
		<ins>}</ins></pre>
						
						<p>Because right now we're only increasing the clouds above submerged cells, we end up with black land and white waterbodies.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/clouds/evaporation.jpg" width="350" height="200">
							<figcaption>Evaporation above water.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Cloud Dispersal</h3>
						
						<p>Clouds don't stay in one place forever, especially not when more and more water keeps evaporating. Pressure differences cause air to move, manifesting as wind, which makes the clouds to move as well.</p>
						
						<p>If there isn't a dominant wind direction, on average the clouds of a cell will disperse in all directions equally, ending up in the  cell's neighbors. As new clouds will be generated in the next cycle, let's distribute all the clouds that are currently in the cell among its neighbors. So each neighbor gets one-sixth of the cell's clouds, after which the local drop to zero.</p>
						
						<pre translate="no">		if (cell.IsUnderwater) {
			cellClimate.clouds += evaporation;
		}

		<ins>float cloudDispersal = cellClimate.clouds * (1f / 6f);</ins>
		<ins>cellClimate.clouds = 0f;</ins>

		climate[cellIndex] = cellClimate;</pre>
						
						<p>To actually add the clouds to the neighbors, loop through them, retrieve their climate data, increase their clouds value, and copy it back to the list.</p>
						
						<pre translate="no">		float cloudDispersal = cellClimate.clouds * (1f / 6f);
		<ins>for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {</ins>
			<ins>HexCell neighbor = cell.GetNeighbor(d);</ins>
			<ins>if (!neighbor) {</ins>
				<ins>continue;</ins>
			<ins>}</ins>
			<ins>ClimateData neighborClimate = climate[neighbor.Index];</ins>
			<ins>neighborClimate.clouds += cloudDispersal;</ins>
			<ins>climate[neighbor.Index] = neighborClimate;</ins>
		<ins>}</ins>
		cellClimate.clouds = 0f;</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/clouds/dispersed-clouds.jpg" width="350" height="200">
							<figcaption>Dispersing clouds.</figcaption>
						</figure>
						
						<p>This produces an almost white map. That's because each cycle all underwater cells add more clouds to the global climate. After the first cycle, the land cells next to water now have some clouds to disperse as well. This process compounds until most of the map is covered with clouds. In the case of map 1208905299 with default settings, only the interior of the large northeast landmass hasn't been fully covered yet.</p>
						
						<p>Note that our waterbodies can generate an infinite amount of clouds. The water level is not part of our climate simulation. In reality, waterbodies persist only because water flows back to them at about the same rate that they evaporate. So we're only simulating a partial water cycle. This is fine, but we should be aware that this means that the longer the simulation runs, the more water gets added to the climate. Right now, the only loss of water happens at the edge of the map, where dispersed clouds are lost to non-existing neighbors.</p>
						
						<p>You can see the loss of water at the top of the map, especially the cells at the top right. The last cell has no clouds at all, because it was the last one to evolve. It hasn't received any clouds from a neighbor yet.</p>
						
						<aside>
							<h3>Shouldn't all cell climates evolve in parallel?</h3>
							<div>
								<p>Yes, that would produce the most consistent simulation. Right now, due to the cell order, clouds get distributed towards the north and east across the entire map in a single cycle, but only a single step towards the south and west. However, this asymmetry gets smoothed out over 40 cycles. It's only really obvious at the edge of the map. We'll switch to parallel evolution later.</p>
							</div>
						</aside>
					</section>
					
					<section>
						<h3>Precipitation</h3>
						
						<p>Water doesn't stay in could form forever. At some point, it will fall back down. This usually happens in the form of rain, but it can also be snow, hail, or sleet. In general, this is known as precipitation. How much of a cloud disappears and how quickly it happens varies a lot, but we'll simply use a configurable global precipitation factor. A value of 0 means no precipitation at all, while a value of 1 means that all the clouds disappear immediately. Let's use 0.25 as the default value. That means that each cycle a quarter of the clouds are removed.</p>
						
						<pre translate="no">	<ins>[Range(0f, 1f)]</ins>
	<ins>public float precipitationFactor = 0.25f;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/clouds/precipidation-slider.png" width="320" height="39">
							<figcaption>Slider for precipitation factor.</figcaption>
						</figure>
						
						<p>We'll simulate precipitation after evaporation and before cloud dispersal. This means that part of the water that evaporates from waterbodies immediately precipitates, so the amount of dispersed clouds is reduced. Above land, precipitation will cause clouds to disappear.</p>
						
						<pre translate="no">		if (cell.IsUnderwater) {
			cellClimate.clouds += evaporation;
		}

		<ins>float precipitation = cellClimate.clouds * precipitationFactor;</ins>
		<ins>cellClimate.clouds -= precipitation;</ins>

		float cloudDispersal = cellClimate.clouds * (1f / 6f);</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/clouds/disappearing-clouds.jpg" width="350" height="200">
							<figcaption>Disappearing clouds.</figcaption>
						</figure>
						
						<p>Now that we're eliminating 25% of the clouds each cycle, the land had turned mostly black again. The clouds only manage to move inland a few steps before they become unnoticeable.</p>
					</section>
					
					<a href="https://catlikecoding.com/unity/tutorials/hex-map/part-25/clouds/clouds.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Moisture</h2>
					
					<p>Although precipitation eliminates clouds, it shouldn't remove water from the climate. After falling to earth, the water is still there, just in another state. It can exist in many forms, which we'll simply abstract as moisture.</p>
					
					<section>
						<h3>Tracking Moisture</h3>
						
						<p>We're going to enhance our climate model by keeping track of two water states, clouds and moisture. To support this, add a <code>moisture</code> field to <code>ClimateData</code>.</p>
						
						<pre translate="no">	struct ClimateData {
		public float clouds<ins>, moisture</ins>;
	}</pre>
						
						<p>In its most general form, evaporation is the process of converting moisture into clouds, at least in our simple climate model. This means that evaporation shouldn't be a constant value but another factor. So refactor-rename <code>evaporation</code> to <code>evaporationFactor</code>.</p>
					
						<pre translate="no">	[Range(0f, 1f)]
	public float <ins>evaporationFactor</ins> = 0.5f;</pre>
						
						<p>When a cell is underwater, we simply declare its moisture level to be 1. This means that the evaporation is equal to the evaporation factor. But we can now also have evaporation from land cells. In that case, we have to calculate the evaporation, subtract it from the moisture and add it to the clouds. After that, precipitation is added to moisture.</p>
					
						<pre translate="no">		if (cell.IsUnderwater) {
			<ins>cellClimate.moisture = 1f;</ins>
			cellClimate.clouds += evaporationFactor;
		}
		<ins>else {</ins>
			<ins>float evaporation = cellClimate.moisture * evaporationFactor;</ins>
			<ins>cellClimate.moisture -= evaporation;</ins>
			<ins>cellClimate.clouds += evaporation;</ins>
		<ins>}</ins>
		
		float precipitation = cellClimate.clouds * precipitationFactor;
		cellClimate.clouds -= precipitation;
		<ins>cellClimate.moisture += precipitation;</ins></pre>
					
						<p>Because clouds are now sustained by evaporation above land, they're able to move further inland. Most of the land is now gray.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/moisture/clouds.jpg" width="350" height="200">
							<figcaption>Clouds with moisture evaporation.</figcaption>
						</figure>
						
						<p>Let's adjust <code>SetTerrainType</code> so it displays moisture instead of clouds, because that's what we'll use to determine the terrain types later.</p>
						
						<pre translate="no">			cell.SetMapData(climate[i].<ins>moisture</ins>);</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/moisture/moisture.jpg" width="350" height="200">
							<figcaption>Showing moisture.</figcaption>
						</figure>
						
						<p>At this point moisture looks quite similar to clouds &ndash; except that all underwater cells are white &ndash; but this will soon change.</p>
					</section>
					
					<section>
						<h3>Runoff</h3>
						
						<p>Evaporation is not the only way that moisture can leave a cell. The water cycle dictates that most of the moisture added to land somehow ends up in waterbodies again. The most visible way in which this happens is by water flowing across the land, dragged down by gravity. We're not bothering with actual rivers in our simulation, instead we'll use a configurable runoff factor. This represents the portion of water that drains away, flowing to lower regions. Let's drain 25% by default.</p>
						
						<pre translate="no">	<ins>[Range(0f, 1f)]</ins>
	<ins>public float runoffFactor = 0.25f;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/moisture/runoff-slider.png" width="320" height="57">
							<figcaption>Runoff slider.</figcaption>
						</figure>
						
						<aside>
							<h3>Won't we generate rivers?</h3>
							<div>
								<p>We'll add them in a future tutorial, based on the climate that we generated.</p>
							</div>
						</aside>
						
						<p>Runoff works just like cloud dispersal, with three differences. First, not all of a cell's moisture is removed. Second, it's transporting moisture, not clouds. Third, it only goes downward, so only to neighbors with lower elevation. The runoff factor describes how much moisture drains away if all neighbors were lower, but it's often less. This means that we have to decrease the cell's moisture only when we find a lower neighbor.</p>
						
						<pre translate="no">		float cloudDispersal = cellClimate.clouds * (1f / 6f);
		<ins>float runoff = cellClimate.moisture * runoffFactor * (1f / 6f);</ins>
		for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {
			HexCell neighbor = cell.GetNeighbor(d);
			if (!neighbor) {
				continue;
			}
			ClimateData neighborClimate = climate[neighbor.Index];
			neighborClimate.clouds += cloudDispersal;

			<ins>int elevationDelta = neighbor.Elevation - cell.Elevation;</ins>
			<ins>if (elevationDelta &lt; 0) {</ins>
				<ins>cellClimate.moisture -= runoff;</ins>
				<ins>neighborClimate.moisture += runoff;</ins>
			<ins>}</ins>
			
			climate[neighbor.Index] = neighborClimate;
		}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/moisture/runoff.jpg" width="350" height="200">
							<figcaption>Water flowing to lower ground.</figcaption>
						</figure>
						
						<p>We end up with a more varied distribution of moisture, as higher cells lose their moisture to lower cells. We also see a lot less moisture in coastal cells, because they drain into the underwater cells. To mitigate this effect, we should also use the water level to determine whether a cell is lower, by using the view elevation instead.</p>
						
						<pre translate="no">			int elevationDelta = neighbor.<ins>ViewElevation</ins> - cell.<ins>ViewElevation</ins>;</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/moisture/runoff-view-elevation.jpg" width="350" height="200">
							<figcaption>Using view elevation.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Seepage</h3>
						
						<p>Water doesn't only flow downward. It also spreads out, seeping across level terrain, and being absorbed by land adjacent to waterbodies. This can be a subtle effect, but useful to smooth out the distribution of moisture, so let's add it to our simulation as well. Give it its own configurable factor, using 0.125 as the default.</p>
						
						<pre translate="no">	<ins>[Range(0f, 1f)]</ins>
	<ins>public float seepageFactor = 0.125f;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/moisture/seepage-slider.png" width="320" height="75">
							<figcaption>Seepage slider.</figcaption>
						</figure>
						
						<p>Seepage is the same as runoff, except that it applies when a neighbor has the same view elevation as the cell itself.</p>
						
						<pre translate="no">		float runoff = cellClimate.moisture * runoffFactor * (1f / 6f);
		<ins>float seepage = cellClimate.moisture * seepageFactor * (1f / 6f);</ins>
		for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {
			&hellip;

			int elevationDelta = neighbor.ViewElevation - cell.ViewElevation;
			if (elevationDelta &lt; 0) {
				cellClimate.moisture -= runoff;
				neighborClimate.moisture += runoff;
			}
			<ins>else if (elevationDelta == 0) {</ins>
				<ins>cellClimate.moisture -= seepage;</ins>
				<ins>neighborClimate.moisture += seepage;</ins>
			<ins>}</ins>

			climate[neighbor.Index] = neighborClimate;
		}</pre>
						
						<figure>
							<img src="moisture/seepage.jpg" width="350" height="200">
							<figcaption>With a little seepage.</figcaption>
						</figure>
					</section>
					
					<a href="moisture/moisture.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Rain Shadows</h2>
					
					<p>While we have a decent simulation of the water cycle at this point, it doesn't look very interesting. That's because it doesn't contain rain shadows, which are some of the most dramatic displays of climate difference. Rain shadows describe areas that have a severe lack of precipitation, compared to nearby regions. These regions exist because mountains prevent clouds from reaching them. This requires high mountains and a prevailing wind direction.</p>
					
					<section>
						<h3>Wind</h3>
						
						<p>Let's begin by adding a dominant wind direction to our simulation. While the dominant wind direction varies a lot across earth, we'll make do with a configurable global wind direction. Let's use northwest as the default. Besides that, also make it configurable how strong this wind is, from 1 to 10, with a default of 4.</p>
						
						<pre translate="no">	<ins>public HexDirection windDirection = HexDirection.NW;</ins>
	
	<ins>[Range(1f, 10f)]</ins>
	<ins>public float windStrength = 4f;</ins></pre>
						
						<figure>
							<img src="rain-shadows/wind-settings.png" width="320" height="111">
							<figcaption>Wind direction and strength.</figcaption>
						</figure>
						
						<p>The strength of the dominant wind is expressed relative to the uniform cloud dispersal. When the wind strength is 1, dispersal is equal in all directions. When it's 2, dispersal is twice as strong in the wind direction than in the other directions, and so on. We can realize this by changing the divisor of the cloud dispersal calculation. Instead of six, it should be five plus the wind strength.</p>
						
						<pre translate="no">		float cloudDispersal = cellClimate.clouds * (1f / <ins>(5f + windStrength)</ins>);</pre>
						
						<p>Also, the wind direction defines the direction from which the wind blows. So we need to use the opposite of that as the main dispersal direction.</p>
						
						<pre translate="no">		<ins>HexDirection mainDispersalDirection = windDirection.Opposite();</ins>
		float cloudDispersal = cellClimate.clouds * (1f / (5f + windStrength));</pre>
						
						<p>Now we can check whether a neighbor lies in the main dispersal direction. If so, we should multiply the cloud dispersal by the wind strength.</p>
						
						<pre translate="no">			ClimateData neighborClimate = climate[neighbor.Index];
			<ins>if (d == mainDispersalDirection) {</ins>
				<ins>neighborClimate.clouds += cloudDispersal * windStrength;</ins>
			<ins>}</ins>
			<ins>else {</ins>
				neighborClimate.clouds += cloudDispersal;
			<ins>}</ins></pre>
						
						<figure>
							<img src="rain-shadows/northwest-wind.jpg" width="350" height="200">
							<figcaption>Northwest wind, strength 4.</figcaption>
						</figure>
						
						<p>A dominant wind adds directionality in the way the moisture gets distributed across the land. The stronger the wind, the more extreme this effect becomes.</p>
					</section>
					
					<section>
						<h3>Altitude</h3>
						
						<p>The second ingredient for rains shadows are mountains. We don't have a strict classification of what a mountain is, and neither does nature. What matters is altitude. Essentially, when air flows across a mountain it is forced upward, cools, can hold less water, which forces precipitation before the air passes the mountain. The result is dry air on the other side, hence the rain shadow.</p>
						
						<p>The key part is that the higher air goes the less water it can contain. We can represent this in our simulation by enforcing a maximum cloud value per cell. The higher a cell's view elevation, the lower this maximum should be. The most straightforward way to do this is to set the maximum to 1 minus the view elevation divided by the elevation maximum. Actually, let's divide by the maximum plus one. That allows a little bit of the clouds to still flow over even the highest cells. We'll enforce this maximum after precipitation, before dispersal.</p>
						
						<pre translate="no">		float precipitation = cellClimate.clouds * precipitationFactor;
		cellClimate.clouds -= precipitation;
		cellClimate.moisture += precipitation;

		<ins>float cloudMaximum = 1f - cell.ViewElevation / (elevationMaximum + 1f);</ins>
		
		HexDirection mainDispersalDirection = windDirection.Opposite();</pre>
						
						<p>If we end up with more clouds than allowed, simply convert the excess clouds to moisture. This effectively forces extra precipitation, just like real mountains do.</p>
						
						<pre translate="no">		float cloudMaximum = 1f - cell.ViewElevation / (elevationMaximum + 1f);
		<ins>if (cellClimate.clouds > cloudMaximum) {</ins>
			<ins>cellClimate.moisture += cellClimate.clouds - cloudMaximum;</ins>
			<ins>cellClimate.clouds = cloudMaximum;</ins>
		<ins>}</ins></pre>
						
						<figure>
							<img src="rain-shadows/rain-shadows.jpg" width="350" height="200">
							<figcaption>Rain shadows caused by high elevation.</figcaption>
						</figure>
					</section>
					
					<a href="rain-shadows/rain-shadows.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Finishing the Simulation</h2>
					
					<p>At this point we have a decent partial water cycle simulation. Let's tidy it up a bit and then use it to determine the terrain type of cells.</p>
					
					<section>
						<h3>Parallel Evaluation</h3>
						
						<p>As mentioned in an aside earlier, the order in which we evolve cells influences the result of the simulation. Ideally, this is not the case and we effectively evolve all cells in parallel. We can do this by applying all changes of the current evolution step to a second climate list, <code>nextClimate</code>.</p>
						
						<pre translate="no">	List&lt;ClimateData> climate = new List&lt;ClimateData>();
	<ins>List&lt;ClimateData> nextClimate = new List&lt;ClimateData>();</ins></pre>
						
						<p>Clear and initialize this list just like the other one. Then swap the lists after each cycle. This makes the simulation alternate between which list is used and the current and the next climate data.</p>
						
						<pre translate="no">	void CreateClimate () {
		climate.Clear();
		<ins>nextClimate.Clear();</ins>
		ClimateData initialData = new ClimateData();
		for (int i = 0; i &lt; cellCount; i++) {
			climate.Add(initialData);
			<ins>nextClimate.Add(initialData);</ins>
		}

		for (int cycle = 0; cycle &lt; 40; cycle++) {
			for (int i = 0; i &lt; cellCount; i++) {
				EvolveClimate(i);
			}
			<ins>List&lt;ClimateData> swap = climate;</ins>
			<ins>climate = nextClimate;</ins>
			<ins>nextClimate = swap;</ins>
		}
	}</pre>
						
						<p>When a cell influences the climate of its neighbor, it should adjust that neighbor's next climate data, not the current.</p>
						
						<pre translate="no">		for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {
			HexCell neighbor = cell.GetNeighbor(d);
			if (!neighbor) {
				continue;
			}
			ClimateData neighborClimate = <ins>nextClimate</ins>[neighbor.Index];
			&hellip;

			<ins>nextClimate</ins>[neighbor.Index] = neighborClimate;
		}</pre>
						
						<p>And instead of copying the cell's climate data back to the current climate list, retrieve its next climate data, add the current moisture to it, and copy that to the next list. After that, reset the data of the current list so it's fresh for the next cycle.</p>
						
						<pre translate="no"><del>//		cellClimate.clouds = 0f;</del>

		<ins>ClimateData nextCellClimate = nextClimate[cellIndex];</ins>
		<ins>nextCellClimate.moisture += cellClimate.moisture;</ins>
		<ins>nextClimate[cellIndex] = nextCellClimate;</ins>
		climate[cellIndex] = <ins>new ClimateData()</ins>;</pre>
						
						<p>While we're at it, let's also enforce a maximum of 1 for the moisture level, so land cells cannot be wetter than underwater cells.</p>
						
						<pre translate="no">		nextCellClimate.moisture += cellClimate.moisture;
		<ins>if (nextCellClimate.moisture > 1f) {</ins>
			<ins>nextCellClimate.moisture = 1f;</ins>
		<ins>}</ins>
		nextClimate[cellIndex] = nextCellClimate;</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/finishing-the-simulation/parallel-evaluation.jpg" width="350" height="200">
							<figcaption>Parallel evaluation.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Initial Moisture</h3>
						
						<p>It's possible that our simulation ends up with too much dry land, especially when there is a high land percentage. To ameliorate this, we can add a configurable starting moisture level, with a default of 0.1.</p>
						
						<pre translate="no">	<ins>[Range(0f, 1f)]</ins>
	<ins>public float startingMoisture = 0.1f;</ins></pre>
						
						<figure>
							<img src="finishing-the-simulation/starting-moisture-slider.png" width="320" height="129">
							<figcaption>Starting moisture slider, at the top.</figcaption>
						</figure>
						
						<p>Use this value for the moisture of the initial climate list, but not for the next list.</p>
						
						<pre translate="no">		ClimateData initialData = new ClimateData();
		<ins>initialData.moisture = startingMoisture;</ins>
		<ins>ClimateData clearData = new ClimateData();</ins>
		for (int i = 0; i &lt; cellCount; i++) {
			climate.Add(initialData);
			nextClimate.Add(<ins>clearData</ins>);
		}</pre>
						
						<figure>
							<img src="finishing-the-simulation/starting-moisture.jpg" width="350" height="200">
							<figcaption>With starting moisture.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Setting Biomes</h3>
						
						<p>We wrap up with using moisture instead of elevation to set the cell terrain type. Let's use snow to represent bone-dry land, sand for arid regions, stone after that, grass for fairly wet, and mud for soaked and underwater cells. The simplest approach is to just use five 0.2 bands.</p>
						
						<pre translate="no">	void SetTerrainType () {
		for (int i = 0; i &lt; cellCount; i++) {
			HexCell cell = grid.GetCell(i);
			<ins>float moisture = climate[i].moisture;</ins>
			if (!cell.IsUnderwater) {
				<ins>if (moisture &lt; 0.2f) {</ins>
					<ins>cell.TerrainTypeIndex = 4;</ins>
				<ins>}</ins>
				<ins>else if (moisture &lt; 0.4f) {</ins>
					<ins>cell.TerrainTypeIndex = 0;</ins>
				<ins>}</ins>
				<ins>else if (moisture &lt; 0.6f) {</ins>
					<ins>cell.TerrainTypeIndex = 3;</ins>
				<ins>}</ins>
				<ins>else if (moisture &lt; 0.8f) {</ins>
					<ins>cell.TerrainTypeIndex = 1;</ins>
				<ins>}</ins>
				<ins>else {</ins>
					<ins>cell.TerrainTypeIndex = 2;</ins>
				<ins>}</ins>
			}
			<ins>else {</ins>
				<ins>cell.TerrainTypeIndex = 2;</ins>
			<ins>}</ins>
			cell.SetMapData(<ins>moisture</ins>);
		}
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/finishing-the-simulation/biomes.jpg" width="350" height="200">
							<figcaption>Biomes.</figcaption>
						</figure>
						
						<p>Using and even distribution doesn't produce good result and also doesn't match nature. A better result can be achieved with thresholds like 0.05, 0.12, 0.28, and 0.85.</p>
						
						<pre translate="no">				if (moisture &lt; <ins>0.05f</ins>) {
					cell.TerrainTypeIndex = 4;
				}
				else if (moisture &lt; <ins>0.12f</ins>) {
					cell.TerrainTypeIndex = 0;
				}
				else if (moisture &lt; <ins>0.28f</ins>) {
					cell.TerrainTypeIndex = 3;
				}
				else if (moisture &lt; <ins>0.85f</ins>) {
					cell.TerrainTypeIndex = 1;
				}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-25/finishing-the-simulation/tweaked-biomes.jpg" width="350" height="200">
							<figcaption>Tweaked biomes.</figcaption>
						</figure>
						
						<p>The next tutorial is <a href="../part-26/index.html">Biomes and Rivers</a>.</p>
					</section>
					
					<a href="https://catlikecoding.com/unity/tutorials/hex-map/part-25/finishing-the-simulation/finishing-the-simulation.unitypackage" download rel="nofollow">unitypackage</a>
					<a href="https://catlikecoding.com/unity/tutorials/hex-map/part-25/Hex-Map-25.pdf" download rel="nofollow">PDF</a>
				</section>
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>