<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/hex-map-1/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/hex-map/part-1/tutorial-image.png">
		<meta property="og:title" content="Hex Map 1">
		<meta property="og:description" content="A Unity Hex Map tutorial about creating a hexagonal grid. Part 1 of 27.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Hex Map 1</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/hex-map/part-1/#article",
				"headline": "Hex Map 1",
				"alternativeHeadline": "Creating a Hexagonal Grid",
				"datePublished": "2016-01-30",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Hex Map tutorial about creating a hexagonal grid. Part 1 of 27.",
				"image": "https://catlikecoding.com/unity/tutorials/hex-map/part-1/tutorial-image.png",
				"dependencies": "Unity 5.3.1",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/hex-map/", "name": "Hex Map" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				HexCell: 1,
				HexCoordinates: 1,
				HexCoordinatesDrawer: 1,
				HexGrid: 1,
				HexMapEditor: 1,
				HexMesh: 1,
				HexMetrics: 1
			};
			
			var hasMath = true;
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Hex Map</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Hex Map 1</h1>
					<p>Creating a Hexagonal Grid</p>
					<ul>
						<li>Turn squares into hexagons.</li>
						<li>Triangulate a hexagonal grid.</li>
						<li>Work with cube coordinates.</li>
						<li>Interact with grid cells.</li>
						<li>Make an in-game editor.</li>
					</ul>
				</header>

				<p>This tutorial is the first part of a series about hexagon maps. Many games use hex grids, especially strategy games, including Age of Wonders 3, Civilization 5, and Endless Legend. We will start with the basics, incrementally adding features until we end up with a complex hex-based terrain.</p>
				
				<p>This tutorial assumes you have completed the <i>Mesh Basics</i> series, which starts with <a href="../../procedural-grid/index.html">Procedural Grid</a>. It has been created with Unity 5.3.1. The entire series progresses through multiple versions of Unity. The final part is made with Unity 2017.3.0p3.</p>
				
				<figure>
					<img src="tutorial-image.png" width="512" height="256">
					<figcaption>A basic hex map.</figcaption>
				</figure>
				
				<section>
					<h2>About Hexagons</h2>
					
					<p>Why use hexagons? If you need a grid, it makes sense to just use squares. Squares are indeed simple to draw and position, but they have a downside. Take a look at a single square in the grid. Then look at its neighbors.</p>
					
					<figure>
						<img src="about-hexagons/square-grid.png" width="255" height="255">
						<figcaption>A square and its neighbors.</figcaption>
					</figure>
					
					<p>There are eight neighbors in total. Four can be reached by crossing an edge of the square. They are the horizontal and vertical neighbors. The other four can be reached by crossing a corner of the square. These are the diagonal neighbors.</p>
					
					<p>What is the distance between the centers of adjacent square cells in the grid? If the edge length is 1, then the answer is 1 for the horizontal and vertical neighbors. But for diagonal neighbors the answer is &radic;2.</p>
					
					<p>The differences between the two kinds of neighbor lead to complications. If you use discrete movement, how do you treat diagonal movement? Do you allow it at all? How can you create a more organic look? Different games use different approaches, with different advantages and disadvantages. One approach is to not use a square grid at all, but to use hexagons instead.</p>
					
					<figure>
						<img src="about-hexagons/hexagon-grid.png" width="285" height="270">
						<figcaption>A hexagon and its neighbors.</figcaption>
					</figure>
					
					<p>Compared to a square, a hexagon has only six neighbors instead of eight. All of these neighbors are edge neighbors. There are no corner neighbors. So there is only one kind of neighbor, which simplifies a lot of things. Of course a hexagon grid is less straightforward to construct than a square grid, but we can deal with that.</p>
					
					<p>Before we get started, we have to settle on a size for our hexagons. Let's pick an edge length of 10 units. Because a hexagon consists of a circle of six equilateral triangles, the distance from the center to any corner is also 10. This defines the outer radius of our hexagon cell.</p>
					
					<figure>
						<img src="about-hexagons/hexagon.png" width="225" height="225">
						<figcaption>A hexagon's outer and inner radius.</figcaption>
					</figure>
					
					<p>There is also an inner radius, which is the distance from the center to each of the edges. This metric is important, because the distance to the center of each neighbor is equal to twice this value. The inner radius is equal to `sqrt(3)/2` times the outer radius, so `5 sqrt(3)` in our case. Let's put these metrics in a static class for easy access.</p>
					
					<pre translate="no"><mark>using UnityEngine;</mark>

<mark>public static class HexMetrics {</mark>

	<mark>public const float outerRadius = 10f;</mark>

	<mark>public const float innerRadius = outerRadius * 0.866025404f;</mark>
<mark>}</mark></pre>
					
					<aside>
						<h3>How do you derive the inner radius?</h3>
						<div>
							<p>Take one of the six triangles of a hexagon. The inner radius is equal to the height of this triangle. You get this height by splitting the triangle into two right triangles, then you can use the <a href="https://en.wikipedia.org/wiki/Pythagorean_theorem">Pythagorean theorem</a>.</p>
							
							<p>So for edge length `e`, the inner radius is `sqrt(e^2 - (e/2)^2) = sqrt(3e^2/4) = e sqrt(3)/2 ~~ 0.886e`.</p>
						</div>
					</aside>
					
					<p>While we're at it, let's also define the positions of the six corners relative to the cell's center. Note that there are two ways to orientate a hexagon. Either pointy side up or flat side up. We'll put a corner at the top. Start with this corner and add the rest in clockwise order. Place them in the XZ plane, so the hexagons will be aligned with the ground.</p>
					
					<figure>
						<img src="about-hexagons/orientations.png" width="250" height="125">
						<figcaption>Possible orientations.</figcaption>
					</figure>
					
					<pre translate="no">	<mark>public static Vector3[] corners = {</mark>
		<mark>new Vector3(0f, 0f, outerRadius),</mark>
		<mark>new Vector3(innerRadius, 0f, 0.5f * outerRadius),</mark>
		<mark>new Vector3(innerRadius, 0f, -0.5f * outerRadius),</mark>
		<mark>new Vector3(0f, 0f, -outerRadius),</mark>
		<mark>new Vector3(-innerRadius, 0f, -0.5f * outerRadius),</mark>
		<mark>new Vector3(-innerRadius, 0f, 0.5f * outerRadius)</mark>
	<mark>};</mark></pre>
					
					<a href="about-hexagons/about-hexagons.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Grid Construction</h2>
					
					<p>To create a hexagon grid, we need grid cells. Create a <code>HexCell</code> component for this purpose. Leave it empty for now, because we're not using any cell data yet.</p>
					
					<pre translate="no"><mark>using UnityEngine;</mark>

<mark>public class HexCell : MonoBehaviour {</mark>
<mark>}</mark></pre>
					
					<p>To start really simple, create a default plane object, add the cell component to it, and turn it into a prefab.</p>
					
					<figure>
						<img src="grid-construction/hex-cell-plane.png" width="320" height="205">
						<figcaption>Using a plane as a hex cell prefab.</figcaption>
					</figure>
					
					<p>Next comes the grid. Create a simple component with public width, height, and cell prefab variables. Then add a game object with this component to the scene.</p>
					
					<pre translate="no"><mark>using UnityEngine;</mark>

<mark>public class HexGrid : MonoBehaviour {</mark>

	<mark>public int width = 6;</mark>
	<mark>public int height = 6;</mark>

	<mark>public HexCell cellPrefab;</mark>

<mark>}</mark></pre>
					
					<figure>
						<img src="grid-construction/hex-grid.png" width="320" height="154">
						<figcaption>Hex grid object.</figcaption>
					</figure>
					
					<p>Let's begin with creating a regular square grid, as we already know how to do that. Store the cells in an array so we can access them later.</p>
					
					<p>As the default planes are 10 by 10 units, offset each cell by that amount.</p>
					
					<pre translate="no">	<mark>HexCell[] cells;</mark>

	<mark>void Awake () {</mark>
		<mark>cells = new HexCell[height * width];</mark>

		<mark>for (int z = 0, i = 0; z &lt; height; z++) {</mark>
			<mark>for (int x = 0; x &lt; width; x++) {</mark>
				<mark>CreateCell(x, z, i++);</mark>
			<mark>}</mark>
		<mark>}</mark>
	<mark>}</mark>
	
	<mark>void CreateCell (int x, int z, int i) {</mark>
		<mark>Vector3 position;</mark>
		<mark>position.x = x * 10f;</mark>
		<mark>position.y = 0f;</mark>
		<mark>position.z = z * 10f;</mark>

		<mark>HexCell cell = cells[i] = Instantiate&lt;HexCell>(cellPrefab);</mark>
		<mark>cell.transform.SetParent(transform, false);</mark>
		<mark>cell.transform.localPosition = position;</mark>
	<mark>}</mark></pre>
					
					<figure>
						<img src="grid-construction/square-grid-of-planes.png" width="465" height="175">
						<figcaption>Square grid of planes.</figcaption>
					</figure>
					
					<p>This gives us a nice grid of seamless square cells. But which cell is where? Of course that is easy for us to check, but it will get trickier with hexagons. It would be convenient if we could see all cell coordinates at once.</p>
					
					<section>
						<h3>Showing Coordinates</h3>
						
						<p>Add a canvas to the scene via <i>GameObject / UI / Canvas</i> and make it a child of our grid object. As this is a purely informative canvas, remove its raycaster component. You can also delete the event system object that was automatically added to the scene, as we don't need it yet.</p>
						
						<p>Set the <i>Render Mode</i> to <i>World Space</i> and rotate by 90 degrees around the X axis so the canvas overlays our grid. Set its pivot to zero and its position too. Give it a slight vertical offset so its contents will appear on top. Its width and height don't matter, as we'll position its contents ourselves. You can set them to zero to get rid of the big rectangle in the scene view.</p>
						
						<p>As a finishing touch, increase <i>Dynamic Pixels Per Unit</i> to 10. This will ensure that text objects will use a decent font texture resolution.</p>
						
						<figure>
							<img alt="hierarchy" src="grid-construction/hierarchy.png" width="120" height="32"><br>
							<img alt="inspector" src="grid-construction/canvas.png" width="320" height="393">
							<figcaption>Canvas for the hex grid coordinates.</figcaption>
						</figure>
						
						<p>To show the coordinates, create a text object via <i>GameObject / UI / Text</i> and turn it into a prefab. Make sure that its anchors and pivot are centered and set its size to 5 by 15. The text's alignment should be both horizontally and vertically centered as well. Set the font size to 4. Finally, we don't need the default text and we won't use <i>Rich Text</i> either. It doesn't matter whether <i>Raycast Target</i> is enabled or not, because our canvas won't do that anyway.</p>
						
						<figure>
							<img alt="transform and canvas components" src="grid-construction/label-part-1.png" width="320" height="228">
							<img alt="text component" src="grid-construction/label-part-2.png" width="320" height="350">
							<figcaption>Cell label prefab.</figcaption>
						</figure>
						
						<p>Now our grid needs to know about the canvas and the prefab. Add <code>using UnityEngine.UI;</code> at the top of its script to conveniently access the <code>UnityEngine.UI.Text</code> type. The label prefab needs a public variable, while the canvas can be found by invoking <code>GetComponentInChildren</code>.</p>
						
						<pre translate="no">	<mark>public Text cellLabelPrefab;</mark>

	<mark>Canvas gridCanvas;</mark>

	void Awake () {
		<mark>gridCanvas = GetComponentInChildren&lt;Canvas>();</mark>
		
		&hellip;
	}</pre>
						<figure>
							<img src="grid-construction/grid-with-label-prefab.png" width="320" height="112">
							<figcaption>Connecting the label prefab.</figcaption>
						</figure>
						
						<p>After hooking up the label prefab, we can instantiate them and show the cell coordinates. Place a newline character between X and Z so they end up on separate lines.</p>
						
						<pre translate="no">	void CreateCell (int x, int z, int i) {
		&hellip;

		<mark>Text label = Instantiate&lt;Text>(cellLabelPrefab);</mark>
		<mark>label.rectTransform.SetParent(gridCanvas.transform, false);</mark>
		<mark>label.rectTransform.anchoredPosition =</mark>
			<mark>new Vector2(position.x, position.z);</mark>
		<mark>label.text = x.ToString() + "\n" + z.ToString();</mark>
	}</pre>
					
						<figure>
							<img src="grid-construction/grid-with-labels.png" width="465" height="175">
							<figcaption>Visible coordinates.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Hexagon Positions</h3>
						
						<p>Now that we can visually identify each cell, let's start moving them around. We know that the distance between adjacent hexagon cells in the X direction is equal to twice the inner radius. So let's use that. Also, the distance to the next row of cells should be 1.5 times the outer radius.</p>
						
						<figure>
							<img src="grid-construction/neighbor-distances.png" width="380" height="370">
							<figcaption>The geometry of hexagon neighbors.</figcaption>
						</figure>
						
						<pre translate="no">		position.x = x <mark>* (HexMetrics.innerRadius * 2f)</mark>;
		position.y = 0f;
		position.z = z <mark>* (HexMetrics.outerRadius * 1.5f)</mark>;</pre>
					
						<figure>
							<img src="grid-construction/hex-distances.png" width="474" height="222">
							<figcaption>Using hexagon distances, without offset.</figcaption>
						</figure>
						
						<p>Of course consecutive hexagon rows are not directly above each other. Each row is offset along the X axis by the inner radius. We can do this by adding half of Z to X before multiplying by double the inner radius.</p>
						
						<pre translate="no">		position.x = <mark>(</mark>x <mark>+ z * 0.5f)</mark> * (HexMetrics.innerRadius * 2f);</pre>
						
						<figure>
							<img src="grid-construction/rhombus.png" width="500" height="222">
							<figcaption>Proper hexagon positions produce a rhombus grid.</figcaption>
						</figure>
						
						<p>While this places our cells in proper hexagon positions, our grid now fills a rhombus instead of a rectangle. As it is more convenient to work with rectangular grids, let's force the cells back in line. We do this by undoing part of the offset. Every second row, all cells should move back one additional step. Subtracting the integer division of Z by 2 before multiplying will do the trick.</p>
						
						<pre translate="no">		position.x = (x + z * 0.5f <mark>- z / 2</mark>) * (HexMetrics.innerRadius * 2f);</pre>
					
						<figure>
							<img src="grid-construction/rectangular-area.png" width="490" height="222">
							<figcaption>Hexagonal spacing in a rectangular area.</figcaption>
						</figure>
					</section>
					
					<a href="grid-construction/grid-construction.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Rendering Hexagons</h2>
					
					<p>With the cells correctly positioned, we can move on to displaying actual hexagons. We have to rid ourselves of the planes first, so remove all components except the <code>HexCell</code> one from the cell prefab.</p>
					
					<figure>
						<img src="rendering-hexagons/empty-cell-prefab.png" width="320" height="100">
						<figcaption>No more planes.</figcaption>
					</figure>
					
					<p>Just like in the <a href="https://catlikecoding.com/unity/tutorials/procedural-grid">Mesh Basics</a> tutorials, we'll use a single mesh to render the entire grid. However, this time we're not going to predetermine how many vertices and triangles we need. We'll use lists instead.</p>
					
					<p>Create a new <code>HexMesh</code> component to take care of our mesh. It requires a mesh filter and renderer, has a mesh, and has lists for its vertices and triangles.</p>
					
					<pre translate="no"><mark>using UnityEngine;</mark>
<mark>using System.Collections.Generic;</mark>

<mark>[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]</mark>
<mark>public class HexMesh : MonoBehaviour {</mark>

	<mark>Mesh hexMesh;</mark>
	<mark>List&lt;Vector3> vertices;</mark>
	<mark>List&lt;int> triangles;</mark>

	<mark>void Awake () {</mark>
		<mark>GetComponent&lt;MeshFilter>().mesh = hexMesh = new Mesh();</mark>
		<mark>hexMesh.name = "Hex Mesh";</mark>
		<mark>vertices = new List&lt;Vector3>();</mark>
		<mark>triangles = new List&lt;int>();</mark>
	<mark>}</mark>
<mark>}</mark></pre>
					
					<p>Create a new child object with this component for our grid. It will automatically get a mesh renderer, but won't have a material assigned to it. So add the default material to it.</p>
					
					<figure>
						<img alt="inspector" src="rendering-hexagons/hex-mesh.png" width="320" height="186">
						<img alt="hierarchy" src="rendering-hexagons/hierarchy.png" width="120" height="50">
						<figcaption>Hex mesh object.</figcaption>
					</figure>
					
					<p>Now <code>HexGrid</code> can retrieve its hex mesh, the same way it finds its canvas.</p>
					
					<pre translate="no">	<mark>HexMesh hexMesh;</mark>

	void Awake () {
		<mark>gridCanvas = GetComponentInChildren&lt;Canvas>();</mark>
		<mark>hexMesh = GetComponentInChildren&lt;HexMesh>();</mark>
		
		&hellip;
	}
</pre>
					
					<p>After the grid has awoken, it has to tell the mesh to triangulate its cells. We must be certain this happens after the hex mesh component has awoken as well. As <code>Start</code> gets invoked later, let's do it there.</p>
					
					<pre translate="no">	<mark>void Start () {</mark>
		<mark>hexMesh.Triangulate(cells);</mark>
	<mark>}</mark></pre>
					
					<p>This <code>HexMesh.Triangulate</code> method could be invoked at any time, even when cells have already been triangulated earlier. So we should begin by clearing the old data. Then loop through all the cells, triangulating them individually. After that is done, assign the generated vertices and triangles to the mesh, and end by recalculating the mesh normals.</p>
					
					<pre translate="no">	<mark>public void Triangulate (HexCell[] cells) {</mark>
		<mark>hexMesh.Clear();</mark>
		<mark>vertices.Clear();</mark>
		<mark>triangles.Clear();</mark>
		<mark>for (int i = 0; i &lt; cells.Length; i++) {</mark>
			<mark>Triangulate(cells[i]);</mark>
		<mark>}</mark>
		<mark>hexMesh.vertices = vertices.ToArray();</mark>
		<mark>hexMesh.triangles = triangles.ToArray();</mark>
		<mark>hexMesh.RecalculateNormals();</mark>
	<mark>}</mark>
	
	<mark>void Triangulate (HexCell cell) {</mark>
	<mark>}</mark></pre>
					
					<p>As hexagons are made with triangles, let's create a convenient method to add a triangle, given three vertex positions. It simply adds the vertices in order. It also adds the indices of those vertices to form a triangle. The index of the first vertex is equal to the length of the vertex list before adding the new vertices to it. So remember it before adding the vertices.</p>
					
					<pre translate="no">	<mark>void AddTriangle (Vector3 v1, Vector3 v2, Vector3 v3) {</mark>
		<mark>int vertexIndex = vertices.Count;</mark>
		<mark>vertices.Add(v1);</mark>
		<mark>vertices.Add(v2);</mark>
		<mark>vertices.Add(v3);</mark>
		<mark>triangles.Add(vertexIndex);</mark>
		<mark>triangles.Add(vertexIndex + 1);</mark>
		<mark>triangles.Add(vertexIndex + 2);</mark>
	<mark>}</mark></pre>
					
					<p>Now we can triangulate our cells. Let's start with just the first triangle. Its first vertex is the center of the hexagon. The other two vertices are the first and second corners, relative to its center.</p>
					
					<pre translate="no">	void Triangulate (HexCell cell) {
		<mark>Vector3 center = cell.transform.localPosition;</mark>
		<mark>AddTriangle(</mark>
			<mark>center,</mark>
			<mark>center + HexMetrics.corners[0],</mark>
			<mark>center + HexMetrics.corners[1]</mark>
		<mark>);</mark>
	}</pre>
					
					<figure>
						<img src="rendering-hexagons/one-triangle-per-hex.png" width="430" height="220">
						<figcaption>The first triangle of each cell.</figcaption>
					</figure>
					
					<p>This works, so loop through all six triangles.</p>
					
					<pre translate="no">		Vector3 center = cell.transform.localPosition;
		<mark>for (int i = 0; i &lt; 6; i++) {</mark>
			AddTriangle(
				center,
				center + HexMetrics.corners[<mark>i</mark>],
				center + HexMetrics.corners[<mark>i +</mark> 1]
			);
		<mark>}</mark></pre>
					
					<aside>
						<h3>Can't we share vertices?</h3>
						<div>
							<p>Yes, we could. Actually, we can do even better and use only four triangles to render one hexagon, instead of six. But refraining from doing so keeps things simple. That's a good idea right now, because things will get more complicated in later tutorials. Optimizing vertices and triangles at this point will only get the in the way.</p>
						</div>
					</aside>
					
					<p>Unfortunately, this produces an <code>IndexOutOfRangeException</code>. This happens because the last triangle tries to fetch a seventh corner, which doesn't exist. Of course it should wrap back and use the first corner for its final vertex. Alternatively, we could duplicate the first corner in <code>HexMetrics.corners</code>, so we don't have to worry about going out of bounds.</p>
					
					<pre translate="no">	public static Vector3[] corners = {
		new Vector3(0f, 0f, outerRadius),
		new Vector3(innerRadius, 0f, 0.5f * outerRadius),
		new Vector3(innerRadius, 0f, -0.5f * outerRadius),
		new Vector3(0f, 0f, -outerRadius),
		new Vector3(-innerRadius, 0f, -0.5f * outerRadius),
		new Vector3(-innerRadius, 0f, 0.5f * outerRadius)<mark>,</mark>
		<mark>new Vector3(0f, 0f, outerRadius)</mark>
	};</pre>
					
					<figure>
						<img src="rendering-hexagons/complete-hexagons.png" width="490" height="240">
						<figcaption>Complete hexagons.</figcaption>
					</figure>
					
					<a href="rendering-hexagons/rendering-hexagons.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Hexagonal Coordinates</h2>
					
					<p>Let's look at our cell coordinates again, in the context of a hexagon grid. The Z coordinate appears fine, but the X coordinate zigzags. This is a side effect of offsetting our rows to cover a rectangular area.</p>
					
					<figure>
						<img src="hexagonal-coordinates/offset-diagram.png" width="400" height="369">
						<figcaption>Offset coordinates, highlighting the zero lines.</figcaption>
					</figure>
					
					<p>These offset coordinates aren't easy to work with when dealing with hexagons. Let's add a <code>HexCoordinates</code> struct which we can use to convert to a different coordinate system. Make it serializable so Unity can store it, which allows them to survive recompiles while in play mode. Also, make these coordinates immutable by using public readonly properties.</p>
					
					<pre translate="no"><mark>using UnityEngine;</mark>

<mark>[System.Serializable]</mark>
<mark>public struct HexCoordinates {</mark>

	<mark>public int X { get; private set; }</mark>

	<mark>public int Z { get; private set; }</mark>

	<mark>public HexCoordinates (int x, int z) {</mark>
		<mark>X = x;</mark>
		<mark>Z = z;</mark>
	<mark>}</mark>
<mark>}</mark></pre>
					
					<p>Add a static method to create a set of coordinates using regular offset coordinates. For now, just copy these coordinates verbatim.</p>
					
					<pre translate="no">	<mark>public static HexCoordinates FromOffsetCoordinates (int x, int z) {</mark>
		<mark>return new HexCoordinates(x, z);</mark>
	<mark>}</mark>
<mark>}</mark></pre>
					
					<p>Add convenient string conversion methods as well. The default <code>ToString</code> method return the struct's type name, which isn't useful. Override it to return the coordinates on a single line. Also add a method to put the coordinates on separate lines, because we are already using such a layout.</p>
					
					<pre translate="no">	<mark>public override string ToString () {</mark>
		<mark>return "(" + X.ToString() + ", " + Z.ToString() + ")";</mark>
	<mark>}</mark>

	<mark>public string ToStringOnSeparateLines () {</mark>
		<mark>return X.ToString() + "\n" + Z.ToString();</mark>
	<mark>}</mark></pre>
					
					<p>Now we can give a set of coordinates to our <code>HexCell</code> component.</p>
					
					<pre translate="no">public class HexCell : MonoBehaviour {

	<mark>public HexCoordinates coordinates;</mark>
}</pre>
					
					<p>Adjust <code>HexGrid.CreateCell</code> so it takes advantage of the new coordinates.</p>
					
					<pre translate="no">		HexCell cell = cells[i] = Instantiate&lt;HexCell>(cellPrefab);
		cell.transform.SetParent(transform, false);
		cell.transform.localPosition = position;
		<mark>cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z);</mark>
		
		Text label = Instantiate&lt;Text>(cellLabelPrefab);
		label.rectTransform.SetParent(gridCanvas.transform, false);
		label.rectTransform.anchoredPosition =
			new Vector2(position.x, position.z);
		label.text = <mark>cell.coordinates.ToStringOnSeparateLines()</mark>;
</pre>
					
					<p>Now let's fix out those X coordinates so they are aligned along a straight axis. We can do this by undoing the horizontal shift. The result is typically know as axial coordinates.</p>
					
					<pre translate="no">	public static HexCoordinates FromOffsetCoordinates (int x, int z) {
		return new HexCoordinates(x <mark>- z / 2</mark>, z);
	}</pre>
					
					<figure>
						<img alt="diagram" src="hexagonal-coordinates/axial-diagram.png" width="400" height="369">
						<img alt="scene" src="hexagonal-coordinates/axial-coordinates.png" width="490" height="240">
						<figcaption>Axial coordinates.</figcaption>
					</figure>
					
					<p>This two-dimensional coordinate system lets us consistently describe movement and offsets in four directions. However, the two remaining directions still require special treatment. This indicates that there is a third dimension. Indeed, if we were to horizontally flip the X dimension, we get the missing Y dimension.</p>
					
					<figure>
						<img src="hexagonal-coordinates/cube-diagram.png" width="400" height="369">
						<figcaption>An Y dimension appears.</figcaption>
					</figure>
					
					<p>As these X and Y dimensions mirror each other, adding their coordinates together will always produces the same result, if you keep Z constant. In fact, if you add all three coordinates together you will always get zero. If you increment one coordinate, you have to decrement another. Indeed, this produces six possible directions of movement. These coordinates are typically know as cube coordinates, as they are three-dimensional and the topology resembles a cube.</p>
					
					<p>Because all coordinates add up to zero, you can always derive each coordinate from the other two. As we already store the X and Z coordinates, we don't need to store the Y coordinate. We can include a property that computes it on demand and use that in the string methods.</p>
					
					<pre translate="no">	<mark>public int Y {</mark>
		<mark>get {</mark>
			<mark>return -X - Z;</mark>
		<mark>}</mark>
	<mark>}</mark>

	public override string ToString () {
		return "(" +
			X.ToString() <mark>+ ", " + Y.ToString()</mark> + ", " + Z.ToString() + ")";
	}

	public string ToStringOnSeparateLines () {
		return X.ToString() <mark>+ "\n" + Y.ToString()</mark> + "\n" + Z.ToString();
	}</pre>
					
					<figure>
						<img src="hexagonal-coordinates/cube-coordinates.png" width="490" height="240">
						<figcaption>Cube coordinates.</figcaption>
					</figure>
					
					<section>
						<h3>Coordinates in the Inspector</h3>
						
						<p>Select one of the grid cells while in play mode. As it turns out, the inspector doesn't show its coordinates. Only the prefix label of <code>HexCell.coordinates</code> is shown.</p>
					</section>
					
					<figure>
						<img src="hexagonal-coordinates/inspector-empty-coordinates.png" width="320" height="58">
						<figcaption>Inspector does not show coordinates.</figcaption>
					</figure>
					
					<p>While this is not a big deal, it would be neat if the coordinates do show up. Unity currently doesn't display the coordinates because they aren't marked as serialized fields. To do so, we have to explicitly define serializable fields for X and Z.</p>
					
					<pre translate="no">	<mark>[SerializeField]</mark>
	<mark>private int x, z;</mark>

	public int X {
		<mark>get {</mark>
			<mark>return x;</mark>
		<mark>}</mark>
	}

	public int Z {
		<mark>get {</mark>
			<mark>return z;</mark>
		<mark>}</mark>
	}

	public HexCoordinates (int x, int z) {
		<mark>this.x</mark> = x;
		<mark>this.z</mark> = z;
	}</pre>
					
					<figure>
						<img src="hexagonal-coordinates/inspector-editable-coordinates.png" width="320" height="56">
						<figcaption>Ugly and editable.</figcaption>
					</figure>
					
					<p>The X and Z coordinates are now shown, but they are editable, which we don't want, as the coordinates should be fixed. It also doesn't look nice that they are displayed below each other.</p>
					
					<p>We can do a better job by defining a custom property drawer for the <code>HexCoordinates</code> type. Create a <code>HexCoordinatesDrawer</code> script and put it inside an <i>Editor</i> folder, as it is an editor-only script.</p>
					
					<p>The class should extend <code>UnityEditor.PropertyDrawer</code> and needs the <code>UnityEditor.CustomPropertyDrawer</code> attribute to associate it with the correct type.</p>
					
					<pre translate="no"><mark>using UnityEngine;</mark>
<mark>using UnityEditor;</mark>

<mark>[CustomPropertyDrawer(typeof(HexCoordinates))]</mark>
<mark>public class HexCoordinatesDrawer : PropertyDrawer {</mark>
<mark>}</mark></pre>
					
					<p>Property drawers render their contents via an <code>OnGUI</code> method. This method is provided the screen rectangle to draw inside, the serialized data of the property, and the label of the field it belongs to.</p>
					
					<pre translate="no">	<mark>public override void OnGUI (</mark>
		<mark>Rect position, SerializedProperty property, GUIContent label</mark>
	<mark>) {</mark>
	<mark>}</mark>
</pre>
					
					<p>Extract the x and z values from the property and use those to create a new set of coordinates. Then draw a GUI label at the specified position, using our <code>HexCoordinates.ToString</code> method.</p>
					
					<pre translate="no">	public override void OnGUI (
		Rect position, SerializedProperty property, GUIContent label
	) {
		<mark>HexCoordinates coordinates = new HexCoordinates(</mark>
			<mark>property.FindPropertyRelative("x").intValue,</mark>
			<mark>property.FindPropertyRelative("z").intValue</mark>
		<mark>);</mark>
		
		<mark>GUI.Label(position, coordinates.ToString());</mark>
	}</pre>
					
					<figure>
						<img src="hexagonal-coordinates/inspector-no-label.png" width="320" height="58">
						<figcaption>Coordinates without prefix label.</figcaption>
					</figure>
					
					<p>This shows our coordinates, but we're now missing the field name. These names are usually drawn with the <code>EditorGUI.PrefixLabel</code> method. As a bonus, it returns an adjusted rectangle which matches the space to the right of this label.</p>
					
					<pre translate="no">		<mark>position = EditorGUI.PrefixLabel(position, label);</mark>
		GUI.Label(position, coordinates.ToString());
</pre>
					
					<figure>
						<img src="hexagonal-coordinates/inspector-with-label.png" width="320" height="58">
						<figcaption>Coordinates with label.</figcaption>
					</figure>
					
					<a href="hexagonal-coordinates/hexagonal-coordinates.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Touching Cells</h2>
					
					<p>A hex grid isn't very interesting if we cannot interact with it. The most basic interaction would be touching a cell, so let's add support for that. For now just put this code directly in <code>HexGrid</code>. We'll move it somewhere else once we got it all working.</p>
					
					<p>To touch a cell, we can shoot rays into the scene from the mouse position. We can use the same approach that we took in the <a href="https://catlikecoding.com/unity/tutorials/mesh-deformation">Mesh Deformation</a> tutorial.</p>
					
					<pre translate="no">	<mark>void Update () {</mark>
		<mark>if (Input.GetMouseButton(0)) {</mark>
			<mark>HandleInput();</mark>
		<mark>}</mark>
	<mark>}</mark>

	<mark>void HandleInput () {</mark>
		<mark>Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition);</mark>
		<mark>RaycastHit hit;</mark>
		<mark>if (Physics.Raycast(inputRay, out hit)) {</mark>
			<mark>TouchCell(hit.point);</mark>
		<mark>}</mark>
	<mark>}</mark>
	
	<mark>void TouchCell (Vector3 position) {</mark>
		<mark>position = transform.InverseTransformPoint(position);</mark>
		<mark>Debug.Log("touched at " + position);</mark>
	<mark>}</mark></pre>
					
					<p>This doesn't do anything yet. We need to add a collider to the grid so that the ray has something to hit. So give <code>HexMesh</code> a mesh collider.</p>
					
					<pre translate="no">	<mark>MeshCollider meshCollider;</mark>

	void Awake () {
		GetComponent&lt;MeshFilter>().mesh = hexMesh = new Mesh();
		<mark>meshCollider = gameObject.AddComponent&lt;MeshCollider>();</mark>
		&hellip;
	}</pre>
					
					<p>Assign our mesh to the collider after we finished triangulating.</p>
					
					<pre translate="no">	public void Triangulate (HexCell[] cells) {
		&hellip;
		<mark>meshCollider.sharedMesh = hexMesh;</mark>
	}</pre>
					
					<aside>
						<h3>Couldn't we just use a box collider?</h3>
						<div>
							<p>We could, but it wouldn't exactly fit the contour of our grid. And our grid won't stay flat for long either, although that's part of a future tutorial.</p>
						</div>
					</aside>
					
					<p>We can now touch the grid! But which cell are we touching? To know that, we have to convert the touch position to hex coordinates. This is a job for <code>HexCoordinates</code>, so let's declare that is has a static <code>FromPosition</code> method.</p>
					
					<pre translate="no">	public void TouchCell (Vector3 position) {
		position = transform.InverseTransformPoint(position);
		<mark>HexCoordinates coordinates = HexCoordinates.FromPosition(position);</mark>
		Debug.Log("touched at " + <mark>coordinates.ToString()</mark>);
	}</pre>
					
					<p>How would this method figure out which coordinate belongs to a position? We can start by dividing x by the horizontal width of a hexagon. And because the Y coordinate is a mirror of the X coordinate, the negative of x gives us y.</p>

					<pre translate="no">	<mark>public static HexCoordinates FromPosition (Vector3 position) {</mark>
		<mark>float x = position.x / (HexMetrics.innerRadius * 2f);</mark>
		<mark>float y = -x;</mark>
	<mark>}</mark></pre>
					
					<p>But of course that would only give us correct coordinates if Z were zero. Once again we have to shift as we move along Z. Every two rows we should shift an entire unit to the left.</p>
					
										<pre translate="no">		<mark>float offset = position.z / (HexMetrics.outerRadius * 3f);</mark>
		<mark>x -= offset;</mark>
		<mark>y -= offset;</mark></pre>
					
					<p>Our x and y values now end up as whole numbers at the center of each cell. So by rounding them to integers we should get the coordinates. We derive Z as well and then construct the final coordinates.</p>

					<pre translate="no">		<mark>int iX = Mathf.RoundToInt(x);</mark>
		<mark>int iY = Mathf.RoundToInt(y);</mark>
		<mark>int iZ = Mathf.RoundToInt(-x -y);</mark>

		<mark>return new HexCoordinates(iX, iZ);</mark></pre>
					
					<p>The results look promising, but are the coordinates correct? Some careful exploring will reveal that we sometimes end up with coordinates that do not add up to zero! Let's log a warning when this happens, to make sure that it really occurs.</p>
					
					<pre translate="no">		<mark>if (iX + iY + iZ != 0) {</mark>
			<mark>Debug.LogWarning("rounding error!");</mark>
		<mark>}</mark>
		
		return new HexCoordinates(iX, iZ);</pre>
					
					<p>Indeed, we get warnings. How do we resolve this issue? It appears to happen only near the edges between hexagons. So rounding the coordinates leads to trouble. Which coordinate got rounded in the wrong direction? Well, the further away from a cell's center you get, the more rounding occurs. So it makes sense to assume that the coordinate that got rounded the most is incorrect.</p>
					
					<p>The solution then becomes to discard the coordinate with the largest rounding delta, and reconstruct it from the other two. But as we only need X and Z, we don't need to bother with reconstructing Y.</p>
					
					<pre translate="no">		if (iX + iY + iZ != 0) {
			<mark>float dX = Mathf.Abs(x - iX);</mark>
			<mark>float dY = Mathf.Abs(y - iY);</mark>
			<mark>float dZ = Mathf.Abs(-x -y - iZ);</mark>

			<mark>if (dX > dY &amp;&amp; dX > dZ) {</mark>
				<mark>iX = -iY - iZ;</mark>
			<mark>}</mark>
			<mark>else if (dZ > dY) {</mark>
				<mark>iZ = -iX - iY;</mark>
			<mark>}</mark>
		}</pre>
					
					<section>
						<h3>Coloring Hexes</h3>
						
						<p>Now that we can touch the correct cell, it is time for some real interaction. Let's change the color of each cell that we hit. Give <code>HexGrid</code> a configurable default and touched cell color.</p>
						
						<pre translate="no">	<mark>public Color defaultColor = Color.white;</mark>
	<mark>public Color touchedColor = Color.magenta;</mark></pre>
						
						<figure>
							<img src="interaction/colors.png" width="320" height="148">
							<figcaption>Cell color choices.</figcaption>
						</figure>
						
						<p>Add a public color field to <code>HexCell</code>.</p>
						
						<pre translate="no">public class HexCell : MonoBehaviour {

	public HexCoordinates coordinates;

	<mark>public Color color;</mark>
}</pre>
						
						<p>Assign the default color to it in <code>HexGrid.CreateCell</code>.</p>
						
						<pre translate="no">	void CreateCell (int x, int z, int i) {
		&hellip;
		cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z);
		<mark>cell.color = defaultColor;</mark>
		&hellip;
	}
</pre>
						
						<p>We also have to add color information to <code>HexMesh</code>.</p>
						
						<pre translate="no">	<mark>List&lt;Color> colors;</mark>

	void Awake () {
		&hellip;
		vertices = new List&lt;Vector3>();
		<mark>colors = new List&lt;Color>();</mark>
		&hellip;
	}

	public void Triangulate (HexCell[] cells) {
		hexMesh.Clear();
		vertices.Clear();
		<mark>colors.Clear();</mark>
		&hellip;
		hexMesh.vertices = vertices.ToArray();
		<mark>hexMesh.colors = colors.ToArray();</mark>
		&hellip;
	}</pre>
						
						<p>When triangulating, we must now add color data for each triangle as well. Add a separate method for that purpose.</p>
						
						<pre translate="no">	void Triangulate (HexCell cell) {
		Vector3 center = cell.transform.localPosition;
		for (int i = 0; i &lt; 6; i++) {
			AddTriangle(
				center,
				center + HexMetrics.corners[i],
				center + HexMetrics.corners[i + 1]
			);
			<mark>AddTriangleColor(cell.color);</mark>
		}
	}

	<mark>void AddTriangleColor (Color color) {</mark>
		<mark>colors.Add(color);</mark>
		<mark>colors.Add(color);</mark>
		<mark>colors.Add(color);</mark>
	<mark>}</mark></pre>
						
						<p>Back to <code>HexGrid.TouchCell</code>. First convert the cell coordinates to the appropriate array index. For a square grid this would just be X plus Z times the width, but in our case we have to add the half-Z offset as well. Then grab the cell, change its color, and triangulate the mesh again.</p>
						
						<aside>
							<h3>Do we really have to triangulate the entire mesh again?</h3>
							<div>
								<p>We could be smart about it, but this is not the time for such optimizations. The mesh will become much more complex in future tutorials. Any assumptions and shortcuts made now will become invalid later on. This brute-force approach will always work.</p>
							</div>
						</aside>
						
						<pre translate="no">	public void TouchCell (Vector3 position) {
		position = transform.InverseTransformPoint(position);
		HexCoordinates coordinates = HexCoordinates.FromPosition(position);
		<mark>int index = coordinates.X + coordinates.Z * width + coordinates.Z / 2;</mark>
		<mark>HexCell cell = cells[index];</mark>
		<mark>cell.color = touchedColor;</mark>
		<mark>hexMesh.Triangulate(cells);</mark>
	}</pre>
						
						<p>Although we can now color cells, we don't see any visual change yet. This is because the default shader doesn't use vertex colors. We have to make our own. Create a new default shader via <i>Assets / Create / Shader / Default Surface Shader</i>. It needs only two changes. First, add color data to its input struct. Second, multiply the albedo by this color. We only care about the RGB channels, as our material is opaque.</p>
						
						<pre translate="no" class="shader">Shader "Custom/VertexColors" {
	Properties {
		_Color ("Color", Color) = (1,1,1,1)
		_MainTex ("Albedo (RGB)", 2D) = "white" {}
		_Glossiness ("Smoothness", Range(0,1)) = 0.5
		_Metallic ("Metallic", Range(0,1)) = 0.0
	}
	SubShader {
		Tags { "RenderType"="Opaque" }
		LOD 200
		
		CGPROGRAM
		#pragma surface surf Standard fullforwardshadows
		#pragma target 3.0

		sampler2D _MainTex;

		struct Input {
			float2 uv_MainTex;
			<mark>float4 color : COLOR;</mark>
		};

		half _Glossiness;
		half _Metallic;
		fixed4 _Color;

		void surf (Input IN, inout SurfaceOutputStandard o) {
			fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
			o.Albedo = c.rgb <mark>* IN.color</mark>;
			o.Metallic = _Metallic;
			o.Smoothness = _Glossiness;
			o.Alpha = c.a;
		}
		ENDCG
	}
	FallBack "Diffuse"
}</pre>
						
						<p>Create a new material that uses this shader, then make sure that the grid mesh uses that material. This will make the cell colors appear.</p>
						
						<figure>
							<img src="interaction/colored-cells.png" width="490" height="240">
							<figcaption>Colored cells.</figcaption>
						</figure>
						
						<aside>
							<h3>I get weird shadow artifacts!</h3>
							<div>
								<p>Custom surface shaders can experience shadow troubles in some Unity versions. If you get ugly shadow dithering or banding, there is Z-fighting going on. Adjusting the shadow bias of the directional light should be enough to solve this.</p>
							</div>
						</aside>
					</section>
					
					<a href="interaction/interaction.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Map Editor</h2>
					
					<p>Now that we know how to edit colors, let's upgrade to a simple in-game editor. This functionality is out of the scope of <code>HexGrid</code>, so change <code>TouchCell</code> into a public method with an additional color parameter. Also remove the <code>touchedColor</code> field.</p>
					
					<pre translate="no">	<mark>public</mark> void <mark>ColorCell</mark> (Vector3 position<mark>, Color color</mark>) {
		position = transform.InverseTransformPoint(position);
		HexCoordinates coordinates = HexCoordinates.FromPosition(position);
		int index = coordinates.X + coordinates.Z * width + coordinates.Z / 2;
		HexCell cell = cells[index];
		cell.color = <mark>color</mark>;
		hexMesh.Triangulate(cells);
	}</pre>
					
					<p>Create a <code>HexMapEditor</code> component and move the <code>Update</code> and <code>HandleInput</code> methods there. Give it a public field to reference a hex grid, an array of colors, and a private field to keep track of the active color. Finally, add a public method to select a color and make sure to initially select the first color.</p>
					
					<pre translate="no"><mark>using UnityEngine;</mark>

<mark>public class HexMapEditor : MonoBehaviour {</mark>

	<mark>public Color[] colors;</mark>

	<mark>public HexGrid hexGrid;</mark>

	<mark>private Color activeColor;</mark>

	<mark>void Awake () {</mark>
		<mark>SelectColor(0);</mark>
	<mark>}</mark>

	void Update () {
		if (Input.GetMouseButton(0)) {
			HandleInput();
		}
	}

	void HandleInput () {
		Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition);
		RaycastHit hit;
		if (Physics.Raycast(inputRay, out hit)) {
			<mark>hexGrid.ColorCell</mark>(hit.point<mark>, activeColor</mark>);
		}
	}

	<mark>public void SelectColor (int index) {</mark>
		<mark>activeColor = colors[index];</mark>
	<mark>}</mark>
}</pre>
					
					<p>Add another canvas, this time keeping its default settings. Add a <code>HexMapEditor</code> component to it, give it a few colors, and connect the hex grid. This time we do need an event system object, and it has once again been created automatically.</p>
					
					<figure>
						<img src="map-editor/canvas.png" width="320" height="283">
						<figcaption>Hex map editor with four colors.</figcaption>
					</figure>
					
					<p>Add a panel to the canvas to house the color selectors, via <i>GameObject / UI / Panel</i>. Give it a toggle group via <i>Components / UI/ Toggle Group</i>. Make it a small panel and put it in a corner of the screen.</p>
					
					<figure>
						<img src="map-editor/panel-toggle-group.png" width="320" height="156">
						<figcaption>Color panel with toggle group.</figcaption>
					</figure>
					
					<p>Now fill the panel with one toggle per color, via <i>GameObject / UI / Toggle</i>. We're not bothering with a fancy UI at this time, just a manual setup that looks good enough.</p>
					
					<figure>
						<img alt="ui" src="map-editor/ui.png" width="85" height="105">
						<img alt="hierarchy" src="map-editor/hierarchy.png" width="120" height="112">
						<figcaption>One toggle per color.</figcaption>
					</figure>
					
					<p>Make sure that only the first toggle is on. Also make them all part of the toggle group, so only one of them will be selected at the same time. Finally, hook them up to the <code>SelectColor</code> method of our editor. You do this via the plus button of the <i>On Value Changed</i> event UI. Select the hex map editor object, then select the correct method from the dropdown list.</p>
					
					<figure>
						<img src="map-editor/toggle.png" width="320" height="461">
						<figcaption>The first toggle.</figcaption>
					</figure>
					
					<p>This event provides a boolean argument which indicated whether the toggle was switched on or off, each time it changes. But we don't care about that. Instead, we have to manually provide an integer argument, which corresponds to the color index that we want to use. So leave that at 0 for the first toggle, set it to 1 for the second, and so on.</p>
					
					<aside>
						<h3>When does the toggle event method get invoked?</h3>
						<div>
							<p>Each time the state of a toggle changes, it will invoke the method. If that method has a boolean parameter, it will tell us whether the toggle was turned on or off.</p>
							
							<p>As our toggles are part of a group, selecting a different one will first turn off the currently active toggle and then turn on the selected toggle. This means that <code>SelectColor</code> will get invoked twice. This is all right, because the second invocation is the one we care about.</p>
						</div>
					</aside>
					
					<figure>
						<img src="map-editor/multi-colored-editing.png" width="450" height="300">
						<figcaption>Painting with multiple colors.</figcaption>
					</figure>
					
					<p>While the UI is functional, there is one annoying detail. To see it, move the panel so it covers the hex grid. When selecting a new color, you will also paint the cells that are underneath the UI. So we're interacting with both the UI and the hex grid at the same time. This is not desirable.</p>
					
					<p>This can be fixed by asking the event system whether it has detected that the cursor is above some object. As it only knows about UI objects, this indicates that we're interacting with the UI. So we should only handle input ourselves when this is not the case.</p>
					
					<pre translate="no">using UnityEngine;
<mark>using UnityEngine.EventSystems;</mark>
	
	&hellip;
	
	void Update () {
		if (
			Input.GetMouseButton(0) <mark>&amp;&amp;</mark>
			<mark>!EventSystem.current.IsPointerOverGameObject()</mark>
		) {
			HandleInput();
		}
	}</pre>
					
					<p>The next tutorial is <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-2">Blending Cell Colors</a>.</p>
					
					<a href="map-editor/map-editor.unitypackage" download rel="nofollow">unitypackage</a>
					<a href="Hex-Map-1.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../../../jquery2.js"></script>
		<script src="../../tutorials.js"></script>
	</body>
</html>