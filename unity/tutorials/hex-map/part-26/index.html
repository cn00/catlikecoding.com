<!DOCTYPE html>
<html lang="en">
	<head prefix="og: http://ogp.me/ns#">
		<meta charset="utf-8">
		<meta property="og:url" content="https://catlikecoding.com/unity/tutorials/hex-map/part-26/">
		<meta property="og:type" content="article">
		<meta property="og:image:width" content="1024">
		<meta property="og:image:height" content="512">
		<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/hex-map/part-26/tutorial-image.jpg">
		<meta property="og:title" content="Hex Map 26">
		<meta property="og:description" content="A Unity Hex Map tutorial about procedurally generating biomes and rivers. Part 26 of 27.">
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:creator" content="@catlikecoding">
		<meta name="viewport" content="width=768">
		<title>Hex Map 26</title>
		<link href="../../tutorials.css" rel="stylesheet">

				<link rel="manifest" href="../../../../site.webmanifest">
		<link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="#aa0000">

		<script type="application/ld+json">{
			"@context": "http://schema.org",
			"@type": "WebPage",
			"mainEntity": {
				"@type": "TechArticle",
				"@id": "https://catlikecoding.com/unity/tutorials/hex-map/part-26/#article",
				"headline": "Hex Map 26",
				"alternativeHeadline": "Biomes and Rivers",
				"datePublished": "2018-02-20",
				"author": { "@type": "Person", "name": "Jasper Flick", "@id": "https://catlikecoding.com/jasper-flick/#person" },
				"publisher": { "@type": "Organization", "name": "Catlike Coding", "@id": "https://catlikecoding.com/#organization" },
				"description": "A Unity Hex Map tutorial about procedurally generating biomes and rivers. Part 26 of 27.",
				"image": "https://catlikecoding.com/unity/tutorials/hex-map/part-26/tutorial-image.jpg",
				"dependencies": "Unity 2017.3.0p3",
				"proficiencyLevel": "Expert"
			},
			"breadcrumb": {
				"@type": "BreadcrumbList",
				"itemListElement": [
					{ "@type": "ListItem", "position": 1, "item": { "@id": "https://catlikecoding.com/unity/", "name": "Unity" }},
					{ "@type": "ListItem", "position": 2, "item": { "@id": "https://catlikecoding.com/unity/tutorials/", "name": "Tutorials" }},
					{ "@type": "ListItem", "position": 3, "item": { "@id": "https://catlikecoding.com/unity/tutorials/hex-map/", "name": "Hex Map" }}
				]
			}
		}</script>
		<script>
			var customTypes = {
				Bezier: 1,
				Biome: 1,
				ClimateData: 1,
				EdgeVertices: 1,
				HemisphereMode: 1,
				HexCell: 1,
				HexCellPriorityQueue: 1,
				HexCellShaderData: 1,
				HexEdgeType: 1,
				HexCoordinates: 1,
				HexCoordinatesDrawer: 1,
				HexDirection: 1,
				HexDirectionExtensions: 1,
				HexFeatureCollection: 1,
				HexFeatureManager: 1,
				HexGameUI: 1,
				HexGrid: 1,
				HexGridChunk: 1,
				HexHash: 1,
				HexMapCamera: 1,
				HexMapEditor: 1,
				HexMapGenerator: 1,
				HexMesh: 1,
				HexMetrics: 1,
				HexUnit: 1,
				ListPool: 1,
				MapRegion: 1,
				NewMapMenu: 1,
				OptionalToggle: 1,
				SaveLoadItem: 1,
				SaveLoadMenu: 1,
				TextureArrayWizard: 1
			};
		</script>
	</head>
	<body>
		<header>
			<a href="../../../../index.html"><img src="../../../../catlike-coding-logo.svg" alt="Catlike Coding" width="45" height="45"></a>
			<nav>
				<ol>
					<li><a href="../../../../index.html">Catlike Coding</a></li>
					<li><a href="../../../index.html">Unity</a></li>
					<li><a href="../../../tutorials">Tutorials</a></li>
					<li><a href="../index.html">Hex Map</a></li>
				</ol>
			</nav>
		</header>
		
		<main>
			<article>
				<header>
					<h1>Hex Map 26</h1>
					<p>Biomes and Rivers</p>
					<ul>
						<li>Have rivers originate from high and wet cells.</li>
						<li>Create a simple temperature model.</li>
						<li>Use a biome matrix for cells, then tweak it.</li>
					</ul>
				</header>

				<p>This is part 26 of a tutorial series about <a href="../index.html">hexagon maps</a>. The <a href="../part-25/index.html">previous part</a> added a partial water cycle to our map generation algorithm. This time we'll supplement it with rivers and temperature and assign more interesting biomes to cells.</p>
				
				<p>This tutorial is made with Unity 2017.3.0p3.</p>
				
				<figure>
					<img src="tutorial-image.jpg" width="512" height="256">
					<figcaption>Heat and water brings a map to life.</figcaption>
				</figure>
				
				<section>
					<h2>Generating Rivers</h2>
					
					<p>Rivers are a consequence of the water cycle. Basically, they're formed by runoff that dug a channel via erosion. This suggests that we could add rivers based on a cell's runoff. However, this won't guarantee that we get anything that looks like actual rivers. Once we start a river, it should keep flowing as far as it can, potentially across many cells. This doesn't fit our water cycle simulation, which operates on cells in parallel. Also, you'd typically want control over how many rivers there are on a map.</p>
					
					<p>Because rivers are so different, we're going to generate them separately. We'll use the results of the water cycle simulation to determine where to place rivers, but we won't have rivers affect the simulation in return.</p>
					
					<aside>
						<h3>Sometimes the flow of a river is wrong?</h3>
						<div>
							<p>There's a bug in our <code>TriangulateWaterShore</code> method, which rarely manifests itself. this happens at a river end point, after reversing the direction of the flow. The problem is that we only checked whether the current direction matching the incoming river direction. This goes wrong when we're dealing with the start of a river. The solution is to also check whether the cell actually has an incoming river. I've put this fix in the <a href="../part-6/index.html">Rivers</a> tutorial as well.</p>
							<pre translate="no">	void TriangulateWaterShore (
		HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center
	) {
		&hellip;

		if (cell.HasRiverThroughEdge(direction)) {
			TriangulateEstuary(
				e1, e2,
				<ins>cell.HasIncomingRiver &amp;&amp;</ins> cell.IncomingRiver == direction, indices
			);
		}
		&hellip;
	}</pre>
						</div>
					</aside>
					
					<section>
						<h3>High and Wet</h3>
						
						<p>On our maps, a cell has either a river or it doesn't. They also cannot branch or merge. In reality, rivers are far more flexible than that, but we'll have to make do with this approximation, representing larger rivers only. The most important fact that we have to determine is where a large river starts, which we'll have to pick at random.</p>
						
						<p>Because rivers require water, the river's origin has to be in a cell that has a lot of moisture. But that's not enough. Rivers flow downhill, so ideally the origin has a high elevation as well. The higher a cell is above the water level, the better a candidate it is for a river origin. We can visualize this as map data, by dividing a cell's elevation by the maximum elevation. To make this relative to the water level, subtract it from both elevations before dividing.</p>
						
						<pre translate="no">	void SetTerrainType () {
		for (int i = 0; i &lt; cellCount; i++) {
			&hellip;
			<ins>float data =</ins>
				<ins>(float)(cell.Elevation - waterLevel) /</ins>
				<ins>(elevationMaximum - waterLevel);</ins>
			cell.SetMapData(<ins>data</ins>);
		}
	}</pre>
						
						<figure>
							<img alt="moisture" src="generating-rivers/moisture.jpg" width="350" height="200">
							<img alt="elevation" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/elevation.jpg" width="350" height="200">
							<figcaption>Moisture and elevation above water. Default large map 1208905299.</figcaption>
						</figure>
						
						<p>The best candidates are those cells that have both high moisture and high elevation. We can combine these criteria by multiplying them. The result is the fitness or weight for river origins.</p>
						
						<pre translate="no">			float data =
				<ins>moisture *</ins> (cell.Elevation - waterLevel) /
				(elevationMaximum - waterLevel);
			cell.SetMapData(data);</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/river-origin-weights.jpg" width="350" height="200">
							<figcaption>Weights for river origins.</figcaption>
						</figure>
						
						<p>Ideally, we'd use these weights to bias the random selection of an origin cell. While we could construct a properly weighed list and pick from it, that's not trivial and slows down the generation process. We can make do with a simpler classification of importance, distinguishing between four levels. Prime candidates have weights above 0.75. Good candidates have weights above 0.5. Still acceptable candidates have weights above 0.25. All other cells are disqualified. Let's visualize what that looks like.</p>
						
						<p></p>
						
						<pre translate="no">			float data =
				moisture * (cell.Elevation - waterLevel) /
				(elevationMaximum - waterLevel);
			<ins>if (data > 0.75f) {</ins>
				<ins>cell.SetMapData(1f);</ins>
			<ins>}</ins>
			<ins>else if (data > 0.5f) {</ins>
				<ins>cell.SetMapData(0.5f);</ins>
			<ins>}</ins>
			<ins>else if (data > 0.25f) {</ins>
				<ins>cell.SetMapData(0.25f);</ins>
			<ins>}</ins>
<del>//			cell.SetMapData(data);</del></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/river-origin-categories.jpg" width="350" height="200">
							<figcaption>River origin weight categories.</figcaption>
						</figure>
						
						<p>With this classification scheme, we'll likely end up with rivers originating from the higher and wetter areas of the map. But it's still possible for rivers to form in somewhat lower or drier areas as well, providing variety.</p>
						
						<p>Add a <code>CreateRivers</code> method that fills a list of cells using these criteria. Acceptable cells are added to this list once, good cells twice, and prime candidates four times. Cell that are underwater are always disqualified, so we can skip checking them.</p>
						
						<pre translate="no">	<ins>void CreateRivers () {</ins>
		<ins>List&lt;HexCell> riverOrigins = ListPool&lt;HexCell>.Get();</ins>
		<ins>for (int i = 0; i &lt; cellCount; i++) {</ins>
			<ins>HexCell cell = grid.GetCell(i);</ins>
			<ins>if (cell.IsUnderwater) {</ins>
				<ins>continue;</ins>
			<ins>}</ins>
			<ins>ClimateData data = climate[i];</ins>
			<ins>float weight =</ins>
				<ins>data.moisture * (cell.Elevation - waterLevel) /</ins>
				<ins>(elevationMaximum - waterLevel);</ins>
			<ins>if (weight > 0.75f) {</ins>
				<ins>riverOrigins.Add(cell);</ins>
				<ins>riverOrigins.Add(cell);</ins>
			<ins>}</ins>
			<ins>if (weight > 0.5f) {</ins>
				<ins>riverOrigins.Add(cell);</ins>
			<ins>}</ins>
			<ins>if (weight > 0.25f) {</ins>
				<ins>riverOrigins.Add(cell);</ins>
			<ins>}</ins>
		<ins>}</ins>

		<ins>ListPool&lt;HexCell>.Add(riverOrigins);</ins>
	<ins>}</ins></pre>
						
						<p>This method must be invoked after <code>CreateClimate</code>, so we have the moisture data available.</p>
						
						<pre translate="no">	public void GenerateMap (int x, int z) {
		&hellip;
		CreateRegions();
		CreateLand();
		ErodeLand();
		CreateClimate();
		<ins>CreateRivers();</ins>
		SetTerrainType();
		&hellip;
	}</pre>
						
						<p>With our classification complete, we can get rid of the map data visualization of it.</p>
						
						<pre translate="no">	void SetTerrainType () {
		for (int i = 0; i &lt; cellCount; i++) {
			&hellip;
<del>//			float data =</del>
<del>//				moisture * (cell.Elevation - waterLevel) /</del>
<del>//				(elevationMaximum - waterLevel);</del>
<del>//			if (data > 0.6f) {</del>
<del>//				cell.SetMapData(1f);</del>
<del>//			}</del>
<del>//			else if (data > 0.4f) {</del>
<del>//				cell.SetMapData(0.5f);</del>
<del>//			}</del>
<del>//			else if (data > 0.2f) {</del>
<del>//				cell.SetMapData(0.25f);</del>
<del>//			}</del>
		}
	}</pre>
					</section>
					
					<section>
						<h3>River Budget</h3>
						
						<p>How many rivers are desirable? This should be configurable. As rivers have varying length, it makes most sense to control this with a river budget, which states how much land cells should contain a river. Let's express this as a percentage with a maximum of 20% and a default of 10%. Like the land percentage, this is a target amount, not a guarantee. We might end up with too few candidates or rivers that are too short to cover the desired amount of land. That's why the maximum percentage shouldn't be too high.</p>
						
						<pre translate="no">	<ins>[Range(0, 20)]</ins>
	<ins>public int riverPercentage = 10;</ins></pre>
						
						<figure>
							<img src="generating-rivers/river-percentage.png" width="320" height="57">
							<figcaption>River percentage slider.</figcaption>
						</figure>
						
						<p>To be able to determine the river budget expressed as an amount of cells, we have to remember how many land cells were generated in <code>CreateLand</code>.</p>
						
						<pre translate="no">	int cellCount<ins>, landCells</ins>;
	&hellip;
	
	void CreateLand () {
		int landBudget = Mathf.RoundToInt(cellCount * landPercentage * 0.01f);
		<ins>landCells = landBudget;</ins>
		for (int guard = 0; guard &lt; 10000; guard++) {
			&hellip;
		}
		if (landBudget > 0) {
			Debug.LogWarning("Failed to use up " + landBudget + " land budget.");
			<ins>landCells -= landBudget;</ins>
		}
	}</pre>
						
						<p>Inside <code>CreateRivers</code>, the river budget can now be computed just like we do in <code>CreateLand</code>.</p>
						
						<pre translate="no">	void CreateRivers () {
		List&lt;HexCell> riverOrigins = ListPool&lt;HexCell>.Get();
		for (int i = 0; i &lt; cellCount; i++) {
			&hellip;
		}

		<ins>int riverBudget = Mathf.RoundToInt(landCells * riverPercentage * 0.01f);</ins>
		
		ListPool&lt;HexCell>.Add(riverOrigins);
	}</pre>
						
						<p>Next, keep picking and removing random cells from the origin list, as long as we have budget and origins remaining. Also log a warning in case we failed to use up the budget.</p>
						
						<pre translate="no">		int riverBudget = Mathf.RoundToInt(landCells * riverPercentage * 0.01f);
		<ins>while (riverBudget > 0 &amp;&amp; riverOrigins.Count > 0) {</ins>
			<ins>int index = Random.Range(0, riverOrigins.Count);</ins>
			<ins>int lastIndex = riverOrigins.Count - 1;</ins>
			<ins>HexCell origin = riverOrigins[index];</ins>
			<ins>riverOrigins[index] = riverOrigins[lastIndex];</ins>
			<ins>riverOrigins.RemoveAt(lastIndex);</ins>
		<ins>}</ins>
		
		<ins>if (riverBudget > 0) {</ins>
			<ins>Debug.LogWarning("Failed to use up river budget.");</ins>
		<ins>}</ins></pre>
						
						<p>Besides that, also add a method to actually create a river. It needs the origin cell as its parameter and should return the river's length once it's done. Begin with a method stub that only returns a length of zero.</p>
						
						<pre translate="no">	<ins>int CreateRiver (HexCell origin) {</ins>
		<ins>int length = 0;</ins>
		<ins>return length;</ins>
	<ins>}</ins></pre>
						
						<p>Invoke this method at the end of the loop that we just added to <code>CreateRivers</code>, using it to decrease the remaining budget. Make sure that we only create a new river if the chosen cell doesn't already have one flowing through it.</p>
						
						<pre translate="no">		while (riverBudget > 0 &amp;&amp; riverOrigins.Count > 0) {
			&hellip;

			<ins>if (!origin.HasRiver) {</ins>
				<ins>riverBudget -= CreateRiver(origin);</ins>
			<ins>}</ins>
		}</pre>
					</section>
					
					<section>
						<h3>Flowing Rivers</h3>
						
						<p>Having a river flow towards the sea or another waterbody seems straightforward. As we start at its origin, we immediately begin with a length of 1. After that, pick a random neighbor, flow into it, and increment the length. Keep doing this until we end up in an underwater cell.</p>
						
						<pre translate="no">	int CreateRiver (HexCell origin) {
		int length = <ins>1</ins>;
		<ins>HexCell cell = origin;</ins>
		<ins>while (!cell.IsUnderwater) {</ins>
			<ins>HexDirection direction = (HexDirection)Random.Range(0, 6);</ins>
			<ins>cell.SetOutgoingRiver(direction);</ins>
			<ins>length += 1;</ins>
			<ins>cell = cell.GetNeighbor(direction);</ins>
		<ins>}</ins>
		<ins>return length;</ins>
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/haphazard-rivers.jpg" width="340" height="230">
							<figcaption>Haphazard rivers.</figcaption>
						</figure>
						
						<p>The result of this naive approach is haphazardly placed river fragments, mostly because we end up replacing previously-generated rivers. It might even lead to errors, as we don't even check whether a neighbor actually exists. We have to loop through all directions and verify that we have a neighbor there. If so, add this direction to a list of potential flow directions, but only if that neighbor doesn't already have a river flowing through it. Then pick a random direction from that list.</p>
						
						<pre translate="no">	<ins>List&lt;HexDirection> flowDirections = new List&lt;HexDirection>();</ins>
	
	&hellip;
	
	int CreateRiver (HexCell origin) {
		int length = 1;
		HexCell cell = origin;
		while (!cell.IsUnderwater) {
			<ins>flowDirections.Clear();</ins>
			<ins>for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {</ins>
				<ins>HexCell neighbor = cell.GetNeighbor(d);</ins>
				<ins>if (!neighbor || neighbor.HasRiver) {</ins>
					<ins>continue;</ins>
				<ins>}</ins>
				<ins>flowDirections.Add(d);</ins>
			<ins>}</ins>

			HexDirection direction =
<del>//				(HexDirection)Random.Range(0, 6);</del>
				<ins>flowDirections[Random.Range(0, flowDirections.Count)];</ins>
			cell.SetOutgoingRiver(direction);
			length += 1;
			cell = cell.GetNeighbor(direction);
		}
		return length;
	}</pre>
						
						<p>With this new approach, it is possible that we end up with zero available flow directions. When that happens, the river cannot flow any further and we have to abort. If the length is equal to 1 at this point, it means that we cannot flow out of the origin cell, so there cannot be a river at all. In that case the river's length is zero.</p>
						
						<pre translate="no">			flowDirections.Clear();
			for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {
				&hellip;
			}

			<ins>if (flowDirections.Count == 0) {</ins>
				<ins>return length > 1 ? length : 0;</ins>
			<ins>}</ins></pre>
						
						<figure>
							<img src="generating-rivers/preserved-rivers.jpg" width="340" height="230">
							<figcaption>Preserved rivers.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Flowing Downhill</h3>
						
						<p>We're now preserving already-created rivers, but we still end up with isolated river fragments. This happens because so far we've ignored elevation. Each time we make a river flow to a higher elevation, <code>HexCell.SetOutgoingRiver</code> correctly aborts the attempt, which leads to discontinuities in our rivers. So we also have to skip directions that would cause the river to flow upward.</p>
						
						<pre translate="no">				if (!neighbor || neighbor.HasRiver) {
					continue;
				}

				<ins>int delta = neighbor.Elevation - cell.Elevation;</ins>
				<ins>if (delta > 0) {</ins>
					<ins>continue;</ins>
				<ins>}</ins>
				
				flowDirections.Add(d);</pre>
						
						<figure>
							<img src="generating-rivers/downhill-rivers.jpg" width="340" height="230">
							<figcaption>Rivers flowing downhill.</figcaption>
						</figure>
						
						<p>This eliminates many river fragments, although we still get a few. From this point, it's a matter of refinement to get rid of most unsightly rivers. To start with, rivers prefer to flow downhill as quickly as possible. It's not guaranteed that they take the shortest possible route, but likely. To simulate this, at downhill directions three extra times to the list.</p>
						
						<pre translate="no">				if (delta > 0) {
					continue;
				}

				<ins>if (delta &lt; 0) {</ins>
					<ins>flowDirections.Add(d);</ins>
					<ins>flowDirections.Add(d);</ins>
					<ins>flowDirections.Add(d);</ins>
				<ins>}</ins>
				flowDirections.Add(d);</pre>
					</section>
					
					<section>
						<h3>Avoiding Sharp Turns</h3>
						
						<p>Besides preferring to go downhill, flowing water also has momentum. A river is more likely to go straight ahead or curve slowly than to make a sudden sharp turn. We can introduce this bias by keeping track of the river's last direction. If a potential flow direction doesn't deviate too much from this direction, add it once more to the list. This isn't an issue at the origin, so simply always add it again in that case.</p>
						
						<pre translate="no">	int CreateRiver (HexCell origin) {
		int length = 1;
		HexCell cell = origin;
		<ins>HexDirection direction = HexDirection.NE;</ins>
		while (!cell.IsUnderwater) {
			flowDirections.Clear();
			for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {
				&hellip;

				if (delta &lt; 0) {
					flowDirections.Add(d);
					flowDirections.Add(d);
					flowDirections.Add(d);
				}
				<ins>if (</ins>
					<ins>length == 1 ||</ins>
					<ins>(d != direction.Next2() &amp;&amp; d != direction.Previous2())</ins>
				<ins>) {</ins>
					<ins>flowDirections.Add(d);</ins>
				<ins>}</ins>
				flowDirections.Add(d);
			}

			if (flowDirections.Count == 0) {
				return length > 1 ? length : 0;
			}

<del>//			HexDirection direction =</del>
			<ins>direction =</ins> flowDirections[Random.Range(0, flowDirections.Count)];
			cell.SetOutgoingRiver(direction);
			length += 1;
			cell = cell.GetNeighbor(direction);
		}
		return length;
	}</pre>
						
						<p>This makes it far less likely for zigzag rivers to appear, which are unsightly.</p>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/fewer-sharp-turns.jpg" width="340" height="230">
							<figcaption>Fewer sharp turns.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Merging Rivers</h3>
						
						<p>Sometimes a river ends up flowing right next to the origin of a previously-created river. Unless that river origin it at a higher elevation, we could decide to make the new river flow into the old one. The result is a single longer river, instead of two nearby shorter ones.</p>
						
						<p>To do this, only skip a neighbor if it has an incoming river, or if it's the origin of the current river. Then after we've established that it isn't an uphill direction, check whether there is an outgoing river. If so, we've found an old river origin. Because this is fairly rare, don't bother checking for other potential neighbor origins and immediately merge the rivers.</p>
						
						<pre translate="no">				HexCell neighbor = cell.GetNeighbor(d);
<del>//				if (!neighbor || neighbor.HasRiver) {</del>
<del>//					continue;</del>
<del>//				}</del>
				<ins>if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) {</ins>
					<ins>continue;</ins>
				<ins>}</ins>

				int delta = neighbor.Elevation - cell.Elevation;
				if (delta > 0) {
					continue;
				}

				<ins>if (neighbor.HasOutgoingRiver) {</ins>
					<ins>cell.SetOutgoingRiver(d);</ins>
					<ins>return length;</ins>
				<ins>}</ins></pre>
						
						<figure>
							<img alt="disconnected" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/disconnected.jpg" width="200" height="150">
							<img alt="connected" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/connected.jpg" width="200" height="150">
							<figcaption>Rivers before and after merging.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Keeping Distance</h3>
						
						<p>Because good quality origin candidates tend to cluster together, we end up with clusters of rivers. Also, we can end up with rivers originating right next to a waterbody, resulting in single-step rivers. We can spread out the origins by disqualifying those that are adjacent to a river or waterbody. Do this by looping through the neighbors of the chosen origin in <code>CreateRivers</code>. If we find an offending neighbor, the origin isn't valid and we should skip it.</p>
						
						<pre translate="no">		while (riverBudget > 0 &amp;&amp; riverOrigins.Count > 0) {
			int index = Random.Range(0, riverOrigins.Count);
			int lastIndex = riverOrigins.Count - 1;
			HexCell origin = riverOrigins[index];
			riverOrigins[index] = riverOrigins[lastIndex];
			riverOrigins.RemoveAt(lastIndex);

			if (!origin.HasRiver) {
				<ins>bool isValidOrigin = true;</ins>
				<ins>for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {</ins>
					<ins>HexCell neighbor = origin.GetNeighbor(d);</ins>
					<ins>if (neighbor &amp;&amp; (neighbor.HasRiver || neighbor.IsUnderwater)) {</ins>
						<ins>isValidOrigin = false;</ins>
						<ins>break;</ins>
					<ins>}</ins>
				<ins>}</ins>
				<ins>if (isValidOrigin) {</ins>
					riverBudget -= CreateRiver(origin);
				<ins>}</ins>
			}</pre>
						
						<p>While rivers can still end up flowing next to each other, they now tend to cover a larger area.</p>
						
						<figure>
							<img alt="clustered" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/clustered.jpg" width="420" height="210">
							<img alt="spread out" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/spread-out.jpg" width="420" height="210">
							<figcaption>Without and with keeping distance.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Ending with a Lake</h3>
						
						<p>Not all rivers make it to a waterbody. Some get struck in a valley or blocked by other rivers. This isn't a big problem, because there are many real rivers that also seem to disappear. This could happen for example because they flow underground, because they diffuse into a swampy area, or because they dry up. Our rivers cannot visualize this, so they simply end.</p>
						
						<p>Having said that, we should try to minimize such occurrences. While we cannot merge rivers or make them flow uphill, we might be able make them end in a lake, which is more common and looks better. To do this, <code>CreateRiver</code> has to raise the water level of the cell when it gets stuck. Whether this is possible depends on the minimum elevation of that cell's neighbors. So keep track of this when investigating the neighbors, which requires a little code restructuring.</p>
						
						<pre translate="no">		while (!cell.IsUnderwater) {
			<ins>int minNeighborElevation = int.MaxValue;</ins>
			flowDirections.Clear();
			for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) {
				HexCell neighbor = cell.GetNeighbor(d);
<del>//				if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) {</del>
<del>//					continue;</del>
<del>//				}</del>
				<ins>if (!neighbor) {</ins>
					<ins>continue;</ins>
				<ins>}</ins>

				<ins>if (neighbor.Elevation &lt; minNeighborElevation) {</ins>
					<ins>minNeighborElevation = neighbor.Elevation;</ins>
				<ins>}</ins>

				<ins>if (neighbor == origin || neighbor.HasIncomingRiver) {</ins>
					<ins>continue;</ins>
				<ins>}</ins>

				int delta = neighbor.Elevation - cell.Elevation;
				if (delta > 0) {
					continue;
				}

				&hellip;
			}

			&hellip;
		}</pre>
						
						<p>If we're stuck, first check whether we're still at the origin. If so, simply abort the river. Otherwise, check whether all neighbors are at least as high as the current cell. If that is the case, then we can raise the water up to this level. This will create a single-cell lake, unless the cell's elevation is at the same level. If this is so, simple set the elevation to one below the water level.</p>
						
						<pre translate="no">			if (flowDirections.Count == 0) {
<del>//				return length > 1 ? length : 0;</del>
				<ins>if (length == 1) {</ins>
					<ins>return 0;</ins>
				<ins>}</ins>

				<ins>if (minNeighborElevation >= cell.Elevation) {</ins>
					<ins>cell.WaterLevel = minNeighborElevation;</ins>
					<ins>if (minNeighborElevation == cell.Elevation) {</ins>
						<ins>cell.Elevation = minNeighborElevation - 1;</ins>
					<ins>}</ins>
				<ins>}</ins>
				<ins>break;</ins>
			}</pre>
						
						<figure>
							<img alt="without" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/without-lake.jpg" width="260" height="140">
							<img alt="with" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/with-lake.jpg" width="260" height="140">
							<figcaption>River endings without and with lakes. River percentage at 20 in this case.</figcaption>
						</figure>
						
						<p>Note that we can now end up with underwater cells above the water level used to generate the map, representing lakes above sea level.</p>
					</section>
					
					<section>
						<h3>Extra Lakes</h3>
						
						<p>We could also create lakes when we aren't stuck. That would result in the river flowing into an out from a lake. When not stuck, a lake can be created by raising the water level to the cell's current elevation, then decrementing the cell elevation. This is only valid when the minimum neighbor elevation is at least equal to the current cell's elevation. Do this at the end of the river loop, before proceeding to the next cell.</p>
						
						<pre translate="no">		while (!cell.IsUnderwater) {
			&hellip;
			
			<ins>if (minNeighborElevation >= cell.Elevation) {</ins>
				<ins>cell.WaterLevel = cell.Elevation;</ins>
				<ins>cell.Elevation -= 1;</ins>
			<ins>}</ins>
			
			cell = cell.GetNeighbor(direction);
		}</pre>
						
						<figure>
							<img alt="without" src="generating-rivers/without-extra-lakes.jpg" width="400" height="200">
							<img alt="with" src="generating-rivers/with-extra-lakes.jpg" width="400" height="200">
							<figcaption>Without and with extra lakes.</figcaption>
						</figure>
						
						<p>While a few lakes are nice, without restraint this approach can generate far too many lakes. So let's add a configurable probability for extra lakes, with a default of 0.25.</p>
						
						<pre translate="no">	<ins>[Range(0f, 1f)]</ins>
	<ins>public float extraLakeProbability = 0.25f;</ins></pre>
						
						<p>This controls the probability that an extra lake gets generated, if it were possible.</p>
						
						<pre translate="no">			if (
				minNeighborElevation >= cell.Elevation <ins>&amp;&amp;</ins>
				<ins>Random.value &lt; extraLakeProbability</ins>
			) {
				cell.WaterLevel = cell.Elevation;
				cell.Elevation -= 1;
			}</pre>
						
						<figure>
							<img alt="inspector" src="generating-rivers/extra-lake-probability.png" width="320" height="39"><br>
							<img alt="scene" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/some-extra-lakes.jpg" width="400" height="190">
							<figcaption>Some extra lakes.</figcaption>
						</figure>
						
						<aside>
							<h3>What about creating lakes larger than one cell?</h3>
							<div>
								<p>You could create larger lakes by allowing them to form adjacent to cells that are underwater, provided that they have the correct water level. However, this has a downside. It can create river loops, where water flows out of a waterbody, only to return to it later. These loops could be long or short, but they're always obvious and incorrect. You could also end up with riverbeds snaking along the bottom of a large lake, which looks weird.</p>
							</div>
						</aside>
					</section>
					
					<a href="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/generating-rivers.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Temperature</h2>
					
					<p>Water is only one factor that can be used to determine a cell's biome. Another very important factor is temperature. While we could simulate temperature flow and diffusion like water, we only need one complex factor to create an interesting climate. So we'll keep temperature simple, determining it once per cell.</p>
					
					<section>
						<h3>Temperature by Latitude</h3>
						
						<p>Latitude has the most profound effect on temperature. The equator is hot, the poles are cold, and there is a gradual transition in between. Let's create a <code>DetermineTemperature</code> method that returns the temperature for a given cell. To start with, we'll simply use the cell's Z coordinate divided by the Z dimension as the latitude, then use that directly as the temperature.</p>
						
						<pre translate="no">	<ins>float DetermineTemperature (HexCell cell) {</ins>
		<ins>float latitude = (float)cell.coordinates.Z / grid.cellCountZ;</ins>
		<ins>return latitude;</ins>
	<ins>}</ins></pre>
						
						<p>Determine the temperature in <code>SetTerrainType</code> and use it as the map data.</p>
						
						<pre translate="no">	void SetTerrainType () {
		for (int i = 0; i &lt; cellCount; i++) {
			HexCell cell = grid.GetCell(i);
			<ins>float temperature = DetermineTemperature(cell);</ins>
			<ins>cell.SetMapData(temperature);</ins>
			float moisture = climate[i].moisture;
			&hellip;
		}
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/temperature/latitude-temperature.jpg" width="350" height="200">
							<figcaption>Latitude as temperature, southern hemisphere.</figcaption>
						</figure>
						
						<p>What we get is a linear temperature gradient that increases from bottom to top. We can use this to represent the southern hemisphere, with the polar region at the bottom and the equator at the top. But we don't need to cover the entire hemisphere. We could represent a smaller region by using a smaller temperature difference, or no difference at all. For this purpose, we'll make the low and high temperature configurable. We'll define these temperatures in the 0&ndash;1 range, using the extremes as default values.</p>
						
						<pre translate="no">	<ins>[Range(0f, 1f)]</ins>
	<ins>public float lowTemperature = 0f;</ins>

	<ins>[Range(0f, 1f)]</ins>
	<ins>public float highTemperature = 1f;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/temperature/low-high-temperatures.png" width="320" height="57">
							<figcaption>Temperature sliders.</figcaption>
						</figure>
						
						<p>Apply the temperature range via linear interpolation, using the latitude as the interpolator. As we express latitude as a value from 0 to 1, we can use <code>Mathf.LerpUnclamped</code>.</p>
						
						<pre translate="no">	float DetermineTemperature (HexCell cell) {
		float latitude = (float)cell.coordinates.Z / grid.cellCountZ;
		<ins>float temperature =</ins>
			<ins>Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude);</ins>
		return <ins>temperature</ins>;
	}</pre>
						
						<p>Note that we don't bother enforcing that the low temperature is indeed lower than the high temperature. If you wanted to, you could invert the temperatures.</p>
					</section>
					
					<section>
						<h3>Hemispheres</h3>
						
						<p>We can now represent the southern hemisphere, and possibly the northern one by flipping the temperature. But it's much more convenient to use a separate configuration option to switch between hemispheres. Let's create an enumeration and field for that. That way we can also include an option to cover both hemispheres, which we'll make the default.</p>
						
						<pre translate="no">	<ins>public enum HemisphereMode {</ins>
		<ins>Both, North, South</ins>
	<ins>}</ins>

	<ins>public HemisphereMode hemisphere;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/temperature/hemisphere-choice.png" width="320" height="39">
							<figcaption>Hemisphere choice.</figcaption>
						</figure>
						
						<p>If we want the northern hemisphere, we can simple reverse the latitude, by subtracting it from 1. To cover both hemispheres, we need to ensure that the poles are at the top and bottom of the map, while the equator is in the middle. We can do this by doubling the latitude, which takes care of the bottom hemisphere correctly but makes the top hemisphere go from 1 to 2. To correct that, subtract the latitude from 2 when it goes above 1.</p>
						
						<pre translate="no">	float DetermineTemperature (HexCell cell) {
		float latitude = (float)cell.coordinates.Z / grid.cellCountZ;
		<ins>if (hemisphere == HemisphereMode.Both) {</ins>
			<ins>latitude *= 2f;</ins>
			<ins>if (latitude > 1f) {</ins>
				<ins>latitude = 2f - latitude;</ins>
			<ins>}</ins>
		<ins>}</ins>
		<ins>else if (hemisphere == HemisphereMode.North) {</ins>
			<ins>latitude = 1f - latitude;</ins>
		<ins>}</ins>

		float temperature =
			Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude);
		return temperature;
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/temperature/both-hemispheres.jpg" width="350" height="200">
							<figcaption>Both hemispheres.</figcaption>
						</figure>
						
						<p>Note that this also makes it possible to create an exotic map where the equator is cold and the poles hot, by using a low temperature that is hotter than the high temperature.</p>
					</section>
					
					<section>
						<h3>Higher is Colder</h3>
						
						<p>Besides latitude, elevation also has a noticeable effect on temperature. On average, the higher you go, the colder it gets. We can turn this into a factor, like we did for the river origin candidates. In this case, we use the cell's view elevation. Also, the factor decreases with height, so it's 1 minus the elevation divided by the maximum, relative to the water level. To prevent the factor from always dropping to zero at the highest level, add 1 to the divisor. Then use this factor to scale the temperature.</p>
						
						<pre translate="no">		float temperature =
			Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude);

		<ins>temperature *= 1f - (cell.ViewElevation - waterLevel) /</ins>
			<ins>(elevationMaximum - waterLevel + 1f);</ins>

		return temperature;</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/temperature/elevation.jpg" width="350" height="200">
							<figcaption>Elevation influencing temperature.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Temperature Fluctuations</h3>
						
						<p>We can make the simplicity of our temperature gradient a little less obvious by adding a random temperature fluctuation. A little randomness can make it look more real, but too much will make it look arbitrary. Let's make the strength of this temperature jitter configurable, expressed as maximum temperature deviation, with a default of 0.1.</p>
						
						<pre translate="no">	<ins>[Range(0f, 1f)]</ins>
	<ins>public float temperatureJitter = 0.1f;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/temperature/jitter.png" width="320" height="39">
							<figcaption>Temperature jitter slider.</figcaption>
						</figure>
						
						<p>These fluctuations should be smooth, with small local changes. We can use our noise texture for that. So invoke <code>HexMetrics.SampleNoise</code> with the cell's position as an argument, scaled by 0.1. Let's grab the W channel, center it, and scale it by the jitter factor. Then add this value to the temperature that we determined earlier.</p>
						
						<pre translate="no">		temperature *= 1f - (cell.ViewElevation - waterLevel) /
			(elevationMaximum - waterLevel + 1f);

		<ins>temperature +=</ins>
			<ins>(HexMetrics.SampleNoise(cell.Position * 0.1f).w * 2f - 1f) *</ins>
			<ins>temperatureJitter;</ins>

		return temperature;</pre>
						
						<figure>
							<img alt="0.1" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/temperature/jittered-01.jpg" width="350" height="200">
							<img alt="1" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/temperature/jittered-10.jpg" width="350" height="200">
							<figcaption>Temperature jitter set to 0.1 and 1.</figcaption>
						</figure>
						
						<p>We can add a little variety to the jitter per map, by randomly choosing which of the four noise channels to use. Determine the channel once in <code>SetTerrainType</code>, then index the color channels in <code>DetermineTemperature</code>.</p>
						
						<pre translate="no">	<ins>int temperatureJitterChannel;</ins>
	
	&hellip;
	
	void SetTerrainType () {
		<ins>temperatureJitterChannel = Random.Range(0, 4);</ins>
		for (int i = 0; i &lt; cellCount; i++) {
			&hellip;
		}
	}
	
	float DetermineTemperature (HexCell cell) {
		&hellip;

		<ins>float jitter =</ins>
			<ins>HexMetrics.SampleNoise(cell.Position * 0.1f)[temperatureJitterChannel];</ins>

		temperature += (<ins>jitter</ins> * 2f - 1f) * temperatureJitter;

		return temperature;
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/temperature/different-jitter.jpg" width="350" height="200">
							<figcaption>Different temperature jitter, at maximum strength.</figcaption>
						</figure>
					</section>
					
					<a href="https://catlikecoding.com/unity/tutorials/hex-map/part-26/temperature/temperature.unitypackage" download rel="nofollow">unitypackage</a>
				</section>
				
				<section>
					<h2>Biomes</h2>
					
					<p>Now that we have both moisture and temperature data, we can create a biome matrix. By indexing this matrix, we can assign biomes to all cells, creating a more complex landscape compared to using just one data dimension.</p>
					
					<section>
						<h3>Biome Matrix</h3>
						
						<p>There are a lot of climate models, but we're not going to use any of them. We'll just keep it very simple, only caring about what looks sensible. Dry means desert &ndash; cold or hot &ndash; for which we'll use sand. Cold and wet means snow. Hot and wet means lots of plants, so grass. In between, we have taiga or tundra, which we'll represent with our grayish mud texture. A 4&times;4 matrix should provide enough room to transition between these biomes.</p>
						
						<p>Previously, we've assigned terrain types based on five moisture bands. We'll simply drop the driest band &ndash; up to 0.05 &ndash; and keep the others. For the temperature bands, we'll use up to 0.1, 0.3, 0.6, and above. Define these values in static arrays, for easy reference.</p>
						
						<pre translate="no">	<ins>static float[] temperatureBands = { 0.1f, 0.3f, 0.6f };</ins>
					
	<ins>static float[] moistureBands = { 0.12f, 0.28f, 0.85f };</ins></pre>
						
						<p>Although we've only set the terrain type based on biome, we can use it to determine other things as well. So let's define a <code>Biome</code> structure inside <code>HexMapGenerator</code> to represent the configuration for a single biome. For now, it only contains the terrain index, plus an appropriate constructor method.</p>
						
						<pre translate="no">	<ins>struct Biome {</ins>
		<ins>public int terrain;</ins>
		
		<ins>public Biome (int terrain) {</ins>
			<ins>this.terrain = terrain;</ins>
		<ins>}</ins>
	<ins>}</ins></pre>
						
						<p>Use this struct to create a static array that contains our matrix data. We'll use moisture as the X dimension and temperature as the Y dimension. Fill the lowest temperature row with snow, the second row with tundra, and the other two with grass. Then change the driest column to desert, overriding the temperature choices.</p>
						
						<pre translate="no">	<ins>static Biome[] biomes = {</ins>
		<ins>new Biome(0), new Biome(4), new Biome(4), new Biome(4),</ins>
		<ins>new Biome(0), new Biome(2), new Biome(2), new Biome(2),</ins>
		<ins>new Biome(0), new Biome(1), new Biome(1), new Biome(1),</ins>
		<ins>new Biome(0), new Biome(1), new Biome(1), new Biome(1)</ins>
	<ins>};</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/biome-matrix.png" width="265" height="250">
							<figcaption>Biome matrix, with 1D array indices.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Determining Biome</h3>
						
						<p>To determine the cell biome in <code>SetTerrainType</code>, loop through the temperature and moisture bands to determine the matrix indices that we need. Use them to retrieve the correct biome and set the cell's terrain type.</p>
						
						<pre translate="no">	void SetTerrainType () {
		temperatureJitterChannel = Random.Range(0, 4);
		for (int i = 0; i &lt; cellCount; i++) {
			HexCell cell = grid.GetCell(i);
			float temperature = DetermineTemperature(cell);
<del>//			cell.SetMapData(temperature);</del>
			float moisture = climate[i].moisture;
			if (!cell.IsUnderwater) {
<del>//				if (moisture &lt; 0.05f) {</del>
<del>//					cell.TerrainTypeIndex = 4;</del>
<del>//				}</del>
<del>//				&hellip;</del>
<del>//				else {</del>
<del>//					cell.TerrainTypeIndex = 2;</del>
<del>//				}</del>
				<ins>int t = 0;</ins>
				<ins>for (; t &lt; temperatureBands.Length; t++) {</ins>
					<ins>if (temperature &lt; temperatureBands[t]) {</ins>
						<ins>break;</ins>
					<ins>}</ins>
				<ins>}</ins>
				<ins>int m = 0;</ins>
				<ins>for (; m &lt; moistureBands.Length; m++) {</ins>
					<ins>if (moisture &lt; moistureBands[m]) {</ins>
						<ins>break;</ins>
					<ins>}</ins>
				<ins>}</ins>
				<ins>Biome cellBiome = biomes[t * 4 + m];</ins>
				<ins>cell.TerrainTypeIndex = cellBiome.terrain;</ins>
			}
			else {
				cell.TerrainTypeIndex = 2;
			}
		}
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/biome-terrain.jpg" width="350" height="200">
							<figcaption>Terrain based on biome matrix.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Tweaking Biomes</h3>
						
						<p>We're not limited to the biomes defined in the matrix. For example, the matrix has defined all dry biomes a sandy desert. But not all dry deserts are filled with sand. There are many rock deserts as well, which look quite different. So let's change part of the desert cells to rock. We'll simply do this based on elevation, reasoning that loose sand is found at lower altitudes, while higher up you encounter mostly bare rock.</p>
						
						<p>Let's say that sand turns to rock if a cell's elevation is closer to the elevation maximum than to the water level. This is the rock-desert elevation line, which we can compute at the start of <code>SetTerrainType</code>. Then if we encounter a cell with sand, and its elevation is sufficiently high, change its biome's terrain to rock.</p>
						
						<pre translate="no">	void SetTerrainType () {
		temperatureJitterChannel = Random.Range(0, 4);
		<ins>int rockDesertElevation =</ins>
			<ins>elevationMaximum - (elevationMaximum - waterLevel) / 2;</ins>
		
		for (int i = 0; i &lt; cellCount; i++) {
			&hellip;
			if (!cell.IsUnderwater) {
				&hellip;
				Biome cellBiome = biomes[t * 4 + m];

				<ins>if (cellBiome.terrain == 0) {</ins>
					<ins>if (cell.Elevation >= rockDesertElevation) {</ins>
						<ins>cellBiome.terrain = 3;</ins>
					<ins>}</ins>
				<ins>}</ins>

				cell.TerrainTypeIndex = cellBiome.terrain;
			}
			else {
				cell.TerrainTypeIndex = 2;
			}
		}
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/rock-deserts.jpg" width="350" height="200">
							<figcaption>Sand and rock deserts.</figcaption>
						</figure>
						
						<p>Another elevation-based tweak is to force cells that are at maximum elevation to become snowcaps, regardless how warm they are, as long as they're not too dry. This makes it more likely for snowcaps to appear near a hot and wet equator.</p>
						
						<pre translate="no">				if (cellBiome.terrain == 0) {
					if (cell.Elevation >= rockDesertElevation) {
						cellBiome.terrain = 3;
					}
				}
				<ins>else if (cell.Elevation == elevationMaximum) {</ins>
					<ins>cellBiome.terrain = 4;</ins>
				<ins>}</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/snowcaps.jpg" width="350" height="200">
							<figcaption>Snowcaps at maximum elevation.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Plants</h3>
						
						<p>Now that we've taken care of the terrain types, let's also have our biomes determine the plant level of cells. This requires us to add a plant field to <code>Biome</code> and include it in its constructor.</p>
						
						<pre translate="no">	struct Biome {
		public int terrain<ins>, plant</ins>;

		public Biome (int terrain<ins>, int plant</ins>) {
			this.terrain = terrain;
			<ins>this.plant = plant;</ins>
		}
	}</pre>
						
						<p>The coldest and driest biomes get no plants at all. Beyond that, we get more plants the warmer and wetter it is. The second moisture column only gets plant level 1 for the hottest row, so [0, 0, 0, 1]. The third column increases the levels by one, except for snow, so [0, 1, 1, 2]. And the wettest column increases them again, so [0, 2, 2, 3]. Adjust the <code>biomes</code> array to include this plant configuration.</p>
						
						<pre translate="no">	static Biome[] biomes = {
		new Biome(0<ins>, 0</ins>), new Biome(4<ins>, 0</ins>), new Biome(4<ins>, 0</ins>), new Biome(4<ins>, 0</ins>),
		new Biome(0<ins>, 0</ins>), new Biome(2<ins>, 0</ins>), new Biome(2<ins>, 1</ins>), new Biome(2<ins>, 2</ins>),
		new Biome(0<ins>, 0</ins>), new Biome(1<ins>, 0</ins>), new Biome(1<ins>, 1</ins>), new Biome(1<ins>, 2</ins>),
		new Biome(0<ins>, 0</ins>), new Biome(1<ins>, 1</ins>), new Biome(1<ins>, 2</ins>), new Biome(1<ins>, 3</ins>)
	};</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/biome-matrix-plants.png" width="265" height="250">
							<figcaption>Biome matrix with plant levels.</figcaption>
						</figure>
						
						<p>Now we can set a cell's plant level as well.</p>
						
						<pre translate="no">				cell.TerrainTypeIndex = cellBiome.terrain;
				<ins>cell.PlantLevel = cellBiome.plant;</ins></pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/plants.jpg" width="400" height="240">
							<figcaption>Biomes with plants.</figcaption>
						</figure>
						
						<aside>
							<h3>The plants look different than before?</h3>
							<div>
								<p>I scaled up most plant prefabs a little, to make them better visible from a distance. Scales for the two low plant prefabs are (1, 2, 1) and (0.75, 1, 0.75). Medium are (1.5, 3, 1.5) and (2, 1.5, 2). And high are (2, 4.5, 2) and (2.5, 3, 2.5).</p>
								<p>I also darkened the plant color a bit, to better combine with the textures, using (13, 114, 0).</p>
							</div>
						</aside>
						
						<p>We can tweak the plant level of biomes too. First, we should ensure that they don't show up on snow terrain, which we might've tweaked. Second, let's also increment the plant level along rivers, if it's not at its maximum yet.</p>
						
						<pre translate="no">				<ins>if (cellBiome.terrain == 4) {</ins>
					<ins>cellBiome.plant = 0;</ins>
				<ins>}</ins>
				<ins>else if (cellBiome.plant &lt; 3 &amp;&amp; cell.HasRiver) {</ins>
					<ins>cellBiome.plant += 1;</ins>
				<ins>}</ins>

				cell.TerrainTypeIndex = cellBiome.terrain;
				cell.PlantLevel = cellBiome.plant;</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/tweaked-plants.jpg" width="400" height="240">
							<figcaption>Tweaked plants.</figcaption>
						</figure>
					</section>
					
					<section>
						<h3>Underwater Biomes</h3>
						
						<p>Up to this point, we've completely ignored underwater cells. Let's add some variety to these cells as well, instead of using mud for all of them. A simple elevation-based approach should already lead to something more interesting to look at. For example, let's use grass for cells with elevation one step below the water level. Let's also use grass for cells higher than that, which are lakes created by rivers. Cells with negative elevation are in deep regions, let's use rock for that. All other cells can remain mud.</p>
						
						<pre translate="no">	void SetTerrainType () {
			&hellip;
			if (!cell.IsUnderwater) {
				&hellip;
			}
			else {
				<ins>int terrain;</ins>
				<ins>if (cell.Elevation == waterLevel - 1) {</ins>
					<ins>terrain = 1;</ins>
				<ins>}</ins>
				<ins>else if (cell.Elevation >= waterLevel) {</ins>
					<ins>terrain = 1;</ins>
				<ins>}</ins>
				<ins>else if (cell.Elevation &lt; 0) {</ins>
					<ins>terrain = 3;</ins>
				<ins>}</ins>
				<ins>else {</ins>
					<ins>terrain = 2;</ins>
				<ins>}</ins>
				cell.TerrainTypeIndex = <ins>terrain</ins>;
			}
		}
	}</pre>
						
						<figure>
							<img src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/underwater.jpg" width="350" height="200">
							<figcaption>Underwater variety.</figcaption>
						</figure>
						
						<p>Let's add some more detail to underwater cells along the coast. These are cells that have at least one neighbor that is above water. If such a cell is shallow, it might have a beach. Or, if it's next to a cliff, then the cliff is a dominant visual feature and we could use rock instead.</p>
						
						<p>To figure this out, check the neighbors of cells that are one step below the water level. Count how many cliff and slope connections there are with land neighbors.</p>
						
						<pre translate="no">				if (cell.Elevation == waterLevel - 1) {
					<ins>int cliffs = 0, slopes = 0;</ins>
					<ins>for (</ins>
						<ins>HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++</ins>
					<ins>) {</ins>
						<ins>HexCell neighbor = cell.GetNeighbor(d);</ins>
						<ins>if (!neighbor) {</ins>
							<ins>continue;</ins>
						<ins>}</ins>
						<ins>int delta = neighbor.Elevation - cell.WaterLevel;</ins>
						<ins>if (delta == 0) {</ins>
							<ins>slopes += 1;</ins>
						<ins>}</ins>
						<ins>else if (delta > 0) {</ins>
							<ins>cliffs += 1;</ins>
						<ins>}</ins>
					<ins>}</ins>
					terrain = 1;
				}</pre>
						
						<p>Now we can use this information to classify the cells. First, if more than half of its neighbors are land, then we're dealing with a lake or inlet. Let's use the grass texture for these cells. If that's not the case, then if we have cliffs we'll use rock. Otherwise, if we have slopes, use sand to create a beach. The only other alternative is a shallow region away from the coast, for which we'll stick with grass.</p>
						
						<pre translate="no">				if (cell.Elevation == waterLevel - 1) {
					int cliffs = 0, slopes = 0;
					for (
						HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++
					) {
						&hellip;
					}
					<ins>if (cliffs + slopes > 3) {</ins>
						<ins>terrain = 1;</ins>
					<ins>}</ins>
					<ins>else if (cliffs > 0) {</ins>
						<ins>terrain = 3;</ins>
					<ins>}</ins>
					<ins>else if (slopes > 0) {</ins>
						<ins>terrain = 0;</ins>
					<ins>}</ins>
					<ins>else {</ins>
						terrain = 1;
					<ins>}</ins>
				}</pre>
						
						<figure>
							<img alt="map" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/coastal.jpg" width="350" height="200">
							<img alt="detail" src="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/coastal-detail.jpg" width="350" height="200">
							<figcaption>Coastal variety.</figcaption>
						</figure>
						
						<p>As a final tweak, let's ensure that we don't end up with green underwater cells in the coldest temperature band. Use mud for those cells instead.</p>
						
						<pre translate="no">				<ins>if (terrain == 1 &amp;&amp; temperature &lt; temperatureBands[0]) {</ins>
					<ins>terrain = 2;</ins>
				<ins>}</ins>
				cell.TerrainTypeIndex = terrain;</pre>
						
						<p>We now have the ability to generate random maps that look fairly interesting and natural, with a lot of configuration options. The next tutorial is <a href="../part-27/index.html">Wrapping</a>.</p>
					</section>
					
					<a href="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/biomes.unitypackage" download rel="nofollow">unitypackage</a>
					<a href="https://catlikecoding.com/unity/tutorials/hex-map/part-26/Hex-Map-26.pdf" download rel="nofollow">PDF</a>
				</section>
				
			</article>
		</main>

		<footer>
			<p>Enjoying the <a href="../../../tutorials">tutorials</a>? Are they useful? Want more?</p>
			<p><b><a href="https://www.patreon.com/catlikecoding">Please support me on Patreon!</a></b></p>
			<p><a href="https://www.patreon.com/catlikecoding"><img src="../../become-a-patron.png" alt="Become my patron!" width="217" height="51"></a></p>
			<p><b><a href="../../donating.html">Or make a direct donation</a>!</b></p>
			<p>made by <a href="../../../../about/index.html" rel="author">Jasper Flick</a></p>
		</footer>
		
		<script src="../../tutorials.js"></script>
	</body>
</html>